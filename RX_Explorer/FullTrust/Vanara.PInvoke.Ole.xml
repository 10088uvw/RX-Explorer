<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vanara.PInvoke.Ole</name>
    </assembly>
    <members>
        <member name="T:Vanara.PInvoke.Ole32">
            <summary></summary>
            <summary>Platform invokable enumerated types, constants and functions from ole32.h</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.AgileReferenceOptions">
            <summary>Specifies options for the RoGetAgileReference function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.AgileReferenceOptions.AGILEREFERENCE_DEFAULT">
            <summary>
            Use the default marshaling behavior, which is to marshal interfaces when an agile reference to the interface is obtained.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.AgileReferenceOptions.AGILEREFERENCE_DELAYEDMARSHAL">
            <summary>
            Marshaling happens on demand. Use this option only in situations where it's known that an object is only resolved from the
            same apartment in which it was registered.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.COWAIT_FLAGS">
            <summary>
            <para>Specifies the behavior of the CoWaitForMultipleHandles function.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_DEFAULT">
            <summary>Dispatch calls needed for marshaling without dispatching arbitrary calls.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_WAITALL">
            <summary>
            If set, the call to CoWaitForMultipleHandles will return S_OK only when all handles associated with the synchronization
            object have been signaled and an input event has been received, all at the same time. In this case, the behavior of
            CoWaitForMultipleHandles corresponds to the behavior of the MsgWaitForMultipleObjectsEx function with the dwFlags parameter
            set to MWMO_WAITALL. If COWAIT_WAITALL is not set, the call to CoWaitForMultipleHandles will return S_OK as soon as any
            handle associated with the synchronization object has been signaled, regardless of whether an input event is received.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_ALERTABLE">
            <summary>
            If set, the call to CoWaitForMultipleHandles will return S_OK if an asynchronous procedure call (APC) has been queued to the
            calling thread with a call to the QueueUserAPC function, even if no handle has been signaled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_INPUTAVAILABLE">
            <summary>
            If set, the call to CoWaitForMultipleHandles will return S_OK if input exists for the queue, even if the input has been seen
            (but not removed) using a call to another function, such as PeekMessage.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_DISPATCH_CALLS">
            <summary>
            Dispatch calls from CoWaitForMultipleHandles in an ASTA. Default is no call dispatch. This value has no meaning in other
            apartment types and is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COWAIT_FLAGS.COWAIT_DISPATCH_WINDOW_MESSAGES">
            <summary>
            Enables dispatch of window messages from CoWaitForMultipleHandles in an ASTA or STA. Default in ASTA is no window messages
            dispatched, default in STA is only a small set of special-cased messages dispatched. The value has no meaning in MTA and is ignored.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CWMO_FLAGS">
            <summary>Provides flags for the CoWaitForMultipleObjects function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CWMO_FLAGS.CWMO_DEFAULT">
            <summary>No call dispatch.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CWMO_FLAGS.CWMO_DISPATCH_CALLS">
            <summary>Dispatch calls from CoWaitForMultipleObjects (default is no call dispatch).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CWMO_FLAGS.CWMO_DISPATCH_WINDOW_MESSAGES">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.REGCLS">
            <summary>
            <para>Controls the type of connections to a class object.</para>
            </summary>
            <remarks>
            <para>
            In CoRegisterClassObject, members of both the <c>REGCLS</c> and the CLSCTX enumerations, taken together, determine how the class
            object is registered.
            </para>
            <para>
            An EXE surrogate (in which DLL servers are run) calls CoRegisterClassObject to register a class factory using a new <c>REGCLS</c>
            value, REGCLS_SURROGATE.
            </para>
            <para>
            All class factories for DLL surrogates should be registered with REGCLS_SURROGATE set. Do not set REGCLS_SINGLUSE or
            REGCLS_MULTIPLEUSE when you register a surrogate for DLL servers.
            </para>
            <para>
            The following table summarizes the allowable <c>REGCLS</c> value combinations and the object registrations affected by the combinations.
            </para>
            <list type="table">
            <listheader>
            <term/>
            <term>REGCLS_SINGLEUSE</term>
            <term>REGCLS_MULTIPLEUSE</term>
            <term>REGCLS_MULTI_SEPARATE</term>
            <term>Other</term>
            </listheader>
            <item>
            <term>CLSCTX_INPROC_SERVER</term>
            <term>Error</term>
            <term>In-process</term>
            <term>In-process</term>
            <term>Error</term>
            </item>
            <item>
            <term>CLSCTX_LOCAL_SERVER</term>
            <term>Local</term>
            <term>In-process/local</term>
            <term>Local</term>
            <term>Error</term>
            </item>
            <item>
            <term>Both of the above</term>
            <term>Error</term>
            <term>In-process/local</term>
            <term>In-process/local</term>
            <term>Error</term>
            </item>
            <item>
            <term>Other</term>
            <term>Error</term>
            <term>Error</term>
            <term>Error</term>
            <term>Error</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_SINGLEUSE">
            <summary>
            After an application is connected to a class object with CoGetClassObject, the class object is removed from public view so
            that no other applications can connect to it. This value is commonly used for single document interface (SDI) applications.
            Specifying this value does not affect the responsibility of the object application to call CoRevokeClassObject; it must
            always call CoRevokeClassObject when it is finished with an object class.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_MULTIPLEUSE">
            <summary>
            Multiple applications can connect to the class object through calls to CoGetClassObject. If both the REGCLS_MULTIPLEUSE and
            CLSCTX_LOCAL_SERVER are set in a call to CoRegisterClassObject, the class object is also automatically registered as an
            in-process server, whether CLSCTX_INPROC_SERVER is explicitly set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_MULTI_SEPARATE">
            <summary>
            Useful for registering separate CLSCTX_LOCAL_SERVER and CLSCTX_INPROC_SERVER class factories through calls to
            CoGetClassObject. If REGCLS_MULTI_SEPARATE is set, each execution context must be set separately; CoRegisterClassObject does
            not automatically register an out-of-process server (for which CLSCTX_LOCAL_SERVER is set) as an in-process server. This
            allows the EXE to create multiple instances of the object for in-process needs, such as self embeddings, without disturbing
            its CLSCTX_LOCAL_SERVER registration. If an EXE registers a REGCLS_MULTI_SEPARATE class factory and a CLSCTX_INPROC_SERVER
            class factory, instance creation calls that specify CLSCTX_INPROC_SERVER in the CLSCTX parameter executed by the EXE would be
            satisfied locally without approaching the SCM. This mechanism is useful when the EXE uses functions such as OleCreate and
            OleLoad to create embeddings, but at the same does not wish to launch a new instance of itself for the self-embedding case.
            The distinction is important for embeddings because the default handler aggregates the proxy manager by default and the
            application should override this default behavior by calling OleCreateEmbeddingHelper for the self-embedding case. If your
            application need not distinguish between the local and inproc case, you need not register your class factory using
            REGCLS_MULTI_SEPARATE. In fact, the application incurs an extra network round trip to the SCM when it registers its
            MULTIPLEUSE class factory as MULTI_SEPARATE and does not register another class factory as INPROC_SERVER.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_SUSPENDED">
            <summary>
            Suspends registration and activation requests for the specified CLSID until there is a call to CoResumeClassObjects. This is
            used typically to register the CLSIDs for servers that can register multiple class objects to reduce the overall registration
            time, and thus the server application startup time, by making a single call to the SCM, no matter how many CLSIDs are
            registered for the server.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_SURROGATE">
            <summary>
            The class object is a surrogate process used to run DLL servers. The class factory registered by the surrogate process is not
            the actual class factory implemented by the DLL server, but a generic class factory implemented by the surrogate. This
            generic class factory delegates instance creation and marshaling to the class factory of the DLL server running in the
            surrogate. For further information on DLL surrogates, see the DllSurrogate registry value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.REGCLS.REGCLS_AGILE">
            <summary>
            The class object aggregates the free-threaded marshaler and will be made visible to all inproc apartments. Can be used
            together with other flags. For example, REGCLS_AGILE | REGCLS_MULTIPLEUSE to register a class object that can be used
            multiple times from different apartments. Without other flags, behavior will retain REGCLS_SINGLEUSE semantics in that only
            one instance can be generated.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STDMSHLFLAGS">
            <summary>Flags used by CoGetStdMarshalEx.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STDMSHLFLAGS.SMEXF_HANDLER">
            <summary>Indicates a client-side (handler) aggregated standard marshaler.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STDMSHLFLAGS.SMEXF_SERVER">
            <summary>Indicates a server-side aggregated standard marshaler.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLSIDFromProgID(System.String,System.Guid@)">
            <summary>Looks up a CLSID in the registry, given a ProgID.</summary>
            <param name="lpszProgID">A pointer to the ProgID whose CLSID is requested.</param>
            <param name="lpclsid">Receives a pointer to the retrieved CLSID on return.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The CLSID was retrieved successfully.</term>
            </item>
            <item>
            <term>CO_E_CLASSSTRING</term>
            <term>The registered CLSID for the ProgID is invalid.</term>
            </item>
            <item>
            <term>REGDB_E_WRITEREGDB</term>
            <term>An error occurred writing the CLSID to the registry. See Remarks below.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Given a ProgID, <c>CLSIDFromProgID</c> looks up its associated CLSID in the registry. If the ProgID cannot be found in the
            registry, <c>CLSIDFromProgID</c> creates an OLE 1 CLSID for the ProgID and a CLSID entry in the registry. Because of the
            restrictions placed on OLE 1 CLSID values, <c>CLSIDFromProgID</c> and CLSIDFromString are the only two functions that can be used
            to generate a CLSID for an OLE 1 object.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLSIDFromProgIDEx(System.String,System.Guid@)">
            <summary>
            <para>Triggers automatic installation if the COMClassStore policy is enabled.</para>
            <para>
            This is analogous to the behavior of CoCreateInstance when neither CLSCTX_ENABLE_CODE_DOWNLOAD nor CLSCTX_NO_CODE_DOWNLOAD are specified.
            </para>
            </summary>
            <param name="lpszProgID">A pointer to the ProgID whose CLSID is requested.</param>
            <param name="lpclsid">Receives a pointer to the retrieved CLSID on return.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The CLSID was retrieved successfully.</term>
            </item>
            <item>
            <term>CO_E_CLASSSTRING</term>
            <term>The registered CLSID for the ProgID is invalid.</term>
            </item>
            <item>
            <term>REGDB_E_WRITEREGDB</term>
            <term>An error occurred writing the CLSID to the registry. See Remarks below.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            CLSCTX_ENABLE_CODE_DOWNLOAD enables automatic installation of missing classes through IntelliMirror/Application Management from
            the Active Directory. If this flag is not specified, the COMClassStore Policy ("Download missing COM components") determines the
            behavior (default: no download).
            </para>
            <para>
            If the COMClassStore Policy enables automatic installation, CLSCTX_NO_CODE_DOWNLOAD can be used to explicitly disallow download
            for an activation.
            </para>
            <para>If either of the following registry values are enabled (meaning set to 1), automatic download of missing classes is enabled:</para>
            <list type="bullet">
            <item>
            <term><c>HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\App Management</c>\ <c>COMClassStore</c></term>
            </item>
            <item>
            <term><c>HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\App Management</c>\ <c>COMClassStore</c></term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLSIDFromString(System.String,System.Guid@)">
            <summary>Converts a string generated by the StringFromCLSID function back into the original CLSID.</summary>
            <param name="lpsz">The string representation of the CLSID.</param>
            <param name="pclsid">A pointer to the CLSID.</param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>NOERROR</term>
            <term>The CLSID was obtained successfully.</term>
            </item>
            <item>
            <term>CO_E_CLASSSTRING</term>
            <term>The class string was improperly formatted.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>The CLSID corresponding to the class string was not found in the registry.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>The registry could not be opened for reading.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoAddRefServerProcess">
            <summary>Increments a global per-process reference count.</summary>
            <returns>The current reference count.</returns>
            <remarks>
            <para>
            Servers can call <c>CoAddRefServerProcess</c> to increment a global per-process reference count. This function is particularly
            helpful to servers that are implemented with multiple threads, either multi-apartmented or free-threaded. Servers of these types
            must coordinate the decision to shut down with activation requests across multiple threads. Calling <c>CoAddRefServerProcess</c>
            increments a global per-process reference count, and calling CoReleaseServerProcess decrements that count.
            </para>
            <para>
            When that count reaches zero, OLE automatically calls CoSuspendClassObjects, which prevents new activation requests from coming
            in. This permits the server to deregister its class objects from its various threads without worry that another activation
            request may come in. New activation requests result in launching a new instance of the local server process.
            </para>
            <para>
            The simplest way for a local server application to make use of these functions is to call <c>CoAddRefServerProcess</c> in the
            constructor for each of its instance objects, and in each of its IClassFactory::LockServer methods when the fLock parameter is
            <c>TRUE</c>. The server application should also call CoReleaseServerProcess in the destruction of each of its instance objects,
            and in each of its <c>LockServer</c> methods when the fLock parameter is <c>FALSE</c>. Finally, the server application should pay
            attention to the return code from <c>CoReleaseServerProcess</c> and if it returns 0, the server application should initiate its
            cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their
            message loops and call CoRevokeClassObject and CoUninitialize.
            </para>
            <para>
            If these functions are used at all, they must be called in both the object instances and the LockServer method, otherwise the
            server application may be shut down prematurely. In-process servers typically should not call <c>CoAddRefServerProcess</c> or CoReleaseServerProcess.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoAllowUnmarshalerCLSID(System.Guid@)">
            <summary>Adds an unmarshaler CLSID to the allowed list for the calling process only.</summary>
            <param name="clsid">The CLSID of the unmarshaler to be added to the per-process allowed list.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            Don't call the <c>CoAllowUnmarshalerCLSID</c> function until after CoInitializeSecurity has been called in the current process.
            </para>
            <para>
            The <c>CoAllowUnmarshalerCLSID</c> function provides more granular control over unmarshaling policy than is provided by the
            policy options. If the process applies any unmarshaling policy, the effect of the <c>CoAllowUnmarshalerCLSID</c> function is to
            make the policy comparatively weaker. For this reason, only call <c>CoAllowUnmarshalerCLSID</c> when the security impact is well
            understood. Usually, this is used to facilitate applying a stronger unmarshaling policy option for the broad attack surface
            reduction this provides, when a specific unmarshaler CLSID not allowed by that option is needed due to other constraints.
            </para>
            <para>
            For example, it's appropriate to call the <c>CoAllowUnmarshalerCLSID</c> function when an unmarshaler is known or believed to
            have a vulnerability but is required by an app. Also, it's appropriate to call <c>CoAllowUnmarshalerCLSID</c> if the unmarshaler
            is used in multiple processes, but only as part of an uncommon feature. Don't use the <c>CoAllowUnmarshalerCLSID</c> function as
            a replacement for hardening the unmarshaler.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCancelCall(System.UInt32,System.UInt32)">
            <summary>Requests cancellation of an outbound DCOM method call pending on a specified thread.</summary>
            <param name="dwThreadId">
            The identifier of the thread on which the pending DCOM call is to be canceled. If this parameter is 0, the call is on the current thread.
            </param>
            <param name="ulTimeout">
            The number of seconds <c>CoCancelCall</c> waits for the server to complete the outbound call after the client requests cancellation.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The cancellation request was made.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>There is no cancel object corresponding to the specified thread.</term>
            </item>
            <item>
            <term>CO_E_CANCEL_DISABLED</term>
            <term>Call cancellation is not enabled on the specified thread.</term>
            </item>
            <item>
            <term>RPC_E_CALL_COMPLETE</term>
            <term>The call was completed during the timeout interval.</term>
            </item>
            <item>
            <term>RPC_E_CALL_CANCELED</term>
            <term>The call was already canceled.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoCancelCall</c> calls CoGetCancelObject and then ICancelMethodCalls::Cancel on the cancel object for the call being executed.
            </para>
            <para>This function does not locate cancel objects for asynchronous calls.</para>
            <para>
            The object server can determine if the call has been canceled by periodically calling CoTestCancel. If the call has been
            canceled, the object server should clean up and return control to the client.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCopyProxy(System.Object,System.Object@)">
            <summary>Makes a private copy of the specified proxy.</summary>
            <param name="pProxy">A pointer to the IUnknown interface on the proxy to be copied. This parameter cannot be <c>NULL</c>.</param>
            <param name="ppCopy">
            Address of the pointer variable that receives the interface pointer to the copy of the proxy. This parameter cannot be <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more arguments are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoCopyProxy</c> makes a private copy of the specified proxy. Typically, this function is called when a client needs to change
            the authentication information of its proxy through a call to either CoSetProxyBlanket or IClientSecurity::SetBlanket without
            changing this information for other clients. <c>CoSetProxyBlanket</c> affects all the users of an instance of a proxy, so
            creating a private copy of the proxy through a call to <c>CoCopyProxy</c> and then calling <c>CoSetProxyBlanket</c> (or
            <c>IClientSecurity::SetBlanket</c>) using the copy eliminates the problem.
            </para>
            <para>This helper function encapsulates the following sequence of common calls (error handling excluded):</para>
            <para>Local interfaces may not be copied. IUnknown and IClientSecurity are examples of existing local interfaces.</para>
            <para>
            Copies of the same proxy have a special relationship with respect to QueryInterface. Given a proxy, a, of the IA interface of a
            remote object, suppose a copy of a is created, called b. In this case, calling <c>QueryInterface</c> from the b proxy for IID_IA
            will not retrieve the IA interface on b, but the one on a, the original proxy with the "default" security settings for the IA interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCreateFreeThreadedMarshaler(System.Object,System.Object@)">
            <summary>Creates an aggregatable object capable of context-dependent marshaling.</summary>
            <param name="punkOuter">A pointer to the aggregating object's controlling IUnknown.</param>
            <param name="ppunkMarshal">Address of the pointer variable that receives the interface pointer to the aggregatable marshaler.</param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following value.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The marshaler was created.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoCreateFreeThreadedMarshaler</c> function enables an object to efficiently marshal interface pointers between threads in
            the same process. If your objects do not support interthread marshaling, you have no need to call this function. It is intended
            for use by free-threaded DLL servers that must be accessed directly by all threads in a process, even those threads associated
            with single-threaded apartments. It custom-marshals the real memory pointer over into other apartments as a bogus "proxy" and
            thereby gives direct access to all callers, even if they are not free-threaded.
            </para>
            <para>The <c>CoCreateFreeThreadedMarshaler</c> function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>Creates a free-threaded marshaler object.</term>
            </item>
            <item>
            <term>
            Aggregates this marshaler to the object specified by the punkOuter parameter. This object is normally the one whose interface
            pointers are to be marshaled.
            </term>
            </item>
            </list>
            <para>
            The aggregating object's implementation of IMarshal should delegate QueryInterface calls for IID_IMarshal to the IUnknown of the
            free-threaded marshaler. Upon receiving a call, the free-threaded marshaler performs the following tasks:
            </para>
            <list type="number">
            <item>
            <term>Checks the destination context specified by the CoMarshalInterface function's dwDestContext parameter.</term>
            </item>
            <item>
            <term>If the destination context is MSHCTX_INPROC, copies the interface pointer into the marshaling stream.</term>
            </item>
            <item>
            <term>
            If the destination context is any other value, finds or creates an instance of COM's default (standard) marshaler and delegates
            marshaling to it.
            </term>
            </item>
            </list>
            <para>
            Values for dwDestContext come from the MSHCTX enumeration. MSHCTX_INPROC indicates that the interface pointer is to be marshaled
            between different threads in the same process. Because both threads have access to the same address space, the client thread can
            dereference the pointer directly rather than having to direct calls to a proxy. In all other cases, a proxy is required, so
            <c>CoCreateFreeThreadedMarshaler</c> delegates the marshaling job to COM's default implementation.
            </para>
            <para>
            Great care should be exercised in using the <c>CoCreateFreeThreadedMarshaler</c> function. This is because the performance of
            objects which aggregate the free-threaded marshaler is obtained through a calculated violation of the rules of COM, with the
            ever-present risk of undefined behavior unless the object operates within certain restrictions. The most important restrictions are:
            </para>
            <list type="bullet">
            <item>
            <term>
            A free-threaded marshaler object cannot hold direct pointers to interfaces on an object that does not aggregate the free-threaded
            marshaler as part of its state. If the object were to use direct references to ordinary single-threaded aggregate objects, it may
            break their single threaded property. If the object were to use direct references to ordinary multithreaded aggregate objects,
            these objects can behave in ways that show no sensitivity to the needs of direct single-threaded aggregate clients. For example,
            these objects can spin new threads and pass parameters to the threads that are references to ordinary single-threaded aggregate objects.
            </term>
            </item>
            <item>
            <term>
            A free-threaded marshaler object cannot hold references to proxies to objects in other apartments. Proxies are sensitive to the
            threading model and can return RPC_E_WRONG_THREAD if called by the wrong client.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCreateGuid(System.Guid@)">
            <summary>Creates a GUID, a unique 128-bit integer used for CLSIDs and interface identifiers.</summary>
            <param name="pguid">A pointer to the requested GUID.</param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The GUID was successfully created.</term>
            </item>
            </list>
            <para>Errors returned by UuidCreate are wrapped as an <c>HRESULT</c>.</para>
            </returns>
            <remarks>
            The <c>CoCreateGuid</c> function calls the RPC function UuidCreate, which creates a GUID, a globally unique 128-bit integer. Use
            <c>CoCreateGuid</c> when you need an absolutely unique number that you will use as a persistent identifier in a distributed
            environment.To a very high degree of certainty, this function returns a unique value – no other invocation, on the same or any
            other system (networked or not), should return the same value.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCreateInstance(System.Guid@,System.Object,Vanara.PInvoke.Ole32.CLSCTX,System.Guid@,System.Object@)">
            <summary>
            <para>Creates a single uninitialized object of the class associated with a specified CLSID.</para>
            <para>
            Call <c>CoCreateInstance</c> when you want to create only one object on the local system. To create a single object on a remote
            system, call the CoCreateInstanceEx function. To create multiple objects based on a single CLSID, call the CoGetClassObject function.
            </para>
            </summary>
            <param name="rclsid">The CLSID associated with the data and code that will be used to create the object.</param>
            <param name="pUnkOuter">
            If <c>NULL</c>, indicates that the object is not being created as part of an aggregate. If non- <c>NULL</c>, pointer to the
            aggregate object's IUnknown interface (the controlling <c>IUnknown</c>).
            </param>
            <param name="dwClsContext">
            Context in which the code that manages the newly created object will run. The values are taken from the enumeration CLSCTX.
            </param>
            <param name="riid">A reference to the identifier of the interface to be used to communicate with the object.</param>
            <param name="ppv">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the
            requested interface pointer. Upon failure, *ppv contains <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>An instance of the specified object class was successfully created.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>
            A specified class is not registered in the registration database. Also can indicate that the type of server you requested in the
            CLSCTX enumeration is not registered or the values for the server types in the registry are corrupt.
            </term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>This class cannot be created as part of an aggregate.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>
            The specified class does not implement the requested interface, or the controlling IUnknown does not expose the requested interface.
            </term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The ppv parameter is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoCreateInstance</c> function provides a convenient shortcut by connecting to the class object associated with the
            specified CLSID, creating an uninitialized instance, and releasing the class object. As such, it encapsulates the following functionality:
            </para>
            <para>
            It is convenient to use <c>CoCreateInstance</c> when you need to create only a single instance of an object on the local machine.
            If you are creating an instance on remote computer, call CoCreateInstanceEx. When you are creating multiple instances, it is more
            efficient to obtain a pointer to the class object's IClassFactory interface and use its methods as needed. In the latter case,
            you should use the CoGetClassObject function.
            </para>
            <para>
            In the CLSCTX enumeration, you can specify the type of server used to manage the object. The constants can be
            CLSCTX_INPROC_SERVER, CLSCTX_INPROC_HANDLER, CLSCTX_LOCAL_SERVER, CLSCTX_REMOTE_SERVER or any combination of these values. The
            constant CLSCTX_ALL is defined as the combination of all four. For more information about the use of one or a combination of
            these constants, see CLSCTX.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCreateInstanceEx(System.Guid@,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.Ole32.COSERVERINFO,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI[])">
            <summary>
            <para>Creates an instance of a specific class on a specific computer.</para>
            </summary>
            <param name="Clsid">
            <para>The CLSID of the object to be created.</para>
            </param>
            <param name="punkOuter">
            <para>
            If this parameter non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used
            as the new instance's controlling IUnknown. Aggregation is currently not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </para>
            </param>
            <param name="dwClsCtx">
            <para>A value from the CLSCTX enumeration.</para>
            </param>
            <param name="pServerInfo">
            <para>
            Information about the computer on which to instantiate the object. See COSERVERINFO. This parameter can be <c>NULL</c>, in which
            case the object is instantiated on the local computer or at the computer specified in the registry under the class's
            RemoteServerName value, according to the interpretation of the dwClsCtx parameter.
            </para>
            </param>
            <param name="dwCount">
            <para>The number of structures in pResults. This value must be greater than 0.</para>
            </param>
            <param name="pResults">
            <para>
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </para>
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates success.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>
            A specified class is not registered in the registration database. Also can indicate that the type of server you requested in the
            CLSCTX enumeration is not registered or the values for the server types in the registry are corrupt.
            </term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>This class cannot be created as part of an aggregate.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures in pResults indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoCreateInstanceEx</c> creates a single uninitialized object associated with the given CLSID on a specified remote computer.
            This is an extension of the function CoCreateInstance, which creates an object on the local computer only. In addition, rather
            than requesting a single interface and obtaining a single pointer to that interface, <c>CoCreateInstanceEx</c> makes it possible
            to specify an array of structures, each pointing to an interface identifier (IID) on input, and, on return, containing (if
            available) a pointer to the requested interface and the return value of the QueryInterface call for that interface. This permits
            fewer round trips between computers.
            </para>
            <para>
            This function encapsulates three calls: first, to CoGetClassObject to connect to the class object associated with the specified
            CLSID, specifying the location of the class; second, to IClassFactory::CreateInstance to create an uninitialized instance, and
            finally, to IClassFactory::Release, to release the class object.
            </para>
            <para>
            The object so created must still be initialized through a call to one of the initialization interfaces (such as
            IPersistStorage::Load). Two functions, CoGetInstanceFromFile and CoGetInstanceFromIStorage encapsulate both the instance creation
            and initialization from the obvious sources.
            </para>
            <para>
            The COSERVERINFO structure passed as the pServerInfo parameter contains the security settings that COM will use when creating a
            new instance of the specified object. Note that this parameter does not influence the security settings used when making method
            calls on the instantiated object. Those security settings are configurable, on a per-interface basis, with the CoSetProxyBlanket
            function. Also see, IClientSecurity::SetBlanket.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoCreateInstanceFromApp(System.Guid@,System.Object,System.UInt32,System.IntPtr,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI@)">
            <summary>Creates an instance of a specific class on a specific computer from within an app container.</summary>
            <param name="Clsid">The CLSID of the object to be created.</param>
            <param name="punkOuter">
            If this parameter non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used
            as the new instance's controlling IUnknown. Aggregation is currently not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </param>
            <param name="dwClsCtx">A value from the CLSCTX enumeration.</param>
            <param name="reserved">Reserved for future use.</param>
            <param name="dwCount">The number of structures in pResults. This value must be greater than 0.</param>
            <param name="pResults">
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates success.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>
            A specified class is not registered in the registration database, or the class is not supported in the app container. Also can
            indicate that the type of server you requested in the CLSCTX enumeration is not registered or the values for the server types in
            the registry are corrupt.
            </term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>This class cannot be created as part of an aggregate.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures in pResults indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>CoCreateInstanceFromApp</c> function is the same as the CoCreateInstanceEx function, with the following differences.</para>
            <list type="bullet">
            <item>
            <term>
            The <c>CoCreateInstanceFromApp</c> function reads class registrations only from application contexts, and from the
            HKLM\SOFTWARE\Classes\CLSID registry hive.
            </term>
            </item>
            <item>
            <term>
            Only built-in classes that are supported in the app container are supplied. Attempts to activate unsupported classes, including
            all classes installed by 3rd-party code as well as many Windows classes, result in error code <c>REGDB_E_CLASSNOTREG</c>.
            </term>
            </item>
            <item>
            <term>
            The <c>CoCreateInstanceFromApp</c> function is available to Windows Store apps. Desktop applications can call this function, but
            they have the same restrictions as Windows Store apps.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDecodeProxy(System.UInt32,System.UInt64,System.IntPtr)">
            <summary>
            Locates the implementation of a Component Object Model (COM) interface in a server process given an interface to a proxied object.
            </summary>
            <param name="dwClientPid">The process ID of the process that contains the proxy.</param>
            <param name="ui64ProxyAddress">
            The address of an interface on a proxy to the object. ui64ProxyAddress is considered a 64-bit value type, rather than a pointer
            to a 64-bit value, and isn't a pointer to an object in the debugger process. Instead, this address is passed to the
            ReadProcessMemory function.
            </param>
            <param name="pServerInformation">A structure that contains the process ID, the thread ID, and the address of the server.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The server information was successfully retrieved.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The caller is an app container, or the developer license is not installed.</term>
            </item>
            <item>
            <term>RPC_E_INVALID_IPID</term>
            <term>ui64ProxyAddress does not point to a proxy.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoDecodeProxy</c> function is a COM API that enables native debuggers to locate the implementation of a COM interface in a
            server process given an interface on a proxy to the object.
            </para>
            <para>
            Also, the <c>CoDecodeProxy</c> function enables the debugger to monitor cross-apartment function calls and fail such calls when appropriate.
            </para>
            <para>
            You can call the <c>CoDecodeProxy</c> function from a 32-bit or 64-bit process. ui64ProxyAddress can be a 32-bit or 64-bit
            address. The <c>CoDecodeProxy</c> function returns a 32-bit or 64-bit address in the pServerInformation field. If it returns a
            64-bit address, you should pass the address to the ReadProcessMemory function only from a 64-bit process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDecrementMTAUsage(Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE)">
            <summary>Releases the increment made by a previous call to the CoIncrementMTAUsage function.</summary>
            <param name="Cookie">A <c>PVOID</c> variable that was set by a previous call to the CoIncrementMTAUsage function.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            Cookie must be a valid value returned by a successful previous call to the CoIncrementMTAUsage function. If the overall count of
            MTA usage reaches 0, including both through this API and through the CoInitializeEx and CoUninitialize functions, the system
            frees resources related to MTA support.
            </para>
            <para>
            You can call CoIncrementMTAUsage from one thread and <c>CoDecrementMTAUsage</c> from another as long as a cookie previously
            returned by <c>CoIncrementMTAUsage</c> is passed to <c>CoDecrementMTAUsage</c>.
            </para>
            <para>
            Don't call <c>CoDecrementMTAUsage</c> during process shutdown or inside dllmain. You can call <c>CoDecrementMTAUsage</c> before
            the call to start the shutdown process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDisableCallCancellation(System.IntPtr)">
            <summary>
            Undoes the action of a call to CoEnableCallCancellation. Disables cancellation of synchronous calls on the calling thread when
            all calls to <c>CoEnableCallCancellation</c> are balanced by calls to <c>CoDisableCallCancellation</c>.
            </summary>
            <param name="pReserved">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Call cancellation was successfully disabled on the thread.</term>
            </item>
            <item>
            <term>CO_E_CANCEL_DISABLED</term>
            <term>
            There have been more successful calls to CoEnableCallCancellation on the thread than there have been calls to
            CoDisableCallCancellation. Cancellation is still enabled on the thread.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can
            suffer serious performance degradation. By default, then, synchronous calls cannot be canceled, even if a cancel object is
            available. To enable call cancellation, you must call CoEnableCallCancellation first.
            </para>
            <para>
            When call cancellation is disabled, attempts to gain a pointer to a call object will fail. If the calling thread already has a
            pointer to a call object, calls on that object will fail.
            </para>
            <para>
            Unless you want to enable call cancellation on a thread at all times, you should pair calls to CoEnableCallCancellation with
            calls to <c>CoDisableCallCancellation</c>. Call cancellation is disabled only if each successful call to
            <c>CoEnableCallCancellation</c> is balanced by a successful call to <c>CoDisableCallCancellation</c>.
            </para>
            <para>
            A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or
            disabling call cancellation has no effect on any calls that are pending on the thread.
            </para>
            <para>
            If a thread is uninitialized and then reinitialized by calls to CoUninitialize and CoInitialize, call cancellation is disabled on
            the thread, even if it was enabled when the thread was uninitialized.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDisconnectContext(System.UInt32)">
            <summary>
            <para>
            Disconnects all proxy connections that are being maintained on behalf of all interface pointers that point to objects in the
            current context.
            </para>
            <para>
            This function blocks connections until all objects are successfully disconnected or the time-out expires. Only the context that
            actually manages the objects should call <c>CoDisconnectContext</c>.
            </para>
            </summary>
            <param name="dwTimeout">
            The time in milliseconds after which <c>CoDisconnectContext</c> returns even if the proxy connections for all objects have not
            been disconnected. INFINITE is an acceptable value for this parameter.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The proxy connections for all objects were successfully disconnected.</term>
            </item>
            <item>
            <term>RPC_E_TIMEOUT</term>
            <term>Not all proxy connections were successfully deleted in the time specified in dwTimeout.</term>
            </item>
            <item>
            <term>CO_E_NOTSUPPORTED</term>
            <term>The current context cannot be disconnected.</term>
            </item>
            <item>
            <term>CONTEXT_E_WOULD_DEADLOCK</term>
            <term>
            An object tried to call CoDisconnectContext on the context it is residing in. This would cause the function to time-out and
            deadlock if dwTimeout were set to INFINITE.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoDisconnectContext</c> function is used to support unloading services in shared service hosts where you must unload your
            service's binaries without affecting other COM servers that are running in the same process. If you control the process lifetime
            and you do not unload until the process exits, the COM infrastructure will perform the necessary cleanup automatically and you do
            not have to call this function.
            </para>
            <para>
            The <c>CoDisconnectContext</c> function enables a server to correctly disconnect all external clients of all objects in the
            current context. Default contexts cannot be disconnected. To use <c>CoDisconnectContext</c>, you must first create a context that
            can be disconnected and register your class factories for objects from which you want to disconnect within that context. You can
            do this with the IContextCallback interface.
            </para>
            <para>
            If <c>CoDisconnectContext</c> returns RPC_E_TIMEOUT, this does not indicate that the function did not disconnect the objects, but
            that not all disconnections could be completed in the time specified by dwTimeout because of outstanding calls on the objects.
            All objects will be disconnected after all calls on them have been completed.
            </para>
            <para>
            It is not safe to unload the DLL that hosts the service until <c>CoDisconnectContext</c> returns S_OK. If the function returns
            RPC_E_TIMEOUT, the service may perform other clean-up. The service must call the function until it returns S_OK, and then it can
            safely unload its DLL.
            </para>
            <para>The <c>CoDisconnectContext</c> function performs the following tasks:</para>
            <list type="bullet">
            <item>
            <term>Calls CoDisconnectObject on all objects in the current context.</term>
            </item>
            <item>
            <term>Blocks until all objects have been disconnected or the time-out has expired.</term>
            </item>
            </list>
            <para>The <c>CoDisconnectContext</c> function has the following limitations:</para>
            <list type="bullet">
            <item>
            <term>Asynchronous COM calls are not supported.</term>
            </item>
            <item>
            <term>In-process objects must be registered and enabled using the CLSCTX_LOCAL_SERVER flag, or they will not be disconnected.</term>
            </item>
            <item>
            <term>COM+ is not supported.</term>
            </item>
            <item>
            <term>
            COM interface pointers are context-sensitive. Therefore, any interface pointer created in the context to be disconnected can only
            be used within that context.
            </term>
            </item>
            </list>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDisconnectObject(System.Object,System.UInt32)">
            <summary>
            <para>
            Disconnects all remote process connections being maintained on behalf of all the interface pointers that point to a specified object.
            </para>
            <para>Only the process that actually manages the object should call <c>CoDisconnectObject</c>.</para>
            </summary>
            <param name="pUnk">A pointer to any interface derived from IUnknown on the object to be disconnected.</param>
            <param name="dwReserved">This parameter is reserved and must be 0.</param>
            <returns>This function returns S_OK to indicate that all connections to remote processes were successfully deleted.</returns>
            <remarks>
            <para>
            The <c>CoDisconnectObject</c> function enables a server to correctly disconnect all external clients to the object specified by pUnk.
            </para>
            <para>It performs the following tasks:</para>
            <list type="number">
            <item>
            <term>
            Checks to see whether the object to be disconnected implements the IMarshal interface. If so, it gets the pointer to that
            interface; if not, it gets a pointer to the standard marshaler's (i.e., COM's) <c>IMarshal</c> implementation.
            </term>
            </item>
            <item>
            <term>
            Using whichever IMarshal interface pointer it has acquired, the function then calls IMarshal::DisconnectObject to disconnect all
            out-of-process clients.
            </term>
            </item>
            </list>
            <para>
            An object's client does not call <c>CoDisconnectObject</c> to disconnect itself from the server (clients should use
            IUnknown::Release for this purpose). Rather, an OLE server calls <c>CoDisconnectObject</c> to forcibly disconnect an object's
            clients, usually in response to a user closing the server application.
            </para>
            <para>
            Similarly, an OLE container that supports external links to its embedded objects can call <c>CoDisconnectObject</c> to destroy
            those links. Again, this call is normally made in response to a user closing the application. The container should first call
            IOleObject::Close for all its OLE objects, each of which should send IAdviseSink::OnClose notifications to their various clients.
            Then the container can call <c>CoDisconnectObject</c> to close any existing connections.
            </para>
            <para>
            <c>CoDisconnectObject</c> does not necessarily disconnect out-of-process clients immediately. If any marshaled calls are pending
            on the server object, <c>CoDisconnectObject</c> disconnects the object only when those calls have returned. In the meantime,
            <c>CoDisconnectObject</c> sets a flag that causes any new marshaled calls to return CO_E_OBJNOTCONNECTED.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoEnableCallCancellation(System.IntPtr)">
            <summary>Enables cancellation of synchronous calls on the calling thread.</summary>
            <param name="pReserved">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>This function can return the standard return values S_OK, E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY.</returns>
            <remarks>
            <para>
            When call cancellation is enabled on a thread, marshaled synchronous calls from that thread to objects on the same computer can
            suffer serious performance degradation. By default, synchronous calls cannot be canceled, even if a cancel object is available.
            To enable call cancellation, you must call <c>CoEnableCallCancellation</c> first.
            </para>
            <para>
            Unless you want to enable call cancellation on a thread at all times, you should pair calls to <c>CoEnableCallCancellation</c>
            with calls to CoDisableCallCancellation. Call cancellation is disabled only if <c>CoDisableCallCancellation</c> has been called
            once for each time <c>CoEnableCallCancellation</c> was called successfully.
            </para>
            <para>
            A call will be cancelable or not depending on the state of the thread at the time the call was made. Subsequently enabling or
            disabling call cancellation has no effect on any calls that are pending on the thread.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFileTimeNow(System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            <para>Returns the current time as a FILETIME structure.</para>
            <para><c>Note</c> This function is provided for compatibility with 16-bit Windows.</para>
            </summary>
            <param name="lpFileTime">A pointer to the FILETIME structure that receives the current time.</param>
            <returns>This function returns S_OK to indicate success.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFreeUnusedLibraries">
            <summary>
            <para>Unloads any DLLs that are no longer in use, probably because the DLL no longer has any instantiated COM objects outstanding.</para>
            <para><c>Note</c> This function is provided for compatibility with 16-bit Windows.</para>
            </summary>
            <remarks>
            Applications can call <c>CoFreeUnusedLibraries</c> periodically to free resources. It is most efficient to call it either at the
            top of a message loop or in some idle-time task. <c>CoFreeUnusedLibraries</c> internally calls DllCanUnloadNow for DLLs that
            implement and export that function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFreeUnusedLibrariesEx(System.UInt32,System.UInt32)">
            <summary>Unloads any DLLs that are no longer in use and whose unload delay has expired.</summary>
            <param name="dwUnloadDelay">
            The delay in milliseconds between the time that the DLL has stated it can be unloaded until it becomes a candidate to unload.
            Setting this parameter to INFINITE uses the system default delay (10 minutes). Setting this parameter to 0 forces the unloading
            of any DLLs without any delay.
            </param>
            <param name="dwReserved">This parameter is reserved and must be 0.</param>
            <remarks>
            <para>
            COM supplies functions to reclaim memory held by DLLs containing components. The most commonly used function is
            CoFreeUnusedLibraries. <c>CoFreeUnusedLibraries</c> does not immediately release DLLs that have no active object. There is a
            10-minute delay for multithreaded apartments (MTAs) and neutral apartments (NAs). For single-threaded apartments (STAs), there is
            no delay.
            </para>
            <para>
            The 10-minute delay for CoFreeUnusedLibraries is to avoid multithread race conditions caused by unloading a component DLL. This
            default delay may be too long for many applications.
            </para>
            <para>
            COM maintains a list of active DLLs that have had components loaded for the apartments that can be hosted on the thread where
            this function is called. When <c>CoFreeUnusedLibrariesEx</c> is called, each DLL on that list has its DllCanUnloadNow function
            called. If <c>DllCanUnloadNow</c> returns S_FALSE (or is not exported), this DLL is not ready to be unloaded. If
            <c>DllCanUnloadNow</c> returns S_OK, this DLL is moved off the active list to a "candidate-for-unloading" list.
            </para>
            <para>
            Adding the DLL to the candidate-for-unloading list time-stamps the DLL dwUnloadDelay milliseconds from when this move occurs.
            When <c>CoFreeUnusedLibrariesEx</c> (or CoFreeUnusedLibraries) is called again, at least dwUnloadDelay milliseconds from the call
            that moved the DLL to the candidate-for-unloading list, the DLL is actually freed from memory. If COM uses the component DLL
            while the DLL is on the candidate-for-unloading list, it is moved back to the active list.
            </para>
            <para>
            Setting dwUnloadDelay to 0 may have unexpected consequences. The component DLL may need some time for cleanup after it returns
            from the DllCanUnloadNow function. For example, if the DLL had its own worker threads, using a value of 0 would most likely lead
            to a problem because the code executing on these threads would be unmapped, caused by the unloading of the DLL before the worker
            threads have a chance to exit. Also, using too brief of a value for dwUnloadDelay can lead to performance issues because there is
            more overhead in reloading a DLL than letting it page out.
            </para>
            <para>
            This behavior is triggered by the DLL supplying components with threading models set to Free, Neutral, or Both. For a threading
            model set to Apartment (or if no threading model is specified), dwUnloadDelay is treated as 0 because these components are tied
            to the single thread hosting the apartment.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetApartmentType(Vanara.PInvoke.Ole32.APTTYPE@,Vanara.PInvoke.Ole32.APTTYPEQUALIFIER@)">
            <summary>Returns the current apartment type and type qualifier.</summary>
            <param name="pAptType">APTTYPE enumeration value that specifies the type of the current apartment.</param>
            <param name="pAptQualifier">APTTYPEQUALIFIER enumeration value that specifies the type qualifier of the current apartment.</param>
            <returns>
            <para>Returns S_OK if the call succeeded. Otherwise, one of the following error codes is returned.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The call could not successfully query the current apartment type and type qualifier.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>
            An invalid parameter value was supplied to the function. Specifically, one or both of the parameters were set to NULL by the caller.
            </term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>CoInitialize or CoInitializeEx was not called on this thread prior to calling CoGetApartmentType.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>On Windows platforms prior to Windows 7, the following actions must be taken on a thread to query the apartment type:</para>
            <list type="bullet">
            <item>
            <term>Call CoGetContextToken to obtain the current context token.</term>
            </item>
            <item>
            <term>Cast the context token to an IUnknown* pointer.</term>
            </item>
            <item>
            <term>Call the QueryInterface method on that pointer to obtain the IComThreadingInfo interface.</term>
            </item>
            <item>
            <term>Call the GetCurrentApartmentType method of the IComThreadingInfo interface to obtain the current apartment type.</term>
            </item>
            </list>
            <para>
            In multithreaded scenarios, there is a race condition which can potentially cause an Access Violation within the process when
            executing the above sequence of operations. The <c>CoGetApartmentType</c> function is recommended as it does not potentially
            incur the Access Violation.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetCallContext(System.Guid@,System.Object@)">
            <summary>Retrieves the context of the current call on the current thread.</summary>
            <param name="riid">
            Interface identifier (IID) of the call context that is being requested. If you are using the default call context supported by
            standard marshaling, IID_IServerSecurity is available. For COM+ applications using role-based security, IID_ISecurityCallContext
            is available.
            </param>
            <param name="ppInterface">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppInterface contains
            the requested interface pointer.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The context was retrieved successfully.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The call context does not support the interface specified by riid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>CoGetCallContext</c> retrieves the context of the current call on the current thread. The riid parameter specifies the
            interface on the context to be retrieved. This is one of the functions provided to give the server access to any contextual
            information of the caller.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetCallerTID(System.UInt32@)">
            <summary>Returns a pointer to a <c>DWORD</c> that contains the apartment ID of the caller's thread.</summary>
            <param name="lpdwTID">
            Receives the apartment ID of the caller's thread. For a single threaded apartment (STA), this is the current thread ID. For a
            multithreaded apartment (MTA), the value is 0. For a neutral apartment (NA), the value is -1.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_TRUE</term>
            <term>The caller's thread ID is set and the caller is in the same process.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The caller's thread ID is set and the caller is in a different process.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>The caller's thread ID was not set.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If the caller is not running on the same computer, this function does not return the apartment ID and the return value is S_FALSE.
            </para>
            <para>
            There is no guarantee that the information returned from this API is not tampered with, so do not use the ID that is returned to
            make security decisions. The ID can only be used for logging and diagnostic purposes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetCancelObject(System.UInt32,System.Guid@,System.Object@)">
            <summary>
            Obtains a pointer to a call control interface, normally ICancelMethodCalls, on the cancel object corresponding to an outbound COM
            method call pending on the same or another client thread.
            </summary>
            <param name="dwThreadId">
            The identifier of the thread on which the pending COM call is to be canceled. If this parameter is 0, the call is on the current thread.
            </param>
            <param name="iid">
            The globally unique identifier of an interface on the cancel object for the call to be canceled. This argument is usually IID_ICancelMethodCalls.
            </param>
            <param name="ppUnk">Receives the address of a pointer to the interface specified by riid.</param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The call control object was retrieved successfully.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object on which the call is executing does not support the interface specified by riid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If two or more calls are pending on the same thread through nested calls, the thread ID may not be sufficient to identify the
            call to be canceled. In this case, <c>CoGetCancelObject</c> returns a cancel interface corresponding to the innermost call that
            is pending on the thread and has registered a cancel object.
            </para>
            <para>This function does not locate cancel objects for asynchronous calls.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetClassObject(System.Guid@,Vanara.PInvoke.Ole32.CLSCTX,System.IntPtr,System.Guid@,System.Object@)">
            <summary>
            <para>
            Provides a pointer to an interface on a class object associated with a specified CLSID. <c>CoGetClassObject</c> locates, and if
            necessary, dynamically loads the executable code required to do this.
            </para>
            <para>
            Call <c>CoGetClassObject</c> directly to create multiple objects through a class object for which there is a CLSID in the system
            registry. You can also retrieve a class object from a specific remote computer. Most class objects implement the IClassFactory
            interface. You would then call CreateInstance to create an uninitialized object. It is not always necessary to go through this
            process however. To create a single object, call the CoCreateInstanceEx function, which allows you to create an instance on a
            remote machine. This replaces the CoCreateInstance function, which can still be used to create an instance on a local computer.
            Both functions encapsulate connecting to the class object, creating the instance, and releasing the class object. Two other
            functions, CoGetInstanceFromFile and CoGetInstanceFromIStorage, provide both instance creation on a remote system and object
            activation. There are numerous functions and interface methods whose purpose is to create objects of a single type and provide a
            pointer to an interface on that object.
            </para>
            </summary>
            <param name="rclsid">The CLSID associated with the data and code that you will use to create the objects.</param>
            <param name="dwClsContext">
            The context in which the executable code is to be run. To enable a remote activation, include CLSCTX_REMOTE_SERVER. For more
            information on the context values and their use, see the CLSCTX enumeration.
            </param>
            <param name="pvReserved">
            A pointer to computer on which to instantiate the class object. If this parameter is <c>NULL</c>, the class object is
            instantiated on the current computer or at the computer specified under the class's RemoteServerName key, according to the
            interpretation of the dwClsCtx parameter. See COSERVERINFO.
            </param>
            <param name="riid">
            Reference to the identifier of the interface, which will be supplied in ppv on successful return. This interface will be used to
            communicate with the class object. Typically this value is IID_IClassFactory, although other values â€“ such as
            IID_IClassFactory2 which supports a form of licensing â€“ are allowed. All OLE-defined interface IIDs are defined in the OLE
            header files as IID_interfacename, where interfacename is the name of the interface.
            </param>
            <param name="ppv">
            The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains the
            requested interface pointer.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Location and connection to the specified class object was successful.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>
            The CLSID is not properly registered. This error can also indicate that the value you specified in dwClsContext is not in the registry.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>
            Either the object pointed to by ppv does not support the interface identified by riid, or the QueryInterface operation on the
            class object returned E_NOINTERFACE.
            </term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading the registration database.</term>
            </item>
            <item>
            <term>CO_E_DLLNOTFOUND</term>
            <term>Either the in-process DLL or handler DLL was not found (depending on the context).</term>
            </item>
            <item>
            <term>CO_E_APPNOTFOUND</term>
            <term>The executable (.exe) was not found (CLSCTX_LOCAL_SERVER only).</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>There was a general access failure on load.</term>
            </item>
            <item>
            <term>CO_E_ERRORINDLL</term>
            <term>There is an error in the executable image.</term>
            </item>
            <item>
            <term>CO_E_APPDIDNTREG</term>
            <term>The executable was launched, but it did not register the class object (and it may have shut down).</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A class object in OLE is an intermediate object that supports an interface that permits operations common to a group of objects.
            The objects in this group are instances derived from the same object definition represented by a single CLSID. Usually, the
            interface implemented on a class object is IClassFactory, through which you can create object instances of a given definition (class).
            </para>
            <para>
            A call to <c>CoGetClassObject</c> creates, initializes, and gives the caller access (through a pointer to an interface specified
            with the riid parameter) to the class object. The class object is the one associated with the CLSID that you specify in the
            rclsid parameter. The details of how the system locates the associated code and data within a computer are transparent to the
            caller, as is the dynamic loading of any code that is not already loaded.
            </para>
            <para>
            If the class context is CLSCTX_REMOTE_SERVER, indicating remote activation is required, the COSERVERINFO structure provided in
            the pServerInfo parameter allows you to specify the computer on which the server is located. For information on the algorithm
            used to locate a remote server when pServerInfo is <c>NULL</c>, refer to the CLSCTX enumeration.
            </para>
            <para>There are two places to find a CLSID for a class:</para>
            <list type="bullet">
            <item>
            <term>
            The registry holds an association between CLSIDs and file suffixes, and between CLSIDs and file signatures for determining the
            class of an object.
            </term>
            </item>
            <item>
            <term>When an object is saved to persistent storage, its CLSID is stored with its data.</term>
            </item>
            </list>
            <para>
            To create and initialize embedded or linked OLE document objects, it is not necessary to call <c>CoGetClassObject</c> directly.
            Instead, call the OleCreate or <c>OleCreate</c> XXX function. These functions encapsulate the entire object instantiation and
            initialization process, and call, among other functions, <c>CoGetClassObject</c>.
            </para>
            <para>
            The riid parameter specifies the interface the client will use to communicate with the class object. In most cases, this
            interface is IClassFactory. This provides access to the CreateInstance method, through which the caller can then create an
            uninitialized object of the kind specified in its implementation. All classes registered in the system with a CLSID must
            implement IClassFactory.
            </para>
            <para>
            In rare cases, however, you may want to specify some other interface that defines operations common to a set of objects. For
            example, in the way OLE implements monikers, the interface on the class object is IParseDisplayName, used to transform the
            display name of an object into a moniker.
            </para>
            <para>
            The dwClsContext parameter specifies the execution context, allowing one CLSID to be associated with different pieces of code in
            different execution contexts. The CLSCTX enumeration specifies the available context flags. <c>CoGetClassObject</c> consults (as
            appropriate for the context indicated) both the registry and the class objects that are currently registered by calling the
            CoRegisterClassObject function.
            </para>
            <para>
            To release a class object, use the class object's Release method. The function CoRevokeClassObject is to be used only to remove a
            class object's CLSID from the system registry.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetContextToken(Vanara.PInvoke.Ole32.IObjContext@)">
            <summary>Returns a pointer to an implementation of IObjContext for the current context.</summary>
            <param name="pToken">A pointer to an implementation of IObjContext for the current context.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The token was retrieved successfully.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The caller did not pass a valid token pointer variable.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>The caller is not in an initialized apartment.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetCurrentLogicalThreadId(System.Guid@)">
            <summary>Returns the logical thread identifier of the current physical thread.</summary>
            <param name="pguid">A pointer to a GUID that contains the logical thread ID on return.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The logical thread ID was retrieved successfully.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>An invalid pointer was passed in for the pguid parameter.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>A memory allocation failed during the operation of the function.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This function retrieves the identifier of the current logical thread under which this physical thread is operating. The current
            physical thread takes on the logical thread identifier of any client thread that makes a COM call into this application.
            Similarly, the logical thread identifier of the current physical thread is used to denote the causality for outgoing COM calls
            from this physical thread.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetCurrentProcess">
            <summary>
            Returns a value that is unique to the current thread. <c>CoGetCurrentProcess</c> can be used to avoid thread ID reuse problems.
            </summary>
            <returns>The function returns the unique identifier of the current thread.</returns>
            <remarks>
            <para>
            Using the value returned from a call to <c>CoGetCurrentProcess</c> can help you in maintaining tables that are keyed by threads
            or in uniquely identifying a thread to other threads or processes.
            </para>
            <para>
            <c>CoGetCurrentProcess</c> returns a value that is effectively unique, because it is not used again until 2³² more threads have
            been created on the current workstation or until the workstation is restarted.
            </para>
            <para>
            The value returned by <c>CoGetCurrentProcess</c> will uniquely identify the same thread for the life of the caller. Because
            thread IDs can be reused without notice as threads are created and destroyed, this value is more reliable than the value returned
            by the GetCurrentThreadId function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetDefaultContext(Vanara.PInvoke.Ole32.APTTYPE,System.Guid@,System.Object@)">
            <summary>Retrieves a reference to the default context of the specified apartment.</summary>
            <param name="aptType">
            <para>The apartment type of the default context that is being requested. This parameter can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>APTTYPE_CURRENT -1</term>
            <term>The caller's apartment.</term>
            </item>
            <item>
            <term>APTTYPE_MTA 1</term>
            <term>The multithreaded apartment for the current process.</term>
            </item>
            <item>
            <term>APTTYPE_NA 2</term>
            <term>The neutral apartment for the current process.</term>
            </item>
            <item>
            <term>APTTYPE_MAINSTA 3</term>
            <term>The main single-threaded apartment for the current process.</term>
            </item>
            </list>
            <para>
            The APTTYPE value APTTYPE_STA (0) is not supported. A process can contain multiple single-threaded apartments, each with its own
            context, so <c>CoGetDefaultContext</c> could not determine which STA is of interest. Therefore, this function returns
            E_INVALIDARG if APTTYPE_STA is specified.
            </para>
            </param>
            <param name="riid">
            The interface identifier (IID) of the interface that is being requested on the default context. Typically, the caller requests
            IID_IObjectContext. The default context does not support all of the normal object context interfaces.
            </param>
            <param name="ppv">
            A reference to the interface specified by riid on the default context. If the object's component is non-configured, (that is, the
            object's component has not been imported into a COM+ application), or if the <c>CoGetDefaultContext</c> function is called from a
            constructor or an IUnknown method, this parameter is set to a <c>NULL</c> pointer.
            </param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is invalid.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>The caller is not in an initialized apartment.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object context does not support the interface specified by riid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Every COM apartment has a special context called the default context. A default context is different from all the other,
            non-default contexts in an apartment because it does not provide runtime services. It does not support all of the normal object
            context interfaces.
            </para>
            <para>
            The default context is also used by instances of non-configured COM components, (that is, components that have not been part of a
            COM+ application), when they are created from an apartment that does not support their threading model. In other words, if a COM
            object creates an instance of a non-configured component and the new object cannot be added to its creator's context because of
            its threading model, the new object is instead added to the default context of an apartment that supports its threading model.
            </para>
            <para>
            An object should never pass an IObjectContext reference to another object. If you pass an <c>IObjectContext</c> reference to
            another object, it is no longer a valid reference.
            </para>
            <para>
            When an object obtains a reference to an IObjectContext, it must release the <c>IObjectContext</c> object when it is finished
            with it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInterfaceAndReleaseStream(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@,System.Object@)">
            <summary>
            Unmarshals a buffer containing an interface pointer and releases the stream when an interface pointer has been marshaled from
            another thread to the calling thread.
            </summary>
            <param name="pStm">A pointer to the IStream interface on the stream to be unmarshaled.</param>
            <param name="iid">A reference to the identifier of the interface requested from the unmarshaled object.</param>
            <param name="ppv">
            The address of pointer variable that receives the interface pointer requested in <paramref name="iid"/>. Upon successful return,
            <paramref name="ppv"/> contains the requested interface pointer to the unmarshaled interface.
            </param>
            <returns>
            This function can return the standard return values S_OK and E_INVALIDARG, as well as any of the values returned by CoUnmarshalInterface.
            </returns>
            <remarks>
            <para>
            <c>Important</c> Security Note: Calling this method with untrusted data is a security risk. Call this method only with trusted
            data. For more information, see Untrusted Data Security Risks.
            </para>
            <para>The <c>CoGetInterfaceAndReleaseStream</c> function performs the following tasks:</para>
            <list type="bullet">
            <item>
            <term>Calls CoUnmarshalInterface to unmarshal an interface pointer previously passed in a call to CoMarshalInterThreadInterfaceInStream.</term>
            </item>
            <item>
            <term>
            Releases the stream pointer. Even if the unmarshaling fails, the stream is still released because there is no effective way to
            recover from a failure of this kind.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetMalloc(System.UInt32,Vanara.PInvoke.Ole32.IMalloc@)">
            <summary>
            Retrieves a pointer to the default OLE task memory allocator (which supports the system implementation of the IMalloc interface)
            so applications can call its methods to manage memory.
            </summary>
            <param name="dwMemContext">This parameter must be 1.</param>
            <param name="ppMalloc">
            The address of an <c>IMalloc*</c> pointer variable that receives the interface pointer to the memory allocator.
            </param>
            <returns>This function can return the standard return values S_OK, E_INVALIDARG, and E_OUTOFMEMORY.</returns>
            <remarks>
            The pointer to the IMalloc interface pointer received through the ppMalloc parameter cannot be used from a remote process; each
            process must have its own allocator.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetMarshalSizeMax(System.UInt32@,System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS)">
            <summary>
            Returns an upper bound on the number of bytes needed to marshal the specified interface pointer to the specified object.
            </summary>
            <param name="pulSize">
            A pointer to the upper-bound value on the size, in bytes, of the data packet to be written to the marshaling stream. If this
            parameter is 0, the size of the packet is unknown.
            </param>
            <param name="riid">
            A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the IUnknown interface.
            </param>
            <param name="pUnk">A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface.</param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. Values for dwDestContext come from the enumeration MSHCTX.
            </param>
            <param name="pvDestContext">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="mshlflags">
            Indicates whether the data to be marshaled is to be transmitted back to the client processthe normal case or written to a global
            table, where it can be retrieved by multiple clients. Values come from the enumeration MSHLFLAGS.
            </param>
            <returns>
            <para>This function can return the standard return value E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The upper bound was returned successfully.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>Before this function can be called, either the CoInitialize or OleInitialize function must be called.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>
            Queries the object for an IMarshal pointer or, if the object does not implement <c>IMarshal</c>, gets a pointer to COM's standard marshaler.
            </term>
            </item>
            <item>
            <term>Using the pointer obtained in the preceding item, calls IMarshal::GetMarshalSizeMax.</term>
            </item>
            <item>
            <term>
            Adds to the value returned by the call to GetMarshalSizeMax the size of the marshaling data header and, possibly, that of the
            proxy CLSID to obtain the maximum size in bytes of the amount of data to be written to the marshaling stream.
            </term>
            </item>
            </list>
            <para>
            You do not explicitly call this function unless you are implementing IMarshal, in which case your marshaling stub should call
            this function to get the correct size of the data packet to be marshaled.
            </para>
            <para>
            The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled does
            not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs the risk
            that the object, because of some change in state, might require more memory to marshal than it originally indicated.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetObjectContext(System.Guid@,System.Object@)">
            <summary>Returns the context for the current object.</summary>
            <param name="riid">
            <para>A reference to the ID of an interface that is implemented on the context object.</para>
            <para>For objects running within COM applications, IID_IComThreadingInfo, IID_IContext, and IID_IContextCallback are available.</para>
            <para>
            For objects running within COM+ applications, IID_IObjectContext, IID_IObjectContextActivity IID_IObjectContextInfo, and
            IID_IContextState are available.
            </para>
            </param>
            <param name="ppv">The address of a pointer to the interface specified by riid on the context object.</param>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object context was successfully retrieved.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The requested interface was not available.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>Before this function can be called, the CoInitializeEx function must be called on the current thread.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoGetObjectContext</c> retrieves the context for the object from which it is called, and returns a pointer to an interface
            that can be used to manipulate context properties. Context properties are used to provide services to configured components
            running within COM+ applications.
            </para>
            <para>
            For components running within COM applications, the following interfaces are supported for accessing context properties:
            IComThreadingInfo, IContext, and IContextCallback.
            </para>
            <para>
            For components running within COM+ applications, the following interfaces are supported for accessing context properties:
            IObjectContext, IObjectContextActivity, IObjectContextInfo, and IContextState.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetPSClsid(System.Guid@,System.Guid@)">
            <summary>Returns the CLSID of the DLL that implements the proxy and stub for the specified interface.</summary>
            <param name="riid">The interface whose proxy/stub CLSID is to be returned.</param>
            <param name="pClsid">Specifies where to store the proxy/stub CLSID for the interface specified by riid.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The proxy/stub CLSID was successfully returned.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is invalid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There is insufficient memory to complete this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>CoGetPSClsid</c> function looks at the <c>HKEY_CLASSES_ROOT</c>&lt;b&gt;Interfaces&lt;i&gt;{string form of
            riid}&lt;b&gt;ProxyStubClsid32 key in the registry to determine the CLSID of the DLL to load in order to create the proxy and
            stub for the interface specified by riid. This function also returns the CLSID for any interface IID registered by
            CoRegisterPSClsid within the current process.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetStandardMarshal(System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS,Vanara.PInvoke.Ole32.IMarshal@)">
            <summary>
            Creates a default, or standard, marshaling object in either the client process or the server process, depending on the caller,
            and returns a pointer to that object's IMarshal implementation.
            </summary>
            <param name="riid">
            A reference to the identifier of the interface whose pointer is to be marshaled. This interface must be derived from the IUnknown interface.
            </param>
            <param name="pUnk">A pointer to the interface to be marshaled.</param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. Values come from the enumeration MSHCTX. Unmarshaling
            can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same computer as the
            current process (MSHCTX_LOCAL).
            </param>
            <param name="pvDestContext">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="mshlflags">
            Indicates whether the data to be marshaled is to be transmitted back to the client process (the normal case) or written to a
            global table where it can be retrieved by multiple clients. Values come from the MSHLFLAGS enumeration.
            </param>
            <param name="ppMarshal">
            The address of <c>IMarshal*</c> pointer variable that receives the interface pointer to the standard marshaler.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The IMarshal instance was returned successfully.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>Before this function can be called, the CoInitialize or OleInitialize function must be called on the current thread.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoGetStandardMarshal</c> function creates a default, or standard, marshaling object in either the client process or the
            server process, as may be necessary, and returns that object's IMarshal pointer to the caller. If you implement <c>IMarshal</c>,
            you may want your implementation to call <c>CoGetStandardMarshal</c> as a way of delegating to COM's default implementation any
            destination contexts that you do not fully understand or want to handle. Otherwise, you can ignore this function, which COM calls
            as part of its internal marshaling procedures.
            </para>
            <para>
            When the COM library in the client process receives a marshaled interface pointer, it looks for a CLSID to be used in creating a
            proxy for the purposes of unmarshaling the packet. If the packet does not contain a CLSID for the proxy, COM calls
            <c>CoGetStandardMarshal</c>, passing a <c>NULL</c> pUnk value. This function creates a standard proxy in the client process and
            returns a pointer to that proxy's implementation of IMarshal. COM uses this pointer to call CoUnmarshalInterface to retrieve the
            pointer to the requested interface.
            </para>
            <para>
            If your OLE server application's implementation of IMarshal calls <c>CoGetStandardMarshal</c>, you should pass both the IID of
            (riid), and a pointer to (pUnk), the interface being requested.
            </para>
            <para>This function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>Determines whether pUnk is <c>NULL</c>.</term>
            </item>
            <item>
            <term>
            If pUnk is <c>NULL</c>, creates a standard interface proxy in the client process for the specified riid and returns the proxy's
            IMarshal pointer.
            </term>
            </item>
            <item>
            <term>
            If pUnk is not <c>NULL</c>, checks to see if a marshaler for the object already exists, creates a new one if necessary, and
            returns the marshaler's IMarshal pointer.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetStdMarshalEx(System.Object,Vanara.PInvoke.Ole32.STDMSHLFLAGS,System.Object@)">
            <summary>Creates an aggregated standard marshaler for use with lightweight client-side handlers.</summary>
            <param name="pUnkOuter">A pointer to the controlling IUnknown.</param>
            <param name="smexflags">
            <para>
            One of two values indicating whether the aggregated standard marshaler is on the client side or the server side. These flags are
            defined in the <c>STDMSHLFLAGS</c> enumeration.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SMEXF_SERVER 0x01</term>
            <term>Indicates a server-side aggregated standard marshaler.</term>
            </item>
            <item>
            <term>SMEXF_HANDLER 0x0</term>
            <term>Indicates a client-side (handler) aggregated standard marshaler.</term>
            </item>
            </list>
            </param>
            <param name="ppUnkInner">
            On successful return, address of pointer to the IUnknown interface on the newly-created aggregated standard marshaler. If an
            error occurs, this value is <c>NULL</c>.
            </param>
            <returns>This function returns S_OK.</returns>
            <remarks>
            The server calls <c>CoGetStdMarshalEx</c> passing in the flag SMEXF_SERVER. This creates a server side standard marshaler (known
            as a stub manager). The handler calls <c>CoGetStdMarshalEx</c> passing in the flag SMEXF_HANDLER. This creates a client side
            standard marshaler (known as a proxy manager). Note that when calling this function, the handler must pass the original
            controlling unknown that was passed to the handler when the handler was created. This will be the system implemented controlling
            unknown. Failure to pass the correct IUnknown results in an error returned. On success, the ppUnkInner returned is the
            controlling unknown of the inner object. The server and handler must keep this pointer, and may use it to call
            IUnknown::QueryInterface for the IMarshal interface.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetTreatAsClass(System.Guid@,System.Guid@)">
            <summary>Returns the CLSID of an object that can emulate the specified object.</summary>
            <param name="clsidOld">The CLSID of the object that can be emulated (treated as) an object with a different CLSID.</param>
            <param name="pClsidNew">
            A pointer to where the CLSID that can emulate clsidOld objects is retrieved. This parameter cannot be <c>NULL</c>. If there is no
            emulation information for clsidOld objects, the clsidOld parameter is supplied.
            </param>
            <returns>
            <para>This function can return the following values, as well as any error values returned by the CLSIDFromString function.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A new CLSID was successfully returned.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>There is no emulation information for the clsidOld parameter, so the pClsidNew parameter is set to clsidOld.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>CoGetTreatAsClass</c> returns the TreatAs entry in the registry for the specified object. The <c>TreatAs</c> entry, if set, is
            the CLSID of a registered object (an application) that can emulate the object in question. The <c>TreatAs</c> entry is set
            through a call to the CoTreatAsClass function. Emulation allows an application to open and edit an object of a different format,
            while retaining the original format of the object. Objects of the original CLSID are activated and treated as objects of the
            second CLSID. When the object is saved, this may result in loss of edits not supported by the original format. If there is no
            <c>TreatAs</c> entry for the specified object, this function returns the CLSID of the original object (clsidOld).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoImpersonateClient">
            <summary>Enables the server to impersonate the client of the current call for the duration of the call.</summary>
            <returns>This function supports the standard return values, including S_OK.</returns>
            <remarks>
            <para>
            This method allows the server to impersonate the client of the current call for the duration of the call. If you do not call
            CoRevertToSelf, COM reverts automatically for you. This function will fail unless the object is being called with
            RPC_C_AUTHN_LEVEL_CONNECT or higher authentication in effect (which is any authentication level except RPC_C_AUTHN_LEVEL_NONE).
            This function encapsulates the following sequence of common calls (error handling excluded):
            </para>
            <para>
            <c>CoImpersonateClient</c> encapsulates the process of getting a pointer to an instance of IServerSecurity that contains data
            about the current call, calling its ImpersonateClient method, and then releasing the pointer. One call to CoRevertToSelf (or
            IServerSecurity::RevertToSelf) will undo any number of calls to impersonate the client.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoIncrementMTAUsage(Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE@)">
            <summary>Keeps MTA support active when no MTA threads are running.</summary>
            <param name="pCookie">
            Address of a <c>PVOID</c> variable that receives the cookie for the CoDecrementMTAUsage function, or <c>NULL</c> if the call fails.
            </param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            The <c>CoIncrementMTAUsage</c> function enables clients to create MTA workers and wait on them for completion before exiting the process.
            </para>
            <para>
            The <c>CoIncrementMTAUsage</c> function ensures that the system doesn't free resources related to MTA support., even if the MTA
            thread count goes to 0.
            </para>
            <para>On success, call the CoDecrementMTAUsage once only. On failure, don't call the <c>CoDecrementMTAUsage</c> function.</para>
            <para>
            Don't call <c>CoIncrementMTAUsage</c> during process shutdown or inside dllmain. You can call <c>CoIncrementMTAUsage</c> before
            the call to start the shutdown process.
            </para>
            <para>
            You can call <c>CoIncrementMTAUsage</c> from one thread and CoDecrementMTAUsage from another as long as a cookie previously
            returned by <c>CoIncrementMTAUsage</c> is passed to <c>CoDecrementMTAUsage</c>.
            </para>
            <para>
            <c>CoIncrementMTAUsage</c> creates the MTA, if the MTA does not already exist. <c>CoIncrementMTAUsage</c> puts the current thread
            into the MTA, if the current thread is not already in an apartment
            </para>
            <para>You can use <c>CoIncrementMTAUsage</c> when:</para>
            <list type="bullet">
            <item>
            <term>You want a server to keep the MTA alive even when all worker threads are idle.</term>
            </item>
            <item>
            <term>
            Your API implementation requires COM to be initialized, but has no information about whether the current thread is already in an
            apartment, and does not need the current thread to go into a particular apartment.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoInvalidateRemoteMachineBindings(System.String)">
            <summary>
            <para>Tells the service control manager to flush any cached RPC binding handles for the specified computer.</para>
            <para>Only administrators may call this function.</para>
            </summary>
            <param name="pszMachineName">
            The computer name for which binding handles should be flushed, or an empty string to signify that all handles in the cache should
            be flushed.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates success.</term>
            </item>
            <item>
            <term>CO_S_MACHINENAMENOTFOUND</term>
            <term>
            Indicates that the specified computer name was not found or that the binding handle cache was empty, indicating that an empty
            string was passed instead of a specific computer name.
            </term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Indicates the caller was not an administrator for this computer.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>Indicates that a NULL value was passed for pszMachineName.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The OLE Service Control Manager is used by COM to send component activation requests to other machines. To do this, the OLE
            Service Control Manager maintains a cache of RPC binding handles to send activation requests to computer, keyed by computer name.
            Under normal circumstances, this works well, but in some scenarios, such as Web farms and load-balancing situations, the ability
            to purge this cache of specific handles might be needed in order to facilitate rebinding to a different physical server by the
            same name. <c>CoInvalidateRemoteMachineBindings</c> is used for this purpose.
            </para>
            <para>
            The OLE Service Control Manager will flush unused binding handles over time. It is not necessary to call
            <c>CoInvalidateRemoteMachineBindings</c> to do this.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoIsHandlerConnected(System.Object)">
            <summary>Determines whether a remote object is connected to the corresponding in-process object.</summary>
            <param name="pUnk">A pointer to the controlling IUnknown interface on the remote object.</param>
            <returns>
            If the object is not remote or if it is remote and still connected, the return value is <c>TRUE</c>; otherwise, it is <c>FALSE</c>.
            </returns>
            <remarks>
            The <c>CoIsHandlerConnected</c> function determines the status of a remote object. You can use it to determine when to release a
            remote object. You specify the remote object by giving the function a pointer to its controlling IUnknown interface (the pUnk
            parameter). A value of <c>TRUE</c> returned from the function indicates either that the specified object is not remote, or that
            it is remote and is still connected to its remote handler. A value of <c>FALSE</c> returned from the function indicates that the
            object is remote but is no longer connected to its remote handler; in this case, the caller should respond by releasing the object.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoLockObjectExternal(System.Object,System.Boolean,System.Boolean)">
            <summary>Called either to lock an object to ensure that it stays in memory, or to release such a lock.</summary>
            <param name="pUnk">A pointer to the IUnknown interface on the object to be locked or unlocked.</param>
            <param name="fLock">
            Indicates whether the object is to be locked or released. If this parameter is <c>TRUE</c>, the object is kept in memory,
            independent of <c>AddRef</c>/ <c>Release</c> operations, registrations, or revocations. If this parameter is <c>FALSE</c>, the
            lock previously set with a call to this function is released.
            </param>
            <param name="fLastUnlockReleases">
            <para>
            If the lock is the last reference that is supposed to keep an object alive, specify <c>TRUE</c> to release all pointers to the
            object (there may be other references that are not supposed to keep it alive). Otherwise, specify <c>FALSE</c>.
            </para>
            <para>If fLock is <c>TRUE</c>, this parameter is ignored.</para>
            </param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>
            The <c>CoLockObjectExternal</c> function must be called in the process in which the object actually resides (the EXE process, not
            the process in which handlers may be loaded).
            </para>
            <para>
            The <c>CoLockObjectExternal</c> function prevents the reference count of an object from going to zero, thereby "locking" it into
            existence until the lock is released. The same function (with different parameters) releases the lock. The lock is implemented by
            having the system call IUnknown::AddRef on the object. The system then waits to call IUnknown::Release on the object until a
            later call to <c>CoLockObjectExternal</c> with fLock set to <c>FALSE</c>. This function can be used to maintain a reference count
            on the object on behalf of the end user, because it acts outside of the object, as does the user.
            </para>
            <para>
            The end user has explicit control over the lifetime of an application, even if there are external locks on it. That is, if a user
            decides to close the application, it must shut down. In the presence of external locks (such as the lock set by
            <c>CoLockObjectExternal</c>), the application can call the CoDisconnectObject function to force these connections to close prior
            to shutdown.
            </para>
            <para>
            Calling <c>CoLockObjectExternal</c> sets a strong lock on an object. A strong lock keeps an object in memory, while a weak lock
            does not. Strong locks are required, for example, during a silent update to an OLE embedding. The embedded object's container
            must remain in memory until the update process is complete. There must also be a strong lock on an application object to ensure
            that the application stays alive until it has finished providing services to its clients. All external references place a strong
            reference lock on an object.
            </para>
            <para>The <c>CoLockObjectExternal</c> function is typically called in the following situations:</para>
            <list type="bullet">
            <item>
            <term>
            Object servers should call <c>CoLockObjectExternal</c> with both fLock and fLastLockReleases set to <c>TRUE</c> when they become
            visible. This call creates a strong lock on behalf of the user. When the application is closing, free the lock with a call to
            <c>CoLockObjectExternal</c>, setting fLock to <c>FALSE</c> and fLastLockReleases to <c>TRUE</c>.
            </term>
            </item>
            <item>
            <term>A call to <c>CoLockObjectExternal</c> on the server can also be used in the implementation of IOleContainer::LockContainer.</term>
            </item>
            </list>
            <para>
            There are several things to be aware of when you use <c>CoLockObjectExternal</c> in the implementation of LockContainer. An
            embedded object would call <c>LockContainer</c> on its container to keep it running (to lock it) in the absence of other reasons
            to keep it running. When the embedded object becomes visible, the container must weaken its connection to the embedded object
            with a call to the OleSetContainedObject function, so other connections can affect the object.
            </para>
            <para>
            Unless an application manages all aspects of its application and document shutdown completely with calls to
            <c>CoLockObjectExternal</c>, the container must keep a private lock count in LockContainer so that it exits when the lock count
            reaches zero and the container is invisible. Maintaining all aspects of shutdown, and thereby avoiding keeping a private lock
            count, means that <c>CoLockObjectExternal</c> should be called whenever one of the following conditions occur:
            </para>
            <list type="bullet">
            <item>
            <term>A document is created and destroyed or made visible or invisible.</term>
            </item>
            <item>
            <term>An application is started and shut down by the user.</term>
            </item>
            <item>
            <term>A pseudo-object is created and destroyed.</term>
            </item>
            </list>
            <para>For debugging purposes, it may be useful to keep a count of the number of external locks (and unlocks) set on the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoMarshalHresult(System.Runtime.InteropServices.ComTypes.IStream,Vanara.PInvoke.HRESULT)">
            <summary>
            <para>Marshals an <c>HRESULT</c> to the specified stream, from which it can be unmarshaled using the CoUnmarshalHresult function.</para>
            </summary>
            <param name="pstm">
            <para>A pointer to the marshaling stream. See IStream.</para>
            </param>
            <param name="hresult">
            <para>The <c>HRESULT</c> in the originating process.</para>
            </param>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The HRESULT was marshaled successfully.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPOINTER</term>
            <term>A bad pointer was specified for pstm.</term>
            </item>
            <item>
            <term>STG_E_MEDIUMFULL</term>
            <term>The medium is full.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            An <c>HRESULT</c> is process-specific, so an <c>HRESULT</c> that is valid in one process might not be valid in another. If you
            are writing your own implementation of IMarshal and need to marshal an <c>HRESULT</c> from one process to another, either as a
            parameter or a return code, you must call this function. In other circumstances, you will have no need to call this function.
            </para>
            <para>This function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>Writes an <c>HRESULT</c> to a stream.</term>
            </item>
            <item>
            <term>Returns an IStream pointer to that stream.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoMarshalInterface(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS)">
            <summary>Writes into a stream the data required to initialize a proxy object in some client process.</summary>
            <param name="pStm">A pointer to the stream to be used during marshaling. See IStream.</param>
            <param name="riid">
            A reference to the identifier of the interface to be marshaled. This interface must be derived from the IUnknown interface.
            </param>
            <param name="pUnk">A pointer to the interface to be marshaled. This interface must be derived from the IUnknown interface.</param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. The possible values come from the enumeration MSHCTX.
            Currently, unmarshaling can occur in another apartment of the current process (MSHCTX_INPROC), in another process on the same
            computer as the current process (MSHCTX_LOCAL), or in a process on a different computer (MSHCTX_DIFFERENTMACHINE).
            </param>
            <param name="pvDestContext">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="mshlflags">
            The flags that specify whether the data to be marshaled is to be transmitted back to the client process (the typical case) or
            written to a global table, where it can be retrieved by multiple clients. The possibles values come from the MSHLFLAGS enumeration.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, the stream-access error values
            returned by IStream, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The HRESULT was marshaled successfully.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>The CoInitialize or OleInitialize function was not called on the current thread before this function was called.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoMarshalInterface</c> function marshals the interface referred to by riid on the object whose IUnknown implementation is
            pointed to by pUnk. To do so, the <c>CoMarshalInterface</c> function performs the following tasks:
            </para>
            <list type="number">
            <item>
            <term>
            Queries the object for a pointer to the IMarshal interface. If the object does not implement <c>IMarshal</c>, meaning that it
            relies on COM to provide marshaling support, <c>CoMarshalInterface</c> gets a pointer to COM's default implementation of <c>IMarshal</c>.
            </term>
            </item>
            <item>
            <term>
            Gets the CLSID of the object's proxy by calling IMarshal::GetUnmarshalClass, using whichever IMarshal interface pointer has been returned.
            </term>
            </item>
            <item>
            <term>Writes the CLSID of the proxy to the stream to be used for marshaling.</term>
            </item>
            <item>
            <term>Marshals the interface pointer by calling IMarshal::MarshalInterface.</term>
            </item>
            </list>
            <para>
            The COM library in the client process calls the CoUnmarshalInterface function to extract the data and initialize the proxy.
            Before calling <c>CoUnmarshalInterface</c>, seek back to the original position in the stream.
            </para>
            <para>
            If you are implementing existing COM interfaces or defining your own interfaces using the Microsoft Interface Definition Language
            (MIDL), the MIDL-generated proxies and stubs call <c>CoMarshalInterface</c> for you. If you are writing your own proxies and
            stubs, your proxy code and stub code should each call <c>CoMarshalInterface</c> to correctly marshal interface pointers. Calling
            IMarshal directly from your proxy and stub code is not recommended.
            </para>
            <para>
            If you are writing your own implementation of IMarshal, and your proxy needs access to a private object, you can include an
            interface pointer to that object as part of the data you write to the stream. In such situations, if you want to use COM's
            default marshaling implementation when passing the interface pointer, you can call <c>CoMarshalInterface</c> on the object to do so.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoMarshalInterThreadInterfaceInStream(System.Guid@,System.Object,System.Runtime.InteropServices.ComTypes.IStream@)">
            <summary>Marshals an interface pointer from one thread to another thread in the same process.</summary>
            <param name="riid">A reference to the identifier of the interface to be marshaled.</param>
            <param name="pUnk">A pointer to the interface to be marshaled, which must be derived from IUnknown. This parameter can be <c>NULL</c>.</param>
            <param name="ppStm">
            The address of the IStream* pointer variable that receives the interface pointer to the stream that contains the marshaled interface.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            The <c>CoMarshalInterThreadInterfaceInStream</c> function enables an object to easily and reliably marshal an interface pointer
            to another thread in the same process. The stream returned in the ppStm parameter is guaranteed to behave correctly when a client
            running in the receiving thread attempts to unmarshal the pointer. The client can then call the CoGetInterfaceAndReleaseStream to
            unmarshal the interface pointer and release the stream object.
            </para>
            <para>The <c>CoMarshalInterThreadInterfaceInStream</c> function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>Creates a stream object.</term>
            </item>
            <item>
            <term>Passes the stream object's IStream pointer to CoMarshalInterface.</term>
            </item>
            <item>
            <term>Returns the IStream pointer to the caller.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoQueryAuthenticationServices(System.UInt32@,Vanara.InteropServices.SafeCoTaskMemHandle@)">
            <summary>Retrieves a list of the authentication services registered when the process called CoInitializeSecurity.</summary>
            <param name="pcAuthSvc">A pointer to a variable that receives the number of entries returned in the asAuthSvc array.</param>
            <param name="asAuthSvc">
            A pointer to an array of SOLE_AUTHENTICATION_SERVICE structures. The list is allocated through a call to the CoTaskMemAlloc
            function. The caller must free the list when finished with it by calling the CoTaskMemFree function.
            </param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para>
            <c>CoQueryAuthenticationServices</c> retrieves a list of the authentication services currently registered. If the process calls
            CoInitializeSecurity, these are the services registered through that call. If the application does not call it,
            <c>CoInitializeSecurity</c> is called automatically by COM, registering the default security package, the first time an interface
            is marshaled or unmarshaled.
            </para>
            <para>
            This function returns only the authentication services registered with CoInitializeSecurity. It does not return all of the
            authentication services installed on the computer, but EnumerateSecurityPackages does. <c>CoQueryAuthenticationServices</c> is
            primarily useful for custom marshalers, to determine which principal names an application can use.
            </para>
            <para>
            Different authentication services support different levels of security. For example, NTLMSSP does not support delegation or
            mutual authentication while Kerberos does. The application is responsible only for registering authentication services that
            provide the features the application needs. This function provides a way to find out which services have been registered with CoInitializeSecurity.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoQueryAuthenticationServices">
            <summary>Retrieves a list of the authentication services registered when the process called CoInitializeSecurity.</summary>
            <returns>
            An array of SOLE_AUTHENTICATION_SERVICE structures.
            </returns>
            <remarks>
            <para>
            <c>CoQueryAuthenticationServices</c> retrieves a list of the authentication services currently registered. If the process calls
            CoInitializeSecurity, these are the services registered through that call. If the application does not call it,
            <c>CoInitializeSecurity</c> is called automatically by COM, registering the default security package, the first time an interface
            is marshaled or unmarshaled.
            </para>
            <para>
            This function returns only the authentication services registered with CoInitializeSecurity. It does not return all of the
            authentication services installed on the computer, but EnumerateSecurityPackages does. <c>CoQueryAuthenticationServices</c> is
            primarily useful for custom marshalers, to determine which principal names an application can use.
            </para>
            <para>
            Different authentication services support different levels of security. For example, NTLMSSP does not support delegation or
            mutual authentication while Kerberos does. The application is responsible only for registering authentication services that
            provide the features the application needs. This function provides a way to find out which services have been registered with CoInitializeSecurity.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoQueryClientBlanket(Vanara.PInvoke.Ole32.RPC_C_AUTHN@,Vanara.PInvoke.Ole32.RPC_C_AUTHZ@,Vanara.InteropServices.SafeCoTaskMemString@,Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL@,Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL@,Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE@,Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES@)">
            <summary>
            Called by the server to find out about the client that invoked the method executing on the current thread. This is a helper
            function for IServerSecurity::QueryBlanket.
            </summary>
            <param name="pAuthnSvc">
            A pointer to a variable that receives the current authentication service. This will be a single value taken from the
            authentication service constants. If the caller specifies <c>NULL</c>, the current authentication service is not retrieved.
            </param>
            <param name="pAuthzSvc">
            A pointer to a variable that receives the current authorization service. This will be a single value taken from the authorization
            constants. If the caller specifies <c>NULL</c>, the current authorization service is not retrieved.
            </param>
            <param name="pServerPrincName">The string builder.</param>
            <param name="pAuthnLevel">
            A pointer to a variable that receives the current authentication level. This will be a single value taken from the authentication
            level constants. If the caller specifies <c>NULL</c>, the current authentication level is not retrieved.
            </param>
            <param name="pImpLevel">This parameter must be <c>NULL</c>.</param>
            <param name="pPrivs">
            A pointer to a handle that receives the privilege information for the client application. The format of the structure that the
            handle refers to depends on the authentication service. The application should not write or free the memory. The information is
            valid only for the duration of the current call. For NTLMSSP and Kerberos, this is a string identifying the client principal. For
            Schannel, this is a CERT_CONTEXT structure that represents the client's certificate. If the client has no certificate,
            <c>NULL</c> is returned. If the caller specifies <c>NULL</c>, the current privilege information is not retrieved. See RPC_AUTHZ_HANDLE.
            </param>
            <param name="pCapabilities">
            A pointer to return flags indicating capabilities of the call. To request that the principal name be returned in fullsic form if
            Schannel is the authentication service, the caller can set the EOAC_MAKE_FULLSIC flag in this parameter. If the caller specifies
            <c>NULL</c>, the current capabilities are not retrieved.
            </param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para>
            <c>CoQueryClientBlanket</c> is called by the server to get security information about the client that invoked the method
            executing on the current thread. This function encapsulates the following sequence of common calls (error handling excluded):
            </para>
            <para>
            This sequence calls CoGetCallContext to get a pointer to IServerSecurity and, with the resulting pointer, calls
            IServerSecurity::QueryBlanket and then releases the pointer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoQueryProxyBlanket(System.Object,Vanara.PInvoke.Ole32.RPC_C_AUTHN@,Vanara.PInvoke.Ole32.RPC_C_AUTHZ@,Vanara.InteropServices.SafeCoTaskMemString,Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL@,Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL@,Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE@,Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES@)">
            <summary>
            Retrieves the authentication information the client uses to make calls on the specified proxy. This is a helper function for IClientSecurity::QueryBlanket.
            </summary>
            <param name="pProxy">
            A pointer indicating the proxy to query. This parameter cannot be <c>NULL</c>. For more information, see the Remarks section.
            </param>
            <param name="pwAuthnSvc">
            A pointer to a variable that receives the current authentication level. This will be a single value taken from the authentication
            level constants. If the caller specifies <c>NULL</c>, the current authentication level is not retrieved.
            </param>
            <param name="pAuthzSvc">
            A pointer to a variable that receives the current authorization service. This will be a single value taken from the authorization
            constants. If the caller specifies <c>NULL</c>, the current authorization service is not retrieved.
            </param>
            <param name="pServerPrincName">
            The current principal name. The string will be allocated by the callee using CoTaskMemAlloc, and must be freed by the caller
            using CoTaskMemFree. The EOAC_MAKE_FULLSIC flag is not accepted in the pCapabilities parameter. For more information about the
            msstd and fullsic forms, see Principal Names. If the caller specifies <c>NULL</c>, the current principal name is not retrieved.
            </param>
            <param name="pAuthnLevel">
            A pointer to a variable that receives the current authentication level. This will be a single value taken from the authentication
            level constants. If the caller specifies <c>NULL</c>, the current authentication level is not retrieved.
            </param>
            <param name="pImpLevel">
            A pointer to a variable that receives the current impersonation level. This will be a single value taken from the impersonation
            level constants. If the caller specifies <c>NULL</c>, the current impersonation level is not retrieved.
            </param>
            <param name="pAuthInfo">
            A pointer to a handle that receives the identity of the client that was passed to the last IClientSecurity::SetBlanket call (or
            the default value). Default values are only valid until the proxy is released. If the caller specifies <c>NULL</c>, the client
            identity is not retrieved. The format of the structure that the handle refers to depends on the authentication service. The
            application should not write or free the memory. For NTLMSSP and Kerberos, if the client specified a structure in the pAuthInfo
            parameter to CoInitializeSecurity, that value is returned. For Schannel, if a certificate for the client could be retrieved from
            the certificate manager, that value is returned here. Otherwise, <c>NULL</c> is returned. See RPC_AUTH_IDENTITY_HANDLE.
            </param>
            <param name="pCapabilites">
            A pointer to a variable that receives the capabilities of the proxy. If the caller specifies <c>NULL</c>, the current capability
            flags are not retrieved.
            </param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para>
            <c>CoQueryProxyBlanket</c> is called by the client to retrieve the authentication information COM will use on calls made from the
            specified proxy. This function encapsulates the following sequence of common calls (error handling excluded):
            </para>
            <para>
            This sequence calls QueryInterface on the proxy to get a pointer to IClientSecurity, and with the resulting pointer, calls
            IClientSecurity::QueryBlanket and then releases the pointer.
            </para>
            <para>
            In pProxy, you can pass any proxy, such as a proxy you get through a call to CoCreateInstance or CoUnmarshalInterface, or you can
            pass an interface pointer. It can be any interface. You cannot pass a pointer to something that is not a proxy. Therefore, you
            can't pass a pointer to an interface that has the local keyword in its interface definition because no proxy is created for such
            an interface. IUnknown is the exception to this rule.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterActivationFilter(Vanara.PInvoke.Ole32.IActivationFilter)">
            <summary>Registers a process-wide filter to process activation requests.</summary>
            <param name="pActivationFilter">Pointer to the filter to register.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>This registers one and only one process-wide filter.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterClassObject(System.Guid@,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.Ole32.REGCLS,System.UInt32@)">
            <summary>Registers an EXE class object with OLE so other applications can connect to it.</summary>
            <param name="rclsid">The CLSID to be registered.</param>
            <param name="pUnk">A pointer to the IUnknown interface on the class object whose availability is being published.</param>
            <param name="dwClsContext">
            The context in which the executable code is to be run. For information on these context values, see the CLSCTX enumeration.
            </param>
            <param name="flags">
            Indicates how connections are made to the class object. For information on these flags, see the REGCLS enumeration.
            </param>
            <param name="lpdwRegister">
            A pointer to a value that identifies the class object registered; later used by the CoRevokeClassObject function to revoke the registration.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The class object was registered successfully.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            EXE object applications should call <c>CoRegisterClassObject</c> on startup. It can also be used to register internal objects for
            use by the same EXE or other code (such as DLLs) that the EXE uses. Only EXE object applications call
            <c>CoRegisterClassObject</c>. Object handlers or DLL object applications do not call this function — instead, they must implement
            and export the DllGetClassObject function.
            </para>
            <para>
            At startup, a multiple-use EXE object application must create a class object (with the IClassFactory interface on it), and call
            <c>CoRegisterClassObject</c> to register the class object. Object applications that support several different classes (such as
            multiple types of embeddable objects) must allocate and register a different class object for each.
            </para>
            <para>
            Multiple registrations of the same class object are independent and do not produce an error. Each subsequent registration yields
            a unique key in lpdwRegister.
            </para>
            <para>
            Multiple document interface (MDI) applications must register their class objects. Single document interface (SDI) applications
            must register their class objects only if they can be started by means of the <c>/Embedding</c> switch.
            </para>
            <para>
            The server for a class object should call CoRevokeClassObject to revoke the class object (remove its registration) when all of
            the following are true:
            </para>
            <list type="bullet">
            <item>
            <term>There are no existing instances of the object definition.</term>
            </item>
            <item>
            <term>There are no locks on the class object.</term>
            </item>
            <item>
            <term>The application providing services to the class object is not under user control (not visible to the user on the display).</term>
            </item>
            </list>
            <para>
            After the class object is revoked, when its reference count reaches zero, the class object can be released, allowing the
            application to exit. Note that <c>CoRegisterClassObject</c> calls IUnknown::AddRef and CoRevokeClassObject calls
            IUnknown::Release, so the two functions form an <c>AddRef</c>/ <c>Release</c> pair.
            </para>
            <para>
            As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure
            the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not,
            COM fails the registration. If the COM object application runs in the system account with no registry key, COM treats the objects
            application identity as Launching User.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterPSClsid(System.Guid@,System.Guid@)">
            <summary>
            Enables a downloaded DLL to register its custom interfaces within its running process so that the marshaling code will be able to
            marshal those interfaces.
            </summary>
            <param name="riid">A pointer to the IID of the interface to be registered.</param>
            <param name="rclsid">
            A pointer to the CLSID of the DLL that contains the proxy/stub code for the custom interface specified by riid.
            </param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            <para>
            Typically, the code responsible for marshaling an interface pointer into the current running process reads the
            <c>HKEY_CLASSES_ROOT\Interfaces</c> section of the registry to obtain the CLSID of the DLL containing the ProxyStub code to be
            loaded. To obtain the ProxyStub CLSIDs for an existing interface, the code calls the CoGetPSClsid function.
            </para>
            <para>
            In some cases, however, it may be desirable or necessary for an in-process handler or in-process server to make its custom
            interfaces available without writing to the registry. A DLL downloaded across a network may not even have permission to access
            the local registry, and because the code originated on another computer, the user, for security purposes, may want to run it in a
            restricted environment. Or a DLL may have custom interfaces that it uses to talk to a remote server and may also include the
            ProxyStub code for those interfaces. In such cases, a DLL needs an alternative way to register its interfaces.
            <c>CoRegisterPSClsid</c>, used in conjunction with CoRegisterClassObject, provides that alternative.
            </para>
            <para>Examples</para>
            <para>A DLL would typically call <c>CoRegisterPSClsid</c> as shown in the following code fragment.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterSurrogate(Vanara.PInvoke.Ole32.ISurrogate)">
            <summary>Registers the surrogate process through its ISurrogate interface pointer.</summary>
            <param name="pSurrogate">A pointer to the ISurrogate interface on the surrogate process to be registered.</param>
            <returns>This function returns S_OK to indicate that the surrogate process was registered successfully.</returns>
            <remarks>
            <para>
            The <c>CoRegisterSurrogate</c> function sets a global interface pointer to the ISurrogate interface implemented on the surrogate
            process. This pointer is set in the ole32 DLL loaded in the surrogate process. COM uses this global pointer in ole32 to call the
            methods of <c>ISurrogate</c>. This function is usually called by the surrogate implementation when it is launched.
            </para>
            <para>
            As of Windows Server 2003, if a COM object application is registered as a service, COM verifies the registration. COM makes sure
            the process ID of the service, in the service control manager (SCM), matches the process ID of the registering process. If not,
            COM fails the registration.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoReleaseMarshalData(System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>Destroys a previously marshaled data packet.</summary>
            <param name="pStm">A pointer to the stream that contains the data packet to be destroyed. See IStream.</param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The data packet was successfully destroyed.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPOINTER</term>
            <term>An error related to the pStm parameter.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>The CoInitialize or OleInitialize function was not called on the current thread before this function was called.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>Important</c> Security Note: Calling this method with untrusted data is a security risk. Call this method only with trusted
            data. For more information, see Untrusted Data Security Risks.
            </para>
            <para>The <c>CoReleaseMarshalData</c> function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>The function reads a CLSID from the stream.</term>
            </item>
            <item>
            <term>
            If COM's default marshaling implementation is being used, the function gets an IMarshal pointer to an instance of the standard
            unmarshaler. If custom marshaling is being used, the function creates a proxy by calling the CoCreateInstance function, passing
            the CLSID it read from the stream, and requests an <c>IMarshal</c> interface pointer to the newly created proxy.
            </term>
            </item>
            <item>
            <term>Using whichever IMarshal interface pointer it has acquired, the function calls IMarshal::ReleaseMarshalData.</term>
            </item>
            </list>
            <para>
            You typically do not call this function. The only situation in which you might need to call this function is if you use custom
            marshaling (write and use your own implementation of IMarshal). Examples of when <c>CoReleaseMarshalData</c> should be called
            include the following situations:
            </para>
            <list type="bullet">
            <item>
            <term>An attempt was made to unmarshal the data packet, but it failed.</term>
            </item>
            <item>
            <term>A marshaled data packet was removed from a global table.</term>
            </item>
            </list>
            <para>
            As an analogy, the data packet can be thought of as a reference to the original object, just as if it were another interface
            pointer being held on the object. Like a real interface pointer, that data packet must be released at some point. The use of
            IMarshal::ReleaseMarshalData to release data packets is analogous to the use of IUnknown::Release to release interface pointers.
            </para>
            <para>
            Note that you do not need to call <c>CoReleaseMarshalData</c> after a successful call of the CoUnmarshalInterface function; that
            function releases the marshal data as part of the processing that it does.
            </para>
            <para>
            <c>Important</c> You must call the <c>CoReleaseMarshalData</c> function in the same apartment that called CoMarshalInterface to
            marshal the object into the stream. Failure to do this may cause the object reference held by the marshaled packet in the stream
            to be leaked.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoReleaseServerProcess">
            <summary>Decrements the global per-process reference count.</summary>
            <returns>
            If the server application should initiate its cleanup, the function returns 0; otherwise, the function returns a nonzero value.
            </returns>
            <remarks>
            <para>
            Servers can call <c>CoReleaseServerProcess</c> to decrement a global per-process reference count incremented through a call to CoAddRefServerProcess.
            </para>
            <para>
            When that count reaches zero, OLE automatically calls CoSuspendClassObjects, which prevents new activation requests from coming
            in. This permits the server to deregister its class objects from its various threads without worry that another activation
            request may come in. New activation requests result in launching a new instance of the local server process.
            </para>
            <para>
            The simplest way for a local server application to make use of these functions is to call CoAddRefServerProcess in the
            constructor for each of its instance objects, and in each of its IClassFactory::LockServer methods when the fLock parameter is
            <c>TRUE</c>. The server application should also call <c>CoReleaseServerProcess</c> in the destructor of each of its instance
            objects, and in each of its <c>IClassFactory::LockServer</c> methods when the fLock parameter is <c>FALSE</c>. Finally, the
            server application must check the return code from <c>CoReleaseServerProcess</c>; if it returns 0, the server application should
            initiate its cleanup. This typically means that a server with multiple threads should signal its various threads to exit their
            message loops and call CoRevokeClassObject and CoUninitialize.
            </para>
            <para>
            If these APIs are used at all, they must be called in both the object instances and the LockServer method, otherwise the server
            application may be shutdown prematurely. In-process Servers typically should not call CoAddRefServerProcess or <c>CoReleaseServerProcess</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoResumeClassObjects">
            <summary>
            Called by a server that can register multiple class objects to inform the SCM about all registered classes, and permits
            activation requests for those class objects.
            </summary>
            <returns>This function returns S_OK to indicate that the CLSID was retrieved successfully.</returns>
            <remarks>
            <para>
            Servers that can register multiple class objects call <c>CoResumeClassObjects</c> once, after having first called
            CoRegisterClassObject, specifying REGCLS_LOCAL_SERVER | REGCLS_SUSPENDED for each CLSID the server supports. This function causes
            OLE to inform the SCM about all the registered classes, and begins letting activation requests into the server process.
            </para>
            <para>
            This reduces the overall registration time, and thus the server application startup time, by making a single call to the SCM, no
            matter how many CLSIDs are registered for the server. Another advantage is that if the server has multiple apartments with
            different CLSIDs registered in different apartments, or is a free-threaded server, no activation requests will come in until the
            server calls <c>CoResumeClassObjects</c>. This gives the server a chance to register all of its CLSIDs and get properly set up
            before having to deal with activation requests, and possibly shutdown requests.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRevertToSelf">
            <summary>Restores the authentication information on a thread of execution.</summary>
            <returns>This function supports the standard return values, including S_OK to indicate success.</returns>
            <remarks>
            <para>
            <c>CoRevertToSelf</c>, which is a helper function that calls IServerSecurity::RevertToSelf, restores the authentication
            information on a thread to the authentication information on the thread before impersonation began.
            </para>
            <para><c>CoRevertToSelf</c> encapsulates the following common sequence of calls (error handling excluded):</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRevokeClassObject(System.UInt32)">
            <summary>
            Informs OLE that a class object, previously registered with the CoRegisterClassObject function, is no longer available for use.
            </summary>
            <param name="dwRegister">A token previously returned from the CoRegisterClassObject function.</param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The class object was revoked successfully.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A successful call to <c>CoRevokeClassObject</c> means that the class object has been removed from the global class object table
            (although it does not release the class object). If other clients still have pointers to the class object and have caused the
            reference count to be incremented by calls to IUnknown::AddRef, the reference count will not be zero. When this occurs,
            applications may benefit if subsequent calls (with the obvious exceptions of <c>AddRef</c> and IUnknown::Release) to the class
            object fail. Note that CoRegisterClassObject calls <c>AddRef</c> and <c>CoRevokeClassObject</c> calls <c>Release</c>, so the two
            functions form an <c>AddRef</c>/ <c>Release</c> pair.
            </para>
            <para>
            An object application must call <c>CoRevokeClassObject</c> to revoke registered class objects before exiting the program. Class
            object implementers should call <c>CoRevokeClassObject</c> as part of the release sequence. You must specifically revoke the
            class object even when you have specified the flags value REGCLS_SINGLEUSE in a call to CoRegisterClassObject, indicating that
            only one application can connect to the class object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoSetCancelObject(System.Object)">
            <summary>
            Sets (registers) or resets (unregisters) a cancel object for use during subsequent cancel operations on the current thread.
            </summary>
            <param name="pUnk">
            Pointer to the IUnknown interface on the cancel object to be set or reset on the current thread. If this parameter is
            <c>NULL</c>, the topmost cancel object is reset.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The cancel object was successfully set or reset.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The cancel object cannot be set or reset at this time because of a block on cancel operations.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            For objects that support standard marshaling, the proxy object begins marshaling a method call by calling
            <c>CoSetCancelObject</c> to register a cancel object for the current thread.
            </para>
            <para>
            <c>CoSetCancelObject</c> calls QueryInterface for ICancelMethodCalls on the cancel object. If the cancel object does not
            implement <c>ICancelMethodCalls</c>, <c>CoSetCancelObject</c> fails with E_NOINTERFACE. To disable cancel operations on a
            custom-marshaled interface, the implementation of ICancelMethodCalls::Cancel should do nothing but return E_NOTIMPL, E_FAIL, or
            some other appropriate value.
            </para>
            <para><c>CoSetCancelObject</c> calls AddRef on objects that it registers and Release on objects that it unregisters.</para>
            <para><c>CoSetCancelObject</c> does not set or reset cancel objects for asynchronous methods.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoSetProxyBlanket(System.Object,Vanara.PInvoke.Ole32.RPC_C_AUTHN,Vanara.PInvoke.Ole32.RPC_C_AUTHZ,System.String,Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL,Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL,Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE,Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES)">
            <summary>
            Sets the authentication information that will be used to make calls on the specified proxy. This is a helper function for IClientSecurity::SetBlanket.
            </summary>
            <param name="pProxy">The proxy to be set.</param>
            <param name="dwAuthnSvc">
            The authentication service to be used. For a list of possible values, see Authentication Service Constants. Use RPC_C_AUTHN_NONE
            if no authentication is required. If RPC_C_AUTHN_DEFAULT is specified, DCOM will pick an authentication service following its
            normal security blanket negotiation algorithm.
            </param>
            <param name="dwAuthzSvc">
            The authorization service to be used. For a list of possible values, see Authorization Constants. If RPC_C_AUTHZ_DEFAULT is
            specified, DCOM will pick an authorization service following its normal security blanket negotiation algorithm. RPC_C_AUTHZ_NONE
            should be used as the authorization service if NTLMSSP, Kerberos, or Schannel is used as the authentication service.
            </param>
            <param name="pServerPrincName">
            <para>
            The server principal name to be used with the authentication service. If COLE_DEFAULT_PRINCIPAL is specified, DCOM will pick a
            principal name using its security blanket negotiation algorithm. If Kerberos is used as the authentication service, this value
            must not be <c>NULL</c>. It must be the correct principal name of the server or the call will fail.
            </para>
            <para>
            If Schannel is used as the authentication service, this value must be one of the msstd or fullsic forms described in Principal
            Names, or <c>NULL</c> if you do not want mutual authentication.
            </para>
            <para>
            Generally, specifying <c>NULL</c> will not reset the server principal name on the proxy; rather, the previous setting will be
            retained. You must be careful when using <c>NULL</c> as pServerPrincName when selecting a different authentication service for
            the proxy, because there is no guarantee that the previously set principal name would be valid for the newly selected
            authentication service.
            </para>
            </param>
            <param name="dwAuthnLevel">
            The authentication level to be used. For a list of possible values, see Authentication Level Constants. If
            RPC_C_AUTHN_LEVEL_DEFAULT is specified, DCOM will pick an authentication level following its normal security blanket negotiation
            algorithm. If this value is none, the authentication service must also be none.
            </param>
            <param name="dwImpLevel">
            The impersonation level to be used. For a list of possible values, see Impersonation Level Constants. If RPC_C_IMP_LEVEL_DEFAULT
            is specified, DCOM will pick an impersonation level following its normal security blanket negotiation algorithm. If NTLMSSP is
            the authentication service, this value must be RPC_C_IMP_LEVEL_IMPERSONATE or RPC_C_IMP_LEVEL_IDENTIFY. NTLMSSP also supports
            delegate-level impersonation (RPC_C_IMP_LEVEL_DELEGATE) on the same computer. If Schannel is the authentication service, this
            parameter must be RPC_C_IMP_LEVEL_IMPERSONATE.
            </param>
            <param name="pAuthInfo">
            <para>
            A pointer to an <c>RPC_AUTH_IDENTITY_HANDLE</c> value that establishes the identity of the client. The format of the structure
            referred to by the handle depends on the provider of the authentication service.
            </para>
            <para>
            For calls on the same computer, RPC logs on the user with the supplied credentials and uses the resulting token for the method call.
            </para>
            <para>
            For NTLMSSP or Kerberos, the structure is a SEC_WINNT_AUTH_IDENTITY or SEC_WINNT_AUTH_IDENTITY_EX structure. The client can
            discard pAuthInfo after calling the API. RPC does not keep a copy of the pAuthInfo pointer, and the client cannot retrieve it
            later in the CoQueryProxyBlanket method.
            </para>
            <para>
            If this parameter is <c>NULL</c>, DCOM uses the current proxy identity (which is either the process token or the impersonation
            token). If the handle refers to a structure, that identity is used.
            </para>
            <para>
            For Schannel, this parameter must be either a pointer to a CERT_CONTEXT structure that contains the client's X.509 certificate or
            is <c>NULL</c> if the client wishes to make an anonymous connection to the server. If a certificate is specified, the caller must
            not free it as long as any proxy to the object exists in the current apartment.
            </para>
            <para>
            For Snego, this member is either <c>NULL</c>, points to a SEC_WINNT_AUTH_IDENTITY structure, or points to a
            SEC_WINNT_AUTH_IDENTITY_EX structure. If it is <c>NULL</c>, Snego will pick a list of authentication services based on those
            available on the client computer. If it points to a <c>SEC_WINNT_AUTH_IDENTITY_EX</c> structure, the structure's
            <c>PackageList</c> member must point to a string containing a comma-separated list of authentication service names and the
            <c>PackageListLength</c> member must give the number of bytes in the <c>PackageList</c> string. If <c>PackageList</c> is
            <c>NULL</c>, all calls using Snego will fail.
            </para>
            <para>
            If COLE_DEFAULT_AUTHINFO is specified for this parameter, DCOM will pick the authentication information following its normal
            security blanket negotiation algorithm.
            </para>
            <para><c>CoSetProxyBlanket</c> will fail if pAuthInfo is set and one of the cloaking flags is set in the dwCapabilities parameter.</para>
            </param>
            <param name="dwCapabilities">
            The capabilities of this proxy. For a list of possible values, see the EOLE_AUTHENTICATION_CAPABILITIES enumeration. The only
            flags that can be set through this function are EOAC_MUTUAL_AUTH, EOAC_STATIC_CLOAKING, EOAC_DYNAMIC_CLOAKING, EOAC_ANY_AUTHORITY
            (this flag is deprecated), EOAC_MAKE_FULLSIC, and EOAC_DEFAULT. Either EOAC_STATIC_CLOAKING or EOAC_DYNAMIC_CLOAKING can be set
            if pAuthInfo is not set and Schannel is not the authentication service. (See Cloaking for more information.) If any capability
            flags other than those mentioned here are set, <c>CoSetProxyBlanket</c> will fail.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function was successful.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more arguments is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoSetProxyBlanket</c> sets the authentication information that will be used to make calls on the specified proxy. This
            function encapsulates the following sequence of common calls (error handling excluded).
            </para>
            <para>
            This sequence calls QueryInterface on the proxy to get a pointer to IClientSecurity, and with the resulting pointer, calls
            IClientSecurity::SetBlanket and then releases the pointer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoSuspendClassObjects">
            <summary>Prevents any new activation requests from the SCM on all class objects registered within the process.</summary>
            <returns>This function returns S_OK to indicate that the activation of class objects was successfully suspended.</returns>
            <remarks>
            <c>CoSuspendClassObjects</c> prevents any new activation requests from the SCM on all class objects registered within the
            process. Even though a process may call this function, the process still must call the CoRevokeClassObject function for each
            CLSID it has registered, in the apartment it registered in. Applications typically do not need to call this function, which is
            generally only called internally by OLE when used in conjunction with the CoReleaseServerProcess function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoSwitchCallContext(System.Object,System.Object@)">
            <summary>Switches the call context object used by CoGetCallContext.</summary>
            <param name="pNewObject">
            A pointer to an interface on the new call context object. COM stores this pointer without adding a reference to the pointer until
            <c>CoSwitchCallContext</c> is called with another object. This parameter may be <c>NULL</c> if you are calling
            <c>CoSwitchCallContext</c> to switch back to the original call context but there was no original call context.
            </param>
            <param name="ppOldObject">
            The address of pointer variable that receives a pointer to the call context object of the call currently in progress. This value
            is returned so that the original call context can be restored by the custom marshaller. The returned pointer will be <c>NULL</c>
            if there was no call in progress.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function was successful.</term>
            </item>
            <item>
            <term>E_OUT_OF_MEMORY</term>
            <term>Out of memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Custom marshallers call <c>CoSwitchCallContext</c> to change the call context object used by the CoGetCallContext function.
            Before dispatching an arriving call, custom marshallers call <c>CoSwitchCallContext</c>, specifying the new context object. After
            sending a reply, they must restore the original call context by calling <c>CoSwitchCallContext</c> again, this time passing a
            pointer to the original context object.
            </para>
            <para>
            <c>CoSwitchCallContext</c> does not add a reference to the new context object. Custom marshallers must ensure that the lifetime
            of their context object continues throughout their call and until the call to restore the original context. Custom marshallers
            should not release the value that they placed into the ppOldObject parameter when they set their context.
            </para>
            <para>Call context objects provided by custom marshallers should support the IServerSecurity interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoTaskMemAlloc(Vanara.PInvoke.SizeT)">
            <summary>Allocates a block of task memory in the same way that IMalloc::Alloc does.</summary>
            <param name="cb">The size of the memory block to be allocated, in bytes.</param>
            <returns>If the function succeeds, it returns the allocated memory block. Otherwise, it returns <c>NULL</c>.</returns>
            <remarks>
            <para>
            <c>CoTaskMemAlloc</c> uses the default allocator to allocate a memory block in the same way that IMalloc::Alloc does. It is not
            necessary to call the CoGetMalloc function before calling <c>CoTaskMemAlloc</c>.
            </para>
            <para>
            The initial contents of the returned memory block are undefined – there is no guarantee that the block has been initialized. The
            allocated block may be larger than cb bytes because of the space required for alignment and for maintenance information.
            </para>
            <para>
            If cb is 0, <c>CoTaskMemAlloc</c> allocates a zero-length item and returns a valid pointer to that item. If there is insufficient
            memory available, <c>CoTaskMemAlloc</c> returns <c>NULL</c>. Applications should always check the return value from this
            function, even when requesting small amounts of memory, because there is no guarantee that the memory will be allocated.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoTaskMemFree(System.IntPtr)">
            <summary>Frees a block of task memory previously allocated through a call to the CoTaskMemAlloc or CoTaskMemRealloc function.</summary>
            <param name="pv">A pointer to the memory block to be freed. If this parameter is <c>NULL</c>, the function has no effect.</param>
            <returns>This function does not return a value.</returns>
            <remarks>
            <para>The <c>CoTaskMemFree</c> function uses the default OLE allocator.</para>
            <para>
            The number of bytes freed equals the number of bytes that were originally allocated or reallocated. After the call, the memory
            block pointed to by pv is invalid and can no longer be used.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoTaskMemRealloc(System.IntPtr,Vanara.PInvoke.SizeT)">
            <summary>Changes the size of a previously allocated block of task memory.</summary>
            <param name="pv">A pointer to the memory block to be reallocated. This parameter can be <c>NULL</c>, as discussed in Remarks.</param>
            <param name="cb">The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in Remarks.</param>
            <returns>If the function succeeds, it returns the reallocated memory block. Otherwise, it returns <c>NULL</c>.</returns>
            <remarks>
            <para>
            This function changes the size of a previously allocated memory block in the same way that IMalloc::Realloc does. It is not
            necessary to call the CoGetMalloc function to get a pointer to the OLE allocator before calling <c>CoTaskMemRealloc</c>.
            </para>
            <para>
            The pv parameter points to the beginning of the memory block. If pv is <c>NULL</c>, <c>CoTaskMemRealloc</c> allocates a new
            memory block in the same way as the CoTaskMemAlloc function. If pv is not <c>NULL</c>, it should be a pointer returned by a prior
            call to <c>CoTaskMemAlloc</c>.
            </para>
            <para>
            The cb parameter specifies the size of the new block. The contents of the block are unchanged up to the shorter of the new and
            old sizes, although the new block can be in a different location. Because the new block can be in a different memory location,
            the pointer returned by <c>CoTaskMemRealloc</c> is not guaranteed to be the pointer passed through the pv argument. If pv is not
            <c>NULL</c> and cb is 0, then the memory pointed to by pv is freed.
            </para>
            <para>
            <c>CoTaskMemRealloc</c> returns a void pointer to the reallocated (and possibly moved) memory block. The return value is
            <c>NULL</c> if the size is 0 and the buffer argument is not <c>NULL</c>, or if there is not enough memory available to expand the
            block to the specified size. In the first case, the original block is freed; in the second case, the original block is unchanged.
            </para>
            <para>
            The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. To get a
            pointer to a type other than <c>void</c>, use a type cast on the return value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoTestCancel">
            <summary>
            <para>Determines whether the call being executed on the server has been canceled by the client.</para>
            </summary>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>RPC_S_CALLPENDING</term>
            <term>The call is still pending and has not yet been canceled by the client.</term>
            </item>
            <item>
            <term>RPC_E_CALL_CANCELED</term>
            <term>The call has been canceled by the client.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Server objects should call <c>CoTestCancel</c> at least once before returning to detect client cancellation requests. Doing so
            can save the server unnecessary work if the client has issued a cancellation request, and it can reduce the client's wait time if
            it has set the cancel timeout as RPC_C_CANCEL_INFINITE_TIMEOUT. Furthermore, if the server object detects a cancellation request
            before returning from a pending call, it can clean up any memory, marshaled interfaces, or handles it has created or obtained.
            </para>
            <para>
            <c>CoTestCancel</c> calls CoGetCallContext to obtain the ICancelMethodCalls interface on the current cancel object and then calls
            ICancelMethodCalls::TestCancel. Objects that implement custom marshaling should first call CoSwitchCallContext to install the
            appropriate call context object.
            </para>
            <para>This function does not test cancellation for asynchronous calls.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoUnmarshalHresult(System.Runtime.InteropServices.ComTypes.IStream,Vanara.PInvoke.HRESULT@)">
            <summary>Unmarshals an <c>HRESULT</c> type from the specified stream.</summary>
            <param name="pstm">A pointer to the stream from which the <c>HRESULT</c> is to be unmarshaled.</param>
            <param name="phresult">A pointer to the unmarshaled <c>HRESULT</c>.</param>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The HRESULT was unmarshaled successfully.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPOINTER</term>
            <term>pStm is an invalid pointer.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You do not explicitly call this function unless you are performing custom marshaling (that is, writing your own implementation of
            IMarshal), and your implementation needs to unmarshal an <c>HRESULT</c>.
            </para>
            <para>
            You must use <c>CoUnmarshalHresult</c> to unmarshal <c>HRESULT</c> values previously marshaled by a call to the CoMarshalHresult function.
            </para>
            <para>This function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>an <c>HRESULT</c> from a stream.</term>
            </item>
            <item>
            <term>Returns the <c>HRESULT</c>.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoUnmarshalInterface(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@,System.Object@)">
            <summary>
            Initializes a newly created proxy using data written into the stream by a previous call to the CoMarshalInterface function, and
            returns an interface pointer to that proxy.
            </summary>
            <param name="pStm">A pointer to the stream from which the interface is to be unmarshaled.</param>
            <param name="riid">
            A reference to the identifier of the interface to be unmarshaled. For <c>IID_NULL</c>, the returned interface is the one defined
            by the stream, objref.iid.
            </param>
            <param name="ppv">
            The address of pointer variable that receives the interface pointer requested in <paramref name="riid"/>. Upon successful return,
            <paramref name="ppv"/> contains the requested interface pointer for the unmarshaled interface.
            </param>
            <returns>
            <para>This function can return the standard return value E_FAIL, errors returned by CoCreateInstance, and the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface pointer was unmarshaled successfully.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPOINTER</term>
            <term>pStm is an invalid pointer.</term>
            </item>
            <item>
            <term>CO_E_NOTINITIALIZED</term>
            <term>The CoInitialize or OleInitialize function was not called on the current thread before this function was called.</term>
            </item>
            <item>
            <term>CO_E_OBJNOTCONNECTED</term>
            <term>
            The object application has been disconnected from the remoting system (for example, as a result of a call to the
            CoDisconnectObject function).
            </term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>An error occurred reading the registration database.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The final QueryInterface of this function for the requested interface returned E_NOINTERFACE.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>Important</c> Security Note: Calling this method with untrusted data is a security risk. Call this method only with trusted
            data. For more information, see Untrusted Data Security Risks.
            </para>
            <para>The <c>CoUnmarshalInterface</c> function performs the following tasks:</para>
            <list type="number">
            <item>
            <term>Reads from the stream the CLSID to be used to create an instance of the proxy.</term>
            </item>
            <item>
            <term>
            Gets an IMarshal pointer to the proxy that is to do the unmarshaling. If the object uses COM's default marshaling implementation,
            the pointer thus obtained is to an instance of the generic proxy object. If the marshaling is occurring between two threads in
            the same process, the pointer is to an instance of the in-process free threaded marshaler. If the object provides its own
            marshaling code, <c>CoUnmarshalInterface</c> calls the CoCreateInstance function, passing the CLSID it read from the marshaling
            stream. <c>CoCreateInstance</c> creates an instance of the object's proxy and returns an <c>IMarshal</c> interface pointer to the proxy.
            </term>
            </item>
            <item>
            <term>
            Using whichever IMarshal interface pointer it has acquired, the function then calls IMarshal::UnmarshalInterface and, if
            appropriate, IMarshal::ReleaseMarshalData.
            </term>
            </item>
            </list>
            <para>
            The primary caller of this function is COM itself, from within interface proxies or stubs that unmarshal an interface pointer.
            There are, however, some situations in which you might call <c>CoUnmarshalInterface</c>. For example, if you are implementing a
            stub, your implementation would call <c>CoUnmarshalInterface</c> when the stub receives an interface pointer as a parameter in a
            method call.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoWaitForMultipleHandles(Vanara.PInvoke.Ole32.COWAIT_FLAGS,System.UInt32,System.UInt32,System.IntPtr[],System.UInt32@)">
            <summary>Waits for specified handles to be signaled or for a specified timeout period to elapse.</summary>
            <param name="dwFlags">The wait options. Possible values are taken from the COWAIT_FLAGS enumeration.</param>
            <param name="dwTimeout">The timeout period, in milliseconds.</param>
            <param name="cHandles">The number of elements in the pHandles array.</param>
            <param name="pHandles">An array of handles.</param>
            <param name="lpdwindex">
            <para>
            A pointer to a variable that, when the returned status is S_OK, receives a value indicating the event that caused the function to
            return. This value is usually the index into pHandles for the handle that was signaled.
            </para>
            <para>
            If pHandles includes one or more handles to mutex objects, a value between WAIT_ABANDONED_0 and (WAIT_ABANDONED_0 + nCountâ€“ 1)
            indicates the index into pHandles for the mutex that was abandoned.
            </para>
            <para>
            If the COWAIT_ALERTABLE flag is set in dwFlags, a value of WAIT_IO_COMPLETION indicates the wait was ended by one or more
            user-mode asynchronous procedure calls (APC) queued to the thread.
            </para>
            <para>See WaitForMultipleObjectsEx for more information.</para>
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <para>
            <c>Note</c> The return value of <c>CoWaitForMultipleHandles</c> can be nondeterministic if the COWAIT_ALERTABLE flag is set in
            dwFlags, or if pHandles includes one or more handles to mutex objects. The recommended workaround is to call
            SetLastError(ERROR_SUCCESS) before <c>CoWaitForMultipleHandles</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The required handle or handles were signaled.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>pHandles was NULL, lpdwindex was NULL, or dwFlags was not a value from the COWAIT_FLAGS enumeration.</term>
            </item>
            <item>
            <term>RPC_E_NO_SYNC</term>
            <term>The value of pHandles was 0.</term>
            </item>
            <item>
            <term>RPC_S_CALLPENDING</term>
            <term>The timeout period elapsed before the required handle or handles were signaled.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Depending on which flags are set in the dwFlags parameter, <c>CoWaitForMultipleHandles</c> blocks the calling thread until one of
            the following events occurs:
            </para>
            <list type="bullet">
            <item>
            <term>
            One or all of the handles is signaled. In the case of mutex objects, this condition is also satisfied by a mutex being abandoned.
            </term>
            </item>
            <item>
            <term>An asynchronous procedure call (APC) has been queued to the calling thread with a call to the QueueUserAPC function.</term>
            </item>
            <item>
            <term>The timeout period expires.</term>
            </item>
            </list>
            <para>
            If the caller resides in a single-thread apartment, <c>CoWaitForMultipleHandles</c> enters the COM modal loop, and the thread's
            message loop will continue to dispatch messages using the thread's message filter. If no message filter is registered for the
            thread, the default COM message processing is used.
            </para>
            <para>
            If the calling thread resides in a multithread apartment (MTA), <c>CoWaitForMultipleHandles</c> calls the
            WaitForMultipleObjectsEx function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoWaitForMultipleObjects(Vanara.PInvoke.Ole32.CWMO_FLAGS,System.UInt32,System.UInt32,System.IntPtr[],System.UInt32@)">
            <summary>
            A replacement for CoWaitForMultipleHandles. This replacement API hides the options for <c>CoWaitForMultipleHandles</c> that are
            not supported in ASTA.
            </summary>
            <param name="dwFlags">
            CWMO_FLAGS flag controlling whether call/window message reentrancy is enabled from this wait. By default, neither COM calls nor
            window messages are dispatched from <c>CoWaitForMultipleObjects</c> in ASTA.
            </param>
            <param name="dwTimeout">The timeout in milliseconds of the wait.</param>
            <param name="cHandles">The length of the pHandles array. Must be &lt;= 56.</param>
            <param name="pHandles">An array of handles to waitable kernel objects.</param>
            <param name="lpdwindex">Receives the index of the handle that satisfied the wait.</param>
            <returns>
            Same return values as CoWaitForMultipleHandles, except the ASTA-specific CO_E_NOTSUPPORTED cases instead return E_INVALIDARG from
            all apartment types.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateStreamOnHGlobal(System.IntPtr,System.Boolean,System.Runtime.InteropServices.ComTypes.IStream@)">
            <summary>
            <para>
            The <c>CreateStreamOnHGlobal</c> function creates a stream object that uses an HGLOBAL memory handle to store the stream
            contents. This object is the OLE-provided implementation of the IStream interface.
            </para>
            <para>
            The returned stream object supports both reading and writing, is not transacted, and does not support region locking. The object
            calls the GlobalReAlloc function to grow the memory block as required.
            </para>
            <para>
            <c>Tip</c> Consider using the SHCreateMemStream function, which produces better performance, or for Windows Store apps, consider
            using InMemoryRandomAccessStream.
            </para>
            </summary>
            <param name="hGlobal">
            A memory handle allocated by the GlobalAlloc function, or if <c>NULL</c> a new handle is to be allocated instead. The handle must
            be allocated as moveable and nondiscardable.
            </param>
            <param name="fDeleteOnRelease">
            A value that indicates whether the underlying handle for this stream object should be automatically freed when the stream object
            is released. If set to <c>FALSE</c>, the caller must free the hGlobal after the final release. If set to <c>TRUE</c>, the final
            release will automatically free the hGlobal parameter.
            </param>
            <param name="ppstm">
            The address of IStream* pointer variable that receives the interface pointer to the new stream object. Its value cannot be <c>NULL</c>.
            </param>
            <returns>This function supports the standard return values E_INVALIDARG and E_OUTOFMEMORY, as well as the following.</returns>
            <remarks>
            <para>If hGlobal is <c>NULL</c>, the function allocates a new memory handle and the stream is initially empty.</para>
            <para>
            If hGlobal is not <c>NULL</c>, the initial contents of the stream are the current contents of the memory block. Thus,
            <c>CreateStreamOnHGlobal</c> can be used to open an existing stream in memory. The memory handle and its contents are undisturbed
            by the creation of the new stream object.
            </para>
            <para>
            The initial size of the stream is the size of hGlobal as returned by the GlobalSize function. Because of rounding, this is not
            necessarily the same size that was originally allocated for the handle. If the logical size of the stream is important, follow
            the call to this function with a call to the IStream::SetSize method.
            </para>
            <para>The new stream object’s initial seek position is the beginning of the stream.</para>
            <para>
            After creating the stream object with <c>CreateStreamOnHGlobal</c>, call GetHGlobalFromStream to retrieve the memory handle
            associated with the stream object.
            </para>
            <para>
            If a memory handle is passed to <c>CreateStreamOnHGlobal</c> or if GetHGlobalFromStream is called, the memory handle of this
            function can be directly accessed by the caller while it is still in use by the stream object. Appropriate caution should be
            exercised in the use of this capability and its implications:
            </para>
            <list type="bullet">
            <item>
            <term>
            Do not free the hGlobal memory handle during the lifetime of the stream object. IStream::Release must be called before freeing
            the memory handle.
            </term>
            </item>
            <item>
            <term>
            Do not call GlobalReAlloc to change the size of the memory handle during the lifetime of the stream object or its clones. This
            may cause application crashes or memory corruption. Avoid creating multiple stream objects separately on the same memory handle,
            because the IStream::Write and IStream::SetSize methods may internally call <c>GlobalReAlloc</c>. The IStream::Clone method can
            be used to create a new stream object based on the same memory handle that will properly coordinate its access with the original
            stream object.
            </term>
            </item>
            <item>
            <term>
            If possible, avoid accessing the memory block during the lifetime of the stream object, because the object may internally call
            GlobalReAlloc and do not make assumptions about its size and location. If the memory block must be accessed, the memory access
            calls should be surrounded by calls to GlobalLock and GlobalUnLock.
            </term>
            </item>
            <item>
            <term>
            Avoid calling the object’s methods while you have the memory handle locked with GlobalLock. This can cause method calls to fail unpredictably.
            </term>
            </item>
            </list>
            <para>
            If the caller sets the fDeleteOnRelease parameter to <c>FALSE</c>, then the caller must also free the hGlobal after the final
            release. If the caller sets the fDeleteOnRelease parameter to <c>TRUE</c>, the final release will automatically free the hGlobal.
            </para>
            <para>
            The memory handle passed as the hGlobal parameter must be allocated as movable and nondiscardable, as shown in the following example:
            </para>
            <para>
            <c>CreateStreamOnHGlobal</c> will accept a memory handle allocated with GMEM_FIXED, but this usage is not recommended. HGLOBALs
            allocated with <c>GMEM_FIXED</c> are not really handles and their value can change when they are reallocated. If the memory
            handle was allocated with <c>GMEM_FIXED</c> and fDeleteOnRelease is <c>FALSE</c>, the caller must call GetHGlobalFromStream to
            get the correct handle in order to free it.
            </para>
            <para>
            Prior to Windows 7 and Windows Server 2008 R2, this implementation did not zero memory when calling GlobalReAlloc to grow the
            memory block. Increasing the size of the stream with IStream::SetSize or by writing to a location past the current end of the
            stream may leave portions of the newly allocated memory uninitialized.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.DllCanUnloadNow">
            <summary>
            <para>Determines whether the DLL that implements this function is in use. If not, the caller can unload the DLL from memory.</para>
            <para>
            OLE does not provide this function. DLLs that support the OLE Component Object Model (COM) should implement and export <c>DllCanUnloadNow</c>.
            </para>
            </summary>
            <returns>If the function succeeds, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <remarks>
            <para>
            A call to <c>DllCanUnloadNow</c> determines whether the DLL from which it is exported is still in use. A DLL is no longer in use
            when it is not managing any existing objects (the reference count on all of its objects is 0).
            </para>
            <para>Notes to Callers</para>
            <para>
            You should not have to call <c>DllCanUnloadNow</c> directly. OLE calls it only through a call to the CoFreeUnusedLibraries
            function. When it returns S_OK, <c>CoFreeUnusedLibraries</c> frees the DLL.
            </para>
            <para>Notes to Implementers</para>
            <para>
            You must implement <c>DllCanUnloadNow</c> in, and export it from, DLLs that are to be dynamically loaded through a call to the
            CoGetClassObject function. (You also need to implement and export the DllGetClassObject function in the same DLL).
            </para>
            <para>
            If a DLL loaded through a call to CoGetClassObject fails to export <c>DllCanUnloadNow</c>, the DLL will not be unloaded until the
            application calls the CoUninitialize function to release the OLE libraries.
            </para>
            <para><c>DllCanUnloadNow</c> should return S_FALSE if there are any existing references to objects that the DLL manages.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.DllGetClassObject(System.Guid@,System.Guid@,System.Object@)">
            <summary>
            <para>Retrieves the class object from a DLL object handler or object application.</para>
            <para>
            OLE does not provide this function. DLLs that support the OLE Component Object Model (COM) must implement
            <c>DllGetClassObject</c> in OLE object handlers or DLL applications.
            </para>
            </summary>
            <param name="rclsid">The CLSID that will associate the correct data and code.</param>
            <param name="riid">
            A reference to the identifier of the interface that the caller is to use to communicate with the class object. Usually, this is
            IID_IClassFactory (defined in the OLE headers as the interface identifier for IClassFactory).
            </param>
            <param name="ppv">
            The address of a pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppv contains
            the requested interface pointer. If an error occurs, the interface pointer is <c>NULL</c>.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was retrieved successfully.</term>
            </item>
            <item>
            <term>CLASS_E_CLASSNOTAVAILABLE</term>
            <term>The DLL does not support the class (object definition).</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a call to the CoGetClassObject function finds the class object that is to be loaded in a DLL, <c>CoGetClassObject</c> uses the
            DLL's exported <c>DllGetClassObject</c> function.
            </para>
            <para>Notes to Callers</para>
            <para>
            You should not call <c>DllGetClassObject</c> directly. When an object is defined in a DLL, CoGetClassObject calls the
            CoLoadLibrary function to load the DLL, which, in turn, calls <c>DllGetClassObject</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>You need to implement <c>DllGetClassObject</c> in (and export it from) DLLs that support COM.</para>
            <para>Examples</para>
            <para>
            The following is an example (in C++) of an implementation of <c>DllGetClassObject</c>. In this example, <c>DllGetClassObject</c>
            creates a class object and calls its QueryInterface method to retrieve a pointer to the interface requested in riid. The
            implementation releases the reference it holds to the IClassFactory interface because it returns a reference-counted pointer to
            <c>IClassFactory</c> to the caller.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.FreePropVariantArray(System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            The <c>FreePropVariantArray</c> function calls PropVariantClear on each of the PROPVARIANT structures in the rgvars array to make
            the value zero for each of the members of the array.
            </summary>
            <param name="cVariants">Count of elements in the PROPVARIANT array (rgvars).</param>
            <param name="rgvars">
            Pointer to an initialized array of PROPVARIANT structures for which any deallocatable elements are to be freed. On exit, all
            zeroes are written to the <c>PROPVARIANT</c> structure (thus tagging them as VT_EMPTY).
            </param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>
            <c>FreePropVariantArray</c> calls PropVariantClear on an array of PROPVARIANT structures to clear all the valid members. All
            valid <c>PROPVARIANT</c> structures are freed. If any of the <c>PROPVARIANT</c> structures contain illegal VT types, valid
            members are freed and the function returns STG_E_INVALIDPARAMETER.
            </para>
            <para>Passing <c>NULL</c> for rgvars is legal, and produces a return code of S_OK.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.GetHGlobalFromStream(System.Runtime.InteropServices.ComTypes.IStream,System.IntPtr@)">
            <summary>
            The <c>GetHGlobalFromStream</c> function retrieves the global memory handle to a stream that was created through a call to the
            CreateStreamOnHGlobal function.
            </summary>
            <param name="pstm">IStream pointer to the stream object previously created by a call to the CreateStreamOnHGlobal function.</param>
            <param name="phglobal">Pointer to the current memory handle used by the specified stream object.</param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>
            The handle <c>GetHGlobalFromStream</c> returns may be different from the original handle due to intervening GlobalReAlloc calls.
            </para>
            <para>This function can be called only from within the same process from which the byte array was created.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IIDFromString(System.String,System.Guid@)">
            <summary>Converts a string generated by the StringFromIID function back into the original interface identifier (IID).</summary>
            <param name="lpsz">A pointer to the string representation of the IID.</param>
            <param name="lpiid">A pointer to the requested IID on return.</param>
            <returns>This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and S_OK.</returns>
            <remarks>
            The function converts the interface identifier in a way that guarantees different interface identifiers will always be converted
            to different strings.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ProgIDFromCLSID(System.Guid@,Vanara.InteropServices.SafeCoTaskMemString@)">
            <summary>Retrieves the ProgID for a given CLSID.</summary>
            <param name="clsid">The CLSID for which the ProgID is to be requested.</param>
            <param name="lplpszProgID">
            The address of a pointer variable that receives the ProgID string. The string that represents clsid includes enclosing braces.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The ProgID was returned successfully.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>Class not registered in the registry.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Every OLE object class listed in the <c>Insert Object</c> dialog box must have a programmatic identifier (ProgID), a string that
            uniquely identifies a given class, stored in the registry. In addition to determining the eligibility for the <c>Insert
            Object</c> dialog box, the ProgID can be used as an identifier in a macro programming language to identify a class. Finally, the
            ProgID is also the class name used for an object of an OLE class that is placed in an OLE 1 container.
            </para>
            <para>
            <c>ProgIDFromCLSID</c> uses entries in the registry to do the conversion. OLE application authors are responsible for ensuring
            that the registry is configured correctly in the application's setup program.
            </para>
            <para>
            The ProgID string must be different than the class name of any OLE 1 application, including the OLE 1 version of the same
            application, if there is one. In addition, a ProgID string must not contain more than 39 characters, start with a digit, or,
            except for a single period, contain any punctuation (including underscores).
            </para>
            <para>
            The ProgID must never be shown to the user in the user interface. If you need a short displayable string for an object, call IOleObject::GetUserType.
            </para>
            <para>
            Call the CLSIDFromProgID function to find the CLSID associated with a given ProgID. Be sure to free the returned ProgID when you
            are finished with it by calling the CoTaskMemFree function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RoGetAgileReference(Vanara.PInvoke.Ole32.AgileReferenceOptions,System.Guid@,System.Object,Vanara.PInvoke.Ole32.IAgileReference@)">
            <summary>Creates an agile reference for an object specified by the given interface.</summary>
            <param name="options">The options.</param>
            <param name="riid">The interface ID of the object for which an agile reference is being obtained.</param>
            <param name="pUnk">
            Pointer to the interface to be encapsulated in an agile reference. It must be the same type as riid. It may be a pointer to an
            in-process object or a pointer to a proxy of an object.
            </param>
            <param name="ppAgileReference">
            The agile reference for the object. Call the Resolve method to localize the object into the apartment in which <c>Resolve</c> is called.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function completed successfully.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The options parameter in invalid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>The agile reference couldn't be constructed due to an out-of-memory condition.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The pUnk parameter doesn't support the interface ID specified by the riid parameter.</term>
            </item>
            <item>
            <term>CO_E_NOT_SUPPORTED</term>
            <term>The object implements the INoMarshal interface.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Call the <c>RoGetAgileReference</c> function on an existing object to request an agile reference to the object. The object may or
            may not be agile, but the returned IAgileReference is agile. The agile reference can be passed to another apartment within the
            same process, where the original object is retrieved by using the <c>IAgileReference</c> interface.
            </para>
            <para>
            This is conceptually similar to the existing Global Interface Table (GIT). Rather than interacting with the GIT, an
            IAgileReference is obtained and used to retrieve the object directly. Just as the GIT is per-process only, agile references are
            per-process and can't be marshaled.
            </para>
            <para>
            The agile reference feature provides a performance improvement over the GIT. The agile reference performs eager marshaling by
            default, which saves a cross-apartment call in cases where the object is retrieved from the agile reference in an apartment
            that's different from where the agile reference was created. For additional performance improvement, users of the
            <c>RoGetAgileReference</c> function can use the same interface to create an IAgileReference and resolve the original object. This
            saves an additional QueryInterface call to obtain the desired interface from the resolved object.
            </para>
            <para>
            For example, you have a non-agile object named CDemoExample, which implements the IDemo and IExample interfaces. Call the
            <c>RoGetAgileReference</c> function and pass the object, with IID_IDemo. You get back an IAgileReference interface pointer, which
            is agile, so you can pass it to a different apartment. In the other apartment, call the Resolve method, with IID_IExample. You
            get back an IExample pointer that you can use within this apartment. This IExample pointer is an IExample proxy that's connected
            to the original CDemoExample object. The agile reference handles the complexity of operations like manually marshaling to a
            stream and unmarshaling on the other side of the apartment boundary.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StringFromCLSID(System.Guid@,System.String@)">
            <summary>Converts a CLSID into a string of printable characters. Different CLSIDs always convert to different strings.</summary>
            <param name="rclsid">The CLSID to be converted.</param>
            <param name="lplpsz">
            The address of a pointer variable that receives a pointer to the resulting string. The string that represents rclsid includes
            enclosing braces.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            <c>StringFromCLSID</c> calls the StringFromGUID2 function to convert a globally unique identifier (GUID) into a string of
            printable characters.
            </para>
            <para>The caller is responsible for freeing the memory allocated for the string by calling the CoTaskMemFree function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StringFromGUID2(System.Guid@,System.Text.StringBuilder,System.Int32)">
            <summary>Converts a globally unique identifier (GUID) into a string of printable characters.</summary>
            <param name="rguid">The GUID to be converted.</param>
            <param name="lpsz">
            A pointer to a caller-allocated string variable to receive the resulting string. The string that represents rguid includes
            enclosing braces.
            </param>
            <param name="cchMax">The number of characters available in the lpsz buffer.</param>
            <returns>
            If the function succeeds, the return value is the number of characters in the returned string, including the null terminator. If
            the buffer is too small to contain the string, the return value is 0.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StringFromIID(System.Guid@,System.String@)">
            <summary>Converts an interface identifier into a string of printable characters.</summary>
            <param name="rclsid">The interface identifier to be converted.</param>
            <param name="lplpsz">
            The address of a pointer variable that receives a pointer to the resulting string. The string that represents rclsid includes
            enclosing braces.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>The caller is responsible for freeing the memory allocated for the string by calling the CoTaskMemFree function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateILockBytesOnHGlobal(System.IntPtr,System.Boolean,Vanara.PInvoke.Ole32.ILockBytes@)">
            <summary>
            <para>
            The <c>CreateILockBytesOnHGlobal</c> function creates a byte array object that uses an HGLOBAL memory handle to store the bytes
            intended for in-memory storage of a compound file. This object is the OLE-provided implementation of the ILockBytes interface.
            </para>
            <para>
            The returned byte array object supports both reading and writing, but does not support region locking . The object calls the
            GlobalReAlloc function to grow the memory block as required.
            </para>
            </summary>
            <param name="hGlobal">
            A memory handle allocated by the GlobalAlloc function, or if <c>NULL</c> a new handle is to be allocated instead. The handle must
            be allocated as moveable and nondiscardable.
            </param>
            <param name="fDeleteOnRelease">
            A flag that specifies whether the underlying handle for this byte array object should be automatically freed when the object is
            released. If set to <c>FALSE</c>, the caller must free the hGlobal after the final release. If set to <c>TRUE</c>, the final
            release will automatically free the hGlobal parameter.
            </param>
            <param name="pplkbyt">
            The address of ILockBytes pointer variable that receives the interface pointer to the new byte array object.
            </param>
            <returns>This function supports the standard return values <c>E_INVALIDARG</c> and <c>E_OUTOFMEMORY</c>, as well as the following:</returns>
            <remarks>
            <para>
            If hGlobal is <c>NULL</c>, the <c>CreateILockBytesOnHGlobal</c> allocates a new memory handle and the byte array is empty initially.
            </para>
            <para>
            If hGlobal is not <c>NULL</c>, the initial contents of the byte array object are the current contents of the memory block. Thus,
            this function can be used to open an existing byte array in memory, for example to reload a storage object previously created by
            the StgCreateDocfileOnILockBytes function. The memory handle and its contents are undisturbed by the creation of the new byte
            array object.
            </para>
            <para>
            The initial size of the byte array is the size of hGlobal as returned by the GlobalSize function. This is not necessarily the
            same size that was originally allocated for the handle because of rounding. If the logical size of the byte array is important,
            follow the call to <c>CreateILockBytesOnHGlobal</c> with a call to ILockBytes::SetSize.
            </para>
            <para>
            After creating the byte array object with CreateStreamOnHGlobal, StgCreateDocfileOnILockBytes can be used to create a new storage
            object in memory, or StgOpenStorageOnILockBytes can be used to reopen a previously existing storage object that is already
            contained in the memory block. GetHGlobalFromILockBytes can be called to retrieve the memory handle associated with the byte
            array object.
            </para>
            <para>
            If a memory handle is passed to <c>CreateILockBytesOnHGlobal</c> or if GetHGlobalFromILockBytes is called, the memory handle of
            this function can be directly accessed by the caller while it is still in use by the byte array object. Appropriate caution
            should be exercised in the use of this capability and its implications:
            </para>
            <list type="bullet">
            <item>
            <term>
            Do not free the hGlobal memory handle during the lifetime of the byte array object. ILockBytes::Releasemust be called before the
            memory handle is freed.
            </term>
            </item>
            <item>
            <term>
            Do not call GlobalReAlloc to change the size of the memory handle during the lifetime of the byte array object. This may cause
            application crashes or memory corruption. Avoid creating multiple byte array objects on the same memory handle, because
            ILockBytes::WriteAt and ILockBytes::SetSize methods may internally call <c>GlobalReAlloc</c>.
            </term>
            </item>
            <item>
            <term>
            If possible, avoid accessing the memory block during the lifetime of the byte array object, because the object may internally
            call GlobalReAlloc and do not make assumptions about its size and location. If the memory block must be accessed, the memory
            access calls should be surrounded by calls to GlobalLock and GlobalUnLock.
            </term>
            </item>
            <item>
            <term>
            Avoid calling the object’s methods while the memory handle is locked with GlobalLock. This can cause method calls to fail unpredictably.
            </term>
            </item>
            </list>
            <para>
            If the caller sets the fDeleteOnRelease parameter to <c>FALSE</c>, then the caller must also free the hGlobal after the final
            release. If the caller sets the fDeleteOnRelease parameter to <c>TRUE</c>, the final release will automatically free the hGlobal.
            The memory handle passed as the hGlobal parameter must be allocated as movable and nondiscardable, as shown in the following example:
            </para>
            <para>
            <c>CreateILockBytesOnHGlobal</c> will accept memory allocated with GMEM_FIXED, but this usage is not recommended. HGLOBALs
            allocated with <c>GMEM_FIXED</c> are not really handles and their value can change when they are reallocated. If the memory
            handle was allocated with <c>GMEM_FIXED</c> and fDeleteOnRelease is <c>FALSE</c>, then the caller must call
            GetHGlobalFromILockBytes to get the correct HGLOBAL value in order to free the handle.
            </para>
            <para>
            This implementation of ILockBytes does not support region locking. Applications that use this implementation with the
            StgCreateDocfileOnILockBytes or StgOpenStorageOnILockBytes functions should avoid opening multiple concurrent instances on the
            same <c>ILockBytes</c> object.
            </para>
            <para>
            Prior to Windows 7 and Windows Server 2008 R2, this implementation did not zero memory when calling GlobalReAlloc to grow the
            memory block. Increasing the size of the byte array with ILockBytes::SetSize or by writing to a location past the current end of
            the byte array will leave any unwritten portions of the newly allocated memory uninitialized. The storage objects returned by the
            StgCreateDocfileOnILockBytes and StgOpenStorageOnILockBytes may increase the size of the byte array without initializing all of
            the newly allocated space.
            </para>
            <para>
            Compound files in memory are typically used as scratch space or with APIs that require a storage object, and in these cases the
            uninitialized memory is generally not a concern. However, if the contents of the memory block will be written to a file, consider
            the following alternatives to avoid potential information disclosure:
            </para>
            <list type="bullet">
            <item>
            <term>
            Copy the logical contents of the in-memory compound file to the destination file using the IStorage::CopyTo method rather than
            directly writing the contents of the memory block.
            </term>
            </item>
            <item>
            <term>
            Instead of a compound file in memory, create a temporary file by calling StgCreateStorageEx with a <c>NULL</c> value for the
            pwcsName parameter. When it is time to write to the destination file, use the IRootStorage::SwitchToFile method.
            </term>
            </item>
            <item>
            <term>
            Implement the ILockBytes interface such that memory reallocations are zeroed (see for example the <c>HEAP_ZERO_MEMORY</c> flag in
            HeapReAlloc). The memory contents of this byte array can then be written to a file.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateILockBytesOnHGlobal(Vanara.InteropServices.SafeHGlobalHandle,System.Boolean,Vanara.PInvoke.Ole32.ILockBytes@)">
            <summary>
            <para>
            The <c>CreateILockBytesOnHGlobal</c> function creates a byte array object that uses an HGLOBAL memory handle to store the bytes
            intended for in-memory storage of a compound file. This object is the OLE-provided implementation of the ILockBytes interface.
            </para>
            <para>
            The returned byte array object supports both reading and writing, but does not support region locking . The object calls the
            GlobalReAlloc function to grow the memory block as required.
            </para>
            </summary>
            <param name="hGlobal">
            A memory handle allocated by the GlobalAlloc function, or if <c>NULL</c> a new handle is to be allocated instead. The handle must
            be allocated as moveable and nondiscardable.
            </param>
            <param name="fDeleteOnRelease">
            A flag that specifies whether the underlying handle for this byte array object should be automatically freed when the object is
            released. If set to <c>FALSE</c>, the caller must free the hGlobal after the final release. If set to <c>TRUE</c>, the final
            release will automatically free the hGlobal parameter.
            </param>
            <param name="pplkbyt">
            The address of ILockBytes pointer variable that receives the interface pointer to the new byte array object.
            </param>
            <returns>This function supports the standard return values <c>E_INVALIDARG</c> and <c>E_OUTOFMEMORY</c>, as well as the following:</returns>
            <remarks>
            <para>
            If hGlobal is <c>NULL</c>, the <c>CreateILockBytesOnHGlobal</c> allocates a new memory handle and the byte array is empty initially.
            </para>
            <para>
            If hGlobal is not <c>NULL</c>, the initial contents of the byte array object are the current contents of the memory block. Thus,
            this function can be used to open an existing byte array in memory, for example to reload a storage object previously created by
            the StgCreateDocfileOnILockBytes function. The memory handle and its contents are undisturbed by the creation of the new byte
            array object.
            </para>
            <para>
            The initial size of the byte array is the size of hGlobal as returned by the GlobalSize function. This is not necessarily the
            same size that was originally allocated for the handle because of rounding. If the logical size of the byte array is important,
            follow the call to <c>CreateILockBytesOnHGlobal</c> with a call to ILockBytes::SetSize.
            </para>
            <para>
            After creating the byte array object with CreateStreamOnHGlobal, StgCreateDocfileOnILockBytes can be used to create a new storage
            object in memory, or StgOpenStorageOnILockBytes can be used to reopen a previously existing storage object that is already
            contained in the memory block. GetHGlobalFromILockBytes can be called to retrieve the memory handle associated with the byte
            array object.
            </para>
            <para>
            If a memory handle is passed to <c>CreateILockBytesOnHGlobal</c> or if GetHGlobalFromILockBytes is called, the memory handle of
            this function can be directly accessed by the caller while it is still in use by the byte array object. Appropriate caution
            should be exercised in the use of this capability and its implications:
            </para>
            <list type="bullet">
            <item>
            <term>
            Do not free the hGlobal memory handle during the lifetime of the byte array object. ILockBytes::Releasemust be called before the
            memory handle is freed.
            </term>
            </item>
            <item>
            <term>
            Do not call GlobalReAlloc to change the size of the memory handle during the lifetime of the byte array object. This may cause
            application crashes or memory corruption. Avoid creating multiple byte array objects on the same memory handle, because
            ILockBytes::WriteAt and ILockBytes::SetSize methods may internally call <c>GlobalReAlloc</c>.
            </term>
            </item>
            <item>
            <term>
            If possible, avoid accessing the memory block during the lifetime of the byte array object, because the object may internally
            call GlobalReAlloc and do not make assumptions about its size and location. If the memory block must be accessed, the memory
            access calls should be surrounded by calls to GlobalLock and GlobalUnLock.
            </term>
            </item>
            <item>
            <term>
            Avoid calling the object’s methods while the memory handle is locked with GlobalLock. This can cause method calls to fail unpredictably.
            </term>
            </item>
            </list>
            <para>
            If the caller sets the fDeleteOnRelease parameter to <c>FALSE</c>, then the caller must also free the hGlobal after the final
            release. If the caller sets the fDeleteOnRelease parameter to <c>TRUE</c>, the final release will automatically free the hGlobal.
            The memory handle passed as the hGlobal parameter must be allocated as movable and nondiscardable, as shown in the following example:
            </para>
            <para>
            <c>CreateILockBytesOnHGlobal</c> will accept memory allocated with GMEM_FIXED, but this usage is not recommended. HGLOBALs
            allocated with <c>GMEM_FIXED</c> are not really handles and their value can change when they are reallocated. If the memory
            handle was allocated with <c>GMEM_FIXED</c> and fDeleteOnRelease is <c>FALSE</c>, then the caller must call
            GetHGlobalFromILockBytes to get the correct HGLOBAL value in order to free the handle.
            </para>
            <para>
            This implementation of ILockBytes does not support region locking. Applications that use this implementation with the
            StgCreateDocfileOnILockBytes or StgOpenStorageOnILockBytes functions should avoid opening multiple concurrent instances on the
            same <c>ILockBytes</c> object.
            </para>
            <para>
            Prior to Windows 7 and Windows Server 2008 R2, this implementation did not zero memory when calling GlobalReAlloc to grow the
            memory block. Increasing the size of the byte array with ILockBytes::SetSize or by writing to a location past the current end of
            the byte array will leave any unwritten portions of the newly allocated memory uninitialized. The storage objects returned by the
            StgCreateDocfileOnILockBytes and StgOpenStorageOnILockBytes may increase the size of the byte array without initializing all of
            the newly allocated space.
            </para>
            <para>
            Compound files in memory are typically used as scratch space or with APIs that require a storage object, and in these cases the
            uninitialized memory is generally not a concern. However, if the contents of the memory block will be written to a file, consider
            the following alternatives to avoid potential information disclosure:
            </para>
            <list type="bullet">
            <item>
            <term>
            Copy the logical contents of the in-memory compound file to the destination file using the IStorage::CopyTo method rather than
            directly writing the contents of the memory block.
            </term>
            </item>
            <item>
            <term>
            Instead of a compound file in memory, create a temporary file by calling StgCreateStorageEx with a <c>NULL</c> value for the
            pwcsName parameter. When it is time to write to the destination file, use the IRootStorage::SwitchToFile method.
            </term>
            </item>
            <item>
            <term>
            Implement the ILockBytes interface such that memory reallocations are zeroed (see for example the <c>HEAP_ZERO_MEMORY</c> flag in
            HeapReAlloc). The memory contents of this byte array can then be written to a file.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.FmtIdToPropStgName(System.Guid@,System.Text.StringBuilder)">
            <summary>
            The <c>FmtIdToPropStgName</c> function converts a property set format identifier (FMTID) to its storage or stream name.
            </summary>
            <param name="pfmtid">A pointer to the FMTID of the property set.</param>
            <param name="oszName">
            A pointer to a null-terminated string that receives the storage or stream name of the property set identified by pfmtid. The
            array allocated for this string must be at least CCH_MAX_PROPSTG_NAME (32) characters in length.
            </param>
            <returns>This function supports the standard return value E_INVALIDARG as well as the following:</returns>
            <remarks>
            <para>
            <c>FmtIdToPropStgName</c> maps a property set FMTID to its stream name for a simple property set or to its storage name for a
            nonsimple property set.
            </para>
            <para>
            This function is useful in creating or opening a property set using the PROPSETFLAG_UNBUFFERED value with the StgCreatePropStg
            and StgOpenPropStg functions. For more information about PROPSETFLAG_UNBUFFERED, see PROPSETFLAG Constants.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.GetConvertStg(Vanara.PInvoke.Ole32.IStorage)">
            <summary>The <c>GetConvertStg</c> function returns the current value of the convert bit for the specified storage object.</summary>
            <param name="pStg">IStorage pointer to the storage object from which the convert bit is to be retrieved.</param>
            <returns>IStorage::OpenStream, IStorage::OpenStorage, and ISequentialStream::Read storage and stream access errors.</returns>
            <remarks>
            <para>
            The <c>GetConvertStg</c> function is called by object servers that support the conversion of an object from one format to
            another. The server must be able to read the storage object using the format of its previous class identifier (CLSID) and write
            the object using the format of its new CLSID to support the object's conversion. For example, a spreadsheet created by one
            application can be converted to the format used by a different application.
            </para>
            <para>
            The convert bit is set by a call to the SetConvertStg function. A container application can call this function on the request of
            an end user, or a setup program can call it when installing a new version of an application. An end user requests converting an
            object through the <c>Convert To</c> dialog box. When an object is converted, the new CLSID is permanently assigned to the
            object, so the object is subsequently associated with the new CLSID.
            </para>
            <para>
            Then, when the object is activated, its server calls the <c>GetConvertStg</c> function to retrieve the value of the convert bit
            from the storage object. If the bit is set, the object's CLSID has been changed, and the server must read the old format and
            write the new format for the storage object.
            </para>
            <para>
            After retrieving the bit value, the object application should clear the convert bit by calling the SetConvertStg function with
            its fConvert parameter set to <c>FALSE</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.GetHGlobalFromILockBytes(Vanara.PInvoke.Ole32.ILockBytes,System.IntPtr@)">
            <summary>
            The <c>GetHGlobalFromILockBytes</c> function retrieves a global memory handle to a byte array object created using the
            CreateILockBytesOnHGlobal function.
            </summary>
            <param name="plkbyt">
            Pointer to the ILockBytes interface on the byte-array object previously created by a call to the CreateILockBytesOnHGlobal function.
            </param>
            <param name="phglobal">Pointer to the current memory handle used by the specified byte-array object.</param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>
            After a call to CreateILockBytesOnHGlobal, which creates a byte array object on global memory, <c>GetHGlobalFromILockBytes</c>
            retrieves a pointer to the handle of the global memory underlying the byte array object. The handle this function returns might
            be different from the original handle due to intervening calls to the GlobalReAlloc function.
            </para>
            <para>
            The contents of the returned memory handle can be written to a clean disk file, and then opened as a storage object using the
            StgOpenStorage function.
            </para>
            <para>This function only works within the same process from which the byte array was created.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PropStgNameToFmtId(System.String,System.Guid@)">
            <summary>The <c>PropStgNameToFmtId</c> function converts a property set storage or stream name to its format identifier.</summary>
            <param name="oszName">
            A pointer to a null-terminated Unicode string that contains the stream name of a simple property set or the storage name of a
            nonsimple property set.
            </param>
            <param name="pfmtid">A pointer to a FMTID variable that receives the format identifier of the property set specified by oszName.</param>
            <returns>This function supports the standard return value E_INVALIDARG as well as the following:</returns>
            <remarks>
            <para>
            The <c>PropStgNameToFmtId</c> function maps the stream name of a simple property set or the storage name of a nonsimple property
            set to its format identifier.
            </para>
            <para>
            This function is useful in creating or opening a property set using the PROPSETFLAG_UNBUFFERED value with the StgCreatePropStg
            and StgOpenPropStg functions. For more information about PROPSETFLAG_UNBUFFERED, see PROPSETFLAG Constants.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ReadClassStg(Vanara.PInvoke.Ole32.IStorage,System.Guid@)">
            <summary>The <c>ReadClassStg</c> function reads the CLSID previously written to a storage object with the WriteClassStg function.</summary>
            <param name="pStg">Pointer to the IStorage interface on the storage object containing the CLSID to be retrieved.</param>
            <param name="pclsid">Pointer to where the CLSID is written. May return CLSID_NULL.</param>
            <returns>
            <para>This function supports the standard return value E_OUTOFMEMORY, in addition to the following:</para>
            <para>This function also returns any of the error values returned by the IStorage::Stat method.</para>
            </returns>
            <remarks>
            <c>ReadClassStg</c> is a helper function that calls the IStorage::Stat method and retrieves the CLSID previously written to the
            storage object with a call to WriteClassStg from the STATSTG structure.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ReadClassStm(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@)">
            <summary>The <c>ReadClassStm</c> function reads the CLSID previously written to a stream object with the WriteClassStm function.</summary>
            <param name="pStm">
            A pointer to the IStream interface on the stream object that contains the CLSID to be read. This CLSID must have been previously
            written to the stream object using WriteClassStm.
            </param>
            <param name="pclsid">A pointer to where the CLSID is to be written.</param>
            <returns>This function also returns any of the error values returned by the ISequentialStream::Read method.</returns>
            <remarks>
            Most applications do not call the <c>ReadClassStm</c> function directly. COM calls it before making a call to an object's
            IPersistStream::Load implementation.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreateDocfile(System.String,Vanara.PInvoke.STGM,System.UInt32,Vanara.PInvoke.Ole32.IStorage@)">
            <summary>
            <para>
            The <c>StgCreateDocfile</c> function creates a new compound file storage object using the COM-provided compound file
            implementation for the IStorage interface.
            </para>
            <para>
            <c>Note</c> Applications should use the new function, StgCreateStorageEx, instead of <c>StgCreateDocfile</c>, to take advantage
            of enhanced Structured Storage features. This function, <c>StgCreateDocfile</c>, still exists for compatibility with Windows 2000.
            </para>
            </summary>
            <param name="pwcsName">
            A pointer to a null-terminated Unicode string name for the compound file being created. It is passed uninterpreted to the file
            system. This can be a relative name or <c>NULL</c>. If <c>NULL</c>, a temporary compound file is allocated with a unique name.
            </param>
            <param name="grfMode">
            Specifies the access mode to use when opening the new storage object. For more information, see STGM Constants. If the caller
            specifies transacted mode together with STGM_CREATE or STGM_CONVERT, the overwrite or conversion takes place when the commit
            operation is called for the root storage. If IStorage::Commit is not called for the root storage object, previous contents of the
            file will be restored. STGM_CREATE and STGM_CONVERT cannot be combined with the STGM_NOSNAPSHOT flag, because a snapshot copy is
            required when a file is overwritten or converted in the transacted mode.
            </param>
            <param name="reserved">Reserved for future use; must be zero.</param>
            <param name="ppstgOpen">A pointer to the location of the IStorage pointer to the new storage object.</param>
            <returns>
            <c>StgCreateDocfile</c> can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more
            information, see Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            The <c>StgCreateDocfile</c> function creates a new storage object using the COM-provided, compound-file implementation for the
            IStorage interface. The name of the open compound file can be retrieved by calling the IStorage::Stat method.
            </para>
            <para>
            <c>StgCreateDocfile</c> creates the file if it does not exist. If it does exist, the use of the STGM_CREATE, STGM_CONVERT, and
            STGM_FAILIFTHERE flags in the grfMode parameter indicate how to proceed. For more information, see STGM Constants.
            </para>
            <para>
            If the compound file is opened in transacted mode (the grfMode parameter specifies STGM_TRANSACTED) and a file with this name
            already exists, the existing file is not altered until all outstanding changes are committed. If the calling process lacks write
            access to the existing file (because of access control in the file system), the grfMode parameter can only specify STGM_READ and
            not STGM_WRITE or STGM_READWRITE. The resulting new open compound file can still be written to, but a subsequent commit operation
            will fail (in transacted mode, write permissions are enforced at commit time).
            </para>
            <para>
            Specifying STGM_SIMPLE provides a much faster implementation of a compound file object in a limited, but frequently used case.
            This can be used by applications that require a compound-file implementation with multiple streams and no storages. The simple
            mode does not support all of the methods on IStorage. For more information, see STGM Constants.
            </para>
            <para>
            If the grfMode parameter specifies STGM_TRANSACTED and no file yet exists with the name specified by the pwcsName parameter, the
            file is created immediately. In an access-controlled file system, the caller must have write permissions in the file system
            directory in which the compound file is created. If STGM_TRANSACTED is not specified, and STGM_CREATE is specified, an existing
            file with the same name is destroyed before the new file is created.
            </para>
            <para>
            <c>StgCreateDocfile</c> can be used to create a temporary compound file by passing a <c>NULL</c> value for the pwcsName
            parameter. However, these files are temporary only in the sense that they have a system-provided unique name — likely one that is
            meaningless to the user. The caller is responsible for deleting the temporary file when finished with it, unless
            STGM_DELETEONRELEASE was specified for the grfMode parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreateDocfileOnILockBytes(Vanara.PInvoke.Ole32.ILockBytes,Vanara.PInvoke.STGM,System.UInt32,Vanara.PInvoke.Ole32.IStorage@)">
            <summary>
            The <c>StgCreateDocfileOnILockBytes</c> function creates and opens a new compound file storage object on top of a byte-array
            object provided by the caller. The storage object supports the COM-provided, compound-file implementation for the IStorage interface.
            </summary>
            <param name="plkbyt">
            A pointer to the ILockBytes interface on the underlying byte-array object on which to create a compound file.
            </param>
            <param name="grfMode">
            Specifies the access mode to use when opening the new compound file. For more information, see STGM Constants and the Remarks
            section below.
            </param>
            <param name="reserved">Reserved for future use; must be zero.</param>
            <param name="ppstgOpen">A pointer to the location of the IStorage pointer on the new storage object.</param>
            <returns>
            The <c>StgCreateDocfileOnILockBytes</c> function can also return any file system errors, or system errors wrapped in an
            <c>HRESULT</c>, or ILockBytes interface error return values. For more information, see Error Handling Strategies and Handling
            Unknown Errors.
            </returns>
            <remarks>
            <para>
            The <c>StgCreateDocfileOnILockBytes</c> function creates a storage object on top of a byte array object using the COM-provided,
            compound-file implementation of the IStorage interface. <c>StgCreateDocfileOnILockBytes</c> can be used to store a document in an
            arbitrary data store, such as memory or a relational database. The byte array (indicated by the pLkbyt parameter, which points to
            the ILockBytes interface on the object) is used for the underlying storage in place of a disk file.
            </para>
            <para>
            Except for specifying a programmer-provided byte-array object, <c>StgCreateDocfileOnILockBytes</c> is similar to the
            StgCreateDocfile function.
            </para>
            <para>
            The newly created compound file is opened according to the access modes in the grfMode parameter, subject to the following restrictions:
            </para>
            <para>
            Sharing mode behavior and transactional isolation depend on the ILockBytes implementation supporting LockRegion and UnlockRegion
            with LOCK_ONLYONCE semantics. Implementations can indicate to structured storage they support this functionality by setting the
            <c>LOCK_ONLYONCE</c> bit in the <c>grfLocksSupported</c> member of STATSTG. If an <c>ILockBytes</c> implementation does not
            support this functionality, sharing modes will not be enforced, and root-level transactional commits will not coordinate properly
            with other transactional instances opened on the same byte array. Applications that use an <c>ILockBytes</c> implementation that
            does not support region locking, such as the CreateStreamOnHGlobal implementation, should avoid opening multiple concurrent
            instances on the same byte array.
            </para>
            <para><c>StgCreateDocfileOnILockBytes</c> does not support simple mode. The STGM_SIMPLE flag, if present, is ignored.</para>
            <para>
            For conversion purposes, the file is considered to already exist. As a result, it is not useful to use the STGM_FAILIFTHERE
            value, because it causes an error to be returned. However, both STGM_CREATE and STGM_CONVERT remain useful.
            </para>
            <para>
            The ability to build a compound file on top of a byte-array object is provided to support having the data (underneath an IStorage
            and IStream tree structure) live in a nonpersistent space. Given this capability, there is nothing preventing a document that is
            stored in a file from using this facility. For example, a container might do this to minimize the impact on its file format
            caused by adopting COM. However, it is recommended that COM documents adopt the <c>IStorage</c> interface for their own
            outer-level storage. This has the following advantages:
            </para>
            <list type="bullet">
            <item>
            <term>
            The storage structure of the document is the same as its storage structure when it is an embedded object, reducing the number of
            cases the application needs to handle.
            </term>
            </item>
            <item>
            <term>
            One can write tools to access the OLE embedded and linked objects within the document without special knowledge of the document's
            file format. An example of such a tool is a copy utility that copies all the documents included in a container containing linked
            objects. A copy utility like this needs access to the contained links to determine the extent of files to be copied.
            </term>
            </item>
            <item>
            <term>
            The IStorage implementation addresses the problem of how to commit the changes to the file. An application using the ILockBytes
            interface must handle these issues itself.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreatePropSetStg(Vanara.PInvoke.Ole32.IStorage,System.UInt32,Vanara.PInvoke.Ole32.IPropertySetStorage@)">
            <summary>
            The <c>StgCreatePropSetStg</c> function creates a property set storage object from a specified storage object. The property set
            storage object supplies the system-provided, stand-alone implementation of the IPropertySetStorage interface.
            </summary>
            <param name="pStorage">A pointer to the storage object that contains or will contain one or more property sets.</param>
            <param name="dwReserved">Reserved for future use; must be zero.</param>
            <param name="ppPropSetStg">
            A pointer to IPropertySetStorage* pointer variable that receives the interface pointer to the property-set storage object.
            </param>
            <returns>This function supports the standard return value <c>E_INVALIDARG</c> as well as the following:</returns>
            <remarks>
            <para>
            The <c>StgCreatePropSetStg</c> function creates an IPropertySetStorage interface that will act on the given IStorage interface
            specified by the pStorage parameter. This function does not modify this <c>IStorage</c> by itself, although subsequent calls to
            the <c>IPropertySetStorage</c> interface might.
            </para>
            <para>
            <c>StgCreatePropSetStg</c> calls IUnknown::AddRef on the storage object specified by pStorage. The caller must release the object
            when it is no longer required by calling Release.
            </para>
            <para>Examples</para>
            <para>The following example code shows how this function creates a property set within a storage object.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreatePropStg(System.Object,System.Guid@,System.Guid@,Vanara.PInvoke.Ole32.PROPSETFLAG,System.UInt32,Vanara.PInvoke.Ole32.IPropertyStorage@)">
            <summary>
            The <c>StgCreatePropStg</c> function creates and opens a property set in a specified storage or stream object. The property set
            supplies the system-provided, stand-alone implementation of the IPropertyStorage interface.
            </summary>
            <param name="pUnk">
            A pointer to the <c>IUnknown</c> interface on the storage or stream object that stores the new property set.
            </param>
            <param name="fmtid">The FMTID of the property set to be created.</param>
            <param name="pclsid">
            A Pointer to the initial CLSID for this property set. May be <c>NULL</c>, in which case pclsid is set to all zeroes.
            </param>
            <param name="grfFlags">The values from PROPSETFLAG Constants that determine how the property set is created and opened.</param>
            <param name="dwReserved">Reserved; must be zero.</param>
            <param name="ppPropStg">
            The address of an IPropertyStorage* pointer variable that receives the interface pointer to the new property set.
            </param>
            <returns>This function supports the standard return values E_INVALIDARG and E_UNEXPECTED, in addition to the following:</returns>
            <remarks>
            <para>
            <c>StgCreatePropStg</c> creates and opens a new property set which supplies the system-provided, stand-alone implementation of
            the IPropertyStorage interface. The new property set is contained in the storage or stream object specified by pUnk. The value of
            the grfFlags parameter indicates whether pUnk specifies a storage or stream object. For example, if PROPSETFLAG_NONSIMPLE is set,
            then pUnk can be queried for an IStorage interface on a storage object.
            </para>
            <para>
            In either case, this function calls pUnk-&gt;AddRef for the storage or stream object containing the property set. It is the
            responsibility of the caller to release the object when it is no longer needed.
            </para>
            <para>
            This function is similar to the IPropertySetStorage::Create method. However, <c>StgCreatePropStg</c> adds the pUnk parameter and
            supports the PROPSETFLAG_UNBUFFERED value for the grfFlags parameter. Use this function instead of the <c>Create</c> method if
            you have an IStorage interface that does not support the IPropertySetStorage interface, or if you want to use the
            PROPSETFLAG_UNBUFFERED value. For more information about using this PROPSETFLAG_UNBUFFERED enumeration value, see PROPSETFLAG Constants.
            </para>
            <para>
            The property set automatically contains code page and locale identifier (ID) properties. These are set to the current system
            default and the current user default, respectively.
            </para>
            <para>
            The grfFlags parameter is a combination of values taken from PROPSETFLAG Constants. The new enumeration value
            PROPSETFLAG_UNBUFFERED is supported. For more information, see <c>PROPSETFLAG Constants</c>.
            </para>
            <para>
            This function is exported out of the redistributable Iprop.dll, which is included in Windows NT 4.0 with Service Pack 2 (SP2) and
            later and available as a redistributable in Windows 95, Windows 98 and later. In Windows 2000 and Windows XP, it is exported out
            of ole32.dll. It can also be exported out of iprop.dll in Windows 2000 and Windows XP, but the call gets forwarded to ole32.dll.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreateStorageEx(System.String,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.STGFMT,Vanara.PInvoke.FileFlagsAndAttributes,Vanara.PInvoke.Ole32.STGOPTIONS@,Vanara.PInvoke.PSECURITY_DESCRIPTOR,System.Guid@,System.Object@)">
            <summary>
            <para>
            The <c>StgCreateStorageEx</c> function creates a new storage object using a provided implementation for the IStorage or
            IPropertySetStorage interfaces. To open an existing file, use the StgOpenStorageEx function instead.
            </para>
            <para>
            Applications written for Windows 2000, Windows Server 2003 and Windows XP must use <c>StgCreateStorageEx</c> rather than
            StgCreateDocfile to take advantage of the enhanced Windows 2000 and Windows XP Structured Storage features.
            </para>
            </summary>
            <param name="pwcsName">
            <para>
            A pointer to the path of the file to create. It is passed uninterpreted to the file system. This can be a relative name or
            <c>NULL</c>. If <c>NULL</c>, a temporary file is allocated with a unique name. If non- <c>NULL</c>, the string size must not
            exceed MAX_PATH characters.
            </para>
            <para><c>Windows 2000:</c> Unlike the CreateFile function, you cannot exceed the MAX_PATH limit by using the "\?" prefix.</para>
            </param>
            <param name="grfMode">
            A value that specifies the access mode to use when opening the new storage object. For more information, see STGM Constants. If
            the caller specifies transacted mode together with STGM_CREATE or STGM_CONVERT, the overwrite or conversion takes place when the
            commit operation is called for the root storage. If IStorage::Commit is not called for the root storage object, previous contents
            of the file will be restored. STGM_CREATE and STGM_CONVERT cannot be combined with the STGM_NOSNAPSHOT flag, because a snapshot
            copy is required when a file is overwritten or converted in the transacted mode.
            </param>
            <param name="stgfmt">A value that specifies the storage file format. For more information, see the STGFMT enumeration.</param>
            <param name="grfAttrs">
            <para>A value that depends on the value of the stgfmt parameter.</para>
            <list type="table">
            <listheader>
            <term>Parameter Values</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGFMT_DOCFILE</term>
            <term>
            0, or FILE_FLAG_NO_BUFFERING. For more information, see CreateFile. If the sector size of the file, specified in pStgOptions, is
            not an integer multiple of the underlying disk's physical sector size, this operation will fail.
            </term>
            </item>
            <item>
            <term>All other values of stgfmt</term>
            <term>Must be 0.</term>
            </item>
            </list>
            </param>
            <param name="pStgOptions">
            The pStgOptions parameter is valid only if the stgfmt parameter is set to STGFMT_DOCFILE. If the stgfmt parameter is set to
            STGFMT_DOCFILE, pStgOptions points to the STGOPTIONS structure, which specifies features of the storage object, such as the
            sector size. This parameter may be <c>NULL</c>, which creates a storage object with a default sector size of 512 bytes. If non-
            <c>NULL</c>, the <c>ulSectorSize</c> member must be set to either 512 or 4096. If set to 4096, STGM_SIMPLE may not be specified
            in the grfMode parameter. The <c>usVersion</c> member must be set before calling <c>StgCreateStorageEx</c>. For more information,
            see <c>STGOPTIONS</c>.
            </param>
            <param name="pSecurityDescriptor">
            <para>
            Enables the ACLs to be set when the file is created. If not <c>NULL</c>, needs to be a pointer to the SECURITY_ATTRIBUTES
            structure. See CreateFile for information on how to set ACLs on files.
            </para>
            <para><c>Windows Server 2003, Windows 2000 Server, Windows XP and Windows 2000 Professional:</c> Value must be <c>NULL</c>.</para>
            </param>
            <param name="riid">
            A value that specifies the interface identifier (IID) of the interface pointer to return. This IID may be for the IStorage
            interface or the IPropertySetStorage interface.
            </param>
            <param name="ppObjectOpen">
            A pointer to an interface pointer variable that receives a pointer for an interface on the new storage object; contains
            <c>NULL</c> if operation failed.
            </param>
            <returns>
            This function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more information, see
            Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            When an application modifies its file, it usually creates a copy of the original. The <c>StgCreateStorageEx</c> function is one
            way for creating a copy. This function works indirectly with the Encrypting File System (EFS) duplication API. When you use this
            function, you will need to set the options for the file storage in the STGOPTIONS structure.
            </para>
            <para>
            <c>StgCreateStorageEx</c> is a superset of the StgCreateDocfile function, and should be used by new code. Future enhancements to
            Structured Storage will be exposed through the <c>StgCreateStorageEx</c> function. See the following Requirements section for
            information on supported platforms.
            </para>
            <para>
            The <c>StgCreateStorageEx</c> function creates a new storage object using one of the system-provided, structured-storage
            implementations. This function can be used to obtain an IStorage compound file implementation, an IPropertySetStorage compound
            file implementation, or to obtain an IPropertySetStorage NTFS implementation.
            </para>
            <para>
            When a new file is created, the storage implementation used depends on the flag that you specify and on the type of drive on
            which the file is stored. For more information, see the STGFMT enumeration.
            </para>
            <para>
            <c>StgCreateStorageEx</c> creates the file if it does not exist. If it does exist, the use of the STGM_CREATE, STGM_CONVERT, and
            STGM_FAILIFTHERE flags in the grfMode parameter indicate how to proceed. For more information on these values, see STGM
            Constants. It is not valid, in direct mode, to specify the STGM_READ mode in the grfMode parameter (direct mode is indicated by
            not specifying the STGM_TRANSACTED flag). This function cannot be used to open an existing file; use the StgOpenStorageEx
            function instead.
            </para>
            <para>
            You can use the <c>StgCreateStorageEx</c> function to get access to the root storage of a structured-storage document or the
            property set storage of any file that supports property sets. See the STGFMT documentation for information about which IIDs are
            supported for different <c>STGFMT</c> values.
            </para>
            <para>
            When a file is created with this function to access the NTFS property set implementation, special sharing rules apply. For more
            information, see IPropertySetStorage-NTFS Implementation.
            </para>
            <para>
            If a compound file is created in transacted mode (by specifying STGM_TRANSACTED) and read-only mode (by specifying STGM_READ), it
            is possible to make changes to the returned storage object. For example, it is possible to call IStorage::CreateStream. However,
            it is not possible to commit those changes by calling IStorage::Commit. Therefore, such changes will be lost.
            </para>
            <para>
            Specifying STGM_SIMPLE provides a much faster implementation of a compound file object in a limited, but frequently used case
            involving applications that require a compound file implementation with multiple streams and no storages. For more information,
            see STGM Constants. It is not valid to specify that STGM_TRANSACTED if STGM_SIMPLE is specified.
            </para>
            <para>
            The simple mode does not support all the methods on IStorage. Specifically, in simple mode, supported <c>IStorage</c> methods are
            CreateStream, Commit, and SetClass as well as the COM IUnknown methods of QueryInterface, AddRef and Release. In addition,
            SetElementTimes is supported with a <c>NULL</c> name, allowing applications to set times on a root storage. All the other methods
            of <c>IStorage</c> return STG_E_INVALIDFUNCTION.
            </para>
            <para>
            If the grfMode parameter specifies STGM_TRANSACTED and no file yet exists with the name specified by the pwcsName parameter, the
            file is created immediately. In an access-controlled file system, the caller must have write permissions for the file system
            directory in which the compound file is created. If STGM_TRANSACTED is not specified, and STGM_CREATE is specified, an existing
            file with the same name is destroyed before creating the new file.
            </para>
            <para>
            You can also use <c>StgCreateStorageEx</c> to create a temporary compound file by passing a <c>NULL</c> value for the pwcsName
            parameter. However, these files are temporary only in the sense that they have a unique system-provided name – one that is
            probably meaningless to the user. The caller is responsible for deleting the temporary file when finished with it, unless
            STGM_DELETEONRELEASE was specified for the grfMode parameter. For more information on these flags, see STGM Constants.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgCreateStorageEx(System.String,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.STGFMT,Vanara.PInvoke.FileFlagsAndAttributes,System.IntPtr,Vanara.PInvoke.PSECURITY_DESCRIPTOR,System.Guid@,System.Object@)">
            <summary>
            <para>
            The <c>StgCreateStorageEx</c> function creates a new storage object using a provided implementation for the IStorage or
            IPropertySetStorage interfaces. To open an existing file, use the StgOpenStorageEx function instead.
            </para>
            <para>
            Applications written for Windows 2000, Windows Server 2003 and Windows XP must use <c>StgCreateStorageEx</c> rather than
            StgCreateDocfile to take advantage of the enhanced Windows 2000 and Windows XP Structured Storage features.
            </para>
            </summary>
            <param name="pwcsName">
            <para>
            A pointer to the path of the file to create. It is passed uninterpreted to the file system. This can be a relative name or
            <c>NULL</c>. If <c>NULL</c>, a temporary file is allocated with a unique name. If non- <c>NULL</c>, the string size must not
            exceed MAX_PATH characters.
            </para>
            <para><c>Windows 2000:</c> Unlike the CreateFile function, you cannot exceed the MAX_PATH limit by using the "\?" prefix.</para>
            </param>
            <param name="grfMode">
            A value that specifies the access mode to use when opening the new storage object. For more information, see STGM Constants. If
            the caller specifies transacted mode together with STGM_CREATE or STGM_CONVERT, the overwrite or conversion takes place when the
            commit operation is called for the root storage. If IStorage::Commit is not called for the root storage object, previous contents
            of the file will be restored. STGM_CREATE and STGM_CONVERT cannot be combined with the STGM_NOSNAPSHOT flag, because a snapshot
            copy is required when a file is overwritten or converted in the transacted mode.
            </param>
            <param name="stgfmt">A value that specifies the storage file format. For more information, see the STGFMT enumeration.</param>
            <param name="grfAttrs">
            <para>A value that depends on the value of the stgfmt parameter.</para>
            <list type="table">
            <listheader>
            <term>Parameter Values</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGFMT_DOCFILE</term>
            <term>
            0, or FILE_FLAG_NO_BUFFERING. For more information, see CreateFile. If the sector size of the file, specified in pStgOptions, is
            not an integer multiple of the underlying disk's physical sector size, this operation will fail.
            </term>
            </item>
            <item>
            <term>All other values of stgfmt</term>
            <term>Must be 0.</term>
            </item>
            </list>
            </param>
            <param name="pStgOptions">
            The pStgOptions parameter is valid only if the stgfmt parameter is set to STGFMT_DOCFILE. If the stgfmt parameter is set to
            STGFMT_DOCFILE, pStgOptions points to the STGOPTIONS structure, which specifies features of the storage object, such as the
            sector size. This parameter may be <c>NULL</c>, which creates a storage object with a default sector size of 512 bytes. If non-
            <c>NULL</c>, the <c>ulSectorSize</c> member must be set to either 512 or 4096. If set to 4096, STGM_SIMPLE may not be specified
            in the grfMode parameter. The <c>usVersion</c> member must be set before calling <c>StgCreateStorageEx</c>. For more information,
            see <c>STGOPTIONS</c>.
            </param>
            <param name="pSecurityDescriptor">
            <para>
            Enables the ACLs to be set when the file is created. If not <c>NULL</c>, needs to be a pointer to the SECURITY_ATTRIBUTES
            structure. See CreateFile for information on how to set ACLs on files.
            </para>
            <para><c>Windows Server 2003, Windows 2000 Server, Windows XP and Windows 2000 Professional:</c> Value must be <c>NULL</c>.</para>
            </param>
            <param name="riid">
            A value that specifies the interface identifier (IID) of the interface pointer to return. This IID may be for the IStorage
            interface or the IPropertySetStorage interface.
            </param>
            <param name="ppObjectOpen">
            A pointer to an interface pointer variable that receives a pointer for an interface on the new storage object; contains
            <c>NULL</c> if operation failed.
            </param>
            <returns>
            This function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more information, see
            Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            When an application modifies its file, it usually creates a copy of the original. The <c>StgCreateStorageEx</c> function is one
            way for creating a copy. This function works indirectly with the Encrypting File System (EFS) duplication API. When you use this
            function, you will need to set the options for the file storage in the STGOPTIONS structure.
            </para>
            <para>
            <c>StgCreateStorageEx</c> is a superset of the StgCreateDocfile function, and should be used by new code. Future enhancements to
            Structured Storage will be exposed through the <c>StgCreateStorageEx</c> function. See the following Requirements section for
            information on supported platforms.
            </para>
            <para>
            The <c>StgCreateStorageEx</c> function creates a new storage object using one of the system-provided, structured-storage
            implementations. This function can be used to obtain an IStorage compound file implementation, an IPropertySetStorage compound
            file implementation, or to obtain an IPropertySetStorage NTFS implementation.
            </para>
            <para>
            When a new file is created, the storage implementation used depends on the flag that you specify and on the type of drive on
            which the file is stored. For more information, see the STGFMT enumeration.
            </para>
            <para>
            <c>StgCreateStorageEx</c> creates the file if it does not exist. If it does exist, the use of the STGM_CREATE, STGM_CONVERT, and
            STGM_FAILIFTHERE flags in the grfMode parameter indicate how to proceed. For more information on these values, see STGM
            Constants. It is not valid, in direct mode, to specify the STGM_READ mode in the grfMode parameter (direct mode is indicated by
            not specifying the STGM_TRANSACTED flag). This function cannot be used to open an existing file; use the StgOpenStorageEx
            function instead.
            </para>
            <para>
            You can use the <c>StgCreateStorageEx</c> function to get access to the root storage of a structured-storage document or the
            property set storage of any file that supports property sets. See the STGFMT documentation for information about which IIDs are
            supported for different <c>STGFMT</c> values.
            </para>
            <para>
            When a file is created with this function to access the NTFS property set implementation, special sharing rules apply. For more
            information, see IPropertySetStorage-NTFS Implementation.
            </para>
            <para>
            If a compound file is created in transacted mode (by specifying STGM_TRANSACTED) and read-only mode (by specifying STGM_READ), it
            is possible to make changes to the returned storage object. For example, it is possible to call IStorage::CreateStream. However,
            it is not possible to commit those changes by calling IStorage::Commit. Therefore, such changes will be lost.
            </para>
            <para>
            Specifying STGM_SIMPLE provides a much faster implementation of a compound file object in a limited, but frequently used case
            involving applications that require a compound file implementation with multiple streams and no storages. For more information,
            see STGM Constants. It is not valid to specify that STGM_TRANSACTED if STGM_SIMPLE is specified.
            </para>
            <para>
            The simple mode does not support all the methods on IStorage. Specifically, in simple mode, supported <c>IStorage</c> methods are
            CreateStream, Commit, and SetClass as well as the COM IUnknown methods of QueryInterface, AddRef and Release. In addition,
            SetElementTimes is supported with a <c>NULL</c> name, allowing applications to set times on a root storage. All the other methods
            of <c>IStorage</c> return STG_E_INVALIDFUNCTION.
            </para>
            <para>
            If the grfMode parameter specifies STGM_TRANSACTED and no file yet exists with the name specified by the pwcsName parameter, the
            file is created immediately. In an access-controlled file system, the caller must have write permissions for the file system
            directory in which the compound file is created. If STGM_TRANSACTED is not specified, and STGM_CREATE is specified, an existing
            file with the same name is destroyed before creating the new file.
            </para>
            <para>
            You can also use <c>StgCreateStorageEx</c> to create a temporary compound file by passing a <c>NULL</c> value for the pwcsName
            parameter. However, these files are temporary only in the sense that they have a unique system-provided name – one that is
            probably meaningless to the user. The caller is responsible for deleting the temporary file when finished with it, unless
            STGM_DELETEONRELEASE was specified for the grfMode parameter. For more information on these flags, see STGM Constants.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgIsStorageFile(System.String)">
            <summary>The <c>StgIsStorageFile</c> function indicates whether a particular disk file contains a storage object.</summary>
            <param name="pwcsName">
            Pointer to the null-terminated Unicode string name of the disk file to be examined. The pwcsName parameter is passed
            uninterpreted to the underlying file system.
            </param>
            <returns>
            <c>StgIsStorageFile</c> function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. See Error
            Handling Strategies and Handling Unknown Errors
            </returns>
            <remarks>
            <para>
            At the beginning of the disk file underlying a storage object is a signature distinguishing a storage object from other file
            formats. The <c>StgIsStorageFile</c> function is useful to applications whose documents use a disk file format that might or
            might not use storage objects.
            </para>
            <para>If a root compound file has been created in transacted mode but not yet committed, this method still return S_OK.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgIsStorageILockBytes(Vanara.PInvoke.Ole32.ILockBytes)">
            <summary>The <c>StgIsStorageILockBytes</c> function indicates whether the specified byte array contains a storage object.</summary>
            <param name="plkbyt">ILockBytes pointer to the byte array to be examined.</param>
            <returns>
            This function can also return any file system errors, or system errors wrapped in an <c>HRESULT</c>, or ILockBytes interface
            error return values. See Error Handling Strategies and Handling Unknown Errors
            </returns>
            <remarks>
            At the beginning of the byte array underlying a storage object is a signature distinguishing a storage object (supporting the
            IStorage interface) from other file formats. The <c>StgIsStorageILockBytes</c> function is useful to applications whose documents
            use a byte array (a byte array object supports the ILockBytes interface) that might or might not use storage objects.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgOpenPropStg(System.Object,System.Guid@,Vanara.PInvoke.Ole32.PROPSETFLAG,System.UInt32,Vanara.PInvoke.Ole32.IPropertyStorage@)">
            <summary>
            The <c>StgOpenPropStg</c> function opens a specified property set in a specified storage or stream object. The property set
            supplies the system-provided, stand-alone implementation of the IPropertyStorage interface.
            </summary>
            <param name="pUnk">
            The interface pointer for <c>IUnknown</c> interface on the storage or stream object that contains the requested property set object.
            </param>
            <param name="fmtid">The FMTID of the property set to be opened.</param>
            <param name="grfFlags">The values from PROPSETFLAG Constants.</param>
            <param name="dwReserved">Reserved for future use; must be zero.</param>
            <param name="ppPropStg">
            A pointer to an IPropertyStorage* pointer variable that receives the interface pointer to the requested property set.
            </param>
            <returns>This function supports the standard return values E_INVALIDARG and E_UNEXPECTED, in addition to the following:</returns>
            <remarks>
            <para>
            <c>StgOpenPropStg</c> opens the requested property set and supplies the system-provided, stand-alone implementation of the
            IPropertyStorage interface. The requested property set is contained in the storage or stream object specified by pUnk. The value
            of the grfFlags parameter indicates whether pUnk specifies a storage or stream object. For example, if PROPSETFLAG_NONSIMPLE is
            set, then pUnk can be queried for an IStorage interface on a storage object.
            </para>
            <para>
            In either case, this function calls pUnk-&gt;AddRef for the storage or stream object containing the property set. The caller must
            release the object when no longer required.
            </para>
            <para>
            This function is similar to the IPropertySetStorage::Open method. However, <c>StgOpenPropStg</c> adds the pUnk and grfFlags
            parameters, including the PROPSETFLAG_UNBUFFERED value for the grfFlags parameter. Use this function instead of the Open method
            if you have an IStorage interface that does not support the IPropertySetStorage interface, or if you want to use the
            PROPSETFLAG_UNBUFFERED value. For more information about using PROPSETFLAG_UNBUFFERED, see PROPSETFLAG Constants.
            </para>
            <para>
            The grfFlags parameter is a combination of values taken from PROPSETFLAG Constants. The new enumeration value
            PROPSETFLAG_UNBUFFERED is supported. For more information, see <c>PROPSETFLAG Constants</c>.
            </para>
            <para>
            This function is exported out of the redistributable iprop.dll, which is included in Windows NT 4.0 with Service Pack 2 (SP2) and
            available as a redistributable in Windows 95 and later. In Windows 2000, it is exported out of Ole32.dll. It can also be exported
            out of iprop.dll in Windows 2000, but the call gets forwarded to ole32.dll.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgOpenStorage(System.String,Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.SNB,System.UInt32,Vanara.PInvoke.Ole32.IStorage@)">
            <summary>
            <para>
            The <c>StgOpenStorage</c> function opens an existing root storage object in the file system. Use this function to open compound
            files. Do not use it to open directories, files, or summary catalogs. Nested storage objects can only be opened using their
            parent IStorage::OpenStorage method.
            </para>
            <para>
            <c>Note</c> Applications should use the new function, StgOpenStorageEx, instead of <c>StgOpenStorage</c>, to take advantage of
            the enhanced and Windows Structured Storage features. This function, <c>StgOpenStorage</c>, still exists for compatibility with
            applications running on Windows 2000.
            </para>
            </summary>
            <param name="pwcsName">
            A pointer to the path of the <c>null</c>-terminated Unicode string file that contains the storage object to open. This parameter
            is ignored if the pstgPriority parameter is not <c>NULL</c>.
            </param>
            <param name="pstgPriority">
            <para>
            A pointer to the IStorage interface that should be <c>NULL</c>. If not <c>NULL</c>, this parameter is used as described below in
            the Remarks section.
            </para>
            <para>
            After <c>StgOpenStorage</c> returns, the storage object specified in pStgPriority may have been released and should no longer be used.
            </para>
            </param>
            <param name="grfMode">Specifies the access mode to use to open the storage object.</param>
            <param name="snbExclude">
            If not <c>NULL</c>, pointer to a block of elements in the storage to be excluded as the storage object is opened. The exclusion
            occurs regardless of whether a snapshot copy happens on the open. Can be <c>NULL</c>.
            </param>
            <param name="reserved">Indicates reserved for future use; must be zero.</param>
            <param name="ppstgOpen">A pointer to a IStorage* pointer variable that receives the interface pointer to the opened storage.</param>
            <returns>
            The <c>StgOpenStorage</c> function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more
            information, see Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            The <c>StgOpenStorage</c> function opens the specified root storage object according to the access mode in the grfMode parameter,
            and, if successful, supplies an IStorage pointer to the opened storage object in the ppstgOpen parameter.
            </para>
            <para>
            To support the simple mode for saving a storage object with no substorages, the <c>StgOpenStorage</c> function accepts one of the
            following two flag combinations as valid modes in the grfMode parameter.
            </para>
            <para>
            To support the single-writer, multireader, direct mode, the first flag combination is the valid grfMode parameter for the writer.
            The second flag combination is valid for readers.
            </para>
            <para>In direct mode, one of the following three combinations are valid.</para>
            <para>
            <c>Note</c> Opening a storage object in read/write mode without denying write permission to others (the grfMode parameter
            specifies STGM_SHARE_DENY_WRITE) can be a time-consuming operation because the <c>StgOpenStorage</c> call must make a snapshot of
            the entire storage object.
            </para>
            <para>
            Applications often try to open storage objects with the following access permissions. If the application succeeds, it never needs
            to make a snapshot copy.
            </para>
            <para>
            The application can revert to using the permissions and make a snapshot copy, if the previous access permissions fail. The
            application should prompt the user before making a time-consuming copy.
            </para>
            <para>
            If the document-sharing semantics implied by the access modes are appropriate, the application could try to open the storage as
            follows. In this case, if the application succeeds, a snapshot copy will not have been made (because <c>STGM_SHARE_DENY_WRITE</c>
            was specified, denying others write access).
            </para>
            <para>
            <c>Note</c> To reduce the expense of making a snapshot copy, applications can open storage objects in priority mode (grfMode
            specifies <c>STGM_PRIORITY</c>).
            </para>
            <para>
            The snbExclude parameter specifies a set of element names in this storage object that are to be emptied as the storage object is
            opened: streams are set to a length of zero; storage objects have all their elements removed. By excluding certain streams, the
            expense of making a snapshot copy can be significantly reduced. Almost always, this approach is used after first opening the
            storage object in priority mode, then completely reading the now-excluded elements into memory. This earlier priority-mode
            opening of the storage object should be passed through the pstgPriority parameter to remove the exclusion implied by priority
            mode. The calling application is responsible for rewriting the contents of excluded items before committing. Thus, this technique
            is most likely useful only to applications whose documents do not require constant access to their storage objects while they are active.
            </para>
            <para>
            The pstgPriority parameter is intended as a convenience for callers replacing an existing storage object, often one opened in
            priority mode, with a new storage object opened on the same file but in a different mode. When pstgPriority is not <c>NULL</c>,
            it is used to specify the file name instead of pwcsName, which is ignored. However, it is recommended that applications always
            pass <c>NULL</c> for pstgPriority because <c>StgOpenStorage</c> releases the object under some circumstances, and does not
            release it under other circumstances. In particular, if the function returns a failure result, it is not possible for the caller
            to determine whether or not the storage object was released.
            </para>
            <para>
            The functionality of the pstgPriority parameter can be duplicated by the caller in a safer manner as shown in the following example:
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgOpenStorageEx(System.String,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.STGFMT,Vanara.PInvoke.FileFlagsAndAttributes,Vanara.PInvoke.Ole32.STGOPTIONS@,Vanara.PInvoke.PSECURITY_DESCRIPTOR,System.Guid@,System.Object@)">
            <summary>
            <para>
            The <c>StgOpenStorageEx</c> function opens an existing root storage object in the file system. Use this function to open Compound
            Files and regular files. To create a new file, use the StgCreateStorageEx function.
            </para>
            <para>
            <c>Note</c> To use enhancements, all Windows 2000, Windows XP, and Windows Server 2003 applications should call
            <c>StgOpenStorageEx</c>, instead of StgOpenStorage. The <c>StgOpenStorage</c> function is used for compatibility with Windows
            2000 and earlier applications.
            </para>
            </summary>
            <param name="pwcsName">
            <para>
            A pointer to the path of the null-terminated Unicode string file that contains the storage object. This string size cannot exceed
            <c>MAX_PATH</c> characters.
            </para>
            <para>
            <c>Windows Server 2003 and Windows XP/2000:</c> Unlike the CreateFile function, the <c>MAX_PATH</c> limit cannot be exceeded by
            using the "\?" prefix.
            </para>
            </param>
            <param name="grfMode">
            <para>
            A value that specifies the access mode to open the new storage object. For more information, see STGM Constants. If the caller
            specifies transacted mode together with <c>STGM_CREATE</c> or <c>STGM_CONVERT</c>, the overwrite or conversion occurs when the
            commit operation is called for the root storage. If IStorage::Commit is not called for the root storage object, previous contents
            of the file will be restored. <c>STGM_CREATE</c> and <c>STGM_CONVERT</c> cannot be combined with the <c>STGM_NOSNAPSHOT</c> flag,
            because a snapshot copy is required when a file is overwritten or converted in transacted mode.
            </para>
            <para>
            If the storage object is opened in direct mode ( <c>STGM_DIRECT</c>) with access to either <c>STGM_WRITE</c> or
            <c>STGM_READWRITE</c>, the sharing mode must be <c>STGM_SHARE_EXCLUSIVE</c> unless the <c>STGM_DIRECT_SWMR</c> mode is specified.
            For more information, see the Remarks section. If the storage object is opened in direct mode with access to <c>STGM_READ</c>,
            the sharing mode must be either <c>STGM_SHARE_EXCLUSIVE</c> or <c>STGM_SHARE_DENY_WRITE</c>, unless <c>STGM_PRIORITY</c> or
            <c>STGM_DIRECT_SWMR</c> is specified. For more information, see the Remarks section.
            </para>
            <para>
            The mode in which a file is opened can affect implementation performance. For more information, see Compound File Implementation Limits.
            </para>
            </param>
            <param name="stgfmt">A value that specifies the storage file format. For more information, see the STGFMT enumeration.</param>
            <param name="grfAttrs">
            <para>A value that depends upon the value of the stgfmt parameter.</para>
            <para>
            <c>STGFMT_DOCFILE</c> must be zero (0) or <c>FILE_FLAG_NO_BUFFERING</c>. For more information about this value, see CreateFile.
            If the sector size of the file, specified in pStgOptions, is not an integer multiple of the physical sector size of the
            underlying disk, then this operation will fail. All other values of stgfmt must be zero.
            </para>
            </param>
            <param name="pStgOptions">
            A pointer to an STGOPTIONS structure that contains data about the storage object opened. The pStgOptions parameter is valid only
            if the stgfmt parameter is set to <c>STGFMT_DOCFILE</c>. The <c>usVersion</c> member must be set before calling
            <c>StgOpenStorageEx</c>. For more information, see the <c>STGOPTIONS</c> structure.
            </param>
            <param name="pSecurityDescriptor">Reserved; must be zero.</param>
            <param name="riid">
            A value that specifies the GUID of the interface pointer to return. Can also be the header-specified value for
            <c>IID_IStorage</c> to obtain the IStorage interface or for <c>IID_IPropertySetStorage</c> to obtain the IPropertySetStorage interface.
            </param>
            <param name="ppObjectOpen">
            The address of an interface pointer variable that receives a pointer for an interface on the storage object opened; contains
            <c>NULL</c> if operation failed.
            </param>
            <returns>
            This function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more information, see
            Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            <c>StgOpenStorageEx</c> is a superset of the StgOpenStorage function, and should be used by new code. Future enhancements to
            structured storage will be exposed through this function. For more information about supported platforms, see the Requirements section.
            </para>
            <para>
            The <c>StgOpenStorageEx</c> function opens the specified root storage object according to the access mode in the grfMode
            parameter, and, if successful, supplies an interface pointer for the opened storage object in the ppObjectOpen parameter. This
            function can be used to obtain an IStorage compound file implementation, an IPropertySetStorage compound file implementation, or
            an NTFS file system implementation of IPropertySetStorage.
            </para>
            <para>
            When you open a file, the system selects a structured storage implementation depending on which STGFMT flag you specify on the
            file type and on the type of drive where the file is stored.
            </para>
            <para>
            Use the <c>StgOpenStorageEx</c> function to access the root storage of a structured storage document or the property set storage
            of any file that supports property sets. For more information about which interface identifiers (IIDs) are supported for the
            different STGFMT values, see STGFMT.
            </para>
            <para>
            When a file is opened with this function to access the NTFS property set implementation, special sharing rules apply. For more
            information, see IPropertySetStorage-NTFS Implementation.
            </para>
            <para>
            If a compound file is opened in transacted mode, by specifying STGM_TRANSACTED, and read-only mode, by specifying STGM_READ, it
            is possible to change the returned storage object. For example, it is possible to call IStorage::CreateStream. However, it is not
            possible to commit those changes by calling IStorage::Commit. Therefore, such changes will be lost.
            </para>
            <para>
            It is not valid to use the <c>STGM_CREATE</c>, <c>STGM_DELETEONRELEASE</c>, or <c>STGM_CONVERT</c> flags in the grfMode parameter
            for this function.
            </para>
            <para>
            To support the simple mode for saving a storage object with no substorages, the <c>StgOpenStorageEx</c> function accepts one of
            the following two flag combinations as valid modes in the grfMode parameter:
            </para>
            <para>
            To support the single-writer, multireader, direct mode, the first flag combination is the valid grfMode parameter for the writer.
            The second flag combination is valid for readers.
            </para>
            <para>For more information about simple mode and single-writer/multiple-reader modes, see STGM Constants.</para>
            <para>
            <c>Note</c> Opening a transacted mode storage object in read and/or write mode without denying write permissions to others (for
            example, the grfMode parameter specifies <c>STGM_SHARE_DENY_WRITE</c>) can be time-consuming because the <c>StgOpenStorageEx</c>
            call must create a snapshot copy of the entire storage object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgOpenStorageEx(System.String,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.STGFMT,Vanara.PInvoke.FileFlagsAndAttributes,System.IntPtr,Vanara.PInvoke.PSECURITY_DESCRIPTOR,System.Guid@,System.Object@)">
            <summary>
            <para>
            The <c>StgOpenStorageEx</c> function opens an existing root storage object in the file system. Use this function to open Compound
            Files and regular files. To create a new file, use the StgCreateStorageEx function.
            </para>
            <para>
            <c>Note</c> To use enhancements, all Windows 2000, Windows XP, and Windows Server 2003 applications should call
            <c>StgOpenStorageEx</c>, instead of StgOpenStorage. The <c>StgOpenStorage</c> function is used for compatibility with Windows
            2000 and earlier applications.
            </para>
            </summary>
            <param name="pwcsName">
            <para>
            A pointer to the path of the null-terminated Unicode string file that contains the storage object. This string size cannot exceed
            <c>MAX_PATH</c> characters.
            </para>
            <para>
            <c>Windows Server 2003 and Windows XP/2000:</c> Unlike the CreateFile function, the <c>MAX_PATH</c> limit cannot be exceeded by
            using the "\?" prefix.
            </para>
            </param>
            <param name="grfMode">
            <para>
            A value that specifies the access mode to open the new storage object. For more information, see STGM Constants. If the caller
            specifies transacted mode together with <c>STGM_CREATE</c> or <c>STGM_CONVERT</c>, the overwrite or conversion occurs when the
            commit operation is called for the root storage. If IStorage::Commit is not called for the root storage object, previous contents
            of the file will be restored. <c>STGM_CREATE</c> and <c>STGM_CONVERT</c> cannot be combined with the <c>STGM_NOSNAPSHOT</c> flag,
            because a snapshot copy is required when a file is overwritten or converted in transacted mode.
            </para>
            <para>
            If the storage object is opened in direct mode ( <c>STGM_DIRECT</c>) with access to either <c>STGM_WRITE</c> or
            <c>STGM_READWRITE</c>, the sharing mode must be <c>STGM_SHARE_EXCLUSIVE</c> unless the <c>STGM_DIRECT_SWMR</c> mode is specified.
            For more information, see the Remarks section. If the storage object is opened in direct mode with access to <c>STGM_READ</c>,
            the sharing mode must be either <c>STGM_SHARE_EXCLUSIVE</c> or <c>STGM_SHARE_DENY_WRITE</c>, unless <c>STGM_PRIORITY</c> or
            <c>STGM_DIRECT_SWMR</c> is specified. For more information, see the Remarks section.
            </para>
            <para>
            The mode in which a file is opened can affect implementation performance. For more information, see Compound File Implementation Limits.
            </para>
            </param>
            <param name="stgfmt">A value that specifies the storage file format. For more information, see the STGFMT enumeration.</param>
            <param name="grfAttrs">
            <para>A value that depends upon the value of the stgfmt parameter.</para>
            <para>
            <c>STGFMT_DOCFILE</c> must be zero (0) or <c>FILE_FLAG_NO_BUFFERING</c>. For more information about this value, see CreateFile.
            If the sector size of the file, specified in pStgOptions, is not an integer multiple of the physical sector size of the
            underlying disk, then this operation will fail. All other values of stgfmt must be zero.
            </para>
            </param>
            <param name="pStgOptions">
            A pointer to an STGOPTIONS structure that contains data about the storage object opened. The pStgOptions parameter is valid only
            if the stgfmt parameter is set to <c>STGFMT_DOCFILE</c>. The <c>usVersion</c> member must be set before calling
            <c>StgOpenStorageEx</c>. For more information, see the <c>STGOPTIONS</c> structure.
            </param>
            <param name="pSecurityDescriptor">Reserved; must be zero.</param>
            <param name="riid">
            A value that specifies the GUID of the interface pointer to return. Can also be the header-specified value for
            <c>IID_IStorage</c> to obtain the IStorage interface or for <c>IID_IPropertySetStorage</c> to obtain the IPropertySetStorage interface.
            </param>
            <param name="ppObjectOpen">
            The address of an interface pointer variable that receives a pointer for an interface on the storage object opened; contains
            <c>NULL</c> if operation failed.
            </param>
            <returns>
            This function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. For more information, see
            Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            <c>StgOpenStorageEx</c> is a superset of the StgOpenStorage function, and should be used by new code. Future enhancements to
            structured storage will be exposed through this function. For more information about supported platforms, see the Requirements section.
            </para>
            <para>
            The <c>StgOpenStorageEx</c> function opens the specified root storage object according to the access mode in the grfMode
            parameter, and, if successful, supplies an interface pointer for the opened storage object in the ppObjectOpen parameter. This
            function can be used to obtain an IStorage compound file implementation, an IPropertySetStorage compound file implementation, or
            an NTFS file system implementation of IPropertySetStorage.
            </para>
            <para>
            When you open a file, the system selects a structured storage implementation depending on which STGFMT flag you specify on the
            file type and on the type of drive where the file is stored.
            </para>
            <para>
            Use the <c>StgOpenStorageEx</c> function to access the root storage of a structured storage document or the property set storage
            of any file that supports property sets. For more information about which interface identifiers (IIDs) are supported for the
            different STGFMT values, see STGFMT.
            </para>
            <para>
            When a file is opened with this function to access the NTFS property set implementation, special sharing rules apply. For more
            information, see IPropertySetStorage-NTFS Implementation.
            </para>
            <para>
            If a compound file is opened in transacted mode, by specifying STGM_TRANSACTED, and read-only mode, by specifying STGM_READ, it
            is possible to change the returned storage object. For example, it is possible to call IStorage::CreateStream. However, it is not
            possible to commit those changes by calling IStorage::Commit. Therefore, such changes will be lost.
            </para>
            <para>
            It is not valid to use the <c>STGM_CREATE</c>, <c>STGM_DELETEONRELEASE</c>, or <c>STGM_CONVERT</c> flags in the grfMode parameter
            for this function.
            </para>
            <para>
            To support the simple mode for saving a storage object with no substorages, the <c>StgOpenStorageEx</c> function accepts one of
            the following two flag combinations as valid modes in the grfMode parameter:
            </para>
            <para>
            To support the single-writer, multireader, direct mode, the first flag combination is the valid grfMode parameter for the writer.
            The second flag combination is valid for readers.
            </para>
            <para>For more information about simple mode and single-writer/multiple-reader modes, see STGM Constants.</para>
            <para>
            <c>Note</c> Opening a transacted mode storage object in read and/or write mode without denying write permissions to others (for
            example, the grfMode parameter specifies <c>STGM_SHARE_DENY_WRITE</c>) can be time-consuming because the <c>StgOpenStorageEx</c>
            call must create a snapshot copy of the entire storage object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgOpenStorageOnILockBytes(Vanara.PInvoke.Ole32.ILockBytes,Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.SNB,System.UInt32,Vanara.PInvoke.Ole32.IStorage@)">
            <summary>
            The <c>StgOpenStorageOnILockBytes</c> function opens an existing storage object that does not reside in a disk file, but instead
            has an underlying byte array provided by the caller.
            </summary>
            <param name="plkbyt">ILockBytes pointer to the underlying byte array object that contains the storage object to be opened.</param>
            <param name="pstgPriority">
            <para>
            A pointer to the IStorage interface that should be <c>NULL</c>. If not <c>NULL</c>, this parameter is used as described below in
            the Remarks section.
            </para>
            <para>
            After <c>StgOpenStorageOnILockBytes</c> returns, the storage object specified in pStgPriority may have been released and should
            no longer be used.
            </para>
            </param>
            <param name="grfMode">
            Specifies the access mode to use to open the storage object. For more information, see STGM Constants and the Remarks section below.
            </param>
            <param name="snbExclude">
            Can be <c>NULL</c>. If not <c>NULL</c>, this parameter points to a block of elements in this storage that are to be excluded as
            the storage object is opened. This exclusion occurs independently of whether a snapshot copy happens on the open.
            </param>
            <param name="reserved">Indicates reserved for future use; must be zero.</param>
            <param name="ppstgOpen">Points to the location of an IStorage pointer to the opened storage on successful return.</param>
            <returns>
            The <c>StgOpenStorageOnILockBytes</c> function can also return any file system errors, or system errors wrapped in an
            <c>HRESULT</c>, or ILockBytes interface error return values. See Error Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            <c>StgOpenStorageOnILockBytes</c> opens the specified root storage object. A pointer to the IStorage interface on the opened
            storage object is supplied through the ppstgOpen parameter.
            </para>
            <para>The storage object must have been previously created by the StgCreateDocfileOnILockBytes function.</para>
            <para>
            Except for specifying a programmer-provided byte-array object, <c>StgOpenStorageOnILockBytes</c> is similar to the StgOpenStorage
            function. The storage object is opened according to the access modes in the grfMode parameter, subject to the following restrictions:
            </para>
            <para>
            Sharing mode behavior and transactional isolation depend on the ILockBytes implementation supporting LockRegion and UnlockRegion
            with LOCK_ONLYONCE semantics. Implementations can indicate to structured storage they support this functionality by setting the
            <c>LOCK_ONLYONCE</c> bit in the <c>grfLocksSupported</c> member of STATSTG. If an <c>ILockBytes</c> implementation does not
            support this functionality, sharing modes will not be enforced, and root-level transactional commits will not coordinate properly
            with other transactional instances opened on the same byte array. Applications that use an <c>ILockBytes</c> implementation that
            does not support region locking, such as the CreateStreamOnHGlobal implementation, should avoid opening multiple concurrent
            instances on the same byte array.
            </para>
            <para><c>StgOpenStorageOnILockBytes</c> does not support simple mode. The STGM_SIMPLE flag, if present, is ignored.</para>
            <para>
            The pStgPriority parameter is intended as a convenience for callers replacing an existing storage object, often one opened in
            priority mode, with a new storage object opened on the same byte array. Unlike the pStgPriority parameter of StgOpenStorage, this
            parameter does not affect the open operation performed by <c>StgOpenStorageOnILockBytes</c> and is simply an existing storage
            object the caller would like released. Callers should always pass <c>NULL</c> for this parameter because
            <c>StgOpenStorageOnILockBytes</c> releases the object under some circumstances, and does not release it under other
            circumstances. The use of the pStgPriority parameter can be duplicated by the caller in a safer manner by instead releasing the
            object before calling <c>StgOpenStorageOnILockBytes</c>, as shown in the following example:
            </para>
            <para>For more information, refer to StgOpenStorage.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgSetTimes(System.String,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            The <c>StgSetTimes</c> function sets the creation, access, and modification times of the indicated file, if supported by the
            underlying file system.
            </summary>
            <param name="lpszName">Pointer to the name of the file to be changed.</param>
            <param name="pctime">Pointer to the new value for the creation time.</param>
            <param name="patime">Pointer to the new value for the access time.</param>
            <param name="pmtime">Pointer to the new value for the modification time.</param>
            <returns>
            The <c>StgSetTimes</c> function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. See Error
            Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            The <c>StgSetTimes</c> function sets the time values for the specified file. Each of the time value parameters can be
            <c>NULL</c>, indicating that no modification should occur.
            </para>
            <para>
            It is possible that one or more of these time values are not supported by the underlying file system. This function sets the
            times that can be set and ignores the rest.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgSetTimes(System.String,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The <c>StgSetTimes</c> function sets the creation, access, and modification times of the indicated file, if supported by the
            underlying file system.
            </summary>
            <param name="lpszName">Pointer to the name of the file to be changed.</param>
            <param name="pctime">Pointer to the new value for the creation time.</param>
            <param name="patime">Pointer to the new value for the access time.</param>
            <param name="pmtime">Pointer to the new value for the modification time.</param>
            <returns>
            The <c>StgSetTimes</c> function can also return any file system errors or system errors wrapped in an <c>HRESULT</c>. See Error
            Handling Strategies and Handling Unknown Errors.
            </returns>
            <remarks>
            <para>
            The <c>StgSetTimes</c> function sets the time values for the specified file. Each of the time value parameters can be
            <c>NULL</c>, indicating that no modification should occur.
            </para>
            <para>
            It is possible that one or more of these time values are not supported by the underlying file system. This function sets the
            times that can be set and ignores the rest.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.WriteClassStg(Vanara.PInvoke.Ole32.IStorage,System.Guid@)">
            <summary>The <c>WriteClassStg</c> function stores the specified class identifier (CLSID) in a storage object.</summary>
            <param name="pStg">IStorage pointer to the storage object that gets a new CLSID.</param>
            <param name="rclsid">Pointer to the CLSID to be stored with the object.</param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            The <c>WriteClassStg</c> function writes a CLSID to the specified storage object so that it can be read by the ReadClassStg
            function. Container applications typically call this function before calling the IPersistStorage::Save method.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.WriteClassStm(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@)">
            <summary>The <c>WriteClassStm</c> function stores the specified CLSID in the stream.</summary>
            <param name="pStm">IStream pointer to the stream into which the CLSID is to be written.</param>
            <param name="rclsid">Specifies the CLSID to write to the stream.</param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            The <c>WriteClassStm</c> function writes a CLSID to the specified stream object so it can be read by the ReadClassStm function.
            Most applications do not call <c>WriteClassStm</c> directly. OLE calls it before making a call to an object's
            IPersistStream::Save method.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.TrustLevel">
            <summary>Represents the trust level of an activatable class.</summary>
            <remarks>
            <para>Classes can be activated depending on the trust level of the caller and the trust classification of the activatable class.</para>
            <para>RegisteredTrustLevel is an alias for this enumeration.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TrustLevel.BaseTrust">
            <summary>The component has access to resources that are not protected.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TrustLevel.PartialTrust">
            <summary>The component has access to resources requested in the app manifest and approved by the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TrustLevel.FullTrust">
            <summary>The component requires the full privileges of the user.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IInspectable">
            <summary>Provides functionality required for all Windows Runtime classes.</summary>
            <remarks><c>IInspectable</c> methods have no effect on COM apartments and are safe to call from user interface threads.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInspectable.GetIids(System.UInt32@,Vanara.InteropServices.SafeCoTaskMemHandle@)">
            <summary>Gets the interfaces that are implemented by the current Windows Runtime class.</summary>
            <param name="iidCount">
            <para>Type: <c>ULONG*</c></para>
            <para>
            The number of interfaces that are implemented by the current Windows Runtime object, excluding the IUnknown and IInspectable implementations.
            </para>
            </param>
            <param name="iids">
            <para>Type: <c>IID**</c></para>
            <para>
            A pointer to an array that contains an IID for each interface implemented by the current Windows Runtime object. The IUnknown
            and IInspectable interfaces are excluded.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The HSTRING was created successfully.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Failed to allocate iids.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Use the <c>GetIids</c> method to discover the interfaces that are implemented by a Windows Runtime object.</para>
            <para>A QueryInterface call on any IID in the iids array must succeed.</para>
            <para>The caller is responsible for freeing the IID array by using the CoTaskMemFree function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInspectable.GetRuntimeClassName(System.String@)">
            <summary>Gets the fully qualified name of the current Windows Runtime object.</summary>
            <param name="className">
            <para>Type: <c>HSTRING*</c></para>
            <para>The fully qualified name of the current Windows Runtime object.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The className string was created successfully.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Failed to allocate className string.</term>
            </item>
            <item>
            <term>E_ILLEGAL_METHOD_CALL</term>
            <term>className refers to a class factory or a static interface.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Use the <c>GetRuntimeClassName</c> method to retrieve the namespace-qualified name of a Windows Runtime object.</para>
            <para>The caller is responsible for freeing the className string by using the WindowsDeleteString function.</para>
            <para>The following table shows example class name strings that cold be returned by the <c>GetRuntimeClassName</c> method.</para>
            <list type="table">
            <listheader>
            <term>Example Class Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>Fabrikam.Kitchen.IToaster</term>
            <term>An interface in the Fabrikam.Kitchen namespace.</term>
            </item>
            <item>
            <term>Fabrikam.Kitchen.Chef</term>
            <term>An class in the Fabrikam.Kitchen namespace.</term>
            </item>
            <item>
            <term>Windows.Foundation.Collections.IVector`1&lt;TailspinToys.IStore&gt;</term>
            <term>A vector of TailspinToys.IStore interfaces.</term>
            </item>
            <item>
            <term>Windows.Foundation.Collections.IVector`1&lt;Windows.Foundation.Collections.IMapâ€™2&lt;String, TailspinToys.IStore&gt;&gt;</term>
            <term>A vector of maps of strings to TailspinToys.IStore interfaces.</term>
            </item>
            </list>
            <para>
            The <c>GetRuntimeClassName</c> method provides the most specific type information that the server object guarantees that it
            implements. The type name may be a runtime class name, interface group name, interface name, or parameterized interface name.
            </para>
            <para>
            The <c>GetRuntimeClassName</c> method returns <c>E_ILLEGAL_METHOD_CALL</c> if the class name refers to a class factory or a
            static interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInspectable.GetTrustLevel(Vanara.PInvoke.Ole32.TrustLevel@)">
            <summary>Gets the trust level of the current Windows Runtime object.</summary>
            <param name="trustLevel">
            <para>Type: <c>TrustLevel*</c></para>
            <para>The trust level of the current Windows Runtime object. The default is <c>BaseLevel</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method always returns <c>S_OK</c>.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IMessageDispatcher">
            <summary>
            Callback interface implemented by components that need to perform special processing of window messages on an ASTA thread.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageDispatcher.GetIids(System.UInt32@,Vanara.InteropServices.SafeCoTaskMemHandle@)">
            <summary>Gets the interfaces that are implemented by the current Windows Runtime class.</summary>
            <param name="iidCount">
            <para>Type: <c>ULONG*</c></para>
            <para>
            The number of interfaces that are implemented by the current Windows Runtime object, excluding the IUnknown and IInspectable implementations.
            </para>
            </param>
            <param name="iids">
            <para>Type: <c>IID**</c></para>
            <para>
            A pointer to an array that contains an IID for each interface implemented by the current Windows Runtime object. The IUnknown
            and IInspectable interfaces are excluded.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The HSTRING was created successfully.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Failed to allocate iids.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Use the <c>GetIids</c> method to discover the interfaces that are implemented by a Windows Runtime object.</para>
            <para>A QueryInterface call on any IID in the iids array must succeed.</para>
            <para>The caller is responsible for freeing the IID array by using the CoTaskMemFree function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageDispatcher.GetRuntimeClassName(System.String@)">
            <summary>Gets the fully qualified name of the current Windows Runtime object.</summary>
            <param name="className">
            <para>Type: <c>HSTRING*</c></para>
            <para>The fully qualified name of the current Windows Runtime object.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The className string was created successfully.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Failed to allocate className string.</term>
            </item>
            <item>
            <term>E_ILLEGAL_METHOD_CALL</term>
            <term>className refers to a class factory or a static interface.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Use the <c>GetRuntimeClassName</c> method to retrieve the namespace-qualified name of a Windows Runtime object.</para>
            <para>The caller is responsible for freeing the className string by using the WindowsDeleteString function.</para>
            <para>The following table shows example class name strings that cold be returned by the <c>GetRuntimeClassName</c> method.</para>
            <list type="table">
            <listheader>
            <term>Example Class Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>Fabrikam.Kitchen.IToaster</term>
            <term>An interface in the Fabrikam.Kitchen namespace.</term>
            </item>
            <item>
            <term>Fabrikam.Kitchen.Chef</term>
            <term>An class in the Fabrikam.Kitchen namespace.</term>
            </item>
            <item>
            <term>Windows.Foundation.Collections.IVector`1&lt;TailspinToys.IStore&gt;</term>
            <term>A vector of TailspinToys.IStore interfaces.</term>
            </item>
            <item>
            <term>Windows.Foundation.Collections.IVector`1&lt;Windows.Foundation.Collections.IMapâ€™2&lt;String, TailspinToys.IStore&gt;&gt;</term>
            <term>A vector of maps of strings to TailspinToys.IStore interfaces.</term>
            </item>
            </list>
            <para>
            The <c>GetRuntimeClassName</c> method provides the most specific type information that the server object guarantees that it
            implements. The type name may be a runtime class name, interface group name, interface name, or parameterized interface name.
            </para>
            <para>
            The <c>GetRuntimeClassName</c> method returns <c>E_ILLEGAL_METHOD_CALL</c> if the class name refers to a class factory or a
            static interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageDispatcher.GetTrustLevel(Vanara.PInvoke.Ole32.TrustLevel@)">
            <summary>Gets the trust level of the current Windows Runtime object.</summary>
            <param name="trustLevel">
            <para>Type: <c>TrustLevel*</c></para>
            <para>The trust level of the current Windows Runtime object. The default is <c>BaseLevel</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method always returns <c>S_OK</c>.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageDispatcher.PumpMessages">
            <summary>Performs custom dispatching when window messages are available to be dispatched on an ASTA thread.</summary>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoHandlePriorityEventsFromMessagePump">
            <summary>
            Called by message dispatchers on an ASTA thread after dispatching a windows message to provide an opportunity for short-running
            infrastructural COM calls and other high-priority or short-running COM work to be dispatched between messages. This helps to
            provide similar responsiveness to these infrastructural calls in an ASTA as in a classic STA, even when there is a long stream of
            window messages to be handled.
            </summary>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            This function dispatches any high-priority COM calls or work that are queued on the ASTA thread, then returns. It returns quickly
            if there is no work to perform.
            </para>
            <para>This function silently does nothing when called on non-ASTA threads.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoSetMessageDispatcher(Vanara.PInvoke.Ole32.IMessageDispatcher)">
            <summary>
            Registers or unregisters the per-thread message dispatcher that is to be invoked when there are window messages available to
            dispatch within COM wait APIs on an ASTA thread. This function is usually called by CoreWindow, but in certain circumstances
            other components that need to specialize how messages are dispatched on an ASTA thread can also call this function.
            </summary>
            <param name="pMessageDispatcher">
            If non-null, message dispatcher object to register. This object must also implement IWeakReferenceSource. If null, unregisters
            the current message dispatcher.
            </param>
            <remarks>
            <para>
            This function is supported only in ASTA threads. An attempt to set the message dispatcher on a non-ASTA thread silently fails
            with no side effects.
            </para>
            <para>An attempt to set an object that does not implement IWeakReferenceSource silently fails with no side effects.</para>
            <para>
            A call to this function with a valid and non-null pMessageDispatcher parameter registers this object to receive a PumpMessages
            callback whenever there are window messages available to dispatch with COM wait APIs on that ASTA thread. A Windows Runtime weak
            reference to this object is held, and the object receives callbacks, until the registration is replaced or the ASTA
            uninitialized. Each call to this function replaces the previously registered message dispatcher, if any.
            </para>
            <para>
            There is no way to check if a message dispatcher is registered on an ASTA thread or to retrieve a previously registered message
            dispatcher. This function should only be called under circumstances where it is known that this will not collide with another
            registration, specifically:
            </para>
            <list type="bullet">
            <item>
            <term>
            In Windows Store app UI threads, this function is called by CoreWindow to register its dispatcher. No other components should
            call this function on these threads.
            </term>
            </item>
            <item>
            <term>
            UI frameworks may support an authoring mode, in which applications are run in the desktop environment and therefore do not have a
            CoreWindow in their UI threads. In lieu of CoreWindow support, these UI frameworks may register a message dispatcher on UI
            threads to handle special window message processing usually handled by CoreWindow (such as accelerators). It is not required to
            call this function if the UI framework has no need for this functionality.
            </term>
            </item>
            <item>
            <term>
            IAppVisibility browsers are not restricted to the Windows Store app APIs and therefore may have their own custom window message
            processing using user32 APIs. However, these applications still have ASTA UI threads as provided by app object, and may register
            a message dispatcher to handle this special processing. It is not required to call this function if the browser has no need for
            this functionality.
            </term>
            </item>
            </list>
            <para>
            The case of IAppVisibility browsers requires care to avoid CoreWindow replacing the browser’s message dispatcher. It is assumed
            that the browser has no need for CoreWindow’s dispatcher. The browser should call <c>CoSetMessageDispatcher</c> no sooner than
            its IViewProvider::Initialize, or, in the case of views that implement IInitializeWithWindowFactory, no sooner than after it has
            created a window on the thread.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.HStringMarshaler">
            <summary>Marshals HSTRING values.</summary>
            <seealso cref="T:System.Runtime.InteropServices.ICustomMarshaler"/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.GetInstance(System.String)">
            <summary>Gets the instance.</summary>
            <param name="cookie">The cookie.</param>
            <returns>A new instance of this class.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.CleanUpManagedData(System.Object)">
            <summary>Performs necessary cleanup of the managed data when it is no longer needed.</summary>
            <param name="ManagedObj">The managed object to be destroyed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.CleanUpNativeData(System.IntPtr)">
            <summary>Performs necessary cleanup of the unmanaged data when it is no longer needed.</summary>
            <param name="pNativeData">A pointer to the unmanaged data to be destroyed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.GetNativeDataSize">
            <summary>Returns the size of the native data to be marshaled.</summary>
            <returns>The size in bytes of the native data.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.MarshalManagedToNative(System.Object)">
            <summary>Converts the managed data to unmanaged data.</summary>
            <param name="ManagedObj">The managed object to be converted.</param>
            <returns>Returns the COM view of the managed object.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HStringMarshaler.MarshalNativeToManaged(System.IntPtr)">
            <summary>Converts the unmanaged data to managed data.</summary>
            <param name="pNativeData">A pointer to the unmanaged data to be wrapped.</param>
            <returns>Returns the managed view of the COM data.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInterceptor(System.Guid@,System.Object,System.Guid@,System.Object@)">
            <summary>
            Instantiates the appropriate interceptor for the specified interface to be intercepted and returns the newly created interceptor.
            </summary>
            <param name="iidIntercepted">A reference to the identifier of the interface for which an interceptor is to be returned.</param>
            <param name="punkOuter">
            If this parameter is <c>NULL</c>, the object is not being created as part of an aggregate. Otherwise, this parameter is a pointer
            to the aggregate object's IUnknown interface (the controlling <c>IUnknown</c>).
            </param>
            <param name="iid">A reference to the identifier of the interface desired on the interceptor.</param>
            <param name="ppv">
            The address of a pointer variable that receives the interface pointer requested in iid. Upon successful return, **ppv contains
            the requested interceptor pointer.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function returned successfully.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error occurred.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgConvertVariantToProperty(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt16,System.IntPtr,System.UInt32@,System.UInt32,System.Boolean,System.UInt32@)">
            <summary>
            The <c>StgConvertVariantToProperty</c> function converts a <c>PROPVARIANT</c> data type to a <c>SERIALIZEDPROPERTYVALUE</c> data type.
            </summary>
            <param name="pvar">A pointer to <c>PROPVARIANT</c>.</param>
            <param name="CodePage">A property set codepage.</param>
            <param name="pprop">Optional. A pointer to <c>SERIALIZEDPROPERTYVALUE</c>.</param>
            <param name="pcb">A pointer to the remaining stream length, updated to the actual property size on return.</param>
            <param name="pid">The propid (used if indirect).</param>
            <param name="fReserved">Reserver. The value must be <c>FALSE</c>.</param>
            <param name="pcIndirect">Optional. A pointer to the indirect property count.</param>
            <returns>Returns a pointer to <c>SERIALIZEDPROPERTYVALUE</c>.</returns>
            <remarks>
            This function converts a <c>PROPVARIANT</c> to a property. If the function fails it throws an exception that represents
            <c>STATUS_INVALID_PARAMETER NT_STATUS</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.StgPropertyLengthAsVariant(System.IntPtr,System.UInt32,System.UInt16,System.Byte)">
            <summary>
            The <c>StgPropertyLengthAsVariant</c> function examines a <c>SERIALIZEDPROPERTYVALUE</c> and returns the amount of memory that
            this property would occupy as a <c>PROPVARIANT</c>.
            </summary>
            <param name="pProp">A pointer to a <c>SERIALIZEDPROPERTYVALUE</c>.</param>
            <param name="cbProp">The size of the pProp buffer in bytes.</param>
            <param name="CodePage">A property set code page.</param>
            <param name="bReserved">Reserved. Must be 0.</param>
            <returns>Returns the amount of memory the property would occupy as a <c>PROPVARIANT</c>.</returns>
            <remarks>
            Use this function to decide whether or not to deserialize a property value in a low-memory scenario. Most applications will have
            no need to call this function.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.APTTYPE">
            <summary>Specifies different types of apartments.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPE.APTTYPE_CURRENT">
            <summary>The current thread.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPE.APTTYPE_STA">
            <summary>A single-threaded apartment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPE.APTTYPE_MTA">
            <summary>A multi-threaded apartment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPE.APTTYPE_NA">
            <summary>A neutral apartment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPE.APTTYPE_MAINSTA">
            <summary>The main single-threaded apartment.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER">
            <summary>Specifies the set of possible COM apartment type qualifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_NONE">
            <summary>No qualifier information for the current COM apartment type is available.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_IMPLICIT_MTA">
            <summary>
            This qualifier is only valid when the pAptType parameter of the CoGetApartmentType function specifies APTTYPE_MTA on return.
            A thread has an implicit MTA apartment type if it does not initialize the COM apartment itself, and if another thread has
            already initialized the MTA in the process. This qualifier informs the API caller that the MTA of the thread is implicitly
            inherited from other threads and is not initialized directly.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_MTA">
            <summary>
            This qualifier is only valid when the pAptType parameter of the CoGetApartmentType function contains APTTYPE_NA on return.
            When an MTA thread creates or invokes a COM in-process object using the "Neutral" threading model, the COM apartment type of
            the thread switches from MTA to a Neutral apartment type. This qualifier informs the API caller that the thread has switched
            from the MTA apartment type to the NA type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_STA">
            <summary>
            This qualifier is only valid when the pAptType parameter of the CoGetApartmentType function contains APTTYPE_NA on return.
            When an STA thread creates or invokes a COM in-process object using the "Neutral" threading model, the COM apartment type of
            the thread switches from STA to a Neutral apartment type. This qualifier informs the API caller that the thread has switched
            from the STA apartment type to the NA type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA">
            <summary>
            This qualifier is only valid when the pAptType parameter of the CoGetApartmentType function contains APTTYPE_NA on return.
            When an implicit MTA thread creates or invokes a COM in-process object using the "Neutral" threading model, the COM apartment
            type of the thread switches from the implicit MTA type to a Neutral apartment type. This qualifier informs the API caller
            that the thread has switched from the implicit MTA apartment type to the NA type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_MAINSTA">
            <summary>
            This qualifier is only valid when the pAptType parameter of the CoGetApartmentType function contains APTTYPE_NA on return.
            When the main STA thread creates or invokes a COM in-process object using the "Neutral" threading model, the COM apartment
            type of the thread switches from the main STA type to a Neutral apartment type. This qualifier informs the API caller that
            the thread has switched from the main STA apartment type to the NA type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_APPLICATION_STA">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.APTTYPEQUALIFIER.APTTYPEQUALIFIER_RESERVED_1">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CLSCTX">
            <summary>
            Values that are used in activation calls to indicate the execution contexts in which an object is to be run. These values are
            also used in calls to CoRegisterClassObject to indicate the set of execution contexts in which a class object is to be made
            available for requests to construct instances.
            </summary>
            <remarks>
            <para>
            Values from the <c>CLSCTX</c> enumeration are used in activation calls (CoCreateInstance, CoCreateInstanceEx, CoGetClassObject,
            and so on) to indicate the preferred execution contextsâ€”in-process, local, or remoteâ€”in which an object is to be run. They
            are also used in calls to CoRegisterClassObject to indicate the set of execution contexts in which a class object is to be made
            available for requests to construct instances ( <c>IClassFactory::CreateInstance</c>).
            </para>
            <para>
            To indicate that more than one context is acceptable, you can combine multiple values with Boolean ORs. The contexts are tried in
            the order in which they are listed.
            </para>
            <para>
            Given a set of <c>CLSCTX</c> flags, the execution context to be used depends on the availability of registered class codes and
            other parameters according to the following algorithm.
            </para>
            <list type="number">
            <item>
            <term>
            If the call specifies one of the following, CLSCTX_REMOTE_SERVER is implied and is added to the list of flags: The second case
            allows applications written prior to the release of distributed COM to be the configuration of classes for remote activation to
            be used by client applications available prior to DCOM and the CLSCTX_REMOTE_SERVER flag. The cases in which there would be no
            explicit COSERVERINFO structure are when the value is specified as <c>NULL</c> or when it is not one of the function parameters
            (as in calls to CoCreateInstance and CoGetClassObject).
            </term>
            </item>
            <item>
            <term>If the explicit COSERVERINFO parameter indicates the current computer, CLSCTX_REMOTE_SERVER is removed if present.</term>
            </item>
            </list>
            <para>The rest of the processing proceeds by looking at the value(s) in the following sequence:</para>
            <list type="number">
            <item>
            <term>
            If the flags include CLSCTX_REMOTE_SERVER and no COSERVERINFO parameter is specified and if the activation request indicates a
            persistent state from which to initialize the object (with CoGetInstanceFromFile, CoGetInstanceFromIStorage, or, for a file
            moniker, in a call to IMoniker::BindToObject) and the class has an ActivateAtStorage subkey or no class registry information
            whatsoever, the request to activate and initialize is forwarded to the computer where the persistent state resides. (Refer to the
            remote activation functions listed in the See Also section for details.)
            </term>
            </item>
            <item>
            <term>
            If the flags include CLSCTX_INPROC_SERVER, the class code in the DLL found under the class's InprocServer32 key is used if this
            key exists. The class code will run within the same process as the caller.
            </term>
            </item>
            <item>
            <term>
            If the flags include CLSCTX_INPROC_HANDLER, the class code in the DLL found under the class's InprocHandler32 key is used if this
            key exists. The class code will run within the same process as the caller.
            </term>
            </item>
            <item>
            <term>
            If the flags include CLSCTX_LOCAL_SERVER, the class code in the service found under the class's LocalService key is used if this
            key exists. If no service is specified but an EXE is specified under that same key, the class code associated with that EXE is
            used. The class code (in either case) will be run in a separate service process on the same computer as the caller.
            </term>
            </item>
            <item>
            <term>
            If the flag is set to CLSCTX_REMOTE_SERVER and an additional COSERVERINFO parameter to the function specifies a particular remote
            computer, a request to activate is forwarded to this remote computer with flags modified to set to CLSCTX_LOCAL_SERVER. The class
            code will run in its own process on this specific computer, which must be different from that of the caller.
            </term>
            </item>
            <item>
            <term>
            Finally, if the flags include CLSCTX_REMOTE_SERVER and no COSERVERINFO parameter is specified and if a computer name is given
            under the class's RemoteServerName named-value, the request to activate is forwarded to this remote computer with the flags
            modified to be set to CLSCTX_LOCAL_SERVER. The class code will run in its own process on this specific computer, which must be
            different from that of the caller.
            </term>
            </item>
            </list>
            <para>CLSCTX_ACTIVATE_32_BIT_SERVER and CLSCTX_ACTIVATE_64_BIT_SERVER</para>
            <para>
            The 64-bit versions of Windows introduce two new flags: CLSCTX_ACTIVATE_32_BIT_SERVER and CLSCTX_ACTIVATE_64_BIT_SERVER. On a
            64-bit computer, a 32-bit and 64-bit version of the same COM server may coexist. When a client requests an activation of an
            out-of-process server, these <c>CLSCTX</c> flags allow the client to specify a 32-bit or a 64-bit version of the server.
            </para>
            <para>
            Usually, a client will not care whether it uses a 32-bit or a 64-bit version of the server. However, if the server itself loads
            an additional in-process server, then it and the in-process server must both be either 32-bit or 64-bit. For example, suppose
            that the client wants to use a server "A", which in turn loads an in-process server "B". If only a 32-bit version of server "B"
            is available, then the client must specify the 32-bit version of server "A". If only a 64-bit version of server "B" is available,
            then the client must specify the 64-bit version of server "A".
            </para>
            <para>
            A server can specify its own architecture preference via the PreferredServerBitness registry key, but the client's preference,
            specified via a CLSCTX_ACTIVATE_32_BIT_SERVER or CLSCTX_ACTIVATE_64_BIT_SERVER flag, will override the server's preference. If
            the client does not specify a preference, then the server's preference will be used.
            </para>
            <para>If neither the client nor the server specifies a preference, then:</para>
            <list type="bullet">
            <item>
            <term>
            If the computer that hosts the server is running Windows Server 2003 with Service Pack 1 (SP1) or a later system, then COM will
            try to match the server architecture to the client architecture. In other words, for a 32-bit client, COM will activate a 32-bit
            server if available; otherwise it will activate a 64-bit version of the server. For a 64-bit client, COM will activate a 64-bit
            server if available; otherwise it will activate a 32-bit server.
            </term>
            </item>
            <item>
            <term>
            If the computer that hosts the server is running Windows XP or Windows Server 2003 without SP1 or later installed, then COM will
            prefer a 64-bit version of the server if available; otherwise it will activate a 32-bit version of the server.
            </term>
            </item>
            </list>
            <para>
            If a <c>CLSCTX</c> enumeration has both the CLSCTX_ACTIVATE_32_BIT_SERVER and CLSCTX_ACTIVATE_64_BIT_SERVER flags set, then it is
            invalid and the activation will return E_INVALIDARG.
            </para>
            <para>
            The following table shows the results of the various combinations of client architectures and client settings and server
            architectures and server settings.
            </para>
            <para>
            The flags CLSCTX_ACTIVATE_32_BIT_SERVER and CLSCTX_ACTIVATE_64_BIT_SERVER flow across computer boundaries. If the computer that
            hosts the server is running the 64-bit Windows, then it will honor these flags; otherwise it will ignore them.
            </para>
            <list type="table">
            <listheader>
            <term/>
            <term>32-bit client, no flag</term>
            <term>64-bit client, no flag</term>
            <term>32-bit client, 32-bit flag¹</term>
            <term>32-bit client, 64-bit flag²</term>
            <term>64-bit client, 32-bit flag¹</term>
            <term>64-bit client, 64-bit flag²</term>
            </listheader>
            <item>
            <term>32-bit server, match client registry value³</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            </item>
            <item>
            <term>32-bit server, 32-bit registry value⁴</term>
            <term>32-bit server</term>
            <term>32-bit server</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            </item>
            <item>
            <term>32-bit server, 64-bit registry value⁵</term>
            <term>See ⁸</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            </item>
            <item>
            <term>32-bit server, no registry value⁶</term>
            <term>32-bit server</term>
            <term>64/32⁹</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            </item>
            <item>
            <term>32-bit server, no registry value (before Windows Server 2003 with SP1)⁷</term>
            <term>64/32⁹</term>
            <term>64/32⁹</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            <term>32-bit server</term>
            <term>See ⁸</term>
            </item>
            <item>
            <term>64-bit server, match client registry value³</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            </item>
            <item>
            <term>64-bit server, 32-bit registry value⁴</term>
            <term>See ⁸</term>
            <term>See ⁸</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            </item>
            <item>
            <term>64-bit server, 64-bit registry value⁵</term>
            <term>64-bit server</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            </item>
            <item>
            <term>64-bit server, no registry value⁶</term>
            <term>32/64¹⁰</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            </item>
            <item>
            <term>64-bit server, no registry value (before Windows Server 2003 with SP1)⁷</term>
            <term>64-bit server</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            <term>See ⁸</term>
            <term>64-bit server</term>
            </item>
            </list>
            <para><c>PreferredServerBitness</c> PreferredServerBitness <c>PreferredServerBitness</c><c>PreferredServerBitness</c><c>PreferredServerBitness</c><c>PreferredServerBitness</c></para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_INPROC_SERVER">
            <summary>
            The code that creates and manages objects of this class is a DLL that runs in the same process as the caller of the function
            specifying the class context.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_INPROC_HANDLER">
            <summary>
            The code that manages objects of this class is an in-process handler. This is a DLL that runs in the client process and
            implements client-side structures of this class when instances of the class are accessed remotely.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_LOCAL_SERVER">
            <summary>
            The EXE code that creates and manages objects of this class runs on same machine but is loaded in a separate process space.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_INPROC_SERVER16">
            <summary>Obsolete.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_REMOTE_SERVER">
            <summary>
            A remote context. The LocalServer32 or LocalService code that creates and manages objects of this class is run on a different computer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_INPROC_HANDLER16">
            <summary>Obsolete.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED1">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED2">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED3">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED4">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_NO_CODE_DOWNLOAD">
            <summary>
            Disaables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_ENABLE_CODE_DOWNLOAD.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED5">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_NO_CUSTOM_MARSHAL">
            <summary>Specify if you want the activation to fail if it uses custom marshalling.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ENABLE_CODE_DOWNLOAD">
            <summary>
            Enables the downloading of code from the directory service or the Internet. This flag cannot be set at the same time as CLSCTX_NO_CODE_DOWNLOAD.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_NO_FAILURE_LOG">
            <summary>
            The CLSCTX_NO_FAILURE_LOG can be used to override the logging of failures in CoCreateInstanceEx. If the
            ActivationFailureLoggingLevel is created, the following values can determine the status of event logging:
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_DISABLE_AAA">
            <summary>
            Disables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the
            EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as
            CLSCTX_ENABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an
            activate-as-activator (AAA) activation. Disabling AAA activations allows an application that runs under a privileged account
            (such as LocalSystem) to help prevent its identity from being used to launch untrusted components. Library applications that
            use activation calls should always set this flag during those calls. This helps prevent the library application from being
            used in an escalation-of-privilege security attack. This is the only way to disable AAA activations in a library application
            because the EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration is applied only to the server process
            and not to the library application. Windows 2000: This flag is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ENABLE_AAA">
            <summary>
            Enables activate-as-activator (AAA) activations for this activation only. This flag overrides the setting of the
            EOAC_DISABLE_AAA flag from the EOLE_AUTHENTICATION_CAPABILITIES enumeration. This flag cannot be set at the same time as
            CLSCTX_DISABLE_AAA. Any activation where a server process would be launched under the caller's identity is known as an
            activate-as-activator (AAA) activation. Enabling this flag allows an application to transfer its identity to an activated
            component. Windows 2000: This flag is not supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_FROM_DEFAULT_CONTEXT">
            <summary>Begin this activation from the default context of the current apartment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ACTIVATE_X86_SERVER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ACTIVATE_32_BIT_SERVER">
            <summary>Activate or connect to a 32-bit version of the server; fail if one is not registered.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ACTIVATE_64_BIT_SERVER">
            <summary>Activate or connect to a 64 bit version of the server; fail if one is not registered.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ENABLE_CLOAKING">
            <summary>
            When this flag is specified, COM uses the impersonation token of the thread, if one is present, for the activation request
            made by the thread. When this flag is not specified or if the thread does not have an impersonation token, COM uses the
            process token of the thread's process for the activation request made by the thread. Windows Vista or later: This flag is supported.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_APPCONTAINER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ACTIVATE_AAA_AS_IU">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_RESERVED6">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ACTIVATE_ARM32_SERVER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_PS_DLL">
            <summary>Used for loading Proxy/Stub DLLs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_INPROC">
            <summary>Combination of CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_SERVER">
            <summary>Combination of CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLSCTX.CLSCTX_ALL">
            <summary>Combination of CLSCTX_SERVER | CLSCTX_INPROC_HANDLER.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.COINIT">
            <summary>
            Determines the concurrency model used for incoming calls to objects created by this thread. This concurrency model can be either
            apartment-threaded or multithreaded.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COINIT.COINIT_APARTMENTTHREADED">
            <summary>Initializes the thread for apartment-threaded object concurrency (see Remarks).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COINIT.COINIT_MULTITHREADED">
            <summary>Initializes the thread for multithreaded object concurrency (see Remarks).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COINIT.COINIT_DISABLE_OLE1DDE">
            <summary>Disables DDE for OLE1 support.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COINIT.COINIT_SPEED_OVER_MEMORY">
            <summary>Increase memory usage in an attempt to increase performance.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.COMSD">
            <summary>Determines the type of COM security descriptor to get when calling CoGetSystemSecurityPermissions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COMSD.SD_LAUNCHPERMISSIONS">
            <summary>Machine-wide launch permissions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COMSD.SD_ACCESSPERMISSIONS">
            <summary>Machine-wide access permissions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COMSD.SD_LAUNCHRESTRICTIONS">
            <summary>Machine-wide launch limits.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COMSD.SD_ACCESSRESTRICTIONS">
            <summary>Machine-wide access limits.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STGFMT">
            <summary>
            The STGFMT enumeration values specify the format of a storage object and are used in the StgCreateStorageEx and StgOpenStorageEx
            functions in the stgfmt parameter. This value, in combination with the value in the riid parameter, is used to determine the file
            format and the interface implementation to use.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGFMT.STGFMT_STORAGE">
            <summary>Indicates that the file must be a compound file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGFMT.STGFMT_NATIVE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGFMT.STGFMT_FILE">
            <summary>
            Indicates that the file must not be a compound file. This element is only valid when using the StgCreateStorageEx or
            StgOpenStorageEx functions to access the NTFS file system implementation of the IPropertySetStorage interface. Therefore,
            these functions return an error if the riid parameter does not specify the IPropertySetStorage interface, or if the specified
            file is not located on an NTFS file system volume.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGFMT.STGFMT_ANY">
            <summary>
            Indicates that the system will determine the file type and use the appropriate structured storage or property set
            implementation. This value cannot be used with the StgCreateStorageEx function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGFMT.STGFMT_DOCFILE">
            <summary>
            Indicates that the file must be a compound file, and is similar to the STGFMT_STORAGE flag, but indicates that the
            compound-file form of the compound-file implementation must be used. For more information, see Compound File Implementation Limits.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BindMoniker(System.Runtime.InteropServices.ComTypes.IMoniker,System.UInt32,System.Guid@,System.Object@)">
            <summary>
            Locates an object by means of its moniker, activates the object if it is inactive, and retrieves a pointer to the specified
            interface on that object.
            </summary>
            <param name="pmk">A pointer to the object's moniker. See IMoniker.</param>
            <param name="grfOpt">This parameter is reserved for future use and must be 0.</param>
            <param name="iidResult">The interface identifier to be used to communicate with the object.</param>
            <param name="ppvResult">
            The address of pointer variable that receives the interface pointer requested in iidResult. Upon successful return, *ppvResult
            contains the requested interface pointer. If an error occurs, *ppvResult is <c>NULL</c>. If the call is successful, the caller is
            responsible for releasing the pointer with a call to the object's IUnknown::Release method.
            </param>
            <returns>
            <para>
            This function can return the following error codes, or any of the error values returned by the IMoniker::BindToObject method.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was located and activated, if necessary, and a pointer to the requested interface was returned.</term>
            </item>
            <item>
            <term>MK_E_NOOBJECT</term>
            <term>The object that the moniker object identified could not be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>BindMoniker</c> is a helper function supplied as a convenient way for a client that has the moniker of an object to obtain a
            pointer to one of that object's interfaces. <c>BindMoniker</c> packages the following calls:
            </para>
            <para>
            CreateBindCtx creates a bind context object that supports the system implementation of IBindContext. The pmk parameter is
            actually a pointer to the IMoniker implementation on a moniker object. This implementation's BindToObject method supplies the
            pointer to the requested interface pointer.
            </para>
            <para>
            If you have several monikers to bind in quick succession and if you know that those monikers will activate the same object, it
            may be more efficient to call the IMoniker::BindToObject method directly, which enables you to use the same bind context object
            for all the monikers. See the IBindCtx interface for more information.
            </para>
            <para>
            Container applications that allow their documents to contain linked objects are a special client that generally does not make
            direct calls to IMoniker methods. Instead, the client manipulates the linked objects through the IOleLink interface. The default
            handler implements this interface and calls the appropriate <c>IMoniker</c> methods as needed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoAllowSetForegroundWindow(System.Object,System.IntPtr)">
            <summary>
            This function passes the foreground privilege (the privilege to set the foreground window) from one process to another. The
            process that has the foreground privilege can call this function to pass that privilege on to a local COM server process. Note
            that calling <c>CoAllowSetForegroundWindow</c> only confers the privilege; it does not set the foreground window itself.
            Foreground and focus are only taken away from the client application when the target COM server calls either SetForegroundWindow
            or another API that does so indirectly.
            </summary>
            <param name="pUnk">A pointer to the IUnknown interface on the proxy of the target COM server.</param>
            <param name="lpvReserved">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method was successful.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The lpvReserved parameter is not NULL.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The pUnk parameter does not support foreground window control.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The calling process does not currently possess the foreground privilege.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The system restricts which processes can call the SetForegroundWindow and AllowSetForegroundWindow functions to set the
            foreground window. As a result, an application is blocked from stealing the focus from another application even when the user is
            interacting with it. Use <c>CoAllowSetForegroundWindow</c> to pass on the foreground privilege from a process that has it to a
            process that does not yet have it. This can be done transitively: passing the privilege from one process to another, and then to
            another, and so on.
            </para>
            <para>
            <c>CoAllowSetForegroundWindow</c> enables a user that has a custom interface to get the same behavior that happens for OLE
            interfaces where a change of window is expected (primarily associated with linking and embedding).
            </para>
            <para>
            Behind the scenes, the IForegroundTransfer interface is used to yield the foreground window between processes. A standard
            COM-provided proxy already implements <c>IForegroundTransfer</c>, so you don't have to do any extra work if you're using a
            standard proxy. Just call <c>CoAllowSetForegroundWindow</c> to transfer the foreground privilege to any out-of-process COM object.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates how a client process can create a local COM server, call <c>CoAllowSetForegroundWindow</c> to
            transfer the foreground privilege, and then call a function on the COM server that in turn directly or indirectly calls SetForegroundWindow.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoDosDateTimeToFileTime(System.UInt16,System.UInt16,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            <para>Converts the MS-DOS representation of the time and date to a FILETIME structure used by Windows.</para>
            <para><c>Note</c> This function is provided for compatibility with 16-bit Windows.</para>
            </summary>
            <param name="nDosDate">The MS-DOS date.</param>
            <param name="nDosTime">The MS-DOS time.</param>
            <param name="lpFileTime">A pointer to the FILETIME structure.</param>
            <returns>
            If the function succeeds, the return value is <c>TRUE</c>; otherwise, it is <c>FALSE</c>, probably because of invalid arguments.
            </returns>
            <remarks>
            <para>An MS-DOS date has the following format.</para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0-4</term>
            <term>Days of the month (1-31).</term>
            </item>
            <item>
            <term>5-8</term>
            <term>Months (1 = January, 2 = February, and so forth).</term>
            </item>
            <item>
            <term>9-15</term>
            <term>Year offset from 1980 (add 1980 to get actual year).</term>
            </item>
            </list>
            <para>An MS-DOS time has the following format.</para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0-4</term>
            <term>Seconds divided by 2.</term>
            </item>
            <item>
            <term>5-10</term>
            <term>Minutes (0-59).</term>
            </item>
            <item>
            <term>11-15</term>
            <term>Hours (0-23 on a 24-hour clock).</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFileTimeToDosDateTime(System.Runtime.InteropServices.ComTypes.FILETIME@,System.UInt16@,System.UInt16@)">
            <summary>
            <para>Converts a FILETIME into MS-DOS date and time values.</para>
            <para><c>Note</c> This function is provided for compatibility with 16-bit Windows.</para>
            </summary>
            <param name="lpFileTime">A pointer to the FILETIME structure.</param>
            <param name="lpDosDate">Receives the MS-DOS date.</param>
            <param name="lpDosTime">Receives the MS-DOS time.</param>
            <returns>If the function succeeds, the return value is <c>TRUE</c>; otherwise, it is <c>FALSE</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFreeAllLibraries">
            <summary>
            Frees all the DLLs that have been loaded with the CoLoadLibrary function (called internally by CoGetClassObject), regardless of
            whether they are currently in use.
            </summary>
            <returns>This function does not return a value.</returns>
            <remarks>
            To unload libraries, <c>CoFreeAllLibraries</c> uses a list of loaded DLLs for each process that the COM library maintains. The
            CoUninitialize and OleUninitialize functions call <c>CoFreeAllLibraries</c> internally, so applications usually have no need to
            call this function directly.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoFreeLibrary(Vanara.PInvoke.HINSTANCE)">
            <summary>
            <para>Frees a library that, when loaded, was specified to be freed explicitly.</para>
            <para><c>Note</c> This function is provided for compatibility with 16-bit Windows.</para>
            </summary>
            <param name="hInst">A handle to the library module to be freed, as returned by the CoLoadLibrary function.</param>
            <returns>This function does not return a value.</returns>
            <remarks>
            The <c>CoFreeLibrary</c> function should be called to free a library that is to be freed explicitly. This is established when the
            library is loaded with the bAutoFree parameter of CoLoadLibrary set to <c>FALSE</c>. It is illegal to free a library explicitly
            when the corresponding <c>CoLoadLibrary</c> call specifies that it be freed automatically (the bAutoFree parameter is set to <c>TRUE</c>).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInstanceFromFile(Vanara.PInvoke.Ole32.COSERVERINFO,System.Guid@,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.STGM,System.String,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI[])">
            <summary>Creates a new object and initializes it from a file using IPersistFile::Load.</summary>
            <param name="pServerInfo">
            A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication
            setting to be used. This parameter can be <c>NULL</c>, in which case the object is instantiated on the current computer, at the
            computer specified under the RemoteServerName registry value for the class, or at the computer where the pwszName file resides if
            the ActivateAtStorage value is specified for the class or there is no local registry information.
            </param>
            <param name="pClsid">
            A pointer to the class identifier of the object to be created. This parameter can be <c>NULL</c>, in which case there is a call
            to GetClassFile, using pwszName as its parameter to get the class of the object to be instantiated.
            </param>
            <param name="punkOuter">
            When non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the
            pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </param>
            <param name="dwClsCtx">Values from the CLSCTX enumeration.</param>
            <param name="grfMode">Specifies how the file is to be opened. See STGM Constants.</param>
            <param name="pwszName">The file used to initialize the object with IPersistFile::Load. This parameter cannot be <c>NULL</c>.</param>
            <param name="dwCount">The number of structures in pResults. This parameter must be greater than 0.</param>
            <param name="pResults">
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function retrieved all of the interfaces successfully.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoGetInstanceFromFile</c> creates a new object and initializes it from a file using IPersistFile::Load. The result of this
            function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to
            <c>IPersistFile::Load</c>, with the following important distinctions:
            </para>
            <list type="bullet">
            <item>
            <term>Fewer network round trips are required by this function when instantiating an object on a remote computer.</term>
            </item>
            <item>
            <term>
            In the case where dwClsCtx is set to CLSCTX_REMOTE_SERVER and pServerInfo is <c>NULL</c>, if the class is registered with the
            ActivateAtStorage sub-key or has no associated registry information, this function will instantiate an object on the computer
            where pwszName resides, providing the least possible network traffic.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInstanceFromFile(Vanara.PInvoke.Ole32.COSERVERINFO,System.IntPtr,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.STGM,System.String,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI[])">
            <summary>Creates a new object and initializes it from a file using IPersistFile::Load.</summary>
            <param name="pServerInfo">
            A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication
            setting to be used. This parameter can be <c>NULL</c>, in which case the object is instantiated on the current computer, at the
            computer specified under the RemoteServerName registry value for the class, or at the computer where the pwszName file resides if
            the ActivateAtStorage value is specified for the class or there is no local registry information.
            </param>
            <param name="pClsid">
            A pointer to the class identifier of the object to be created. This parameter can be <c>NULL</c>, in which case there is a call
            to GetClassFile, using pwszName as its parameter to get the class of the object to be instantiated.
            </param>
            <param name="punkOuter">
            When non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the
            pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </param>
            <param name="dwClsCtx">Values from the CLSCTX enumeration.</param>
            <param name="grfMode">Specifies how the file is to be opened. See STGM Constants.</param>
            <param name="pwszName">The file used to initialize the object with IPersistFile::Load. This parameter cannot be <c>NULL</c>.</param>
            <param name="dwCount">The number of structures in pResults. This parameter must be greater than 0.</param>
            <param name="pResults">
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function retrieved all of the interfaces successfully.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoGetInstanceFromFile</c> creates a new object and initializes it from a file using IPersistFile::Load. The result of this
            function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to
            <c>IPersistFile::Load</c>, with the following important distinctions:
            </para>
            <list type="bullet">
            <item>
            <term>Fewer network round trips are required by this function when instantiating an object on a remote computer.</term>
            </item>
            <item>
            <term>
            In the case where dwClsCtx is set to CLSCTX_REMOTE_SERVER and pServerInfo is <c>NULL</c>, if the class is registered with the
            ActivateAtStorage sub-key or has no associated registry information, this function will instantiate an object on the computer
            where pwszName resides, providing the least possible network traffic.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInstanceFromIStorage(Vanara.PInvoke.Ole32.COSERVERINFO,System.Guid@,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.Ole32.IStorage,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI[])">
            <summary>Creates a new object and initializes it from a storage object through an internal call to IPersistFile::Load.</summary>
            <param name="pServerInfo">
            A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication
            setting to be used. This parameter can be <c>NULL</c>, in which case the object is instantiated on the current computer, at the
            computer specified under the RemoteServerName registry value for the class, or at the computer where the pstg storage object
            resides if the ActivateAtStorage value is specified for the class or there is no local registry information.
            </param>
            <param name="pClsid">
            A pointer to the class identifier of the object to be created. This parameter can be <c>NULL</c>, in which case there is a call
            to IStorage::Stat to find the class of the object.
            </param>
            <param name="punkOuter">
            When non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the
            pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </param>
            <param name="dwClsCtx">Values from the CLSCTX enumeration.</param>
            <param name="pstg">
            A pointer to the storage object used to initialize the object with IPersistFile::Load. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="dwCount">The number of structures in pResults. This parameter must be greater than 0.</param>
            <param name="pResults">
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function retrieved all of the interfaces successfully.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoGetInstanceFromIStorage</c> creates a new object and initializes it from a storage object using IPersistFile::Load. The
            result of this function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to
            <c>IPersistFile::Load</c>, with the following important distinctions:
            </para>
            <list type="bullet">
            <item>
            <term>Fewer network round trips are required by this function when instantiating an object on a remote computer.</term>
            </item>
            <item>
            <term>
            In the case where dwClsCtx is set to CLSCTX_REMOTE_SERVER and pServerInfo is <c>NULL</c>, if the class is registered with the
            ActivateAtStorage value or has no associated registry information, this function will instantiate an object on the computer where
            pstg resides, providing the least possible network traffic.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetInstanceFromIStorage(Vanara.PInvoke.Ole32.COSERVERINFO,System.IntPtr,System.Object,Vanara.PInvoke.Ole32.CLSCTX,Vanara.PInvoke.Ole32.IStorage,System.UInt32,Vanara.PInvoke.Ole32.MULTI_QI[])">
            <summary>Creates a new object and initializes it from a storage object through an internal call to IPersistFile::Load.</summary>
            <param name="pServerInfo">
            A pointer to a COSERVERINFO structure that specifies the computer on which to instantiate the object and the authentication
            setting to be used. This parameter can be <c>NULL</c>, in which case the object is instantiated on the current computer, at the
            computer specified under the RemoteServerName registry value for the class, or at the computer where the pstg storage object
            resides if the ActivateAtStorage value is specified for the class or there is no local registry information.
            </param>
            <param name="pClsid">
            A pointer to the class identifier of the object to be created. This parameter can be <c>NULL</c>, in which case there is a call
            to IStorage::Stat to find the class of the object.
            </param>
            <param name="punkOuter">
            When non- <c>NULL</c>, indicates the instance is being created as part of an aggregate, and punkOuter is to be used as the
            pointer to the new instance's controlling IUnknown. Aggregation is not supported cross-process or cross-computer. When
            instantiating an object out of process, CLASS_E_NOAGGREGATION will be returned if punkOuter is non- <c>NULL</c>.
            </param>
            <param name="dwClsCtx">Values from the CLSCTX enumeration.</param>
            <param name="pstg">
            A pointer to the storage object used to initialize the object with IPersistFile::Load. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="dwCount">The number of structures in pResults. This parameter must be greater than 0.</param>
            <param name="pResults">
            An array of MULTI_QI structures. Each structure has three members: the identifier for a requested interface ( <c>pIID</c>), the
            location to return the interface pointer ( <c>pItf</c>) and the return value of the call to QueryInterface ( <c>hr</c>).
            </param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function retrieved all of the interfaces successfully.</term>
            </item>
            <item>
            <term>CO_S_NOTALLINTERFACES</term>
            <term>
            At least one, but not all of the interfaces requested in the pResults array were successfully retrieved. The hr member of each of
            the MULTI_QI structures indicates with S_OK or E_NOINTERFACE whether the specific interface was returned.
            </term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>None of the interfaces requested in the pResults array were successfully retrieved.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CoGetInstanceFromIStorage</c> creates a new object and initializes it from a storage object using IPersistFile::Load. The
            result of this function is similar to creating an instance with a call to CoCreateInstanceEx, followed by an initializing call to
            <c>IPersistFile::Load</c>, with the following important distinctions:
            </para>
            <list type="bullet">
            <item>
            <term>Fewer network round trips are required by this function when instantiating an object on a remote computer.</term>
            </item>
            <item>
            <term>
            In the case where dwClsCtx is set to CLSCTX_REMOTE_SERVER and pServerInfo is <c>NULL</c>, if the class is registered with the
            ActivateAtStorage value or has no associated registry information, this function will instantiate an object on the computer where
            pstg resides, providing the least possible network traffic.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetObject(System.String,System.Runtime.InteropServices.ComTypes.BIND_OPTS@,System.Guid@,System.Object@)">
            <summary>
            Converts a display name into a moniker that identifies the object named, and then binds to the object identified by the moniker.
            </summary>
            <param name="pszName">The display name of the object to be created.</param>
            <param name="pBindOptions">
            The binding options used to create a moniker that creates the actual object. For details, see BIND_OPTS. This parameter can be <c>NULL</c>.
            </param>
            <param name="riid">A reference to the identifier of an interface that is implemented on the object to be created.</param>
            <param name="ppv">The address of a pointer to the interface specified by riid on the object that is created.</param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was created successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>The pszName parameter is not a properly formed display name.</term>
            </item>
            <item>
            <term>MK_E_NOOBJECT</term>
            <term>
            The object identified by this moniker, or some object identified by the composite moniker of which this moniker is a part, could
            not be found.
            </term>
            </item>
            <item>
            <term>MK_E_EXCEEDEDDEADLINE</term>
            <term>The binding operation could not be completed within the time limit specified by the BIND_OPTS structure passed in pBindOptions.</term>
            </item>
            <item>
            <term>MK_E_CONNECTMANUALLY</term>
            <term>
            The binding operation requires assistance from the end user. The most common reasons for returning this value are that a password
            is needed or that a floppy needs to be mounted.
            </term>
            </item>
            <item>
            <term>MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</term>
            <term>
            An intermediate object was found but it did not support an interface required to complete the binding operation. For example, an
            item moniker returns this value if its container does not support the IOleItemContainer interface.
            </term>
            </item>
            </list>
            </returns>
            <remarks><c>CoGetObject</c> encapsulates calls to the COM library functions CreateBindCtx, MkParseDisplayName, and IMoniker::BindToObject.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetObject(System.String,System.IntPtr,System.Guid@,System.Object@)">
            <summary>
            Converts a display name into a moniker that identifies the object named, and then binds to the object identified by the moniker.
            </summary>
            <param name="pszName">The display name of the object to be created.</param>
            <param name="pBindOptions">
            The binding options used to create a moniker that creates the actual object. For details, see BIND_OPTS. This parameter can be <c>NULL</c>.
            </param>
            <param name="riid">A reference to the identifier of an interface that is implemented on the object to be created.</param>
            <param name="ppv">The address of a pointer to the interface specified by riid on the object that is created.</param>
            <returns>
            <para>
            This function can return the standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was created successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>The pszName parameter is not a properly formed display name.</term>
            </item>
            <item>
            <term>MK_E_NOOBJECT</term>
            <term>
            The object identified by this moniker, or some object identified by the composite moniker of which this moniker is a part, could
            not be found.
            </term>
            </item>
            <item>
            <term>MK_E_EXCEEDEDDEADLINE</term>
            <term>The binding operation could not be completed within the time limit specified by the BIND_OPTS structure passed in pBindOptions.</term>
            </item>
            <item>
            <term>MK_E_CONNECTMANUALLY</term>
            <term>
            The binding operation requires assistance from the end user. The most common reasons for returning this value are that a password
            is needed or that a floppy needs to be mounted.
            </term>
            </item>
            <item>
            <term>MK_E_INTERMEDIATEINTERFACENOTSUPPORTED</term>
            <term>
            An intermediate object was found but it did not support an interface required to complete the binding operation. For example, an
            item moniker returns this value if its container does not support the IOleItemContainer interface.
            </term>
            </item>
            </list>
            </returns>
            <remarks><c>CoGetObject</c> encapsulates calls to the COM library functions CreateBindCtx, MkParseDisplayName, and IMoniker::BindToObject.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoGetSystemSecurityPermissions(Vanara.PInvoke.Ole32.COMSD,Vanara.PInvoke.AdvApi32.SafePSECURITY_DESCRIPTOR@)">
            <summary>
            Returns the default values of the Security Descriptors of the machine-wide launch and access permissions, as well as launch and
            access limits.
            </summary>
            <param name="comSDType">
            A value from the COMSD enumeration. Specifies the type of the requested system security permissions, such as launch permissions,
            access permissions, launch restrictions, and access restrictions.
            </param>
            <param name="ppSD">
            Pointer to a caller-supplied variable that this routine sets to the address of a buffer containing the SECURITY_DESCRIPTOR for
            the system security permissions. Memory will be allocated by <c>CoGetSystemSecurityPermissions</c> and should be freed by caller
            with LocalFree.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>Invalid parameter comSDType or ppSD.</term>
            </item>
            <item>
            <term>E_FAIL</term>
            <term>No connection to the resolver process.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Not enough memory for the security descriptor's allocation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoInitialize(System.IntPtr)">
            <summary>
            <para>Initializes the COM library on the current thread and identifies the concurrency model as single-thread apartment (STA).</para>
            <para>New applications should call CoInitializeEx instead of CoInitialize.</para>
            <para>If you want to use the Windows Runtime, you must call Windows::Foundation::Initialize instead.</para>
            </summary>
            <param name="pvReserved">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The COM library was initialized successfully on this thread.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The COM library is already initialized on this thread.</term>
            </item>
            <item>
            <term>RPC_E_CHANGED_MODE</term>
            <term>
            A previous call to CoInitializeEx specified the concurrency model for this thread as multithread apartment (MTA). This could also
            indicate that a change from neutral-threaded apartment to single-threaded apartment has occurred.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You need to initialize the COM library on a thread before you call any of the library functions except CoGetMalloc, to get a
            pointer to the standard allocator, and the memory allocation functions.
            </para>
            <para>
            After the concurrency model for a thread is set, it cannot be changed. A call to <c>CoInitialize</c> on an apartment that was
            previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE.
            </para>
            <para>
            CoInitializeEx provides the same functionality as <c>CoInitialize</c> and also provides a parameter to explicitly specify the
            thread's concurrency model. <c>CoInitialize</c> calls <c>CoInitializeEx</c> and specifies the concurrency model as single-thread
            apartment. Applications developed today should call <c>CoInitializeEx</c> rather than <c>CoInitialize</c>.
            </para>
            <para>
            Typically, the COM library is initialized on a thread only once. Subsequent calls to <c>CoInitialize</c> or CoInitializeEx on the
            same thread will succeed, as long as they do not attempt to change the concurrency model, but will return S_FALSE. To close the
            COM library gracefully, each successful call to <c>CoInitialize</c> or <c>CoInitializeEx</c>, including those that return
            S_FALSE, must be balanced by a corresponding call to CoUninitialize. However, the first thread in the application that calls
            <c>CoInitialize</c> with 0 (or <c>CoInitializeEx</c> with COINIT_APARTMENTTHREADED) must be the last thread to call
            <c>CoUninitialize</c>. Otherwise, subsequent calls to <c>CoInitialize</c> on the STA will fail and the application will not work.
            </para>
            <para>
            Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <c>CoInitialize</c>,
            CoInitializeEx, or CoUninitialize from the DllMain function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoInitializeEx(System.IntPtr,Vanara.PInvoke.Ole32.COINIT)">
            <summary>
            Initializes the COM library for use by the calling thread, sets the thread's concurrency model, and creates a new apartment for
            the thread if one is required.
            <para>
            You should call Windows::Foundation::Initialize to initialize the thread instead of CoInitializeEx if you want to use the Windows
            Runtime APIs or if you want to use both COM and Windows Runtime components. Windows::Foundation::Initialize is sufficient to use
            for COM components.
            </para>
            </summary>
            <param name="pvReserved">This parameter is reserved and must be NULL.</param>
            <param name="coInit">
            The concurrency model and initialization options for the thread. Values for this parameter are taken from the COINIT enumeration.
            Any combination of values from COINIT can be used, except that the COINIT_APARTMENTTHREADED and COINIT_MULTITHREADED flags cannot
            both be set. The default is COINIT_MULTITHREADED.
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <defintion>The COM library was initialized successfully on this thread.</defintion>
            </item>
            <item>
            <term>S_FALSE</term>
            <defintion>The COM library is already initialized on this thread.</defintion>
            </item>
            <item>
            <term>RPC_E_CHANGED_MODE</term>
            <defintion>A previous call to CoInitializeEx specified the concurrency model for this thread as multithreaded apartment (MTA).
            This could also indicate that a change from neutral-threaded apartment to single-threaded apartment has occurred.</defintion>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoInitializeSecurity(System.IntPtr,System.Int32,Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE[],System.IntPtr,Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL,Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL,Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_LIST@,Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES,System.IntPtr)">
            <summary>Registers security and sets the default security values for the process.</summary>
            <param name="pSecDesc">
            The access permissions that a server will use to receive calls. This parameter is used by COM only when a server calls
            <c>CoInitializeSecurity</c>. Its value is a pointer to one of three types: an AppID, an <c>IAccessControl</c> object, or a
            <c>SECURITY_DESCRIPTOR</c>, in absolute format. See the Remarks section for more information.
            </param>
            <param name="cAuthSvc">
            The count of entries in the asAuthSvc parameter. This parameter is used by COM only when a server calls
            <c>CoInitializeSecurity</c>. If this parameter is 0, no authentication services will be registered and the server cannot receive
            secure calls. A value of -1 tells COM to choose which authentication services to register, and if this is the case, the asAuthSvc
            parameter must be <c>NULL</c>. However, Schannel will never be chosen as an authentication service by the server if this
            parameter is -1.
            </param>
            <param name="asAuthSvc">
            An array of authentication services that a server is willing to use to receive a call. This parameter is used by COM only when a
            server calls <c>CoInitializeSecurity</c>. For more information, see <c>SOLE_AUTHENTICATION_SERVICE</c>.
            </param>
            <param name="pReserved1">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="dwAuthnLevel">
            The default authentication level for the process. Both servers and clients use this parameter when they call
            <c>CoInitializeSecurity</c>. COM will fail calls that arrive with a lower authentication level. By default, all proxies will use
            at least this authentication level. This value should contain one of the authentication level constants. By default, all calls to
            <c>IUnknown</c> are made at this level.
            </param>
            <param name="dwImpLevel">
            <para>
            The default impersonation level for proxies. The value of this parameter is used only when the process is a client. It should be
            a value from the impersonation level constants, except for RPC_C_IMP_LEVEL_DEFAULT, which is not for use with <c>CoInitializeSecurity</c>.
            </para>
            <para>
            Outgoing calls from the client always use the impersonation level as specified. (It is not negotiated.) Incoming calls to the
            client can be at any impersonation level. By default, all <c>IUnknown</c> calls are made with this impersonation level, so even
            security-aware applications should set this level carefully. To determine which impersonation levels each authentication service
            supports, see the description of the authentication services in COM and Security Packages. For more information about
            impersonation levels, see Impersonation.
            </para>
            </param>
            <param name="pAuthList">
            A pointer to <c>SOLE_AUTHENTICATION_LIST</c>, which is an array of <c>SOLE_AUTHENTICATION_INFO</c> structures. This list
            indicates the information for each authentication service that a client can use to call a server. This parameter is used by COM
            only when a client calls <c>CoInitializeSecurity</c>.
            </param>
            <param name="dwCapabilities">
            Additional capabilities of the client or server, specified by setting one or more <c>EOLE_AUTHENTICATION_CAPABILITIES</c> values.
            Some of these value cannot be used simultaneously, and some cannot be set when particular authentication services are being used.
            For more information about these flags, see the Remarks section.
            </param>
            <param name="pReserved3">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates success.</term>
            </item>
            <item>
            <term>RPC_E_TOO_LATE</term>
            <term>CoInitializeSecurity has already been called.</term>
            </item>
            <item>
            <term>RPC_E_NO_GOOD_SECURITY_PACKAGES</term>
            <term>
            The asAuthSvc parameter was not NULL, and none of the authentication services in the list could be registered. Check the results
            saved in asAuthSvc for authentication service–specific error codes.
            </term>
            </item>
            <item>
            <term>E_OUT_OF_MEMORY</term>
            <term>Out of memory.</term>
            </item>
            </list>
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoIsOle1Class(System.Guid@)">
            <summary>Determines whether the specified CLSID represents an OLE 1 object.</summary>
            <param name="rclsid">The CLSID to be checked.</param>
            <returns>If the CLSID refers to an OLE 1 object, the return value is <c>TRUE</c>; otherwise, it is <c>FALSE</c>.</returns>
            <remarks>
            <para>
            The <c>CoIsOle1Class</c> function determines whether an object class is from OLE 1. You can use it to prevent linking to embedded
            OLE 1 objects within a container, which OLE 1 objects do not support. After a container has determined that copied data
            represents an embedded object, the container code can call <c>CoIsOle1Class</c> to determine whether the embedded object is an
            OLE 1 object. If <c>CoIsOle1Class</c> returns <c>TRUE</c>, the container does not offer CF_LINKSOURCE as one of its clipboard
            formats. This is one of several OLE compatibility functions. The following compatibility functions, listed below, can be used to
            convert the storage formats of objects between OLE 1 and OLE.
            </para>
            <list type="bullet">
            <item>
            <term>OleConvertIStorageToOLESTREAM</term>
            </item>
            <item>
            <term>OleConvertIStorageToOLESTREAMEx</term>
            </item>
            <item>
            <term>OleConvertOLESTREAMToIStorage</term>
            </item>
            <item>
            <term>OleConvertOLESTREAMToIStorageEx</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoLoadLibrary(System.String,System.Boolean)">
            <summary>
            <para>Loads a specific DLL into the caller's process.</para>
            <para><c>CoLoadLibrary</c> is equivalent to LoadLibraryEx. <c>CoLoadLibrary</c> does not affect the lifetime of the library.</para>
            </summary>
            <param name="lpszLibName">The name of the library to be loaded.</param>
            <param name="bAutoFree">This parameter is maintained for compatibility with 16-bit applications, but is ignored.</param>
            <returns>If the function succeeds, the return value is a handle to the loaded library; otherwise, it is <c>NULL</c>.</returns>
            <remarks>
            <para>
            The CoGetClassObject function does not call <c>CoLoadLibrary</c>. <c>CoLoadLibrary</c> loads a DLL specified by the lpszLibName
            parameter into the process that called <c>CoGetClassObject</c>. Containers should not call <c>CoLoadLibrary</c> directly.
            </para>
            <para>
            Internally, a reference count is kept on the loaded DLL by using <c>CoLoadLibrary</c> to increment the count and the
            CoFreeLibrary function to decrement it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterChannelHook(System.Guid@,Vanara.PInvoke.Ole32.IChannelHook)">
            <summary>Registers a channel hook.</summary>
            <param name="ExtensionUuid">The extension to register.</param>
            <param name="pChannelHook">The channel hook to register.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterInitializeSpy(Vanara.PInvoke.Ole32.IInitializeSpy,System.UInt64@)">
            <summary>
            Registers an implementation of the IInitializeSpy interface. The <c>IInitializeSpy</c> interface is defied to allow developers to
            perform initialization and cleanup on COM apartments.
            </summary>
            <param name="pSpy">A pointer to an instance of the IInitializeSpy implementation.</param>
            <param name="puliCookie">The address at which to store a cookie that identifies this registration.</param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was successfully registered.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support IInitializeSpy.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoRegisterInitializeSpy</c> function registers an implementation of the IInitializeSpy interface, which defines methods to
            be called when CoInitializeEx (or CoInitialize) or CoUninitialize is invoked.
            </para>
            <para>
            <c>CoRegisterInitializeSpy</c> calls QueryInterface for IID_InitializeSpy on pSpy. It stores the address of the returned
            interface pointer in thread-specific storage that is independent of the COM initialization state for this thread. On success, it
            stores in puliCookie a ULARGE_INTEGER cookie that represents this registration. Pass this cookie to CoRevokeInitializeSpy to
            revoke the registration.
            </para>
            <para>
            IInitializeSpy implementations must deal with nesting issues caused by calling CoInitializeEx or CoUninitialize from within a
            notification method. Notifications occur only after the registration happens on this thread. For example, if
            <c>CoInitializeEx</c> is called before <c>CoRegisterInitializeSpy</c>, then the PreInitialize and PostInitialize notification
            methods will not be called.
            </para>
            <para>
            Notification methods must not cause the failure of CoInitializeEx or CoUninitialize by throwing exceptions. Implementations of
            IInitializeSpy must not propagate exceptions to code that calls <c>CoInitializeEx</c> or <c>CoUninitialize</c>.
            </para>
            <para>
            It is unpredictable whether a call to <c>CoRegisterInitializeSpy</c> from within an IInitializeSpy method call will be effective
            during the current top-level (non-nested) call to CoInitializeEx or CoUninitialize. A registered implementation of
            <c>IInitializeSpy</c> will always be effective for future top-level calls to <c>CoInitializeEx</c> or <c>CoUninitialize</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterMallocSpy(Vanara.PInvoke.Ole32.IMallocSpy)">
            <summary>
            Registers an implementation of the IMallocSpy interface, thereafter requiring OLE to call its wrapper methods around every call
            to the corresponding IMalloc method.
            </summary>
            <param name="pMallocSpy">A pointer to an instance of the IMallocSpy implementation.</param>
            <returns>
            <para>This function can return the standard return value E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was successfully registered.</term>
            </item>
            <item>
            <term>CO_E_OBJISREG</term>
            <term>The object is already registered.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>CoRegisterMallocSpy</c> function registers the IMallocSpy object, which is used to debug calls to IMalloc methods. The
            function calls QueryInterface on the pointer pMallocSpy for the interface IID_IMallocSpy. This is to ensure that pMallocSpy
            really points to an implementation of <c>IMallocSpy</c>. By the rules of OLE, it is expected that a successful call to
            <c>QueryInterface</c> has added a reference (through the AddRef method) to the <c>IMallocSpy</c> object. That is,
            <c>CoRegisterMallocSpy</c> does not directly call <c>AddRef</c> on pMallocSpy, but fully expects that the <c>QueryInterface</c>
            call will.
            </para>
            <para>
            When the IMallocSpy object is registered, whenever there is a call to one of the IMalloc methods, OLE first calls the
            corresponding <c>IMallocSpy</c> pre-method. Then, after executing the <c>IMalloc</c> method, OLE calls the corresponding
            <c>IMallocSpy</c> post-method. For example, whenever there is a call to IMalloc::Alloc, from whatever source, OLE calls
            IMallocSpy::PreAlloc, calls <c>Alloc</c>, and after that allocation is completed, calls IMallocSpy::PostAlloc.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRegisterMessageFilter(Vanara.PInvoke.Ole32.IMessageFilter,Vanara.PInvoke.Ole32.IMessageFilter@)">
            <summary>
            Registers with OLE the instance of an IMessageFilter interface, which is to be used for handling concurrency issues on the
            current thread. Only one message filter can be registered for each thread. Threads in multithreaded apartments cannot have
            message filters.
            </summary>
            <param name="lpMessageFilter">
            <para>
            A pointer to the IMessageFilter interface on the message filter. This message filter should be registered on the current thread,
            replacing the previous message filter (if any). This parameter can be <c>NULL</c>, indicating that no message filter should be
            registered on the current thread.
            </para>
            <para>Note that this function calls AddRef on the interface pointer to the message filter.</para>
            </param>
            <param name="lplpMessageFilter">
            Address of the IMessageFilter* pointer variable that receives the interface pointer to the previously registered message filter.
            If there was no previously registered message filter for the current thread, the value of *lplpMessageFilter is <c>NULL</c>.
            </param>
            <returns>If the instance was registered or revoked successfully, the return value is S_OK; otherwise, it is S_FALSE.</returns>
            <remarks>
            To revoke the registered message filter, pass the previous message filter (possibly <c>NULL</c>) as the lpMessageFilter parameter
            to <c>CoRegisterMessageFilter</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRevokeInitializeSpy(System.UInt64)">
            <summary>Revokes a registered implementation of the IInitializeSpy interface.</summary>
            <param name="uliCookie">A ULARGE_INTEGER cookie identifying the registration.</param>
            <returns>This function can return the standard return value E_INVALIDARG, as well as S_OK to indicate success.</returns>
            <remarks>
            <para>
            <c>CoRevokeInitializeSpy</c> can only revoke cookies issued by previous calls to CoRegisterInitializeSpy that were executed on
            the current thread. Using a cookie from another thread, or one that corresponds to an already revoked registration, will return E_INVALIDARG.
            </para>
            <para>
            It is unpredictable whether a call to <c>CoRevokeInitializeSpy</c> from within an IInitializeSpy method call will have an effect
            during the current top-level (non-nested) call to CoInitializeEx or CoUninitialize. The revocation will always have an effect
            after the current top-level call to <c>CoInitializeEx</c> or <c>CoUninitialize</c> returns.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoRevokeMallocSpy">
            <summary>Revokes a registered IMallocSpy object.</summary>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was revoked successfully.</term>
            </item>
            <item>
            <term>CO_E_OBJNOTREG</term>
            <term>No spy is currently registered.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>A spy is registered but there are outstanding allocations (not yet freed) made while this spy was active.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The IMallocSpy object is released when it is revoked. This release corresponds to the call to IUnknown::AddRef in the
            implementation of the QueryInterface function by the CoRegisterMallocSpy function. The implementation of the <c>IMallocSpy</c>
            interface should then do any appropriate cleanup.
            </para>
            <para>
            If the return code is E_ACCESSDENIED, there are still outstanding allocations that were made while the spy was active. In this
            case, the registered spy cannot be revoked at this time because it may have attached arbitrary headers and/or trailers to these
            allocations that only the spy knows about. Only the spy's PreFree (or PreRealloc) method knows how to account for these headers
            and trailers. Before returning E_ACCESSDENIED, <c>CoRevokeMallocSpy</c> notes internally that a revoke is pending. When the
            outstanding allocations have been freed, the revoke proceeds automatically, releasing the IMallocSpy object. Thus, it is
            necessary to call <c>CoRevokeMallocSpy</c> only once for each call to CoRegisterMallocSpy, even if E_ACCESSDENIED is returned.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoTreatAsClass(System.Guid@,System.Guid@)">
            <summary>Establishes or removes an emulation, in which objects of one class are treated as objects of a different class.</summary>
            <param name="clsidOld">The CLSID of the object to be emulated.</param>
            <param name="clsidNew">
            The CLSID of the object that should emulate the original object. This replaces any existing emulation for clsidOld. This
            parameter can be CLSID_NULL, in which case any existing emulation for clsidOld is removed.
            </param>
            <returns>
            <para>This function can return the standard return values E_INVALIDARG, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The emulation was successfully established or removed.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>The clsidOld parameter is not properly registered in the registration database.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>Error reading from registration database.</term>
            </item>
            <item>
            <term>REGDB_E_WRITEREGDB</term>
            <term>Error writing to registration database.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function sets the <c>TreatAs</c> entry in the registry for the specified object, allowing the object to be emulated by
            another application. Emulation allows an application to open and edit an object of a different format, while retaining the
            original format of the object. After this entry is set, whenever any function such as CoGetClassObject specifies the object's
            original CLSID (clsidOld), it is transparently forwarded to the new CLSID (clsidNew), thus launching the application associated
            with the <c>TreatAs</c> CLSID. When the object is saved, it can be saved in its native format, which may result in loss of edits
            not supported by the original format.
            </para>
            <para>If your application supports emulation, call <c>CoTreatAsClass</c> in the following situations:</para>
            <list type="bullet">
            <item>
            <term>
            In response to an end-user request (through a conversion dialog box) that a specified object be treated as an object of a
            different class (an object created under one application be run under another application, while retaining the original format information).
            </term>
            </item>
            <item>
            <term>In a setup program, to register that one class of objects be treated as objects of a different class.</term>
            </item>
            </list>
            <para>
            An example of the first case is that an end user might wish to edit a spreadsheet created by one application using a different
            application that can read and write the spreadsheet format of the original application. For an application that supports
            emulation, <c>CoTreatAsClass</c> can be called to implement a <c>Treat As</c> option in a conversion dialog box.
            </para>
            <para>
            An example of the use of <c>CoTreatAsClass</c> in a setup program would be in an updated version of an application. When the
            application is updated, the objects created with the earlier version can be activated and treated as objects of the new version,
            while retaining the previous format information. This would allow you to give the user the option to convert when they save, or
            to save it in the previous format, possibly losing format information not available in the older version.
            </para>
            <para>
            One result of setting an emulation is that when you enumerate verbs, as in the IOleObject::EnumVerbs method implementation in the
            default handler, this would enumerate the verbs from clsidNew instead of clsidOld.
            </para>
            <para>
            To ensure that existing emulation information is removed when you install an application, your setup programs should call
            <c>CoTreatAsClass</c>, setting the clsidNew parameter to CLSID_NULL to remove any existing emulation for the classes they install.
            </para>
            <para>
            If there is no CLSID assigned to the <c>AutoTreatAs</c> key in the registry, setting clsidNew and clsidOld to the same value
            removes the <c>TreatAs</c> entry, so there is no emulation. If there is a CLSID assigned to the <c>AutoTreatAs</c> key, that
            CLSID is assigned to the <c>TreatAs</c> key.
            </para>
            <para><c>CoTreatAsClass</c> does not validate whether an appropriate registry entry for clsidNew currently exists.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CoUninitialize">
            <summary>
            Closes the COM library on the current thread, unloads all DLLs loaded by the thread, frees any other resources that the thread
            maintains, and forces all RPC connections on the thread to close.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateAntiMoniker(System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates and returns a new anti-moniker.</summary>
            <param name="ppmk">
            The address of an IMoniker* pointer variable that receives the interface pointer to the new anti-moniker. When successful, the
            function has called AddRef on the anti-moniker and the caller is responsible for calling Release. When an error occurs, the
            anti-moniker pointer is <c>NULL</c>.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            You would call this function only if you are writing your own moniker class (implementing the IMoniker interface). If you are
            writing a new moniker class that has no internal structure, you can use <c>CreateAntiMoniker</c> in your implementation of the
            IMoniker::Inverse method, and then check for an anti-moniker in your implementation of IMoniker::ComposeWith.
            </para>
            <para>
            Like the ".." directory, which acts as the inverse to any directory name just preceding it in a path, an anti-moniker acts as the
            inverse of a simple moniker that precedes it in a composite moniker. An anti-moniker is used as the inverse of simple monikers
            with no internal structure. For example, the system-provided implementations of file monikers, item monikers, and pointer
            monikers all use anti-monikers as their inverse; consequently, an anti-moniker composed to the right of one of these monikers
            composes to nothing.
            </para>
            <para>
            A moniker client (an object that is using a moniker to bind to another object) typically does not know the class of a given
            moniker, so the client cannot be sure that an anti-moniker is the inverse. Therefore, to get the inverse of a moniker, you would
            call IMoniker::Inverse rather than <c>CreateAntiMoniker</c>.
            </para>
            <para>To remove the last piece of a composite moniker, you would do the following:</para>
            <list type="number">
            <item>
            <term>
            Call IMoniker::Enum on the composite, specifying <c>FALSE</c> as the first parameter. This creates an enumerator that returns the
            component monikers in reverse order.
            </term>
            </item>
            <item>
            <term>Use the enumerator to retrieve the last piece of the composite.</term>
            </item>
            <item>
            <term>Call IMoniker::Inverse on that moniker. The moniker returned by <c>Inverse</c> will remove the last piece of the composite.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateBindCtx(System.UInt32,System.Runtime.InteropServices.ComTypes.IBindCtx@)">
            <summary>
            Returns a pointer to an implementation of IBindCtx (a bind context object). This object stores information about a particular
            moniker-binding operation.
            </summary>
            <param name="reserved">This parameter is reserved and must be 0.</param>
            <param name="ppbc">
            Address of an IBindCtx* pointer variable that receives the interface pointer to the new bind context object. When the function is
            successful, the caller is responsible for calling Release on the bind context. A NULL value for the bind context indicates that
            an error occurred.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateClassMoniker(System.Guid@,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates a class moniker that refers to the specified class.</summary>
            <param name="rclsid">A reference to the CLSID of the object type to which this moniker binds.</param>
            <param name="ppmk">
            The address of an IMoniker* pointer variable that receives the interface pointer to the new class moniker. On successful return,
            the function has called AddRef on the moniker and the caller is responsible for calling Release. When an error occurs, the value
            of the moniker pointer is <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The moniker has been created successfully.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more arguments are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>The class moniker will support the binding to a fresh instance of the class identified by the CLSID in rclsid.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateDataCache(System.Object,System.Guid@,System.Guid@,System.Object@)">
            <summary>Retrieves a pointer to a new instance of an OLE-provided implementation of a data cache.</summary>
            <param name="pUnkOuter">
            If the cache is to be created as part of an aggregate, pointer to the controlling IUnknown of the aggregate. If not, the
            parameter should be <c>NULL</c>.
            </param>
            <param name="rclsid">CLSID used to generate icon labels. This value is typically CLSID_NULL.</param>
            <param name="iid">
            Reference to the identifier of the interface the caller wants to use to communicate with the cache. This value is typically
            IID_IOleCache (defined in the OLE headers to equal the interface identifier for IOleCache).
            </param>
            <param name="ppv">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer to the supplied cache object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The interface represented by riid is not supported by the object. The parameter ppvObj is set to NULL.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The cache object created by <c>CreateDataCache</c> supports the IOleCache, IOleCache2, and IOleCacheControl interfaces for
            controlling the cache. It also supports the IPersistStorage, IDataObject (without advise sinks), IViewObject, and IViewObject2 interfaces.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateFileMoniker(System.String,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates a file moniker based on the specified path.</summary>
            <param name="lpszPathName">
            <para>The path on which this moniker is to be based.</para>
            <para>
            This parameter can specify a relative path, a UNC path, or a drive-letter-based path. If based on a relative path, the resulting
            moniker must be composed onto another file moniker before it can be bound.
            </para>
            </param>
            <param name="ppmk">
            The address of an IMoniker* pointer variable that receives the interface pointer to the new file moniker. When successful, the
            function has called AddRef on the file moniker and the caller is responsible for calling Release. When an error occurs, the value
            of the interface pointer is <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The moniker was created successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>There was an error in the syntax of the path.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CreateFileMoniker</c> creates a moniker for an object that is stored in a file. A moniker provider (an object that provides
            monikers to other objects) can call this function to create a moniker to identify a file-based object that it controls, and can
            then make the pointer to this moniker available to other objects. An object identified by a file moniker must also implement the
            IPersistFile interface so it can be loaded when a file moniker is bound.
            </para>
            <para>
            When each object resides in its own file, as in an OLE server application that supports linking only to file-based documents in
            their entirety, file monikers are the only type of moniker necessary. To identify objects smaller than a file, the moniker
            provider must use another type of moniker (such as an item moniker) in addition to file monikers, creating a composite moniker.
            Composite monikers would be needed in an OLE server application that supports linking to objects smaller than a document (such as
            sections of a document or embedded objects).
            </para>
            <para>
            A file moniker can be composed to the right only of another file moniker when the first moniker is based on an absolute path and
            the other is a relative path, resulting in a single file moniker based on the combination of the two paths. A moniker composed to
            the right of another moniker must be a refinement of that moniker, and the file moniker represents the largest unit of storage.
            To identify objects stored within a file, you would compose other types of monikers (usually item monikers) to the right of a
            file moniker.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateGenericComposite(System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Performs a generic composition of two monikers and supplies a pointer to the resulting composite moniker.</summary>
            <param name="pmkFirst">
            A pointer to the moniker to be composed to the left of the moniker that pmkRest points to. Can point to any kind of moniker,
            including a generic composite.
            </param>
            <param name="pmkRest">
            A pointer to the moniker to be composed to the right of the moniker to which pmkFirst points. Can point to any kind of moniker
            compatible with the type of the pmkRest moniker, including a generic composite.
            </param>
            <param name="ppmkComposite">
            The address of an IMoniker* pointer variable that receives the interface pointer to the composite moniker object that is the
            result of composing pmkFirst and pmkRest. This object supports the OLE composite moniker implementation of <c>IMoniker</c>. When
            successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If either pmkFirst
            or pmkRest are <c>NULL</c>, the supplied pointer is the one that is non- <c>NULL</c>. If both pmkFirst and pmkRest are
            <c>NULL</c>, or if an error occurs, the returned pointer is <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The input monikers were composed successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>
            The two monikers could not be composed due to an error in the syntax of a path (for example, if both pmkFirst and pmkRest are
            file monikers based on absolute paths).
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>CreateGenericComposite</c> joins two monikers into one. The moniker classes being joined can be different, subject only to the
            rules of composition. Call this function only if you are writing a new moniker class by implementing the IMoniker interface,
            within an implementation of IMoniker::ComposeWith that includes generic composition capability.
            </para>
            <para>
            Moniker providers should call ComposeWith to compose two monikers together. Implementations of <c>ComposeWith</c> should (as do
            OLE implementations) attempt, when reasonable for the class, to perform non-generic compositions first, in which two monikers of
            the same class are combined. If this is not possible, the implementation can call <c>CreateGenericComposite</c> to do a generic
            composition, which combines two monikers of different classes, within the rules of composition. You can define new types of
            non-generic compositions if you write a new moniker class.
            </para>
            <para>
            During the process of composing the two monikers, <c>CreateGenericComposite</c> makes all possible simplifications. Consider the
            example where pmkFirst is the generic composite moniker, A + B + C, and pmkRest is the generic composite moniker, C -1 + B -1 + Z
            (where C -1 is the inverse of C). The function first composes C to C -1, which composes to nothing. Then it composes B and B -1
            to nothing. Finally, it composes A to Z, and supplies a pointer to the generic composite moniker, A + Z.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateItemMoniker(System.String,System.String,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates an item moniker that identifies an object within a containing object (typically a compound document).</summary>
            <param name="lpszDelim">
            A pointer to a wide character string (two bytes per character) zero-terminated string containing the delimiter (typically "!")
            used to separate this item's display name from the display name of its containing object.
            </param>
            <param name="lpszItem">
            A pointer to a zero-terminated string indicating the containing object's name for the object being identified. This name can
            later be used to retrieve a pointer to the object in a call to IOleItemContainer::GetObject.
            </param>
            <param name="ppmk">
            The address of an IMoniker* pointer variable that receives the interface pointer to the item moniker. When successful, the
            function has called AddRef on the item moniker and the caller is responsible for calling Release. If an error occurs, the
            supplied interface pointer has a <c>NULL</c> value.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            A moniker provider, which hands out monikers to identify its objects so they are accessible to other parties, would call
            <c>CreateItemMoniker</c> to identify its objects with item monikers. Item monikers are based on a string, and identify objects
            that are contained within another object and can be individually identified using a string. The containing object must also
            implement the IOleContainer interface.
            </para>
            <para>
            Most moniker providers are OLE applications that support linking. Applications that support linking to objects smaller than
            file-based documents, such as a server application that allows linking to a selection within a document, should use item monikers
            to identify the objects. Container applications that allow linking to embedded objects use item monikers to identify the embedded objects.
            </para>
            <para>
            The lpszItem parameter is the name used by the document to uniquely identify the object. For example, if the object being
            identified is a cell range in a spreadsheet, an appropriate name might be something like "A1:E7." An appropriate name when the
            object being identified is an embedded object might be something like "embedobj1." The containing object must provide an
            implementation of the IOleItemContainer interface that can interpret this name and locate the corresponding object. This allows
            the item moniker to be bound to the object it identifies.
            </para>
            <para>
            Item monikers are not used in isolation. They must be composed with a moniker that identifies the containing object as well. For
            example, if the object being identified is a cell range contained in a file-based document, the item moniker identifying that
            object must be composed with the file moniker identifying that document, resulting in a composite moniker that is the equivalent
            of "C:\work\sales.xls!A1:E7."
            </para>
            <para>
            Nested containers are allowed also, as in the case where an object is contained within an embedded object inside another
            document. The complete moniker of such an object would be the equivalent of "C:\work\report.doc!embedobj1!A1:E7." In this case,
            each containing object must call <c>CreateItemMoniker</c> and provide its own implementation of the IOleItemContainer interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateObjrefMoniker(System.Object,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates an OBJREF moniker based on a pointer to an object.</summary>
            <param name="punk">A pointer to the IUnknown interface on the object that the moniker is to represent.</param>
            <param name="ppmk">Address of a pointer to the IMoniker interface on the OBJREF moniker that was created.</param>
            <returns>This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>Clients use OBJREF monikers to obtain a marshaled pointer to a running object in the servers address space.</para>
            <para>
            The server typically calls <c>CreateObjrefMoniker</c> to create an OBJREF moniker and then calls IMoniker::GetDisplayName, and
            finally releases the moniker. The display name for an OBJREF moniker is of the form:
            </para>
            <para>OBJREF:nnnnnnnn</para>
            <para>
            Where nnnnnnnn is an arbitrarily long base-64 encoding that encapsulates the computer location, process endpoint, and interface
            pointer ID (IPID) of the running object
            </para>
            <para>
            The display name can then be transferred to the client as text. For example, the display name can reside on an HTML page that the
            client downloads.
            </para>
            <para>
            The client can pass the display name to MkParseDisplayName, which creates an OBJREF moniker based on the display name. A call to
            the monikers IMoniker::BindToObject method then obtains a marshaled pointer to the running instance on the server.
            </para>
            <para>
            For example, a server-side COM component contained in an Active Server Page can create an OBJREF moniker, obtain its display
            name, and write the display name to the HTML output that is sent to the client browser. A script that runs on the client side can
            use the display name to get access to the running object itself. A client-side Visual Basic script, for instance, could store the
            display name in a variable called strMyName and include this line:
            </para>
            <para>
            The script engine internally makes the calls to MkParseDisplayName and IMoniker::BindToObject, and the script can then use
            objMyInstance to refer directly to the running object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreatePointerMoniker(System.Object,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Creates a pointer moniker based on a pointer to an object.</summary>
            <param name="punk">A pointer to an IUnknown interface on the object to be identified by the resulting moniker.</param>
            <param name="ppmk">
            The address of an IMoniker* pointer variable that receives the interface pointer to the new pointer moniker. When successful, the
            function has called AddRef on the moniker and the caller is responsible for calling Release. When an error occurs, the returned
            interface pointer has a <c>NULL</c> value.
            </param>
            <returns>This function can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>
            A pointer moniker wraps an existing interface pointer in a moniker that can be passed to those interfaces that require monikers.
            Pointer monikers allow an object that has no persistent representation to participate in a moniker-binding operation.
            </para>
            <para>Pointer monikers are not commonly used, so this function is not often called.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.GetClassFile(System.String,System.Guid@)">
            <summary>Returns the CLSID associated with the specified file name.</summary>
            <param name="szFilename">A pointer to the filename for which you are requesting the associated CLSID.</param>
            <param name="pclsid">A pointer to the location where the associated CLSID is written on return.</param>
            <returns>
            <para>This function can return any of the file system errors, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The CLSID was retrieved successfully.</term>
            </item>
            <item>
            <term>MK_E_CANTOPENFILE</term>
            <term>Unable to open the specified file name.</term>
            </item>
            <item>
            <term>MK_E_INVALIDEXTENSION</term>
            <term>The specified extension in the registry is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When given a file name, <c>GetClassFile</c> finds the CLSID associated with that file. Examples of its use are in the
            OleCreateFromFile function, which is passed a file name and requires an associated CLSID, and in the OLE implementation of
            IMoniker::BindToObject, which, when a link to a file-based document is activated, calls <c>GetClassFile</c> to locate the object
            application that can open the file.
            </para>
            <para><c>GetClassFile</c> uses the following strategies to determine an appropriate CLSID:</para>
            <list type="number">
            <item>
            <term>
            If the file contains a storage object, as determined by a call to the StgIsStorageFile function, <c>GetClassFile</c> returns the
            CLSID that was written with the IStorage::SetClass method.
            </term>
            </item>
            <item>
            <term>
            If the file is not a storage object, <c>GetClassFile</c> attempts to match various bits in the file against a pattern in the
            registry. A pattern in the registry can contain a series of entries of the form:
            </term>
            </item>
            <item>
            <term>
            If the above strategies fail, <c>GetClassFile</c> searches for the <c>File Extension</c> key in the registry that corresponds to
            the .ext portion of the file name. If the database entry contains a valid CLSID, <c>GetClassFile</c> returns that CLSID.
            </term>
            </item>
            <item>
            <term>If all strategies fail, the function returns MK_E_INVALIDEXTENSION.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.GetRunningObjectTable(System.UInt32,Vanara.PInvoke.Ole32.IRunningObjectTable@)">
            <summary>Returns a pointer to the IRunningObjectTable interface on the local running object table (ROT).</summary>
            <param name="reserved">This parameter is reserved and must be 0.</param>
            <param name="pprot">
            The address of an IRunningObjectTable* pointer variable that receives the interface pointer to the local ROT. When the function
            is successful, the caller is responsible for calling Release on the interface pointer. If an error occurs, *pprot is undefined.
            </param>
            <returns>This function can return the standard return values E_UNEXPECTED and S_OK.</returns>
            <remarks>
            <para>
            Each workstation has a local ROT that maintains a table of the objects that have been registered as running on that computer.
            This function returns an IRunningObjectTable interface pointer, which provides access to that table.
            </para>
            <para>
            Moniker providers, which hand out monikers that identify objects so they are accessible to others, should call
            <c>GetRunningObjectTable</c>. Use the interface pointer returned by this function to register your objects when they begin
            running, to record the times that those objects are modified, and to revoke their registrations when they stop running. See the
            IRunningObjectTable interface for more information.
            </para>
            <para>
            Compound-document link sources are the most common example of moniker providers. These include server applications that support
            linking to their documents (or portions of a document) and container applications that support linking to embeddings within their
            documents. Server applications that do not support linking can also use the ROT to cooperate with container applications that
            support linking to embeddings.
            </para>
            <para>
            If you are implementing the IMoniker interface to write a new moniker class, and you need an interface pointer to the ROT, call
            IBindCtx::GetRunningObjectTable rather than the <c>GetRunningObjectTable</c> function. This allows future implementations of the
            IBindCtx interface to modify binding behavior.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IsEqualGUID(System.Guid,System.Guid)">
            <summary>Determines whether two GUIDs are equal.</summary>
            <param name="rguid1">The first GUID.</param>
            <param name="rguid2">The second GUID.</param>
            <returns><see langword="true"/> if equal; <see langword="false"/> otherwise.</returns>
            <remarks><c>IsEqualGUID</c> is used by the IsEqualCLSID and IsEqualIID functions.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.MkParseDisplayName(System.Runtime.InteropServices.ComTypes.IBindCtx,System.String,System.UInt32@,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>
            <para>Converts a string into a moniker that identifies the object named by the string.</para>
            <para>
            This function is the inverse of the IMoniker::GetDisplayName operation, which retrieves the display name associated with a moniker.
            </para>
            </summary>
            <param name="pbc">A pointer to the IBindCtx interface on the bind context object to be used in this binding operation.</param>
            <param name="szUserName">A pointer to the display name to be parsed.</param>
            <param name="pchEaten">
            A pointer to the number of characters of szUserName that were consumed. If the function is successful, *pchEaten is the length of
            szUserName; otherwise, it is the number of characters successfully parsed.
            </param>
            <param name="ppmk">
            The address of the IMoniker* pointer variable that receives the interface pointer to the moniker that was built from szUserName.
            When successful, the function has called AddRef on the moniker and the caller is responsible for calling Release. If an error
            occurs, the specified interface pointer will contain as much of the moniker that the method was able to create before the error occurred.
            </param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The parse operation was successful and the moniker was created.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>Error in the syntax of a file name or an error in the syntax of the resulting composite moniker.</term>
            </item>
            </list>
            <para>
            This function can also return any of the error values returned by IMoniker::BindToObject, IOleItemContainer::GetObject, or IParseDisplayName::ParseDisplayName.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>MkParseDisplayName</c> function parses a human-readable name into a moniker that can be used to identify a link source.
            The resulting moniker can be a simple moniker (such as a file moniker), or it can be a generic composite made up of the component
            moniker pieces. For example, the display name "c:\mydir\somefile!item 1"
            </para>
            <para>
            could be parsed into the following generic composite moniker: FileMoniker based on "c:\mydir\somefile") + (ItemMoniker based on
            "item 1").
            </para>
            <para>
            The most common use of <c>MkParseDisplayName</c> is in the implementation of the standard <c>Links</c> dialog box, which allows
            an end user to specify the source of a linked object by typing in a string. You may also need to call <c>MkParseDisplayName</c>
            if your application supports a macro language that permits remote references (reference to elements outside of the document).
            </para>
            <para>
            Parsing a display name often requires activating the same objects that would be activated during a binding operation, so it can
            be just as expensive (in terms of performance) as binding. Objects that are bound during the parsing operation are cached in the
            bind context passed to the function. If you plan to bind the moniker returned by <c>MkParseDisplayName</c>, it is best to do so
            immediately after the function returns, using the same bind context, which removes the need to activate objects a second time.
            </para>
            <para>
            <c>MkParseDisplayName</c> parses as much of the display name as it understands into a moniker. The function then calls
            IMoniker::ParseDisplayName on the newly created moniker, passing the remainder of the display name. The moniker returned by
            <c>ParseDisplayName</c> is composed onto the end of the existing moniker and, if any of the display name remains unparsed,
            <c>ParseDisplayName</c> is called on the result of the composition. This process is repeated until the entire display name has
            been parsed.
            </para>
            <para>
            <c>MkParseDisplayName</c> attempts the following strategies to parse the beginning of the display name, using the first one that succeeds:
            </para>
            <list type="number">
            <item>
            <term>
            The function looks in the Running Object Table for file monikers corresponding to all prefixes of the display name that consist
            solely of valid file name characters. This strategy can identify documents that are as yet unsaved.
            </term>
            </item>
            <item>
            <term>
            The function checks the maximal prefix of the display name, which consists solely of valid file name characters, to see if an OLE
            1 document is registered by that name. In this case, the returned moniker is an internal moniker provided by the OLE 1
            compatibility layer of OLE 2.
            </term>
            </item>
            <item>
            <term>
            The function consults the file system to check whether a prefix of the display name matches an existing file. The file name can
            be drive-absolute, drive-relative, working-directory relative, or begin with an explicit network share name. This is the common case.
            </term>
            </item>
            <item>
            <term>
            If the initial character of the display name is '@', the function finds the longest string immediately following it that conforms
            to the legal ProgID syntax. The function converts this string to a CLSID using the CLSIDFromProgID function. If the CLSID
            represents an OLE 2 class, the function loads the corresponding class object and asks for an IParseDisplayName interface pointer.
            The resulting <c>IParseDisplayName</c> interface is then given the whole string to parse, starting with the '@'. If the CLSID
            represents an OLE 1 class, then the function treats the string following the ProgID as an OLE1/DDE link designator having
            filename|item syntax.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.MonikerCommonPrefixWith(System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>
            <para>
            Creates a new moniker based on the common prefix that this moniker (the one comprising the data of this moniker object) shares
            with another moniker.
            </para>
            <para>This function is intended to be called only in implementations of IMoniker::CommonPrefixWith.</para>
            </summary>
            <param name="pmkThis">
            A pointer to the IMoniker interface on one of the monikers for which a common prefix is sought; usually the moniker in which this
            call is used to implement IMoniker::CommonPrefixWith.
            </param>
            <param name="pmkOther">A pointer to the IMoniker interface on the moniker to be compared with the first moniker.</param>
            <param name="ppmkCommon">
            The address of an IMoniker* pointer variable that receives the interface pointer to the moniker based on the common prefix of
            pmkThis and pmkOther. When successful, the function has called AddRef on the moniker and the caller is responsible for calling
            Release. If an error occurs, the supplied interface pointer value is <c>NULL</c>.
            </param>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A common prefix exists that is neither pmkThis nor pmkOther.</term>
            </item>
            <item>
            <term>MK_S_HIM</term>
            <term>The entire pmkOther moniker is a prefix of the pmkThis moniker.</term>
            </item>
            <item>
            <term>MK_S_ME</term>
            <term>The entire pmkThis moniker is a prefix of the pmkOther moniker.</term>
            </item>
            <item>
            <term>MK_S_US</term>
            <term>The pmkThis and pmkOther monikers are equal.</term>
            </item>
            <item>
            <term>MK_E_NOPREFIX</term>
            <term>The monikers have no common prefix.</term>
            </item>
            <item>
            <term>MK_E_NOTBINDABLE</term>
            <term>This function was called on a relative moniker. It is not meaningful to take the common prefix of relative monikers.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Your implementation of IMoniker::CommonPrefixWith should first check whether the other moniker is of a type that you recognize
            and handle in a special way. If not, you should call <c>MonikerCommonPrefixWith</c>, passing itself as pmkThis and the other
            moniker as pmkOther. <c>MonikerCommonPrefixWith</c> correctly handles the cases where either moniker is a generic composite.
            </para>
            <para>
            You should call this function only if pmkThis and pmkOther are both absolute monikers (where an absolute moniker is either a file
            moniker or a generic composite whose leftmost component is a file moniker, and where the file moniker represents an absolute
            path). Do not call this function on relative monikers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.MonikerRelativePathTo(System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker,System.Runtime.InteropServices.ComTypes.IMoniker@,System.Boolean)">
            <summary>
            <para>
            Provides a moniker that, when composed onto the end of the first specified moniker (or one with a similar structure), yields the
            second specified moniker.
            </para>
            <para>This function is intended for use only by IMoniker::RelativePathTo implementations.</para>
            </summary>
            <param name="pmkSrc">
            A pointer to the IMoniker interface on the moniker that, when composed with the relative moniker to be created, produces pmkDest.
            This moniker identifies the "source" of the relative moniker to be created.
            </param>
            <param name="pmkDest">
            A pointer to the IMoniker interface on the moniker to be expressed relative to pmkSrc. This moniker identifies the destination of
            the relative moniker to be created.
            </param>
            <param name="ppmkRelPath">
            The address of an IMoniker* pointer variable that receives the interface pointer to the new relative moniker. When successful,
            the function has called AddRef on the moniker and the caller is responsible for calling Release. If an error occurs, the
            interface pointer value is <c>NULL</c>.
            </param>
            <param name="dwReserved">This parameter is reserved and must be nonzero.</param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A meaningful relative path has been returned.</term>
            </item>
            <item>
            <term>MK_S_HIM</term>
            <term>The only form of the relative path is the other moniker.</term>
            </item>
            <item>
            <term>MK_E_NOTBINDABLE</term>
            <term>
            The pmkSrc parameter is a relative moniker, such as an item moniker, and must be composed with the moniker of its container
            before a relative path can be determined.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Your implementation of IMoniker::RelativePathTo should first check whether the other moniker is of a type you recognize and
            handle in a special way. If not, you should call <c>MonikerRelativePathTo</c>, passing itself as pmkThis and the other moniker as
            pmkOther. <c>MonikerRelativePathTo</c> correctly handles the cases where either moniker is a generic composite.
            </para>
            <para>
            You should call this function only if pmkSrc and pmkDest are both absolute monikers, where an absolute moniker is either a file
            moniker or a generic composite whose leftmost component is a file moniker, and where the file moniker represents an absolute
            path. Do not call this function on relative monikers.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE">
            <summary>Provides a CO_MTA_USAGE_COOKIE.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.op_Explicit(Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.op_Inequality(Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE,Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.op_Equality(Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE,Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CO_MTA_USAGE_COOKIE.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.MULTI_QI">
            <summary>Represents an interface in a query for multiple interfaces.</summary>
            <remarks>
            To optimize network performance, most remote activation functions take an array of <c>MULTI_QI</c> structures rather than just a
            single IID as input and a single pointer to the requested interface on the object as output, as do local activation functions.
            This allows a set of pointers to interfaces to be returned from the same object in a single round-trip to the server. In network
            scenarios, requesting multiple interfaces at the time of object construction can save considerable time over using a number of
            calls to QueryInterface for unique interfaces, each of which would require a round-trip to the server.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MULTI_QI.pIID">
            <summary>A pointer to an interface identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MULTI_QI.pItf">
            <summary>A pointer to the interface requested in <c>pIID</c>. This member must be <c>NULL</c> on input.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MULTI_QI.hr">
            <summary>
            The return value of the QueryInterface call to locate the requested interface. Common return values include S_OK and
            E_NOINTERFACE. This member must be 0 on input.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STGOPTIONS">
            <summary>
            The STGOPTIONS structure specifies features of the storage object, such as sector size, in the StgCreateStorageEx and
            StgOpenStorageEx functions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGOPTIONS.usVersion">
            <summary>
            Specifies the version of the STGOPTIONS structure. It is set to STGOPTIONS_VERSION. <note>When usVersion is set to 1, the
            ulSectorSize member can be set.This is useful when creating a large-sector documentation file.However, when usVersion is set
            to 1, the pwcsTemplateFile member cannot be used.</note>
            <para>In Windows 2000 and later: STGOPTIONS_VERSION can be set to 1 for version 1.</para>
            <para>In Windows XP and later: STGOPTIONS_VERSION can be set to 2 for version 2.</para>
            <para>For operating systems prior to Windows 2000: STGOPTIONS_VERSION will be set to 0 for version 0.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGOPTIONS.reserved">
            <summary>Reserved for future use; must be zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGOPTIONS.ulSectorSize">
            <summary>Specifies the sector size of the storage object. The default is 512 bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGOPTIONS.pwcsTemplateFile">
            <summary>
            Specifies the name of a file whose Encrypted File System (EFS) metadata will be transferred to a newly created Structured
            Storage file. This member is valid only when STGFMT_DOCFILE is used with StgCreateStorageEx.
            <para>
            In Windows XP and later: The pwcsTemplateFile member is only valid if version 2 or later is specified in the usVersion member.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.COSERVERINFO">
            <summary>Identifies a remote computer resource to the activation functions.</summary>
            <remarks>
            <para>
            The <c>COSERVERINFO</c> structure is used primarily to identify a remote system in object creation functions. Computer resources
            are named using the naming scheme of the network transport. By default, all UNC ("\server" or "server") and DNS names
            ("domain.com", "example.microsoft.com", or "135.5.33.19") names are allowed.
            </para>
            <para>
            If <c>pAuthInfo</c> is set to <c>NULL</c>, Snego will be used to negotiate an authentication service that will work between the
            client and server. However, a non- <c>NULL</c> COAUTHINFO structure can be specified for <c>pAuthInfo</c> to meet any one of the
            following needs:
            </para>
            <list type="bullet">
            <item>
            <term>
            To specify a different client identity for computer remote activations. The specified identity will be used for the launch
            permission check on the server rather than the real client identity.
            </term>
            </item>
            <item>
            <term>
            To specify that Kerberos, rather than NTLMSSP, is used for machine remote activation. A nondefault client identity may or may not
            be specified.
            </term>
            </item>
            <item>
            <term>To request unsecure activation.</term>
            </item>
            <item>
            <term>To specify a proprietary authentication service.</term>
            </item>
            </list>
            <para>
            If <c>pAuthInfo</c> is not <c>NULL</c>, those values will be used to specify the authentication settings for the remote call.
            These settings will be passed to the RpcBindingSetAuthInfoEx function.
            </para>
            <para>
            If the pAuthInfo parameter is <c>NULL</c>, then dwAuthnLevel can be overridden by the authentication level set by the
            CoInitializeSecurity function. If the <c>CoInitializeSecurity</c> function isn't called, then the authentication level specified
            under the AppID registry key is used, if it exists.
            </para>
            <para>
            Starting with Windows XP with Service Pack 2 (SP2), dwAuthnLevel is the maximum of RPC_C_AUTHN_LEVEL_CONNECT and the process-wide
            authentication level of the client process that is issuing the activation request. For earlier versions of the operating system,
            this is RPC_C_AUTHN_LEVEL_CONNECT.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COSERVERINFO.dwReserved1">
            <summary>This member is reserved and must be 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COSERVERINFO.pwszName">
            <summary>The name of the computer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COSERVERINFO.pAuthInfo">
            <summary>
            A pointer to a COAUTHINFO structure to override the default activation security for machine remote activations. Otherwise,
            set to <c>NULL</c> to indicate that default values should be used. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.COSERVERINFO.dwReserved2">
            <summary>This member is reserved and must be 0.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ACTIVATIONTYPE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_UNCATEGORIZED">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_FROM_MONIKER">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_FROM_DATA">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_FROM_STORAGE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_FROM_STREAM">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ACTIVATIONTYPE.ACTIVATIONTYPE_FROM_FILE">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.BIND_FLAGS">
            <summary>Controls aspects of moniker binding operations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_FLAGS.BIND_MAYBOTHERUSER">
            <summary>
            If this flag is specified, the moniker implementation can interact with the end user. Otherwise, the moniker implementation
            should not interact with the user in any way, such as by asking for a password for a network volume that needs mounting. If
            prohibited from interacting with the user when it otherwise would, a moniker implementation can use a different algorithm
            that does not require user interaction, or it can fail with the error MK_E_MUSTBOTHERUSER.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_FLAGS.BIND_JUSTTESTEXISTENCE">
            <summary>
            If this flag is specified, the caller is not interested in having the operation carried out, but only in learning whether the
            operation could have been carried out had this flag not been specified. For example, this flag lets the caller indicate only
            an interest in finding out whether an object actually exists by using this flag in a IMoniker::BindToObject call. Moniker
            implementations can, however, ignore this possible optimization and carry out the operation in full. Callers must be able to
            deal with both cases.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CALLTYPE">
            <summary>Specifies the call types used by IMessageFilter::HandleInComingCall.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CALLTYPE.CALLTYPE_TOPLEVEL">
            <summary>
            A top-level call has arrived and the object is not currently waiting for a reply from a previous outgoing call. Calls of this
            type should always be handled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CALLTYPE.CALLTYPE_NESTED">
            <summary>
            A call has arrived bearing the same logical thread identifier as that of a previous outgoing call for which the object is
            still awaiting a reply. Calls of this type should always be handled.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CALLTYPE.CALLTYPE_ASYNC">
            <summary>An asynchronous call has arrived. Calls of this type cannot be rejected. OLE always delivers calls of this type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CALLTYPE.CALLTYPE_TOPLEVEL_CALLPENDING">
            <summary>
            A new top-level call has arrived with a new logical thread identifier and the object is currently waiting for a reply from a
            previous outgoing call. Calls of this type may be handled or rejected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CALLTYPE.CALLTYPE_ASYNC_CALLPENDING">
            <summary>
            An asynchronous call has arrived with a new logical thread identifier and the object is currently waiting for a reply from a
            previous outgoing call. Calls of this type cannot be rejected.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES">
            <summary>
            <para>Specifies various capabilities in CoInitializeSecurity and IClientSecurity::SetBlanket (or its helper function CoSetProxyBlanket).</para>
            </summary>
            <remarks>
            <para>
            When the EOAC_APPID flag is set, CoInitializeSecurity looks for the authentication level under the AppID. If the authentication
            level is not found, it looks for the default authentication level. If the default authentication level is not found, it generates
            a default authentication level of connect. If the authentication level is not RPC_C_AUTHN_LEVEL_NONE, <c>CoInitializeSecurity</c>
            looks for the access permission value under the AppID. If not found, it looks for the default access permission value. If not
            found, it generates a default access permission. All the other security settings are determined the same way as for a legacy application.
            </para>
            <para>
            If the AppID is NULL, <c>CoInitializeSecurity</c> looks up the application .exe name in the registry and uses the AppID stored
            there. If the AppID does not exist, the machine defaults are used.
            </para>
            <para>
            The IClientSecurity::SetBlanket method and CoSetProxyBlanket function return an error if any of the following flags are set in
            the capabilities parameter: EOAC_SECURE_REFS, EOAC_ACCESS_CONTROL, EOAC_APPID, EOAC_DYNAMIC, EOAC_REQUIRE_FULLSIC,
            EOAC_DISABLE_AAA, or EOAC_NO_CUSTOM_MARSHAL.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_NONE">
            <summary>Indicates that no capability flags are set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_MUTUAL_AUTH">
            <summary>
            If this flag is specified, it will be ignored. Support for mutual authentication is automatically provided by some
            authentication services. See COM and Security Packages for more information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_STATIC_CLOAKING">
            <summary>
            Sets static cloaking. When this flag is set, DCOM uses the thread token (if present) when determining the client's identity.
            However, the client's identity is determined on the first call on each proxy (if SetBlanket is not called) and each time
            CoSetProxyBlanket is called on the proxy. For more information about static cloaking, see Cloaking. CoInitializeSecurity and
            IClientSecurity::SetBlanket return errors if both cloaking flags are set or if either flag is set when Schannel is the
            authentication service.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_DYNAMIC_CLOAKING">
            <summary>
            Sets dynamic cloaking. When this flag is set, DCOM uses the thread token (if present) when determining the client's identity.
            On each call to a proxy, the current thread token is examined to determine whether the client's identity has changed
            (incurring an additional performance cost) and the client is authenticated again only if necessary. Dynamic cloaking can be
            set by clients only. For more information about dynamic cloaking, see Cloaking. CoInitializeSecurity and
            IClientSecurity::SetBlanket return errors if both cloaking flags are set or if either flag is set when Schannel is the
            authentication service.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_ANY_AUTHORITY">
            <summary>This flag is obsolete.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_MAKE_FULLSIC">
            <summary>
            Causes DCOM to send Schannel server principal names in fullsic format to clients as part of the default security negotiation.
            The name is extracted from the server certificate. For more information about the fullsic form, see Principal Names.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_DEFAULT">
            <summary>
            Tells DCOM to use the valid capabilities from the call to CoInitializeSecurity. If CoInitializeSecurity was not called,
            EOAC_NONE will be used for the capabilities flag. This flag can be set only by clients in a call to
            IClientSecurity::SetBlanket or CoSetProxyBlanket.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_SECURE_REFS">
            <summary>
            Authenticates distributed reference count calls to prevent malicious users from releasing objects that are still being used.
            If this flag is set, which can be done only in a call to CoInitializeSecurity by the client, the authentication level (in
            dwAuthnLevel) cannot be set to none. The server always authenticates Release calls. Setting this flag prevents an
            authenticated client from releasing the objects of another authenticated client. It is recommended that clients always set
            this flag, although performance is affected because of the overhead associated with the extra security.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_APPID">
            <summary>
            Indicates that the pSecDesc parameter to CoInitializeSecurity is a pointer to a GUID that is an AppID. The
            CoInitializeSecurity function looks up the AppID in the registry and reads the security settings from there. If this flag is
            set, all other parameters to CoInitializeSecurity are ignored and must be zero. Only the server can set this flag. For more
            information about this capability flag, see the Remarks section below. CoInitializeSecurity returns an error if both the
            EOAC_APPID and EOAC_ACCESS_CONTROL flags are set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_NO_CUSTOM_MARSHAL">
            <summary>
            Specifying this flag helps protect server security when using DCOM or COM+. It reduces the chances of executing arbitrary
            DLLs because it allows the marshaling of only CLSIDs that are implemented in Ole32.dll, ComAdmin.dll, ComSvcs.dll, or Es.dll,
            or that implement the CATID_MARSHALER category ID. Any service that is critical to system operation should set this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_RESERVED1">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_ACCESS_CONTROL">
            <summary>
            Indicates that the pSecDesc parameter to CoInitializeSecurity is a pointer to an IAccessControl interface on an access
            control object. When DCOM makes security checks, it calls IAccessControl::IsAccessAllowed. This flag is set only by the
            server. CoInitializeSecurity returns an error if both the EOAC_APPID and EOAC_ACCESS_CONTROL flags are set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_DYNAMIC">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_REQUIRE_FULLSIC">
            <summary>
            Causes DCOM to fail CoSetProxyBlanket calls where an Schannel principal name is specified in any format other than fullsic.
            This flag is currently for clients only. For more information about the fullsic form, see Principal Names.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_AUTO_IMPERSONATE">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EOLE_AUTHENTICATION_CAPABILITIES.EOAC_DISABLE_AAA">
            <summary>
            Causes any activation where a server process would be launched under the caller's identity (activate-as-activator) to fail
            with E_ACCESSDENIED. This value, which can be specified only in a call to CoInitializeSecurity by the client, allows an
            application that runs under a privileged account (such as LocalSystem) to help prevent its identity from being used to launch
            untrusted components. An activation call that uses CLSCTX_ENABLE_AAA of the CLSCTX enumeration will allow
            activate-as-activator activations for that call.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.LOCKTYPE">
            <summary>
            <para>
            The <c>LOCKTYPE</c> enumeration values indicate the type of locking requested for the specified range of bytes. The values are
            used in the ILockBytes::LockRegion and IStream::LockRegion methods.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LOCKTYPE.LOCK_WRITE">
            <summary>
            If this lock is granted, the specified range of bytes can be opened and read any number of times, but writing to the locked
            range is prohibited except for the owner that was granted this lock.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LOCKTYPE.LOCK_EXCLUSIVE">
            <summary>
            If this lock is granted, writing to the specified range of bytes is prohibited except by the owner that was granted this lock.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LOCKTYPE.LOCK_ONLYONCE">
            <summary>
            If this lock is granted, no other LOCK_ONLYONCE lock can be obtained on the range. Usually this lock type is an alias for
            some other lock type. Thus, specific implementations can have additional behavior associated with this lock type.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PENDINGMSG">
            <summary>Specifies the return values for the IMessageFilter::MessagePending method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PENDINGMSG.PENDINGMSG_CANCELCALL">
            <summary>Cancel the outgoing call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PENDINGMSG.PENDINGMSG_WAITNOPROCESS">
            <summary>Wait for the return and don't dispatch the message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PENDINGMSG.PENDINGMSG_WAITDEFPROCESS">
            <summary>Wait and dispatch the message.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PENDINGTYPE">
            <summary>Indicates the level of nesting in the IMessageFilter::MessagePending method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PENDINGTYPE.PENDINGTYPE_TOPLEVEL">
            <summary>Top-level call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PENDINGTYPE.PENDINGTYPE_NESTED">
            <summary>Nested call.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ROTFLAGS">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.Ole32.IRunningObjectTable.Register(Vanara.PInvoke.Ole32.ROTFLAGS,System.Object,System.Runtime.InteropServices.ComTypes.IMoniker)"/></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ROTFLAGS.ROTFLAGS_REGISTRATIONKEEPSALIVE">
            <summary>When set, indicates a strong registration for the object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ROTFLAGS.ROTFLAGS_ALLOWANYCLIENT">
            <summary>
            When set, any client can connect to the running object through its entry in the ROT.When not set, only clients in the window
            station that registered the object can connect to it.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.SERVERCALL">
            <summary>Indicates the status of server call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SERVERCALL.SERVERCALL_ISHANDLED">
            <summary>The object may be able to process the call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SERVERCALL.SERVERCALL_REJECTED">
            <summary>The object cannot handle the call due to an unforeseen problem, such as network unavailability.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SERVERCALL.SERVERCALL_RETRYLATER">
            <summary>
            The object cannot handle the call at this time. For example, an application might return this value when it is in a
            user-controlled modal state.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STGTY">
            <summary>
            The <c>STGTY</c> enumeration values are used in the <c>type</c> member of the STATSTG structure to indicate the type of the
            storage element. A storage element is a storage object, a stream object, or a byte-array object (LOCKBYTES).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGTY.STGTY_STORAGE">
            <summary>Indicates that the storage element is a storage object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGTY.STGTY_STREAM">
            <summary>Indicates that the storage element is a stream object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGTY.STGTY_LOCKBYTES">
            <summary>Indicates that the storage element is a byte-array object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGTY.STGTY_PROPERTY">
            <summary>Indicates that the storage element is a property storage object.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IActivationFilter">
            <summary>Undocumented.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IActivationFilter.HandleActivation(Vanara.PInvoke.Ole32.ACTIVATIONTYPE,System.Guid@,System.Guid@)">
            <summary>Handles the activation.</summary>
            <param name="dwActivationType">Type of the activation.</param>
            <param name="rclsid">The CLSID.</param>
            <param name="pReplacementClsId">The replacement CLSID.</param>
            <returns>An appropriate error response.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IAgileObject">
            <summary>Marks an interface as agile across apartments.</summary>
            <remarks>
            <para>
            The <c>IAgileObject</c> interface is a marker interface that indicates that an object is free threaded and can be called from any apartment.
            </para>
            <para>
            Unlike what happens when aggregating the Free Threaded Marshaler (FTM), implementing the <c>IAgileObject</c> interface doesn't
            affect what happens when marshaling a call. Instead, the <c>IAgileObject</c> interface is recognized by the Global Interface
            Table (GIT). When an object that implements the <c>IAgileObject</c> interface is placed in the GIT and localized to another
            apartment, the object is called directly in the new apartment, rather than marshaling.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IAgileReference">
            <summary>Enables retrieving an agile reference to an object.</summary>
            <remarks>Call the RoGetAgileReference function to create an agile reference to an object.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IAgileReference.Resolve(System.Guid@)">
            <summary>Gets the interface ID of an agile reference to an object.</summary>
            <param name="riid">The riid.</param>
            <returns>On successful completion, *ppvObjectReference is a pointer to the interface specified by riid.</returns>
            <remarks>
            Call the RoGetAgileReference function to create an agile reference to an object. Call the <c>Resolve</c> method to localize
            the object into the apartment in which <c>Resolve</c> is called.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IBindCtxV">
            <summary>
            Provides access to a bind context, which is an object that stores information about a particular moniker binding operation.
            </summary>
            <remarks>
            <para>A bind context includes the following information:</para>
            <list type="bullet">
            <item>
            <term>
            A BIND_OPTS structure containing a set of parameters that do not change during the binding operation. When a composite moniker is
            bound, each component uses the same bind context, so it acts as a mechanism for passing the same parameters to each component of
            a composite moniker.
            </term>
            </item>
            <item>
            <term>
            A set of pointers to objects that the binding operation has activated. The bind context holds pointers to these bound objects,
            keeping them loaded and thus eliminating redundant activations if the objects are needed again during subsequent binding operations.
            </term>
            </item>
            <item>
            <term>
            A pointer to the running object table (ROT) on the same computer as the process that started the bind operation. Moniker
            implementations that need to access the ROT should use the IBindCtx::GetRunningObjectTable method rather than using the
            GetRunningObjectTable function. This allows future enhancements to the system's <c>IBindCtx</c> implementation to modify binding behavior.
            </term>
            </item>
            <item>
            <term>
            A table of interface pointers, each associated with a string key. This capability enables moniker implementations to store
            interface pointers under a well-known string so that they can later be retrieved from the bind context. For example, OLE defines
            several string keys ("ExceededDeadline", "ConnectManually", and so on) that can be used to store a pointer to the object that
            caused an error during a binding operation.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.RegisterObjectBound(System.Object)">
            <summary>
            Registers an object with the bind context to ensure that the object remains active until the bind context is released.
            </summary>
            <param name="punk">A pointer to the IUnknown interface on the object that is being registered as bound.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            Those writing a new moniker class (through an implementation of the IMoniker interface) should call this method whenever the
            implementation activates an object. This happens most often in the course of binding a moniker, but it can also happen while
            retrieving a moniker's display name, parsing a display name into a moniker, or retrieving the time that an object was last modified.
            </para>
            <para>
            <c>RegisterObjectBound</c> calls AddRef to create an additional reference to the object. You must, however, still release
            your own copy of the pointer. Calling this method twice for the same object creates two references to that object. You can
            release a reference obtained through a call to this method by calling IBindCtx::RevokeObjectBound. All references held by the
            bind context are released when the bind context itself is released.
            </para>
            <para>
            Calling <c>RegisterObjectBound</c> to register an object with a bind context keeps the object active until the bind context
            is released. Reusing a bind context in a subsequent binding operation (either for another piece of the same composite moniker
            or for a different moniker) can make the subsequent binding operation more efficient because it doesn't have to reload that
            object. This, however, improves performance only if the subsequent binding operation requires some of the same objects as the
            original one, so you need to balance the possible performance improvement of reusing a bind context against the costs of
            keeping objects activated unnecessarily.
            </para>
            <para>
            IBindCtx does not provide a method to retrieve a pointer to an object registered using <c>RegisterObjectBound</c>. Assuming
            the object has registered itself with the running object table, moniker implementations can call
            IRunningObjectTable::GetObject to retrieve a pointer to the object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.RevokeObjectBound(System.Object)">
            <summary>Removes the object from the bind context, undoing a previous call to RegisterObjectBound.</summary>
            <param name="punk">A pointer to the IUnknown interface on the object to be removed.</param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was released successfully.</term>
            </item>
            <item>
            <term>MK_E_NOTBOUND</term>
            <term>The object was not previously registered.</term>
            </item>
            </list>
            </returns>
            <remarks>You would rarely call this method. It is documented primarily for completeness.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.ReleaseBoundObjects">
            <summary>Releases all pointers to all objects that were previously registered by calls to RegisterObjectBound.</summary>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            You rarely call this method directly. The system's IBindCtx implementation calls this method when the pointer to the
            <c>IBindCtx</c> interface on the bind context is released (the bind context is released). If a bind context is not released,
            all of the registered objects remain active.
            </para>
            <para>
            If the same object has been registered more than once, this method calls the Release method on the object the number of times
            it was registered.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.SetBindOptions(Vanara.PInvoke.Ole32.BIND_OPTS_V)">
            <summary>Sets new values for the binding parameters stored in the bind context.</summary>
            <param name="pbindopts">A pointer to a BIND_OPTS, BIND_OPTS2, or BIND_OPTS3 structure containing the binding parameters.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            A bind context contains a block of parameters that are common to most IMoniker operations. These parameters do not change as
            the operation moves from piece to piece of a composite moniker.
            </para>
            <para>Subsequent binding operations can call IBindCtx::GetBindOptions to retrieve these parameters.</para>
            <para>Notes to Callers</para>
            <para>This method can be called by moniker clients (those who use monikers to acquire interface pointers to objects).</para>
            <para>
            When you first create a bind context by using the CreateBindCtx function, the fields of the BIND_OPTS structure are
            initialized to the following values:
            </para>
            <para>
            You can use the <c>IBindCtx::SetBindOptions</c> method to modify these values before using the bind context, if you want
            values other than the defaults.
            </para>
            <para>
            <c>SetBindOptions</c> copies the members of the specified structure, but not the COSERVERINFO structure and the pointers it
            contains. Callers may not free these pointers until the bind context is released.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.GetBindOptions(Vanara.PInvoke.Ole32.BIND_OPTS_V)">
            <summary>Retrieves the binding options stored in this bind context.</summary>
            <param name="pbindopts">
            A pointer to an initialized structure that receives the current binding parameters on return. See BIND_OPTS, BIND_OPTS2, and BIND_OPTS3.
            </param>
            <returns>This method can return the standard return values E_UNEXPECTED and S_OK.</returns>
            <remarks>
            <para>
            A bind context contains a block of parameters that are common to most IMoniker operations and that do not change as the
            operation moves from piece to piece of a composite moniker.
            </para>
            <para>Notes to Callers</para>
            <para>
            You typically call this method if you are writing your own moniker class. (This requires that you implement the IMoniker
            interface.) You call this method to retrieve the parameters specified by the moniker client.
            </para>
            <para>
            You must initialize the structure that is filled in by this method. Before calling this method, you must initialize the
            <c>cbStruct</c> member to the size of the structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.GetRunningObjectTable(Vanara.PInvoke.Ole32.IRunningObjectTable@)">
            <summary>
            Retrieves an interface pointer to the running object table (ROT) for the computer on which this bind context is running.
            </summary>
            <param name="pprot">
            The address of a IRunningObjectTable pointer variable that receives the interface pointer to the running object table. If an
            error occurs, *pprot is set to <c>NULL</c>. If *pprot is non- <c>NULL</c>, the implementation calls AddRef on the running
            table object; it is the caller's responsibility to call Release.
            </param>
            <returns>This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, and S_OK.</returns>
            <remarks>
            <para>
            The running object table is a globally accessible table on each computer. It keeps track of all the objects that are
            currently running on the computer.
            </para>
            <para>Notes to Callers</para>
            <para>
            Typically, those implementing a new moniker class (through an implementation of IMoniker interface) call
            <c>GetRunningObjectTable</c>. It is useful to call this method in an implementation of IMoniker::BindToObject or
            IMoniker::IsRunning to check whether an object is currently running. You can also call this method in the implementation of
            IMoniker::GetTimeOfLastChange to learn when a running object was last modified.
            </para>
            <para>
            Moniker implementations should call this method instead of using the <c>GetRunningObjectTable</c> function. This makes it
            possible for future implementations of IBindCtx to modify binding behavior.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.RegisterObjectParam(System.String,System.Object)">
            <summary>Associates an object with a string key in the bind context's string-keyed table of pointers.</summary>
            <param name="pszKey">The bind context string key under which the object is being registered. Key string comparison is case-sensitive.</param>
            <param name="punk">
            <para>A pointer to the IUnknown interface on the object that is to be registered.</para>
            <para>The method calls AddRef on the pointer.</para>
            </param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>
            A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between
            a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under
            a string known to both parties so that the other party can later retrieve it from the bind context.
            </para>
            <para>Binding operations subsequent to the use of this method can use IBindCtx::GetObjectParam to retrieve the stored pointer.</para>
            <para>Notes to Callers</para>
            <para>
            <c>RegisterObjectParam</c> is useful to those implementing a new moniker class (through an implementation of IMoniker) and to
            moniker clients (those who use monikers to bind to objects).
            </para>
            <para>
            In implementing a new moniker class, you call this method when an error occurs during moniker binding to inform the caller of
            the cause of the error. The key that you would obtain with a call to this method would depend on the error condition.
            Following is a list of common moniker binding errors, describing for each the keys that would be appropriate:
            </para>
            <list type="bullet">
            <item>
            <term>
            MK_E_EXCEEDEDDEADLINEâ€”If a binding operation exceeds its deadline because a given object is not running, you should
            register the object's moniker using the first unused key from the list: "ExceededDeadline", "ExceededDeadline1",
            "ExceededDeadline2", and so on. If the caller later finds the moniker in the running object table, the caller can retry the
            binding operation.
            </term>
            </item>
            <item>
            <term>
            MK_E_CONNECTMANUALLYâ€”The "ConnectManually" key indicates a moniker whose binding requires assistance from the end user. To
            request that the end user manually connect to the object, the caller can retry the binding operation after showing the
            moniker's display name. Common reasons for this error are that a password is needed or that a floppy needs to be mounted.
            </term>
            </item>
            <item>
            <term>
            E_CLASSNOTFOUNDâ€”The "ClassNotFound" key indicates a moniker whose class could not be found. (The server for the object
            identified by this moniker could not be located.) If this key is used for an OLE compound-document object, the caller can use
            IMoniker::BindToStorage to bind to the object and then try to carry out a <c>Treat As...</c> or <c>Convert To...</c>
            operation to associate the object with a different server. If this is successful, the caller can retry the binding operation.
            </term>
            </item>
            </list>
            <para>
            A moniker client with detailed knowledge of the implementation of the moniker can also call this method to pass private
            information to that implementation.
            </para>
            <para>
            You can define new strings as keys for storing pointers. By convention, you should use key names that begin with the string
            form of the CLSID of the moniker class. (See the StringFromCLSID function.)
            </para>
            <para>
            If the pszKey parameter matches the name of an existing key in the bind context's table, the new object replaces the existing
            object in the table.
            </para>
            <para>When you register an object using this method, the object is not released until one of the following occurs:</para>
            <list type="bullet">
            <item>
            <term>It is replaced in the table by another object with the same key.</term>
            </item>
            <item>
            <term>It is removed from the table by a call to IBindCtx::RevokeObjectParam.</term>
            </item>
            <item>
            <term>The bind context is released. All registered objects are released when the bind context is released.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.GetObjectParam(System.String,System.Object@)">
            <summary>
            Retrieves an interface pointer to the object associated with the specified key in the bind context's string-keyed table of pointers.
            </summary>
            <param name="pszKey">The bind context string key to be searched for. Key string comparison is case-sensitive.</param>
            <param name="ppunk">
            The address of an IUnknown pointer variable that receives the interface pointer to the object associated with pszKey. When
            successful, the implementation calls AddRef on *ppunk. It is the caller's responsibility to call Release. If an error occurs,
            the implementation sets *ppunk to <c>NULL</c>.
            </param>
            <returns>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</returns>
            <remarks>
            <para>
            A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between
            a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under
            a string known to both parties so that the other party can later retrieve it from the bind context.
            </para>
            <para>
            The pointer this method retrieves must have previously been inserted into the table using the IBindCtx::RegisterObjectParam method.
            </para>
            <para>Notes to Callers</para>
            <para>
            Objects using monikers to locate other objects can call this method when a binding operation fails to get specific
            information about the error that occurred. Depending on the error, it may be possible to correct the situation and retry the
            binding operation. See IBindCtx::RegisterObjectParam for more information.
            </para>
            <para>
            Moniker implementations can call this method to handle situations where a caller initiates a binding operation and requests
            specific information. By convention, the implementer should use key names that begin with the string form of the CLSID of a
            moniker class. (See the StringFromCLSID function.)
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.EnumObjectParam(System.Runtime.InteropServices.ComTypes.IEnumString@)">
            <summary>
            Retrieves a pointer to an interface that can be used to enumerate the keys of the bind context's string-keyed table of pointers.
            </summary>
            <param name="ppenum">
            The address of an IEnumString pointer variable that receives the interface pointer to the enumerator. If an error occurs,
            *ppenum is set to <c>NULL</c>. If *ppenum is non- <c>NULL</c>, the implementation calls AddRef on *ppenum; it is the caller's
            responsibility to call Release.
            </param>
            <returns>This method can return the standard return values E_OUTOFMEMORY and S_OK.</returns>
            <remarks>
            <para>The keys returned by the enumerator are the ones previously specified in calls to IBindCtx::RegisterObjectParam.</para>
            <para>Notes to Callers</para>
            <para>
            A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between
            a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under
            a string known to both parties so that the other party can later retrieve it from the bind context.
            </para>
            <para>
            In the system implementation of the IBindCtx interface, this method is not implemented. Therefore, calling this method
            results in a return value of E_NOTIMPL.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IBindCtxV.RevokeObjectParam(System.String)">
            <summary>
            Removes the specified key and its associated pointer from the bind context's string-keyed table of objects. The key must have
            previously been inserted into the table with a call to RegisterObjectParam.
            </summary>
            <param name="pszKey">The bind context string key to be removed. Key string comparison is case-sensitive.</param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The specified key was removed successfully.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The object was not previously registered.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A bind context maintains a table of interface pointers, each associated with a string key. This enables communication between
            a moniker implementation and the caller that initiated the binding operation. One party can store an interface pointer under
            a string known to both parties so that the other party can later retrieve it from the bind context.
            </para>
            <para>
            This method is used to remove an entry from the table. If the specified key is found, the bind context also releases its
            reference to the object.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IContext">
            <summary>Supports setting COM+ context properties.</summary>
            <remarks>An instance of this interface for the current context can be obtained using CoGetObjectContext.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IContext.SetProperty(System.Guid@,System.UInt32,System.Object)">
            <summary>Adds the specified context property to the object context.</summary>
            <param name="rpolicyId">A GUID that uniquely identifies this context property.</param>
            <param name="flags">This parameter is reserved and must be zero.</param>
            <param name="pUnk">A pointer to the context property to be added.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IContext.RemoveProperty(System.Guid@)">
            <summary>Removes the specified context property from the context.</summary>
            <param name="rPolicyId">The GUID that uniquely identifies the context property to be removed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IContext.GetProperty(System.Guid@,System.UInt32@)">
            <summary>Retrieves the specified context property from the context.</summary>
            <param name="rGuid">The GUID that uniquely identifies the context property to be retrieved.</param>
            <param name="pFlags">The address of the variable that receives the flags associated with the property.</param>
            <returns>The address of the variable that receives the IUnknown interface pointer of the requested context property.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IContext.EnumContextProps">
            <summary>
            Returns an IEnumContextProps interface pointer that can be used to enumerate the context properties in this context.
            </summary>
            <returns>The address of the variable that receives the new IEnumContextProps interface pointer.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IDataAdviseHolder">
            <summary>
            <para>
            Creates and manages advisory connections between a data object and one or more advise sinks. Its methods are intended to be used
            to implement the advisory methods of IDataObject. <c>IDataAdviseHolder</c> is implemented on an advise holder object. Its methods
            establish and delete data advisory connections and send notification of change in data from a data object to an object that
            requires this notification, such as an OLE container, which must contain an advise sink.
            </para>
            <para>
            Advise sinks are objects that require notification of change in the data the object contains and implement the IAdviseSink
            interface. Advise sinks are also usually associated with OLE compound document containers.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDataAdviseHolder.Advise(System.Runtime.InteropServices.ComTypes.IDataObject,System.Runtime.InteropServices.ComTypes.FORMATETC@,System.Runtime.InteropServices.ComTypes.ADVF,System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32@)">
            <summary>Creates a connection between an advise sink and a data object for receiving notifications.</summary>
            <param name="pDataObject">
            A pointer to the IDataObject interface on the data object for which notifications are requested. If data in this object
            changes, a notification is sent to the advise sinks that have requested notification.
            </param>
            <param name="pFetc">
            A pointer to a FORMATETC structure that contains the specified format, medium, and target device that is of interest to the
            advise sink requesting notification. For example, one sink may want to know only when the bitmap representation of the data
            in the data object changes. Another sink may be interested in only the metafile format of the same object. Each advise sink
            is notified when the data of interest changes. This data is passed back to the advise sink when notification occurs.
            </param>
            <param name="advf">
            <para>
            A group of flags that control the advisory connection. Possible values are from the ADVF enumeration. However, only some of
            the possible <c>ADVF</c> values are relevant for this method. The following table briefly describes the relevant values; a
            more detailed description can be found in the description of the <c>ADVF</c> enumeration.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ADVF_NODATA</term>
            <term>Asks that no data be sent along with the notification.</term>
            </item>
            <item>
            <term>ADVF_ONLYONCE</term>
            <term>
            Causes the advisory connection to be destroyed after the first notification is sent. An implicit call to
            IDataAdviseHolder::Unadvise is made on behalf of the caller to remove the connection.
            </term>
            </item>
            <item>
            <term>ADVF_PRIMEFIRST</term>
            <term>Causes an initial notification to be sent regardless of whether data has changed from its current state.</term>
            </item>
            <item>
            <term>ADVF_DATAONSTOP</term>
            <term>
            When specified with ADVF_NODATA, this flag causes a last notification with the data included to be sent before the data
            object is destroyed. When ADVF_NODATA is not specified, this flag has no effect.
            </term>
            </item>
            </list>
            </param>
            <param name="pAdvise">A pointer to the IAdviseSink interface on the advisory sink that receives the change notification.</param>
            <param name="pdwConnection">
            A pointer to a variable that receives a token that identifies this connection. The calling object can later delete the
            advisory connection by passing this token to IDataAdviseHolder::Unadvise. If this value is zero, the connection was not established.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para>
            Through the connection established through this method, the advisory sink can receive future notifications in a call to IAdviseSink::OnDataChange.
            </para>
            <para>
            An object issues a call to IDataObject::DAdvise to request notification on changes to the format, medium, or target device of
            interest. This data is specified in the pFormatetc parameter. The <c>DAdvise</c> method is usually implemented to call
            <c>IDataAdviseHolder::Advise</c> to delegate the task of setting up and tracking a connection to the advise holder. When the
            format, medium, or target device in question changes, the data object calls IDataAdviseHolder::SendOnDataChange to send the
            necessary notifications.
            </para>
            <para>The established connection can be deleted by passing the value in pdwConnection in a call to IDataAdviseHolder::Unadvise.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDataAdviseHolder.Unadvise(System.UInt32)">
            <summary>
            Removes a connection between a data object and an advisory sink that was set up through a previous call to
            IDataAdviseHolder::Advise. This method is typically called in the implementation of IDataObject::DUnadvise.
            </summary>
            <param name="dwConnection">
            A token that specifies the connection to be removed. This value was returned by IDataAdviseHolder::Advise when the connection
            was originally established.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_NOCONNECTION</term>
            <term>The dwConnection parameter does not specify a valid connection.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDataAdviseHolder.EnumAdvise(System.Runtime.InteropServices.ComTypes.IEnumSTATDATA@)">
            <summary>Returns an object that can be used to enumerate the current advisory connections.</summary>
            <param name="ppenumAdvise">
            A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator object. If the
            implementation returns NULL in *ppenumAdvise, there are no connections to advise sinks at this time.
            </param>
            <returns>This method returns S_OK if the enumerator object is successfully instantiated or there are no connections.</returns>
            <remarks>
            <para>
            This method must supply a pointer to an implementation of the IEnumSTATDATA interface. Its methods allow you to enumerate the
            data stored in an array of STATDATA structures. You get a pointer to the OLE implementation of IDataAdviseHolder through a
            call to CreateDataAdviseHolder, and then call <c>IDataAdviseHolder::EnumAdvise</c> to implement IDataObject::EnumDAdvise.
            </para>
            <para>
            Adding more advisory connections while the enumerator object is active has an undefined effect on the enumeration that
            results from this method.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDataAdviseHolder.SendOnDataChange(System.Runtime.InteropServices.ComTypes.IDataObject,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF)">
            <summary>
            Sends notifications to each advise sink for which there is a connection established by calling the IAdviseSink::OnDataChange
            method for each advise sink currently being handled by this instance of the advise holder object.
            </summary>
            <param name="pDataObject">
            A pointer to the IDataObject interface on the data object in which the data has just changed. This pointer is used in
            subsequent calls to IAdviseSink::OnDataChange.
            </param>
            <param name="dwReserved">This parameter is reserved and must be 0.</param>
            <param name="advf">
            Container for advise flags that specify how the call to IAdviseSink::OnDataChange is made. These flag values are from the
            enumeration ADVF. Typically, the value for advf is <c>NULL</c>. The only exception occurs when the data object is shutting
            down and must send a final notification that includes the actual data to sinks that have specified ADVF_DATAONSTOP and
            ADVF_NODATA in their call to IDataObject::DAdvise. In this case, advf contains ADVF_DATAONSTOP.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para>
            The data object must call this method when it detects a change that would be of interest to an advise sink that has
            previously requested notification.
            </para>
            <para>
            Most notifications include the actual data with them. The only exception is if the ADVF_NODATA flag was previously specified
            when the connection was initially set up in the IDataAdviseHolder::Advise method.
            </para>
            <para>
            Before calling the IAdviseSink::OnDataChange method for each advise sink, this method obtains the actual data by calling the
            IDataObject::GetData method through the pointer specified in the pDataObject parameter.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IDirectWriterLock">
            <summary>
            The <c>IDirectWriterLock</c> interface enables a single writer to obtain exclusive write access to a root storage object opened
            in direct mode while allowing concurrent access by multiple readers. This single-writer, multiple-reader mode does not require
            the overhead of making a snapshot copy of the storage for the readers.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDirectWriterLock.WaitForWriteAccess(System.UInt32)">
            <summary>The <c>WaitForWriteAccess</c> method obtains exclusive write access to a storage object.</summary>
            <param name="dwTimeout">
            Specifies the time in milliseconds that this method blocks while waiting to obtain exclusive write access to the storage
            object. If dwTimeout is zero, the method does not block waiting for exclusive access for writing. The INFINITE time-out
            defined in the Platform SDK is allowed for dwTimeout.
            </param>
            <returns>
            This method can return one of these values.
            <list type="bullet">
            <item>
            <term>S_OK</term>
            <description>The caller has successfully obtained exclusive write access to the storage.</description>
            </item>
            <item>
            <term>S_FALSE</term>
            <description>This method was called again without an intervening call to IDirectWriterLock::ReleaseWriteAccess.</description>
            </item>
            <item>
            <term>STG_E_INUSE</term>
            <description>The specified time-out expired without obtaining exclusive write access.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When a storage is opened in direct mode (STGM_DIRECT) with the STGM_READWRITE|STGM_SHARE_DENY_WRITE, you can call this method
            to obtain exclusive write access to the storage.
            </para>
            <para>
            This method returns immediately if no readers have the storage open. If the storage is still open for reading, this method
            blocks for the specified dwTimeout or until the current readers close the storage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDirectWriterLock.ReleaseWriteAccess">
            <summary>The <c>ReleaseWriteAccess</c> method releases the write lock previously obtained.</summary>
            <remarks>
            <para>The writer calls this method to release exclusive access to the storage object previously taken by calling IDirectWriterLock::WaitForWriteAccess.</para>
            <para>
            After the writer calls this method, it is safe to allow readers to reopen the storage again until the next call to IDirectWriterLock::WaitForWriteAccess.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDirectWriterLock.HaveWriteAccess">
            <summary>The <c>HaveWriteAccess</c> method indicates whether the write lock has been taken.</summary>
            <returns>
            This method can return one of these values.
            <list type="bullet">
            <item>
            <term>S_OK</term>
            <description>The storage object is currently locked for write access.</description>
            </item>
            <item>
            <term>S_FALSE</term>
            <description>The storage object is not currently locked for write access.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumContextProps">
            <summary>Provides a mechanism for enumerating the context properties associated with a COM+ object context.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumContextProps.Next(System.UInt32,Vanara.PInvoke.Ole32.ContextProperty[],System.UInt32@)">
            <summary>Retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">
            The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method
            retrieves the remaining elements.
            </param>
            <param name="pContextProperties">
            <para>An array of enumerated items.</para>
            <para>
            The enumerator is responsible for allocating any memory, and the caller is responsible for freeing it. If celt is greater
            than 1, the caller must also pass a non-NULL pointer passed to pceltFetched to know how many pointers to release.
            </para>
            </param>
            <param name="pceltFetched">
            The number of items that were retrieved. This parameter is always less than or equal to the number of items requested.
            </param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumContextProps.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumContextProps.Reset">
            <summary>
            <para>Resets the enumeration sequence to the beginning.</para>
            </summary>
            <returns>
            <para>The return value is S_OK.</para>
            </returns>
            <remarks>
            <para>
            There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static
            collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to
            guarantee this condition.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumContextProps.Clone">
            <summary>
            <para>Creates a new enumerator that contains the same enumeration state as the current one.</para>
            <para>
            This method makes it possible to record a point in the enumeration sequence in order to return to that point at a later time.
            The caller must release this new enumerator separately from the first enumerator.
            </para>
            </summary>
            <returns>A pointer to the cloned enumerator object.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumContextProps.Count">
            <summary>Retrieves the number of context properties in the context.</summary>
            <returns>The count of items in the sequence.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumSTATSTG">
            <summary>
            The IEnumSTATSTG interface enumerates an array of STATSTG structures. These structures contain statistical data about open
            storage, stream, or byte array objects.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATSTG.Next(System.UInt32,System.Runtime.InteropServices.ComTypes.STATSTG[],System.UInt32@)">
            <summary>
            The Next method retrieves a specified number of STATSTG structures, that follow in the enumeration sequence. If there are
            fewer than the requested number of STATSTG structures that remain in the enumeration sequence, it retrieves the remaining
            STATSTG structures.
            </summary>
            <param name="celt">The number of STATSTG structures requested.</param>
            <param name="rgelt">An array of STATSTG structures returned.</param>
            <param name="pceltFetched">The number of STATSTG structures retrieved in the rgelt parameter.</param>
            <returns>
            This method supports the following return values: S_OK = The number of STATSTG structures returned is equal to the number
            specified in the celt parameter. S_FALSE = The number of STATSTG structures returned is less than the number specified in the
            celt parameter.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATSTG.Skip(System.UInt32)">
            <summary>Skips a specified number of STATSTG structures in the enumeration sequence.</summary>
            <param name="celt">The number of STATSTG structures to skip.</param>
            <returns>
            This method supports the following return values: S_OK = The specified number of STATSTG structures that were successfully
            skipped. S_FALSE = The number of STATSTG structures skipped is less than the celt parameter.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATSTG.Reset">
            <summary>Resets the enumeration sequence to the beginning of the STATSTG structure array.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATSTG.Clone">
            <summary>Creates a new enumerator that contains the same enumeration state as the current STATSTG structure enumerator.</summary>
            <returns>An IEnumSTATSTG interface pointer.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumUnknown">
            <summary>
            Enumerates objects with the IUnknown interface. It can be used to enumerate through the objects in a component containing
            multiple objects.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknown.Next(System.UInt32,System.IntPtr[],System.UInt32@)">
            <summary>Retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">
            The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method
            retrieves the remaining elements.
            </param>
            <param name="rgelt">
            <para>An array of enumerated items.</para>
            <para>
            The enumerator is responsible for calling AddRef, and the caller is responsible for calling Release through each pointer
            enumerated. If celt is greater than 1, the caller must also pass a non-NULL pointer passed to pceltFetched to know how many
            pointers to release.
            </para>
            </param>
            <param name="pceltFetched">
            The number of items that were retrieved. This parameter is always less than or equal to the number of items requested.
            </param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknown.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknown.Reset">
            <summary>Resets the enumeration sequence to the beginning.</summary>
            <remarks>
            There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static
            collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to
            guarantee this condition.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknown.Clone">
            <summary>
            <para>Creates a new enumerator that contains the same enumeration state as the current one.</para>
            <para>
            This method makes it possible to record a point in the enumeration sequence in order to return to that point at a later time.
            The caller must release this new enumerator separately from the first enumerator.
            </para>
            </summary>
            <returns>A pointer to the cloned enumerator object.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IFillLockBytes">
            <summary>
            The <c>IFillLockBytes</c> interface enables downloading code to write data asynchronously to a structured storage byte array.
            When the downloading code has new data available, it calls IFillLockBytes::FillAppend or IFillLockBytes::FillAt to write the data
            to the byte array. An application attempting to access this data, through calls to the ILockBytes interface, can do so even as
            the downloader continues to make calls to <c>IFillLockBytes</c>. If the application attempts to access data that has not already
            been downloaded through a call to <c>IFillLockBytes</c>, then <c>ILockBytes</c> returns a new error, E_PENDING.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IFillLockBytes.FillAppend(System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>The <c>FillAppend</c> method writes a new block of bytes to the end of a byte array.</summary>
            <param name="pv">
            Pointer to the data to be appended to the end of an existing byte array. This operation does not create a danger of a memory
            leak or a buffer overrun.
            </param>
            <param name="cb">Size of pv in bytes.</param>
            <param name="pcbWritten">Number of bytes that were successfully written.</param>
            <remarks>
            The <c>FillAppend</c> method is used for sequential downloading, where bytes are written to the end of the byte array in the
            order in which they are received. This method obtains the current size of the byte array (for example, lockbytes object) and
            writes a new block of data to the end of the array. As each block of data becomes available, the downloader calls this method
            to write it to the byte array. Subsequent calls by the compound file implementation to ILockBytes::ReadAt return any
            available data or return E_PENDING if data is currently unavailable.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IFillLockBytes.FillAt(System.UInt64,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>The <c>FillAt</c> method writes a new block of data to a specified location in the byte array.</summary>
            <param name="ulOffset">The offset, expressed in number of bytes, from the first element of the byte array.</param>
            <param name="pv">Pointer to the data to be written at the location specified by uIOffset.</param>
            <param name="cb">Size of pv in bytes.</param>
            <param name="pcbWritten">Number of bytes that were successfully written.</param>
            <remarks>
            <para>
            The <c>FillAt</c> method is used for nonsequential downloading (for example, HTTP byte range requests). In nonsequential
            downloading the caller specifies ranges in the byte array where various blocks of data are to be written. Subsequent calls by
            the compound file implementation to ILockBytes::ReadAt are passed by the byte array wrapper object's own implementation of
            ILockBytes to the underlying byte array. This method is not currently implemented and will return E_NOTIMPL.
            </para>
            <para><c>Note</c> The system-supplied IFillLockBytes implementation does not support <c>FillAt</c> and returns E_NOTIMPL.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IFillLockBytes.SetFillSize(System.UInt64)">
            <summary>The <c>SetFillSize</c> method sets the expected size of the byte array.</summary>
            <param name="ulSize">Size in bytes of the byte array object that is to be filled in subsequent calls to IFillLockBytes::FillAppend.</param>
            <remarks>
            If <c>SetFillSize</c> has not been called, any call to ILockBytes::ReadAt that attempts to access data that has not yet been
            written using IFillLockBytes::FillAppend or IFillLockBytes::FillAt will return a new error message, E_PENDING. After
            <c>SetFillSize</c> has been called, any call to <c>ReadAt</c> that attempts to access data beyond the current size, as set by
            <c>SetFillSize</c>, returns E_FAIL instead of E_PENDING.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IFillLockBytes.Terminate(System.Boolean)">
            <summary>
            The <c>Terminate</c> method informs the byte array that the download has been terminated, either successfully or unsuccessfully.
            </summary>
            <param name="bCanceled">
            Download is complete. If <c>TRUE</c>, the download was terminated unsuccessfully. If <c>FALSE</c>, the download terminated successfully.
            </param>
            <remarks>After this method has been called, the byte array will no longer return E_PENDING.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IInitializeSpy">
            <summary>Performs initialization or cleanup when entering or exiting a COM apartment.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInitializeSpy.PreInitialize(Vanara.PInvoke.Ole32.COINIT,System.UInt32)">
            <summary>Performs initialization steps required before calling the CoInitializeEx function.</summary>
            <param name="dwCoInit">The apartment type passed to CoInitializeEx, specified as a member of the COINIT enumeration.</param>
            <param name="dwCurThreadAptRefs">The number of times CoInitializeEx has been called on this thread.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInitializeSpy.PostInitialize(Vanara.PInvoke.HRESULT,Vanara.PInvoke.Ole32.COINIT,System.UInt32)">
            <summary>Performs initialization steps required after calling the CoInitializeEx function.</summary>
            <param name="hrCoInit">The value returned by CoInitializeEx.</param>
            <param name="dwCoInit">The apartment type passed to CoInitializeEx, specified as a member of the COINIT enumeration.</param>
            <param name="dwNewThreadAptRefs">The number of times CoInitializeEx has been called on this thread.</param>
            <returns>
            This method returns the value that it intends the CoInitializeEx call to return to its caller. For more information, see the
            Remarks section.
            </returns>
            <remarks>
            <para>
            The return value from <c>PostInitialize</c> is intended to be the returned <c>HRESULT</c> from the call to CoInitializeEx.
            This is always the case for a single active registration on this thread.
            </para>
            <para>
            For cases where there are multiple registrations active on this thread, the returned <c>HRESULT</c> is arrived at by chaining
            of the various <c>PostInitialize</c> methods as follows: The COM determined <c>HRESULT</c> will be passed as the hrCoInit
            parameter to the first <c>PostInitialize</c> method called. The <c>HRESULT</c> from that <c>PostInitialize</c> call will be
            passed as the hrCoInit parameter to the next <c>PostInitialize</c> call. This chaining continues leading to the
            <c>HRESULT</c> from the last <c>PostInitialize</c> call being returned as the <c>HRESULT</c> from the call to CoInitializeEx.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInitializeSpy.PreUninitialize(System.UInt32)">
            <summary>Performs cleanup steps required before calling the CoUninitialize function.</summary>
            <param name="dwCurThreadAptRefs">The number of times CoInitializeEx has been called on this thread.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IInitializeSpy.PostUninitialize(System.UInt32)">
            <summary>Performs cleanup steps required after calling the CoUninitialize function.</summary>
            <param name="dwNewThreadAptRefs">The number of calls to CoUninitialize remaining on this thread.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ILayoutStorage">
            <summary>
            <para>
            The <c>ILayoutStorage</c> interface enables an application to optimize the layout of its compound files for efficient downloading
            across a slow link. The goal is to enable a browser or other application to download data in the order in which it will actually
            be required.
            </para>
            <para>To optimize a compound file, an application calls CopyTo to layout a docfile, thus improving performance in most scenarios.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILayoutStorage.LayoutScript(Vanara.PInvoke.Ole32.StorageLayout[],System.UInt32,System.UInt32)">
            <summary>
            The <c>LayoutScript</c> method provides explicit directions for reordering the storages, streams, and controls in a compound
            file to match the order in which they are accessed during the download.
            </summary>
            <param name="pStorageLayout">Pointer to an array of StorageLayout structures.</param>
            <param name="nEntries">Number of entries in the array of StorageLayout structures.</param>
            <param name="glfInterleavedFlag">Reserved for future use.</param>
            <remarks>
            <para>
            To provide explicit layout instructions, the application calls <c>ILayoutStorage::LayoutScript</c>, passing an array of
            StorageLayout structures. Each structure defines a single storage or stream data block and specifies where the block is to be
            written in the ILockBytes byte array.
            </para>
            <para>An application can combine scripted layout with monitoring, as the structure of a particular compound file may dictate.</para>
            <para>
            When the optimal data-layout pattern of an entire compound file has been determined, the application calls
            ILayoutStorage::ReLayoutDocfile to restructure the compound file to match the order in which its data sectors were accessed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILayoutStorage.BeginMonitor">
            <summary>
            The <c>BeginMonitor</c> method is used to begin monitoring when a loading operation is started. When the operation is
            complete, the application must call ILayoutStorage::EndMonitor.
            </summary>
            <remarks>
            <para>
            Normally an application calls <c>BeginMonitor</c> before the actual loading begins. Once this method has been called, the
            compound file implementation regards any operation performed on the files storages and streams as part of the desired access
            pattern. The result is a layout script like that created explicitly by calling ILayoutStorage::LayoutScript.
            </para>
            <para>
            Applications will usually use monitoring to obtain the access pattern of embedded objects. Monitoring also makes possible
            generic layout tools, that launch existing applications and monitor their access patterns.
            </para>
            <para>
            A call to ILayoutStorage::EndMonitor ends monitoring. Multiple calls to <c>BeginMonitor</c> and <c>EndMonitor</c> are
            permitted. Monitoring can also be mixed with calls to ILayoutStorage::LayoutScript.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILayoutStorage.EndMonitor">
            <summary>The <c>EndMonitor</c> method ends monitoring of a compound file. Must be preceded by a call to ILayoutStorage::BeginMonitor.</summary>
            <remarks>
            A call to <c>EndMonitor</c> is generally followed by a call to ILayoutStorage::RelayoutDocfile, which uses the access pattern
            detected by the monitoring to restructure the compound file.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILayoutStorage.ReLayoutDocfile(System.String)">
            <summary>
            The <c>ReLayoutDocfile</c> method rewrites the compound file, using the layout script obtained through monitoring, or
            provided through explicit layout scripting, to create a new compound file.
            </summary>
            <param name="pwcsNewDfName">
            Pointer to the name of the compound file to be rewritten. This name must be a valid filename, distinct from the name of the
            original compound file. The original compound file will be optimized and written to the new pwcsNewDfName.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILayoutStorage.ReLayoutDocfileOnILockBytes(Vanara.PInvoke.Ole32.ILockBytes)">
            <summary>
            <para>Not supported.</para>
            <para>The <c>ReLayoutDocfileOnILockBytes</c> method is not implemented. If called, it returns <c>STG_E_UNIMPLEMENTEDFUNCTION</c>.</para>
            </summary>
            <param name="pILockBytes">
            A pointer to the ILockBytes interface on the underlying byte-array object where the compound file is to be rewritten.
            </param>
            <remarks>
            If implemented, it would rewrite the compound file in the byte-array object specified by the caller. It would return
            <c>S_OK</c> for success or one of the <c>STG_E_*</c> error codes for failure.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ILockBytes">
            <summary>
            The <c>ILockBytes</c> interface is implemented on a byte array object that is backed by some physical storage, such as a disk
            file, global memory, or a database. It is used by a COM compound file storage object to give its root storage access to the
            physical device, while isolating the root storage from the details of accessing the physical storage.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.ReadAt(System.UInt64,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>
            The <c>ReadAt</c> method reads a specified number of bytes starting at a specified offset from the beginning of the byte
            array object.
            </summary>
            <param name="ulOffset">Specifies the starting point from the beginning of the byte array for reading data.</param>
            <param name="pv">Pointer to the buffer into which the byte array is read. The size of this buffer is contained in cb.</param>
            <param name="cb">Specifies the number of bytes of data to attempt to read from the byte array.</param>
            <param name="pcbRead">
            Pointer to a <c>ULONG</c> where this method writes the actual number of bytes read from the byte array. You can set this
            pointer to <c>NULL</c> to indicate that you are not interested in this value. In this case, this method does not provide the
            actual number of bytes that were read.
            </param>
            <remarks>
            <para>
            <c>ILockBytes::ReadAt</c> reads bytes from the byte array object. It reports the number of bytes that were actually read.
            This value may be less than the number of bytes requested if an error occurs or if the end of the byte array is reached
            during the read.
            </para>
            <para>
            It is not an error to read less than the specified number of bytes if the operation encounters the end of the byte array.
            Note that this is the same end-of-file behavior as found in MS-DOS file allocation table (FAT) file system files.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.WriteAt(System.UInt64,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>
            The <c>WriteAt</c> method writes the specified number of bytes starting at a specified offset from the beginning of the byte array.
            </summary>
            <param name="ulOffset">Specifies the starting point from the beginning of the byte array for the data to be written.</param>
            <param name="pv">Pointer to the buffer containing the data to be written.</param>
            <param name="cb">Specifies the number of bytes of data to attempt to write into the byte array.</param>
            <param name="pcbWritten">
            Pointer to a location where this method specifies the actual number of bytes written to the byte array. You can set this
            pointer to <c>NULL</c> to indicate that you are not interested in this value. In this case, this method does not provide the
            actual number of bytes written.
            </param>
            <remarks>
            <para>
            <c>ILockBytes::WriteAt</c> writes the specified data at the specified location in the byte array. The number of bytes
            actually written must always be returned in pcbWritten, even if an error is returned. If the byte count is zero bytes, the
            write operation has no effect.
            </para>
            <para>
            If ulOffset is past the end of the byte array and cb is greater than zero, <c>ILockBytes::WriteAt</c> increases the size of
            the byte array. The fill bytes written to the byte array are not initialized to any particular value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.Flush">
            <summary>
            The <c>Flush</c> method ensures that any internal buffers maintained by the ILockBytes implementation are written out to the
            underlying physical storage.
            </summary>
            <remarks>
            <para><c>ILockBytes::Flush</c> flushes internal buffers to the underlying storage device.</para>
            <para>
            The COM-provided implementation of compound files calls this method during a transacted commit operation to provide a
            two-phase commit process that protects against loss of data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.SetSize(System.UInt64)">
            <summary>The <c>SetSize</c> method changes the size of the byte array.</summary>
            <param name="cb">Specifies the new size of the byte array as a number of bytes.</param>
            <remarks>
            <para>
            <c>ILockBytes::SetSize</c> changes the size of the byte array. If the cb parameter is larger than the current byte array, the
            byte array is extended to the indicated size by filling the intervening space with bytes of undefined value, as does
            ILockBytes::WriteAt, if the seek pointer is past the current end-of-stream.
            </para>
            <para>If the cb parameter is smaller than the current byte array, the byte array is truncated to the indicated size.</para>
            <para>Notes to Callers</para>
            <para>
            Callers cannot rely on STG_E_MEDIUMFULL being returned at the appropriate time because of cache buffering in the operating
            system or network. However, callers must be able to deal with this return code because some ILockBytes implementations might
            support it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.LockRegion(System.UInt64,System.UInt64,Vanara.PInvoke.Ole32.LOCKTYPE)">
            <summary>The <c>LockRegion</c> method restricts access to a specified range of bytes in the byte array.</summary>
            <param name="libOffset">Specifies the byte offset for the beginning of the range.</param>
            <param name="cb">Specifies, in bytes, the length of the range to be restricted.</param>
            <param name="dwLockType">
            Specifies the type of restrictions being requested on accessing the range. This parameter uses one of the values from the
            LOCKTYPE enumeration.
            </param>
            <remarks>
            <para>
            <c>ILockBytes::LockRegion</c> restricts access to the specified range of bytes. Once a region is locked, attempts by others
            to gain access to the restricted range must fail with the STG_E_ACCESSDENIED error.
            </para>
            <para>
            The byte range can extend past the current end of the byte array. Locking beyond the end of an array is useful as a method of
            communication between different instances of the byte array object without changing data that is actually part of the byte
            array. For example, an implementation of ILockBytes for compound files could rely on locking past the current end of the
            array as a means of access control, using specific locked regions to indicate permissions currently granted.
            </para>
            <para>
            The dwLockType parameter specifies one of three types of locking, using values from the LOCKTYPE enumeration. The types are
            as follows: locking to exclude other writers, locking to exclude other readers or writers, and locking that allows only one
            requester to obtain a lock on the given range. This third type of locking is usually an alias for one of the other two lock
            types, and permits an Implementer to add other behavior as well. A given byte array might support either of the first two
            types, or both.
            </para>
            <para>
            To determine the lock types supported by a particular ILockBytes implementation, you can examine the <c>grfLocksSupported</c>
            member of the STATSTG structure returned by a call to ILockBytes::Stat.
            </para>
            <para>
            Any region locked with <c>ILockBytes::LockRegion</c> must later be explicitly unlocked by calling ILockBytes::UnlockRegion
            with exactly the same values for the libOffset, cb, and dwLockType parameters. The region must be unlocked before the stream
            is released. Two adjacent regions cannot be locked separately and then unlocked with a single unlock call.
            </para>
            <para>Notes to Callers</para>
            <para>
            Since the type of locking supported is optional and can vary in different implementations of ILockBytes, you must provide
            code to deal with the STG_E_INVALIDFUNCTION error.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Support for this method depends on how the storage object built on top of the ILockBytes implementation is used. If you know
            that only one storage object at any given time can be opened on the storage device that underlies the byte array, then your
            <c>ILockBytes</c> implementation does not need to support locking. However, if multiple simultaneous openings of a storage
            object are possible, then region locking is needed to coordinate them.
            </para>
            <para>
            A <c>LockRegion</c> implementation can choose to support all, some, or none of the lock types. For unsupported lock types,
            the implementation should return STG_E_INVALIDFUNCTION.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.UnlockRegion(System.UInt64,System.UInt64,Vanara.PInvoke.Ole32.LOCKTYPE)">
            <summary>The <c>UnlockRegion</c> method removes the access restriction on a previously locked range of bytes.</summary>
            <param name="libOffset">Specifies the byte offset for the beginning of the range.</param>
            <param name="cb">Specifies, in bytes, the length of the range that is restricted.</param>
            <param name="dwLockType">
            Specifies the type of access restrictions previously placed on the range. This parameter uses a value from the LOCKTYPE enumeration.
            </param>
            <remarks>
            <c>ILockBytes::UnlockRegion</c> unlocks a region previously locked with a call to ILockBytes::LockRegion. Each region locked
            must be explicitly unlocked, using the same values for the libOffset, cb, and dwLockType parameters as in the matching calls
            to <c>ILockBytes::LockRegion</c>. Two adjacent regions cannot be locked separately and then unlocked with a single unlock call.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ILockBytes.Stat(System.Runtime.InteropServices.ComTypes.STATSTG@,Vanara.PInvoke.Ole32.STATFLAG)">
            <summary>The <c>Stat</c> method retrieves a STATSTG structure containing information for this byte array object.</summary>
            <param name="pstatstg">
            Pointer to a STATSTG structure in which this method places information about this byte array object. The pointer is
            <c>NULL</c> if an error occurs.
            </param>
            <param name="grfStatFlag">
            Specifies whether this method should supply the <c>pwcsName</c> member of the STATSTG structure through values taken from the
            STATFLAG enumeration. If the STATFLAG_NONAME is specified, the <c>pwcsName</c> member of <c>STATSTG</c> is not supplied, thus
            saving a memory-allocation operation. The other possible value, STATFLAG_DEFAULT, indicates that all members of the
            <c>STATSTG</c> structure be supplied.
            </param>
            <remarks><c>ILockBytes::Stat</c> should supply information about the byte array object in a STATSTG structure.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IMalloc">
            <summary>Allocates, frees, and manages memory.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.Alloc(Vanara.PInvoke.SizeT)">
            <summary>Allocates a block of memory.</summary>
            <param name="cb">The size of the memory block to be allocated, in bytes.</param>
            <returns>
            <para>If the method succeeds, the return value is a pointer to the allocated block of memory. Otherwise, it is <c>NULL</c>.</para>
            <para>
            Applications should always check the return value from this method, even when requesting small amounts of memory, because
            there is no guarantee the memory will be allocated.
            </para>
            </returns>
            <remarks>
            <para>
            The initial contents of the returned memory block are undefined, there is no guarantee that the block has been initialized,
            so you should initialize it in your code. The allocated block may be larger than cb bytes because of the space required for
            alignment and for maintenance information.
            </para>
            <para>
            If cb is zero, <c>Alloc</c> allocates a zero-length item and returns a valid pointer to that item. If there is insufficient
            memory available, <c>Alloc</c> returns <c>NULL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.Realloc(System.IntPtr,Vanara.PInvoke.SizeT)">
            <summary>Changes the size of a previously allocated block of memory.</summary>
            <param name="pv">
            A pointer to the block of memory to be reallocated. This parameter can be <c>NULL</c>, as discussed in the Remarks section below.
            </param>
            <param name="cb">
            The size of the memory block to be reallocated, in bytes. This parameter can be 0, as discussed in the Remarks section below.
            </param>
            <returns>If the method succeeds, the return value is a pointer to the reallocated block of memory. Otherwise, it is <c>NULL</c>.</returns>
            <remarks>
            <para>
            This method reallocates a block of memory, but does not guarantee that its contents are initialized. Therefore, the caller is
            responsible for subsequently initializing the memory. The allocated block may be larger than cb bytes because of the space
            required for alignment and for maintenance information.
            </para>
            <para>
            The pv argument points to the beginning of the block. If pv is <c>NULL</c>, <c>Realloc</c> allocates a new memory block in
            the same way that IMalloc::Alloc does. If pv is not <c>NULL</c>, it should be a pointer returned by a prior call to <c>Alloc</c>.
            </para>
            <para>
            The cb argument specifies the size of the new block, in bytes. The contents of the block are unchanged up to the shorter of
            the new and old sizes, although the new block can be in a different location. Because the new block can be in a different
            memory location, the pointer returned by <c>Realloc</c> is not guaranteed to be the pointer passed through the pv argument.
            If pv is not <c>NULL</c> and cb is zero, the memory pointed to by pv is freed.
            </para>
            <para>
            <c>Realloc</c> returns a void pointer to the reallocated (and possibly moved) block of memory. The return value is
            <c>NULL</c> if the size is zero and the buffer argument is not <c>NULL</c>, or if there is not enough memory available to
            expand the block to the specified size. In the first case, the original block is freed; in the second, the original block is unchanged.
            </para>
            <para>
            The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. To
            get a pointer to a type other than <c>void</c>, use a type cast on the return value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.Free(System.IntPtr)">
            <summary>Frees a previously allocated block of memory.</summary>
            <param name="pv">A pointer to the memory block to be freed. If this parameter is <c>NULL</c>, this method has no effect.</param>
            <remarks>
            This method frees a block of memory previously allocated through a call to IMalloc::Alloc or IMalloc::Realloc. The number of
            bytes freed equals the number of bytes that were allocated. After the call, the block of memory pointed to by pv is invalid
            and can no longer be used.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.GetSize(System.IntPtr)">
            <summary>Retrieves the size of a previously allocated block of memory.</summary>
            <param name="pv">A pointer to the block of memory.</param>
            <returns>The size of the allocated memory block in bytes or, if pv is a <c>NULL</c> pointer, -1.</returns>
            <remarks>
            To get the size in bytes of a memory block, the block must have been previously allocated with IMalloc::Alloc or
            IMalloc::Realloc. The size returned is the actual size of the allocation, which may be greater than the size requested when
            the allocation was made.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.DidAlloc(System.IntPtr)">
            <summary>Determines whether this allocator was used to allocate the specified block of memory.</summary>
            <param name="pv">A pointer to the block of memory. If this parameter is a <c>NULL</c> pointer, -1 is returned.</param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>1</term>
            <term>The block of memory was allocated by this allocator.</term>
            </item>
            <item>
            <term>0</term>
            <term>The block of memory was not allocated by this allocator.</term>
            </item>
            <item>
            <term>-1</term>
            <term>This method cannot determine whether this allocator allocated the block of memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMalloc.HeapMinimize">
            <summary>
            Minimizes the heap as much as possible by releasing unused memory to the operating system, coalescing adjacent free blocks,
            and committing free pages.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IMallocSpy">
            <summary>
            Enables application developers to monitor (spy on) memory allocation, detect memory leaks, and simulate memory failure in calls
            to IMalloc methods.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreAlloc(Vanara.PInvoke.SizeT)">
            <summary>Performs operations required before calling IMalloc::Alloc.</summary>
            <param name="cbRequest">The number of bytes specified in the allocation request the caller is passing to Alloc.</param>
            <returns>The number of bytes specified in the call to Alloc, which can be greater than or equal to the value of cbRequest.</returns>
            <remarks>
            <para>
            The <c>PreAlloc</c> implementation may extend and/or modify the allocation to store debug-specific information with the allocation.
            </para>
            <para>
            <c>PreAlloc</c> can force memory allocation failure by returning 0, allowing testing to ensure that the application handles
            allocation failure gracefully in all cases. In this case, IMallocSpy::PostAlloc is not called and Alloc returns <c>NULL</c>.
            Forcing allocation failure is effective only if cbRequest is not equal to 0. If <c>PreAlloc</c> is forcing failure by
            returning <c>NULL</c>, <c>PostAlloc</c> is not called. However, <c>Alloc</c> encounters a real memory failure and returns
            <c>NULL</c>, <c>PostAlloc</c> is called.
            </para>
            <para>The call to <c>PreAlloc</c> through the return from PostAlloc is guaranteed to be thread-safe.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostAlloc(System.IntPtr)">
            <summary>Performs operations required after calling IMalloc::Alloc.</summary>
            <param name="pActual">The pointer returned from Alloc.</param>
            <returns>
            This method returns a pointer to the beginning of the block of memory actually allocated. This pointer is also returned to
            the caller of Alloc. If debug information is written at the front of the caller's allocation, this should be a forward offset
            from pActual. The value is the same as pActual if debug information is appended or if no debug information is attached.
            </returns>
            <remarks>
            When a spy object implementing IMallocSpy is registered using the CoRegisterMallocSpy function, COM calls <c>PostAlloc</c>
            after any call to Alloc. It takes as input a pointer to the allocation done by the call to <c>Alloc</c>, and returns a
            pointer to the beginning of the total allocation, which could include a forward offset from the other value if
            IMallocSpy::PreAlloc was implemented to attach debug information to the allocation in this way. If not, the same pointer is
            returned and also becomes the return value to the caller of <c>Alloc</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreFree(System.IntPtr,System.Boolean)">
            <summary>
            Performs operations required before calling IMalloc::Free. This method ensures that the pointer passed to <c>Free</c> points
            to the beginning of the actual allocation.
            </summary>
            <param name="pRequest">A pointer to the block of memory that the caller is passing to Free.</param>
            <param name="fSpyed">Indicates whether the block of memory to be freed was allocated while the current spy was active.</param>
            <returns>The value to be passed to IMalloc::Free.</returns>
            <remarks>
            If IMallocSpy::PreAlloc modified the original allocation request passed to IMalloc::Alloc (or IMalloc::Realloc),
            <c>PreFree</c> must supply a pointer to the actual allocation, which COM will pass to IMalloc::Free. For example, if the
            <c>PreAlloc</c>/PostAlloc pair attached a header used to store debug information to the beginning of the caller's allocation,
            <c>PreFree</c> must return a pointer to the beginning of this header so that all of the block that was allocated can be freed.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostFree(System.Boolean)">
            <summary>Performs operations required after calling IMalloc::Free.</summary>
            <param name="fSpyed">Indicates whether the block of memory to be freed was allocated while the current spy was active.</param>
            <returns>This method does not return a value.</returns>
            <remarks>
            When a spy object implementing IMallocSpy is registered using CoRegisterMallocSpy function, COM calls this method immediately
            after any call to IMalloc::Free. This method is included for completeness and consistencyâ€”it is not anticipated that
            developers will implement significant functionality in this method.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreRealloc(System.IntPtr,Vanara.PInvoke.SizeT,System.IntPtr@,System.Boolean)">
            <summary>Performs operations required before calling IMalloc::Realloc.</summary>
            <param name="pRequest">The pointer to the block of memory specified in the call to IMalloc::Realloc.</param>
            <param name="cbRequest">The byte count of the block of memory as specified in the original call to IMalloc::Realloc.</param>
            <param name="ppNewRequest">
            Address of pointer variable that receives a pointer to the memory block to be reallocated. This may be different from the
            pointer in pRequest if the implementation of <c>PreRealloc</c> extends or modifies the reallocation. This is pointer should
            always be stored by <c>PreRealloc</c>.
            </param>
            <param name="fSpyed">Indicates whether the block of memory was allocated while this spy was active.</param>
            <returns>The byte count to be passed to IMalloc::Realloc.</returns>
            <remarks>
            <para>
            The <c>PreRealloc</c> implementation may extend and/or modify the allocation to store debug-specific information with the
            allocation. Thus, the ppNewRequest parameter may differ from pRequest, a pointer to the request specified in the original
            call to Realloc.
            </para>
            <para>
            <c>PreRealloc</c> can force memory allocation failure by returning 0, allowing testing to ensure that the application handles
            allocation failure gracefully in all cases. In this case, PostRealloc is not called and Realloc returns <c>NULL</c>. However,
            if <c>Realloc</c> encounters a real memory failure and returns <c>NULL</c>, <c>PostRealloc</c> is called. Forcing allocation
            failure is effective only if cbRequest is not equal to 0.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostRealloc(System.IntPtr,System.Boolean)">
            <summary>Performs operations required after calling IMalloc::Realloc.</summary>
            <param name="pActual">The pointer specified in the call to Realloc.</param>
            <param name="fSpyed">Indicates whether the block of memory was allocated while the current spy was active.</param>
            <returns>
            The method returns a pointer to the beginning of the block actually allocated. This pointer is also returned to the caller of
            IMalloc::Realloc. If debug information is written at the front of the caller's allocation, it should be a forward offset from
            pActual. The value should be the same as pActual if debug information is appended or if no debug information is attached.
            </returns>
            <remarks>
            If memory is successfully reallocated while the spy is active, fSpyed will be <c>TRUE</c> in subsequent calls to IMallocSpy
            methods that track the reallocated memory, even if fSpyed was previously <c>FALSE</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreGetSize(System.IntPtr,System.Boolean)">
            <summary>Performs operations required before calling IMalloc::GetSize.</summary>
            <param name="pRequest">The pointer that the caller is passing to GetSize.</param>
            <param name="fSpyed">Indicates whether the block of memory was allocated while the current spy was active.</param>
            <returns>A pointer to the actual allocation for which the size is to be determined.</returns>
            <remarks>
            <para>
            The <c>PreGetSize</c> method receives as its pRequest parameter the pointer the caller is passing to IMalloc::GetSize. It
            must then return a pointer to the actual allocation, which may have altered pRequest in the implementation of either the
            PreAlloc or the PreRealloc method of IMallocSpy. The pointer to the true allocation is then passed to <c>GetSize</c> as its
            pv parameter.
            </para>
            <para>IMalloc::GetSize then returns the size determined, and COM passes this value to IMallocSpy::PostGetSize in cbActual.</para>
            <para>
            The size determined by GetSize is the value returned by the HeapSize function. This is the size originally requested. For
            example, a memory allocation request of 27 bytes returns an allocation of 32 bytes and <c>GetSize</c> returns 27.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostGetSize(Vanara.PInvoke.SizeT,System.Boolean)">
            <summary>Performs operations required after calling IMalloc::GetSize.</summary>
            <param name="cbActual">The number of bytes in the allocation, as returned by GetSize.</param>
            <param name="fSpyed">Indicates whether the block of memory was allocated while the current spy was active.</param>
            <returns>The value returned by IMalloc::GetSize, which is the size of the allocated block of memory, in bytes.</returns>
            <remarks>
            The size determined by GetSize is the value returned by the HeapSize function. This is the size originally requested. For
            example, a memory allocation request of 27 bytes returns an allocation of 32 bytes and <c>GetSize</c> returns 27.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreDidAlloc(System.IntPtr,System.Boolean)">
            <summary>Performs operations required before calling IMalloc::DidAlloc.</summary>
            <param name="pRequest">The pointer specified in the call to DidAlloc.</param>
            <param name="fSpyed">Indicates whether the allocation was done while this spy was active.</param>
            <returns>The value passed to DidAlloc as the fActual parameter.</returns>
            <remarks>
            When a spy object implementing IMallocSpy is registered with the CoRegisterMallocSpy function, COM calls this method
            immediately before any call to IMalloc::DidAlloc. This method is included for completeness and consistencyâ€”it is not
            anticipated that developers will implement significant functionality in this method.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostDidAlloc(System.IntPtr,System.Boolean,System.Int32)">
            <summary>Performs operations required after calling IMalloc::DidAlloc.</summary>
            <param name="pRequest">The pointer specified in the call to DidAlloc.</param>
            <param name="fSpyed">Indicates whether the allocation was done while this spy was active.</param>
            <param name="fActual">The value returned by DidAlloc.</param>
            <returns>The value returned to the caller of DidAlloc.</returns>
            <remarks>
            <para>
            When a spy object implementing IMallocSpy is registered using the CoRegisterMallocSpy function, COM calls this method
            immediately after any call to DidAlloc. This method is included for completeness and consistencyâ€”it is not anticipated that
            developers will implement significant functionality in this method.
            </para>
            <para>
            For convenience, pRequest, the original pointer passed in the call to DidAlloc, is passed to <c>PostDidAlloc</c>. In
            addition, the parameter fActual is a Boolean value that indicates whether this value was actually passed to <c>DidAlloc</c>.
            If not, it would indicate that IMallocSpy::PreDidAlloc was implemented to alter this pointer for some debugging purpose.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PreHeapMinimize">
            <summary>Performs operations required before calling IMalloc::HeapMinimize.</summary>
            <returns>This method does not return a value.</returns>
            <remarks>
            This method is included for completeness; it is not anticipated that developers will implement significant functionality in
            this method.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMallocSpy.PostHeapMinimize">
            <summary>Performs operations required after calling IMalloc::HeapMinimize.</summary>
            <returns>This method does not return a value.</returns>
            <remarks>
            When a spy object implementing IMallocSpy is registered using the CoRegisterMallocSpy function, COM calls this method
            immediately after any call to IMalloc::Free. This method is included for completeness and consistencyâ€”it is not anticipated
            that developers will implement significant functionality in this method.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IMarshal">
            <summary>Enables a COM object to define and manage the marshaling of its interface pointers.</summary>
            <remarks>
            <para>
            Marshaling is the process of packaging data into packets for transmission to a different process or computer. Unmarshaling is the
            process of recovering that data at the receiving end. In any given call, method arguments are marshaled and unmarshaled in one
            direction, while return values are marshaled and unmarshaled in the other.
            </para>
            <para>
            Although marshaling applies to all data types, interface pointers require special handling. The fundamental problem is how client
            code running in one address space can correctly dereference a pointer to an interface on an object residing in a different
            address space. The COM solution is for a client application to communicate with the original object through a surrogate object,
            or proxy, which lives in the client's process. The proxy holds a reference to an interface on the original object and hands the
            client a pointer to an interface on itself. When the client calls an interface method on the original object, its call is
            actually going to the proxy. Therefore, from the client's point of view, all calls are in-process.
            </para>
            <para>
            On receiving a call, the proxy marshals the method arguments and through some means of interprocess communication, such as RPC,
            passes them along to code in the server process, which unmarshals the arguments and passes them to the original object. This same
            code marshals return values for transmission back to the proxy, which unmarshals the values and passes them to the client application.
            </para>
            <para>
            <c>IMarshal</c> provides methods for creating, initializing, and managing a proxy in a client process; it does not dictate how
            the proxy should communicate with the original object. The COM default implementation of <c>IMarshal</c> uses RPC. When you
            implement this interface yourself, you are free to choose any method of interprocess communication you deem to be appropriate for
            your application—shared memory, named pipe, window handle, RPC—in short, whatever works.
            </para>
            <para>IMarshal Default Implementation</para>
            <para>
            COM uses its own internal implementation of the <c>IMarshal</c> interface to marshal any object that does not provide its own
            implementation. COM makes this determination by querying the object for <c>IMarshal</c>. If the interface is missing, COM
            defaults to its internal implementation.
            </para>
            <para>
            The COM default implementation of <c>IMarshal</c> uses a generic proxy for each object and creates individual stubs and proxies,
            as they are needed, for each interface implemented on the object. This mechanism is necessary because COM cannot know in advance
            what particular interfaces a given object may implement. Developers who do not use COM default marshaling, electing instead to
            write their own proxy and marshaling routines, know at compile time all the interfaces to be found on their objects and therefore
            understand exactly what marshaling code is required. COM, in providing marshaling support for all objects, must do so at run time.
            </para>
            <para>
            The interface proxy resides in the client process; the interface stub resides in the server. Together, each pair handles all
            marshaling for the interface. The job of each interface proxy is to marshal arguments and unmarshal return values and out
            parameters that are passed back and forth in subsequent calls to its interface. The job of each interface stub is to unmarshal
            function arguments and pass them along to the original object and then marshal the return values and out parameters that the
            object returns.
            </para>
            <para>
            Proxy and stub communicate by means of an RPC (remote procedure call) channel, which utilizes the system's RPC infrastructure for
            interprocess communication. The RPC channel implements a single interface, IRpcChannelBuffer, to which both interface proxies and
            stubs hold a pointer. The proxy and stub call the interface to obtain a marshaling packet, send the data to their counterpart,
            and destroy the packet when they are done. The interface stub also holds a pointer to the original object.
            </para>
            <para>
            For any given interface, the proxy and stub are both implemented as instances of the same class, which is listed for each
            interface in the system registry under the label <c>ProxyStubClsid32</c>. This entry maps the interface's IID to the <c>CLSID</c>
            of its proxy and stub objects. When COM needs to marshal an interface, it looks in the system registry to obtain the appropriate
            <c>CLSID</c>. The server identified by this <c>CLSID</c> implements both the interface proxy and interface stub.
            </para>
            <para>
            Most often, the class to which this <c>CLSID</c> refers is automatically generated by a tool whose input is a description of the
            function signatures and semantics of a given interface, written in some interface description language. While using such a
            language is highly recommended and encouraged for accuracy's sake, doing so is not required. Proxies and stubs are merely COM
            components used by the RPC infrastructure and, as such, can be written in any manner desired, as long as the correct external
            contracts are upheld. The programmer who designs a new interface is responsible for ensuring that all interface proxies and stubs
            that ever exist agree on the representation of their marshaled data.
            </para>
            <para>
            When created, interface proxies are always aggregated into a larger proxy, which represents the object as a whole. This object
            proxy also aggregates the COM generic proxy object, which is known as the proxy manager. The proxy manager implements two
            interfaces: IUnknown and <c>IMarshal</c>. All of the other interfaces that may be implemented on an object are exposed in its
            object proxy through the aggregation of individual interface proxies. A client holding a pointer to the object proxy "believes"
            it holds a pointer to the actual object.
            </para>
            <para>
            A proxy representing the object as a whole is required in the client process so that a client can distinguish calls to the same
            interfaces implemented on entirely different objects. Such a requirement does not exist in the server process, however, where the
            object itself resides, because all interface stubs communicate only with the objects for which they were created. No other
            connection is possible.
            </para>
            <para>
            Interface stubs, by contrast with interface proxies, are not aggregated because there is no need that they appear to some
            external client to be part of a larger whole. When connected, an interface stub is given a pointer to the server object to which
            it should forward method invocations that it receives. Although it is useful to refer conceptually to a stub manager, meaning
            whatever pieces of code and state in the server-side RPC infrastructure that service the remoting of a given object, there is no
            direct requirement that the code and state take any particular, well-specified form.
            </para>
            <para>
            The first time a client requests a pointer to an interface on a particular object, COM loads an IClassFactory stub in the server
            process and uses it to marshal the first pointer back to the client. In the client process, COM loads the generic proxy for the
            class factory object and calls its implementation of <c>IMarshal</c> to unmarshal that first pointer. COM then creates the first
            interface proxy and hands it a pointer to the RPC channel. Finally, COM returns the <c>IClassFactory</c> pointer to the client,
            which uses it to call IClassFactory::CreateInstance, passing it a reference to the interface.
            </para>
            <para>
            Back in the server process, COM now creates a new instance of the object, along with a stub for the requested interface. This
            stub marshals the interface pointer back to the client process, where another object proxy is created, this time for the object
            itself. Also created is a proxy for the requested interface, a pointer to which is returned to the client. With subsequent calls
            to other interfaces on the object, COM will load the appropriate interface stubs and proxies as needed.
            </para>
            <para>
            When a new interface proxy is created, COM hands it a pointer to the proxy manager's implementation of IUnknown, to which it
            delegates all QueryInterface calls. Each interface proxy implements two interfaces of its own: the interface it represents and
            IRpcProxyBuffer. The interface proxy exposes its own interface directly to clients, which can obtain its pointer by calling
            <c>QueryInterface</c> on the proxy manager. Only COM, however, can call <c>IRpcProxyBuffer</c>, which is used to connect and
            disconnect the proxy to the RPC channel. A client cannot query an interface proxy to obtain a pointer to the
            <c>IRpcProxyBuffer</c> interface.
            </para>
            <para>
            On the server side, each interface stub implements IRpcStubBuffer. The server code acting as a stub manager calls
            IRpcStubBuffer::Connect and passes the interface stub the IUnknown pointer of its object.
            </para>
            <para>
            When an interface proxy receives a method invocation, it obtains a marshaling packet from its RPC channel through a call to
            IRpcChannelBuffer::GetBuffer. The process of marshaling the arguments will copy data into the buffer. When marshaling is
            complete, the interface proxy invokes IRpcChannelBuffer::SendReceive to send the marshaled packet to the corresponding interface
            stub. When <c>IRpcChannelBuffer::SendReceive</c> returns, the buffer into which the arguments were marshaled will have been
            replaced by a new buffer containing the return values marshaled from the interface stub. The interface proxy unmarshals the
            return values, invokes IRpcChannelBuffer::FreeBuffer to free the buffer, and then returns the return values to the original
            caller of the method.
            </para>
            <para>
            It is the implementation of IRpcChannelBuffer::SendReceive that actually sends the request to the server process and that knows
            how to identify the server process and, within that process, the object to which the request should be sent. The channel
            implementation also knows how to forward the request on to the appropriate stub manager in that process. The interface stub
            unmarshals the arguments from the provided buffer, invokes the indicated method on the server object, and marshals the return
            values back into a new buffer allocated by a call to IRpcChannelBuffer::GetBuffer. The channel then transmits the return data
            packet back to the interface proxy, which is still in the middle of <c>IRpcChannelBuffer::SendReceive</c>, which returns to the
            interface proxy.
            </para>
            <para>
            A particular instance of an interface proxy can be used to service more than one interface, as long as the following conditions
            are met:
            </para>
            <list type="bullet">
            <item>
            <term>The IIDs of the affected interfaces must be mapped to the appropriate ProxyStubClsid in the system registry.</term>
            </item>
            <item>
            <term>
            The interface proxy must support calls to QueryInterface from one supported interface to the other interfaces, as usual, as well
            as from IUnknown and IRpcProxyBuffer.
            </term>
            </item>
            </list>
            <para>
            A single instance of an interface stub can also service more than one interface, but only if that set of interfaces has a strict
            single-inheritance relationship. This restriction exists because the stub can direct method invocations to multiple interfaces
            only where it knows in advance which methods are implemented on which interfaces.
            </para>
            <para>
            At various times, proxies and stubs will have need to allocate or free memory. Interface proxies, for example, will need to
            allocate memory in which to return out parameters to their caller. In this respect, interface proxies and interface stubs are
            just normal COM components, in that they should use the standard task allocator. (See CoGetMalloc.)
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.GetUnmarshalClass(System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS)">
            <summary>Retrieves the CLSID of the unmarshaling code.</summary>
            <param name="riid">A reference to the identifier of the interface to be marshaled.</param>
            <param name="pv">
            A pointer to the interface to be marshaled; can be <c>NULL</c> if the caller does not have a pointer to the desired interface.
            </param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. Possible values come from the enumeration MSHCTX.
            Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same
            computer as the current process (MSHCTX_LOCAL).
            </param>
            <param name="pvDestContext">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="mshlflags">
            Indicates whether the data to be marshaled is to be transmitted back to the client process, the typical caseâ€”or written to
            a global table, where it can be retrieved by multiple clients. Possible values come from the MSHLFLAGS enumeration.
            </param>
            <returns>A pointer that receives the CLSID to be used to create a proxy in the client process.</returns>
            <remarks>
            <para>
            This method is called indirectly, in a call to CoMarshalInterface, by whatever code in the server process is responsible for
            marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several
            interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the
            IClassFactory and IOleItemContainer interfaces. For purposes of discussion, the code responsible for marshaling a pointer is
            called the marshaling stub.
            </para>
            <para>
            To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be
            written to the marshaling stream and the proxy's CLSID.
            </para>
            <para>The marshaling stub obtains these two pieces of information with successive calls to CoGetMarshalSizeMax and CoMarshalInterface.</para>
            <para>Notes to Callers</para>
            <para>
            The marshaling stub calls the object's implementation of this method to obtain the CLSID to be used in creating an instance
            of the proxy. The client, upon receiving the CLSID, loads the DLL listed for it in the system registry.
            </para>
            <para>
            You do not explicitly call this method if you are implementing existing COM interfaces or using the Microsoft Interface
            Definition Language (MIDL) to define your own interfaces. In either case, the stub automatically makes the call. See Defining
            COM Interfaces.
            </para>
            <para>
            If you are not using MIDL to define your own interface, your stub must call this method, either directly or indirectly, to
            get the CLSID that the client-side COM library needs to create a proxy for the object implementing the interface.
            </para>
            <para>
            If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the pv parameter to
            pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the
            proxy does not have to call QueryInterface on itself. If a caller does not have a pointer to the interface to be marshaled,
            it can pass <c>NULL</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>
            COM calls <c>GetUnmarshalClass</c> to obtain the CLSID to be used for creating a proxy in the client process. The CLSID to be
            used for a proxy is normally not that of the original object, but one you will have generated (using the Guidgen.exe tool)
            specifically for your proxy object.
            </para>
            <para>
            Implement this method for each object that provides marshaling for one or more of its interfaces. The code responsible for
            marshaling the object writes the CLSID, along with the marshaling data, to a stream; COM extracts the CLSID and data from the
            stream on the receiving side.
            </para>
            <para>
            If your proxy implementation consists simply of copying the entire original object into the client process, thereby
            eliminating the need to forward calls to the original object, the CLSID returned would be the same as that of the original
            object. This strategy, of course, is advisable only for objects that are not expected to change.
            </para>
            <para>
            If the pv parameter is <c>NULL</c> and your implementation needs an interface pointer, it can call QueryInterface on the
            current object to get it. The pv parameter exists merely to improve efficiency.
            </para>
            <para>
            To ensure that your implementation of <c>GetUnmarshalClass</c> continues to work properly as new destination contexts are
            supported in the future, delegate marshaling to the COM default implementation for all dwDestContext values that your
            implementation does not handle. To delegate marshaling to the COM default implementation, call the CoGetStandardMarshal function.
            </para>
            <para>
            <c>Note</c> The <c>ThreadingModel</c> registry value must be <c>Both</c> for an in-process server that implements the CLSID
            returned from the <c>GetUnmarshalClass</c> method. For more information, see InprocServer32.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.GetMarshalSizeMax(System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS)">
            <summary>Retrieves the maximum size of the buffer that will be needed during marshaling.</summary>
            <param name="riid">A reference to the identifier of the interface to be marshaled.</param>
            <param name="pv">The interface pointer to be marshaled. This parameter can be <c>NULL</c>.</param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. Possible values come from the enumeration MSHCTX.
            Unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or in another process on the same
            computer as the current process (MSHCTX_LOCAL).
            </param>
            <param name="pvDestContext">This parameter is reserved and must be <c>NULL</c>.</param>
            <param name="mshlflags">
            Indicates whether the data to be marshaled is to be transmitted back to the client processâ€”the typical caseâ€”or written to
            a global table, where it can be retrieved by multiple clients. Possible values come from the MSHLFLAGS enumeration.
            </param>
            <returns>A pointer to a variable that receives the maximum size of the buffer.</returns>
            <remarks>
            <para>
            This method is called indirectly, in a call to CoGetMarshalSizeMax, by whatever code in the server process is responsible for
            marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several
            interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the
            IClassFactory and IOleItemContainer interfaces. For purposes of discussion, the code responsible for marshaling a pointer is
            called the marshaling stub.
            </para>
            <para>
            To create a proxy for an object, COM requires two pieces of information from the original object: the amount of data to be
            written to the marshaling stream and the proxy's CLSID.
            </para>
            <para>The marshaling stub obtains these two pieces of information with successive calls to CoGetMarshalSizeMax and CoMarshalInterface.</para>
            <para>Notes to Callers</para>
            <para>
            The marshaling stub, through a call to CoGetMarshalSizeMax, calls the object's implementation of this method to preallocate
            the stream buffer that will be passed to MarshalInterface.
            </para>
            <para>
            You do not explicitly call this method if you are implementing existing COM interfaces or using the Microsoft Interface
            Definition Language (MIDL) to define your own custom interfaces. In either case, the MIDL-generated stub automatically makes
            the call.
            </para>
            <para>
            If you are not using MIDL to define your own interface (see Defining COM Interfaces), your marshaling stub does not have to
            call <c>GetMarshalSizeMax</c>, although doing so is highly recommended. An object knows better than an interface stub what
            the maximum size of a marshaling data packet is likely to be. Therefore, unless you are providing an automatically growing
            stream that is so efficient that the overhead of expanding it is insignificant, you should call this method even when
            implementing your own interfaces.
            </para>
            <para>
            The value returned by this method is guaranteed to be valid only as long as the internal state of the object being marshaled
            does not change. Therefore, the actual marshaling should be done immediately after this function returns, or the stub runs
            the risk that the object, because of some change in state, might require more memory to marshal than it originally indicated.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Your implementation of MarshalInterface will use the preallocated buffer to write marshaling data into the stream. If the
            buffer is too small, the marshaling operation will fail. Therefore, the value returned by this method must be a conservative
            estimate of the amount of data that will be needed to marshal the interface. Violation of this requirement should be treated
            as a catastrophic error.
            </para>
            <para>
            In a subsequent call to MarshalInterface, your IMarshal implementation cannot rely on the caller actually having called
            <c>GetMarshalSizeMax</c> beforehand. It must still be wary of STG_E_MEDIUMFULL errors returned by the stream and be prepared
            to handle them gracefully.
            </para>
            <para>
            To ensure that your implementation of <c>GetMarshalSizeMax</c> will continue to work properly as new destination contexts are
            supported in the future, delegate marshaling to the COM default implementation for all dwDestContext values that your
            implementation does not understand. To delegate marshaling to the COM default implementation, call the CoGetStandardMarshal function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.MarshalInterface(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@,System.Object,Vanara.PInvoke.Ole32.MSHCTX,System.IntPtr,Vanara.PInvoke.Ole32.MSHLFLAGS)">
            <summary>Marshals an interface pointer.</summary>
            <param name="pStm">A pointer to the stream to be used during marshaling.</param>
            <param name="riid">
            A reference to the identifier of the interface to be marshaled. This interface must be derived from the IUnknown interface.
            </param>
            <param name="pv">
            A pointer to the interface pointer to be marshaled. This parameter can be <c>NULL</c> if the caller does not have a pointer
            to the desired interface.
            </param>
            <param name="dwDestContext">
            The destination context where the specified interface is to be unmarshaled. Possible values for dwDestContext come from the
            enumeration MSHCTX. Currently, unmarshaling can occur either in another apartment of the current process (MSHCTX_INPROC) or
            in another process on the same computer as the current process (MSHCTX_LOCAL).
            </param>
            <param name="pvDestContext">This parameter is reserved and must be 0.</param>
            <param name="mshlflags">
            Indicates whether the data to be marshaled is to be transmitted back to the client process—the typical case—or written to a
            global table, where it can be retrieved by multiple clients. Possible values come from the MSHLFLAGS enumeration.
            </param>
            <remarks>
            <para>
            This method is called indirectly, in a call to CoMarshalInterface, by whatever code in the server process is responsible for
            marshaling a pointer to an interface on an object. This marshaling code is usually a stub generated by COM for one of several
            interfaces that can marshal a pointer to an interface implemented on an entirely different object. Examples include the
            IClassFactory and IOleItemContainer interfaces. For purposes of discussion, the code responsible for marshaling a pointer is
            called the marshaling stub.
            </para>
            <para>Notes to Callers</para>
            <para>
            Typically, rather than calling <c>MarshalInterface</c> directly, your marshaling stub instead should call the
            CoMarshalInterface function, which contains a call to this method. The stub makes this call to command an object to write its
            marshaling data into a stream. The stub then either passes the marshaling data back to the client process or writes it to a
            global table, where it can be unmarshaled by multiple clients. The stub's call to <c>CoMarshalInterface</c> is normally
            preceded by a call to CoGetMarshalSizeMax to get the maximum size of the stream buffer into which the marshaling data will be written.
            </para>
            <para>
            You do not explicitly call this method if you are implementing existing COM interfaces or defining your own interfaces using
            the Microsoft Interface Definition Language (MIDL). In either case, the MIDL-generated stub automatically makes the call.
            </para>
            <para>
            If you are not using MIDL to define your own interface, your marshaling stub must call this method, either directly or
            indirectly. Your stub implementation should call <c>MarshalInterface</c> immediately after its previous call to
            IMarshal::GetMarshalSizeMax returns. Because the value returned by <c>GetMarshalSizeMax</c> is guaranteed to be valid only as
            long as the internal state of the object being marshaled does not change, a delay in calling <c>MarshalInterface</c> runs the
            risk that the object will require a larger stream buffer than originally indicated.
            </para>
            <para>
            If the caller has a pointer to the interface to be marshaled, it should, as a matter of efficiency, use the pv parameter to
            pass that pointer. In this way, an implementation that may use such a pointer to determine the appropriate CLSID for the
            proxy does not have to call QueryInterface on itself. If a caller does not have a pointer to the interface to be marshaled,
            it can pass <c>NULL</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Your implementation of <c>MarshalInterface</c> must write to the stream whatever data is needed to initialize the proxy on
            the receiving side. Such data would include a reference to the interface to be marshaled, a MSHLFLAGS value specifying
            whether the data should be returned to the client process or written to a global table, and whatever is needed to connect to
            the object, such as a named pipe, handle to a window, or pointer to an RPC channel.
            </para>
            <para>
            Your implementation should not assume that the stream is large enough to hold all the data. Rather, it should gracefully
            handle a STG_E_MEDIUMFULL error. Just before exiting, your implementation should position the seek pointer in the stream
            immediately after the last byte of data written.
            </para>
            <para>
            If the pv parameter is <c>NULL</c> and your implementation needs an interface pointer, it can call QueryInterface on the
            current object to get it. The pv parameter exists merely to improve efficiency.
            </para>
            <para>
            To ensure that your implementation of <c>MarshalInterface</c> continues to work properly as new destination contexts are
            supported in the future, delegate marshaling to the COM default implementation for all dwDestContext values that your
            implementation does not handle. To delegate marshaling to the COM default implementation, call the CoGetStandardMarshal
            helper function.
            </para>
            <para>
            Using the MSHLFLAGS enumeration, callers can specify whether an interface pointer is to be marshaled back to a single client
            or written to a global table, where it can be unmarshaled by multiple clients. You must make sure that your object can handle
            calls from the multiple proxies that might be created from the same initialization data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.UnmarshalInterface(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@)">
            <summary>Unmarshals an interface pointer.</summary>
            <param name="pStm">A pointer to the stream from which the interface pointer is to be unmarshaled.</param>
            <param name="riid">A reference to the identifier of the interface to be unmarshaled.</param>
            <returns>
            The address of pointer variable that receives the interface pointer. Upon successful return, *ppv contains the requested
            interface pointer of the interface to be unmarshaled.
            </returns>
            <remarks>
            <para>The COM library in the process where unmarshaling is to occur calls the proxy's implementation of this method.</para>
            <para>Notes to Callers</para>
            <para>
            You do not call this method directly. There are, however, some situations in which you might call it indirectly through a
            call to CoUnmarshalInterface. For example, if you are implementing a stub, your implementation would call
            <c>CoUnmarshalInterface</c> when the stub receives an interface pointer as a parameter in a method call.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The proxy's implementation should read the data written to the stream by the original object's implementation of
            IMarshal::MarshalInterface and use that data to initialize the proxy object whose CLSID was returned by the marshaling stub's
            call to the original object's implementation of IMarshal::GetUnmarshalClass.
            </para>
            <para>
            To return the appropriate interface pointer, the proxy implementation can simply call QueryInterface on itself, passing the
            riid and ppv parameters. However, your implementation of <c>UnmarshalInterface</c> is free to create a different object and,
            if necessary, return a pointer to it.
            </para>
            <para>
            Just before exiting, even if exiting with an error, your implementation should reposition the seek pointer in the stream
            immediately after the last byte of data read.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.ReleaseMarshalData(System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>Destroys a marshaled data packet.</summary>
            <param name="pStm">A pointer to a stream that contains the data packet to be destroyed.</param>
            <remarks>
            <para>
            If an object's marshaled data packet does not get unmarshaled in the client process space and the packet is no longer needed,
            the client calls <c>ReleaseMarshalData</c> on the proxy's IMarshal implementation to instruct the object to destroy the data
            packet. The call occurs within the CoReleaseMarshalData function. The data packet serves as an additional reference on the
            object, and releasing the data is like releasing an interface pointer by calling Release.
            </para>
            <para>
            If the marshaled data packet somehow does not arrive in the client process or if <c>ReleaseMarshalData</c> is not
            successfully re-created in the proxy, COM can call this method on the object itself.
            </para>
            <para>Notes to Callers</para>
            <para>
            You will rarely if ever have occasion to call this method yourself. A possible exception would be if you were to implement
            IMarshal on a class factory for a class object on which you are also implementing <c>IMarshal</c>. In this case, if you were
            marshaling the object to a table where it could be retrieved by multiple clients, you might, as part of your unmarshaling
            routine, call <c>ReleaseMarshalData</c> to release the data packet for each proxy.
            </para>
            <para>Notes to Implementers</para>
            <para>
            If your implementation stores state information about marshaled data packets, you can use this method to release the state
            information associated with the data packet represented by pStm. Your implementation should also position the seek pointer in
            the stream past the last byte of data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMarshal.DisconnectObject(System.UInt32)">
            <summary>
            Releases all connections to an object. The object's server calls the object's implementation of this method prior to shutting down.
            </summary>
            <param name="dwReserved">This parameter is reserved and must be 0.</param>
            <remarks>
            <para>This method is implemented on the object, not the proxy.</para>
            <para>Notes to Callers</para>
            <para>
            The usual case in which this method is called occurs when an end user forcibly closes a COM server that has one or more
            running objects that implement IMarshal. Prior to shutting down, the server calls the CoDisconnectObject function to release
            external connections to all its running objects. For each object that implements <c>IMarshal</c>, however, this function
            calls <c>DisconnectObject</c> so that each object that manages its own marshaling can take steps to notify its proxy that it
            is about to shut down.
            </para>
            <para>Notes to Implementers</para>
            <para>
            As part of its normal shutdown code, a server should call CoDisconnectObject, which in turn calls <c>DisconnectObject</c>, on
            each of its running objects that implements IMarshal.
            </para>
            <para>
            The outcome of any implementation of this method should be to enable a proxy to respond to all subsequent calls from its
            client by returning RPC_E_DISCONNECTED or CO_E_OBJNOTCONNECTED rather than attempting to forward the calls on to the original
            object. It is up to the client to destroy the proxy.
            </para>
            <para>
            If you are implementing this method for an immutable object, such as a moniker, your implementation does not need to do
            anything because such objects are typically copied whole into the client's address space. Therefore, they have neither a
            proxy nor a connection to the original object. For more information on marshaling immutable objects, see the "When to
            Implement" section of the IMarshal topic.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IMessageFilter">
            <summary>
            <para>This interface allows an application to capture a message before it is dispatched to a control or form.</para>
            <para>
            A class that implements the IMessageFilter interface can be added to the application's message pump to filter out a message or
            perform other operations before the message is dispatched to a form or control. To add the message filter to an application's
            message pump, use the AddMessageFilter method in the Application class.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageFilter.HandleInComingCall(Vanara.PInvoke.Ole32.CALLTYPE,Vanara.PInvoke.HTASK,System.UInt32,Vanara.PInvoke.Ole32.INTERFACEINFO)">
            <summary>
            <para>Provides a single entry point for incoming calls.</para>
            <para>
            This method is called prior to each method invocation originating outside the current process and provides the ability to
            filter or reject incoming calls (or callbacks) to an object or a process.
            </para>
            </summary>
            <param name="dwCallType">The type of incoming call that has been received. Possible values are from the enumeration CALLTYPE.</param>
            <param name="htaskCaller">The thread id of the caller.</param>
            <param name="dwTickCount">
            The elapsed tick count since the outgoing call was made, if dwCallType is not CALLTYPE_TOPLEVEL. If dwCallType is
            CALLTYPE_TOPLEVEL, dwTickCount should be ignored.
            </param>
            <param name="lpInterfaceInfo">
            A pointer to an INTERFACEINFO structure that identifies the object, interface, and method being called. In the case of DDE
            calls, lpInterfaceInfo can be <c>NULL</c> because the DDE layer does not return interface information.
            </param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>SERVERCALL_ISHANDLED</term>
            <term>The application might be able to process the call.</term>
            </item>
            <item>
            <term>SERVERCALL_REJECTED</term>
            <term>
            The application cannot handle the call due to an unforeseen problem, such as network unavailability, or if it is in the
            process of terminating.
            </term>
            </item>
            <item>
            <term>SERVERCALL_RETRYLATER</term>
            <term>
            The application cannot handle the call at this time. An application might return this value when it is in a user-controlled
            modal state.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>If implemented, <c>HandleInComingCall</c> is called by COM when an incoming COM message is received.</para>
            <para>
            Depending on an application's current state, a call is either accepted and processed or rejected (permanently or
            temporarily). If SERVERCALL_ISHANDLED is returned, the application may be able to process the call, although success depends
            on the interface for which the call is destined. If the call cannot be processed, COM returns RPC_E_CALL_REJECTED.
            </para>
            <para>Input-synchronized and asynchronous calls are dispatched even if the application returns SERVERCALL_REJECTED or SERVERCALL_RETRYLATER.</para>
            <para>
            <c>HandleInComingCall</c> should not be used to hold off updates to objects during operations such as band printing. For that
            purpose, use IViewObject::Freeze.
            </para>
            <para>
            You can also use <c>HandleInComingCall</c> to set up the application's state so that the call can be processed in the future.
            </para>
            <para>
            <c>Note</c> Although the htaskCaller parameter is typed as an HTASK, it contains the thread id of the calling thread. When
            you implement the IMessageFilter interface, you can call the OpenThread function to get the thread handle from the
            htaskCaller parameter, and you can call the GetProcessIdOfThread function to get the process id.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageFilter.RetryRejectedCall(Vanara.PInvoke.HTASK,System.UInt32,Vanara.PInvoke.Ole32.SERVERCALL)">
            <summary>
            Provides applications with an opportunity to display a dialog box offering retry, cancel, or task-switching options.
            </summary>
            <param name="htaskCallee">The thread id of the called application.</param>
            <param name="dwTickCount">The number of elapsed ticks since the call was made.</param>
            <param name="dwRejectType">Specifies either SERVERCALL_REJECTED or SERVERCALL_RETRYLATER, as returned by the object application.</param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>-1</term>
            <term>The call should be canceled. COM then returns RPC_E_CALL_REJECTED from the original method call.</term>
            </item>
            <item>
            <term>0 ≤ value &lt; 100</term>
            <term>The call is to be retried immediately.</term>
            </item>
            <item>
            <term>100 ≤ value</term>
            <term>COM will wait for this many milliseconds and then retry the call.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            COM calls <c>RetryRejectedCall</c> on the caller's IMessageFilter interface immediately after receiving SERVERCALL_RETRYLATER
            or SERVERCALL_REJECTED from the IMessageFilter::HandleInComingCall method on the callee's <c>IMessageFilter</c> interface.
            </para>
            <para>
            If a called task rejects a call, the application is probably in a state where it cannot handle such calls, possibly only
            temporarily. When this occurs, COM returns to the caller and issues <c>RetryRejectedCall</c> to determine whether it should
            retry the rejected call.
            </para>
            <para>
            Applications should silently retry calls that have returned with SERVERCALL_RETRYLATER. If, after a reasonable amount of time
            has passed, say about 30 seconds, the application should display the busy dialog box; a standard implementation of this
            dialog box is available in the OLEDLG library. The callee may momentarily be in a state where calls can be handled. The
            option to wait and retry is provided for special kinds of calling applications, such as background tasks executing macros or
            scripts, so that they can retry the calls in a nonintrusive way.
            </para>
            <para>
            If, after a dialog box is displayed, the user chooses to cancel, <c>RetryRejectedCall</c> returns -1 and the call will appear
            to fail with RPC_E_CALL_REJECTED.
            </para>
            <para>
            If a client implements IMessageFilter and calls a server method on a remote machine, <c>RetryRejectedCall</c> will not be called.
            </para>
            <para>
            <c>Note</c> Although the htaskCallee parameter is typed as an HTASK, it contains the thread id of the called thread. When you
            implement the IMessageFilter interface, you can call the OpenThread function to get the thread handle from the htaskCallee
            parameter, and you can call the GetProcessIdOfThread function to get the process id.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IMessageFilter.MessagePending(Vanara.PInvoke.HTASK,System.UInt32,Vanara.PInvoke.Ole32.PENDINGTYPE)">
            <summary>
            <para>Indicates that a message has arrived while COM is waiting to respond to a remote call.</para>
            <para>
            Handling input while waiting for an outgoing call to finish can introduce complications. The application should determine
            whether to process the message without interrupting the call, to continue waiting, or to cancel the operation.
            </para>
            </summary>
            <param name="htaskCallee">The thread id of the called application.</param>
            <param name="dwTickCount">The number of ticks since the call was made. It is calculated from the GetTickCount function.</param>
            <param name="dwPendingType">
            The type of call made during which a message or event was received. Possible values are from the enumeration PENDINGTYPE,
            where PENDINGTYPE_TOPLEVEL means the outgoing call was not nested within a call from another application and
            PENDINTGYPE_NESTED means the outgoing call was nested within a call from another application.
            </param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>PENDINGMSG_CANCELCALL</term>
            <term>
            Cancel the outgoing call. This should be returned only under extreme conditions. Canceling a call that has not replied or
            been rejected can create orphan transactions and lose resources. COM fails the original call and returns RPC_E_CALL_CANCELLED.
            </term>
            </item>
            <item>
            <term>PENDINGMSG_WAITNOPROCESS</term>
            <term>Unused.</term>
            </item>
            <item>
            <term>PENDINGMSG_WAITDEFPROCESS</term>
            <term>
            Keyboard and mouse messages are no longer dispatched. However there are some cases where mouse and keyboard messages could
            cause the system to deadlock, and in these cases, mouse and keyboard messages are discarded. WM_PAINT messages are
            dispatched. Task-switching and activation messages are handled as before.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            COM calls <c>MessagePending</c> after an application has made a COM method call and a Windows message occurs before the call
            has returned. A Windows message is sent, for example, when the user selects a menu command or double-clicks an object. Before
            COM makes the <c>MessagePending</c> call, it calculates the elapsed time since the original COM method call was made. COM
            delivers the elapsed time in the dwTickCount parameter. In the meantime, COM does not remove the message from the queue.
            </para>
            <para>
            Windows messages that appear in the caller's queue should remain in the queue until sufficient time has passed to ensure that
            the messages are probably not the result of typing ahead, but are instead an attempt to get attention. Set the delay with the
            dwTickCount parameter —a two-second or three-second delay is recommended. If that amount of time passes and the call has not
            been completed, the caller should flush the messages from the queue and the OLE UI busy dialog box should be displayed
            offering the user the choice of retrying the call (continue waiting) or switching to the specified task. This ensures the
            following behaviors:
            </para>
            <list type="bullet">
            <item>
            <term>If calls are completed in a reasonable amount of time, type ahead will be treated correctly.</term>
            </item>
            <item>
            <term>
            If the callee does not respond, type ahead is not misinterpreted and the user is able to act to solve the problem. For
            example, OLE 1 servers can queue up requests without responding when they are in modal dialog boxes.
            </term>
            </item>
            </list>
            <para>
            Handling input while waiting for an outgoing call to finish can introduce complications. The application should determine
            whether to process the message without interrupting the call, to continue waiting, or to cancel the operation.
            </para>
            <para>
            When there is no response to the original COM call, the application can cancel the call and restore the COM object to a
            consistent state by calling IStorage::Revert on its storage. The object can be released when the container can shut down.
            However, canceling a call can create orphaned operations and resource leaks. Canceling should be used only as a last resort.
            It is strongly recommended that applications not allow such calls to be canceled.
            </para>
            <para>
            <c>Note</c> Although the htaskCallee parameter is typed as an HTASK, it contains the thread id of the called thread. When you
            implement the IMessageFilter interface, you can call the OpenThread function to get the thread handle from the htaskCallee
            parameter, and you can call the GetProcessIdOfThread function to get the process id.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.INoMarshal">
            <summary>Marks an object that doesn't support being marshaled or stored in the Global Interface Table.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IObjContext">
            <summary>Performs various operations on contexts.</summary>
            <seealso cref="T:Vanara.PInvoke.Ole32.IContext"/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.SetProperty(System.Guid@,System.UInt32,System.Object)">
            <summary>Adds the specified context property to the object context.</summary>
            <param name="rpolicyId">A GUID that uniquely identifies this context property.</param>
            <param name="flags">This parameter is reserved and must be zero.</param>
            <param name="pUnk">A pointer to the context property to be added.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.RemoveProperty(System.Guid@)">
            <summary>Removes the specified context property from the context.</summary>
            <param name="rPolicyId">The GUID that uniquely identifies the context property to be removed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.GetProperty(System.Guid@,System.UInt32@)">
            <summary>Retrieves the specified context property from the context.</summary>
            <param name="rGuid">The GUID that uniquely identifies the context property to be retrieved.</param>
            <param name="pFlags">The address of the variable that receives the flags associated with the property.</param>
            <returns>The address of the variable that receives the IUnknown interface pointer of the requested context property.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.EnumContextProps">
            <summary>
            Returns an IEnumContextProps interface pointer that can be used to enumerate the context properties in this context.
            </summary>
            <returns>The address of the variable that receives the new IEnumContextProps interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved1">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved2">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved3">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved4">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved5">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved6">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IObjContext.Reserved7">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPersistStorage">
            <summary>
            Enables a container application to pass a storage object to one of its contained objects and to load and save the storage object.
            This interface supports the structured storage model, in which each contained object has its own storage that is nested within
            the container's storage.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.GetClassID">
            <summary>Retrieves the class identifier (CLSID) of the object.</summary>
            <returns>
            <para>
            A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely
            represents an object class that defines the code that can manipulate the object's data.
            </para>
            <para>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetClassID</c> method retrieves the class identifier (CLSID) for an object, used in later operations to load
            object-specific code into the caller's context.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container application might call this method to retrieve the original CLSID of an object that it is treating as a different
            class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the
            container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object.
            Typically, in this case, the container calls the OleSave helper function, which performs all the necessary steps. For this
            reason, most container applications have no need to call this method directly.
            </para>
            <para>
            The exception would be a container that provides an object handler for certain objects. In particular, a container
            application should not get an object's CLSID and then use it to retrieve class specific information from the registry.
            Instead, the container should use IOleObject and IDataObject interfaces to retrieve such class-specific information directly
            from the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's
            <c>TreatAs</c> registry key has been set by an application that supports emulation (and so is treating the object as one of a
            different class), a call to <c>GetClassID</c> must supply the CLSID specified in the <c>TreatAs</c> key. For more information
            on emulation, see CoTreatAsClass.
            </para>
            <para>
            When an object is in the running state, the default handler calls an implementation of <c>GetClassID</c> that delegates the
            call to the implementation in the object. When the object is not running, the default handler instead calls the ReadClassStg
            function to read the CLSID that is saved in the object's storage.
            </para>
            <para>
            If you are writing a custom object handler for your object, you might want to simply delegate this method to the default
            handler implementation (see OleCreateDefaultHandler).
            </para>
            <para>URL Moniker Notes</para>
            <para>This method returns CLSID_StdURLMoniker.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.IsDirty">
            <summary>Determines whether an object has changed since it was last saved to its current storage.</summary>
            <returns>This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.</returns>
            <remarks>
            <para>
            Use this method to determine whether an object should be saved before closing it. The dirty flag for an object is
            conditionally cleared in the IPersistStorage::Save method.
            </para>
            <para>
            For example, you could optimize a <c>File Save</c> operation by calling the <c>IPersistStorage::IsDirty</c> method for each
            object and then calling the IPersistStorage::Save method only for those objects that are dirty.
            </para>
            <para>Notes to Callers</para>
            <para>
            You should treat any error return codes as an indication that the object has changed. Unless this method explicitly returns
            S_FALSE, assume that the object must be saved.
            </para>
            <para>Notes to Implementers</para>
            <para>An object with no contained objects simply checks its dirty flag to return the appropriate result.</para>
            <para>
            A container with one or more contained objects must maintain an internal dirty flag that is set when any of its contained
            objects has changed since it was last saved.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.InitNew(Vanara.PInvoke.Ole32.IStorage)">
            <summary>Initializes a new storage object.</summary>
            <param name="pStg">
            An IStorage pointer to the new storage object to be initialized. The container creates a nested storage object in its storage
            object (see IStorage::CreateStorage). Then, the container calls the WriteClassStg function to initialize the new storage
            object with the object class identifier (CLSID).
            </param>
            <remarks>
            <para>
            A container application can call this method when it needs to initialize a new object, for example, with an InsertObject command.
            </para>
            <para>
            An object that supports the IPersistStorage interface must have access to a valid storage object at all times while it is
            running. This includes the time just after the object has been created but before it has been made persistent. The object's
            container must provide the object with a valid IStorage pointer to the storage during this time through the call to
            <c>IPersistStorage::InitNew</c>. Depending on the container's state, a temporary file might have to be created for this purpose.
            </para>
            <para>If the object wants to retain the IStorage instance, it must call AddRef to increment its reference count.</para>
            <para>
            After the call to <c>IPersistStorage::InitNew</c>, the object is in either the loaded or running state. For example, if the
            object class has an in-process server, the object will be in the running state. However, if the object uses the default
            handler, the container's call to <c>InitNew</c> only invokes the handler's implementation which does not run the object.
            Later if the container runs the object, the handler calls the <c>InitNew</c> method for the object.
            </para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStorage::InitNew</c> directly, you typically call the OleCreate helper function which does the following:
            </para>
            <list type="number">
            <item>
            <term>Calls the CoCreateInstance function to create an instance of the object class.</term>
            </item>
            <item>
            <term>Queries the new instance for the IPersistStorage interface.</term>
            </item>
            <item>
            <term>Calls the <c>InitNew</c> method to initialize the object.</term>
            </item>
            </list>
            <para>
            The container application should cache the IPersistStorage pointer to the object for use in later operations on the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            An implementation of <c>IPersistStorage::InitNew</c> should initialize the object to its default state, taking the following steps:
            </para>
            <list type="number">
            <item>
            <term>Pre-open and cache the pointers to any streams or storages that the object will need to save itself to this storage.</term>
            </item>
            <item>
            <term>Call AddRef and cache the storage pointer that is passed in.</term>
            </item>
            <item>
            <term>
            Call the WriteFmtUserTypeStg function to write the native clipboard format and user type string for the object to the storage object.
            </term>
            </item>
            <item>
            <term>Set the dirty flag for the object.</term>
            </item>
            </list>
            <para>
            The first two steps are particularly important for ensuring that the object can save itself in low memory situations.
            Pre-opening and holding onto pointers to the stream and storage interfaces guarantee that a save operation to this storage
            will not fail due to insufficient memory.
            </para>
            <para>
            Your implementation of this method should return the CO_E_ALREADYINITIALIZED error code if it receives a call to either the
            <c>IPersistStorage::InitNew</c> method or the IPersistStorage::Load method after it is already initialized.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.Load(Vanara.PInvoke.Ole32.IStorage)">
            <summary>Loads an object from its existing storage.</summary>
            <param name="pStg">An IStorage pointer to the existing storage from which the object is to be loaded.</param>
            <remarks>
            <para>
            This method initializes an object from an existing storage. The object is placed in the loaded state if this method is called
            by the container application. If called by the default handler, this method places the object in the running state.
            </para>
            <para>Either the default handler or the object itself can hold onto the IStorage pointer while the object is loaded or running.</para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStorage::Load</c> directly, you typically call the OleLoad helper function which does the following:
            </para>
            <list type="number">
            <item>
            <term>Create an uninitialized instance of the object class.</term>
            </item>
            <item>
            <term>Query the new instance for the IPersistStorage interface.</term>
            </item>
            <item>
            <term>Call <c>Load</c> to initialize the object from the existing storage.</term>
            </item>
            </list>
            <para>
            You also call this method indirectly when you call the OleCreateFromData function or the OleCreateFromFile function to insert
            an object into a compound file (as in a drag-and-drop or clipboard paste operation).
            </para>
            <para>The container should cache the IPersistStorage pointer for use in later operations on the object.</para>
            <para>Notes to Implementers</para>
            <para>Your implementation should perform the following steps to load an object:</para>
            <list type="number">
            <item>
            <term>Open the object's streams in the storage object, and read the necessary data into the object's internal data structures.</term>
            </item>
            <item>
            <term>Clear the object's dirty flag.</term>
            </item>
            <item>
            <term>Call the AddRef method and cache the passed in storage pointer.</term>
            </item>
            <item>
            <term>Keep open and cache the pointers to any streams or storages that the object will need to save itself to this storage.</term>
            </item>
            <item>
            <term>Perform any other default initialization required for the object.</term>
            </item>
            </list>
            <para>
            Steps 3 and 4 are particularly important for ensuring that the object can save itself in low memory situations. Holding onto
            pointers to the storage and stream interfaces guarantees that a save operation to this storage will not fail due to
            insufficient memory.
            </para>
            <para>
            Your implementation of this method should return the CO_E_ALREADYINITIALIZED error code if it receives a call to either the
            IPersistStorage::InitNew method or the <c>IPersistStorage::Load</c> method after it is already initialized.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.Save(Vanara.PInvoke.Ole32.IStorage,System.Boolean)">
            <summary>
            Saves an object, and any nested objects that it contains, into the specified storage object. The object enters NoScribble mode.
            </summary>
            <param name="pStgSave">An IStorage pointer to the storage into which the object is to be saved.</param>
            <param name="fSameAsLoad">
            <para>
            Indicates whether the specified storage is the current one, which was passed to the object by one of the following calls:
            IPersistStorage::InitNew, IPersistStorage::Load, or IPersistStorage::SaveCompleted.
            </para>
            <para>
            This parameter is set to <c>FALSE</c> when performing a <c>Save As</c> or <c>Save A Copy To</c> operation or when performing
            a full save. In the latter case, this method saves to a temporary file, deletes the original file, and renames the temporary file.
            </para>
            <para>
            This parameter is set to <c>TRUE</c> to perform a full save in a low-memory situation or to perform a fast incremental save
            in which only the dirty components are saved.
            </para>
            </param>
            <remarks>
            <para>
            This method saves an object, and any nested objects it contains, into the specified storage. It also places the object into
            NoScribble mode. Thus, the object cannot write to its storage until a subsequent call to the IPersistStorage::SaveCompleted
            method returns the object to Normal mode.
            </para>
            <para>
            If the storage object is the same as the one it was loaded or created from, the save operation may be able to write
            incremental changes to the storage object. Otherwise, a full save must be done.
            </para>
            <para>
            This method recursively calls the <c>IPersistStorage::Save</c> method, the OleSave function, or the IStorage::CopyTo method
            to save its nested objects.
            </para>
            <para>
            This method does not call the IStorage::Commit method. Nor does it write the CLSID to the storage object. Both of these tasks
            are the responsibilities of the caller.
            </para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStorage::Save</c> directly, you typically call the OleSave helper function which performs the
            following steps:
            </para>
            <list type="number">
            <item>
            <term>Call the WriteClassStg function to write the class identifier for the object to the storage.</term>
            </item>
            <item>
            <term>Call the <c>IPersistStorage::Save</c> method.</term>
            </item>
            <item>
            <term>If needed, call the IStorage::Commit method on the storage object.</term>
            </item>
            </list>
            <para>
            Then, a container application performs any other operations necessary to complete the save and calls the SaveCompleted method
            for each object.
            </para>
            <para>
            If an embedded object passes the <c>IPersistStorage::Save</c> method to its nested objects, it must receive a call to its
            IPersistStorage::SaveCompleted method before calling this method for its nested objects.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.SaveCompleted(Vanara.PInvoke.Ole32.IStorage)">
            <summary>
            Notifies the object that it can write to its storage object. It does this by notifying the object that it can revert from
            NoScribble mode (in which it must not write to its storage object), to Normal mode (in which it can). The object enters
            NoScribble mode when it receives an IPersistStorage::Save call.
            </summary>
            <param name="pStgNew">
            An IStorage pointer to the new storage object, if different from the storage object prior to saving. This pointer can be
            <c>NULL</c> if the current storage object does not change during the save operation. If the object is in HandsOff mode, this
            parameter must be non- <c>NULL</c>.
            </param>
            <remarks>
            <para>
            This method notifies an object that it can revert to Normal mode and can once again write to its storage object. The object
            exits NoScribble mode or HandsOff mode.
            </para>
            <para>
            If the object is reverting from HandsOff mode, the pStgNew parameter must be non- <c>NULL</c>. In HandsOffFromNormal mode,
            this parameter is the new storage object that replaces the one that was revoked by the IPersistStorage::HandsOffStorage
            method. The data in the storage object is a copy of the data from the revoked storage object. In HandsOffAfterSave mode, the
            data is the same as the data that was most recently saved. It is not the same as the data in the revoked storage object.
            </para>
            <para>
            If the object is reverting from NoScribble mode, the pStgNew parameter can be <c>NULL</c> or non- <c>NULL</c>. If
            <c>NULL</c>, the object once again has access to its storage object. If it is not <c>NULL</c>, the component object should
            simulate receiving a call to its HandsOffStorage method. If the component object cannot simulate this call, its container
            must be prepared to actually call the <c>HandsOffStorage</c> method.
            </para>
            <para>This method must recursively call any nested objects that are loaded or running.</para>
            <para>
            If this method returns an error code, the object is not returned to Normal mode. Thus, the container object can attempt
            different save strategies.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStorage.HandsOffStorage">
            <summary>
            Instructs the object to release all storage objects that have been passed to it by its container and to enter HandsOff mode.
            </summary>
            <remarks>
            <para>
            This method causes an object to release any storage objects that it is holding and to enter the HandsOff mode until a
            subsequent IPersistStorage::SaveCompleted call. In HandsOff mode, the object cannot do anything and the only operation that
            works is a close operation.
            </para>
            <para>
            A container application typically calls this method during a full save or low-memory full save operation to force the object
            to release all pointers to its current storage. In these scenarios, the <c>HandsOffStorage</c> call comes after a call to
            either OleSave or IPersistStorage::Save, putting the object in HandsOffAfterSave mode. Calling this method is necessary so
            the container application can delete the current file as part of a full save, or so it can call the
            IRootStorage::SwitchToFile method as part of a low-memory save.
            </para>
            <para>
            A container application also calls this method when an object is in Normal mode to put the object in HandsOffFromNormal mode.
            </para>
            <para>
            While the component object is in either HandsOffAfterSave or HandsOffFromNormal mode, most operations on the object will
            fail. Thus, the container should restore the object to Normal mode as soon as possible. The container application does this
            by calling the IPersistStorage::SaveCompleted method, which passes a storage pointer back to the component object for the new
            storage object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            This method must release all pointers to the current storage object, including pointers to any nested streams and storages.
            If the object contains nested objects, the container application must recursively call this method for any nested objects
            that are loaded or running.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IRunningObjectTable">
            <summary>
            Manages access to the running object table (ROT), a globally accessible look-up table on each workstation. A workstation's ROT
            keeps track of those objects that can be identified by a moniker and that are currently running on the workstation. When a client
            tries to bind a moniker to an object, the moniker checks the ROT to see if the object is already running; this allows the moniker
            to bind to the current instance instead of loading a new one.
            </summary>
            <remarks>
            <para>The ROT contains entries of the following form: (pmkObjectName, pUnkObject).</para>
            <para>
            The pmkObjectName element is a pointer to the moniker that identifies the running object. The pUnkObject element is a pointer to
            the running object itself. During the binding process, monikers consult the pmkObjectName entries in the ROT to see whether an
            object is already running.
            </para>
            <para>
            Objects that can be named by monikers must be registered with the ROT when they are loaded and their registration must be revoked
            when they are no longer running.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.Register(Vanara.PInvoke.Ole32.ROTFLAGS,System.Object,System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>Registers an object and its identifying moniker in the running object table (ROT).</summary>
            <param name="grfFlags">
            <para>
            Specifies whether the ROT's reference to punkObject is weak or strong and controls access to the object through its entry in
            the ROT. For details, see the Remarks section.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ROTFLAGS_REGISTRATIONKEEPSALIVE</term>
            <term>When set, indicates a strong registration for the object.</term>
            </item>
            <item>
            <term>ROTFLAGS_ALLOWANYCLIENT</term>
            <term>
            When set, any client can connect to the running object through its entry in the ROT. When not set, only clients in the window
            station that registered the object can connect to it.
            </term>
            </item>
            </list>
            </param>
            <param name="punkObject">A pointer to the object that is being registered as running.</param>
            <param name="pmkObjectName">A pointer to the moniker that identifies punkObject.</param>
            <returns>
            An identifier for this ROT entry that can be used in subsequent calls to IRunningObjectTable::Revoke or
            IRunningObjectTable::NoteChangeTime. The caller cannot specify <c>NULL</c> for this parameter. If an error occurs,
            *pdwRegister is set to zero.
            </returns>
            <remarks>
            <para>
            This method registers a pointer to an object under a moniker that identifies the object. The moniker is used as the key when
            the table is searched with IRunningObjectTable::GetObject.
            </para>
            <para>
            When an object is registered, the ROT always calls AddRef on the object. For a weak registration
            (ROTFLAGS_REGISTRATIONKEEPSALIVE not set), the ROT will release the object whenever the last strong reference to the object
            is released. For a strong registration (ROTFLAGS_REGISTRATIONKEEPSALIVE set), the ROT prevents the object from being
            destroyed until the object's registration is explicitly revoked.
            </para>
            <para>
            A server registered as either LocalService or RunAs can set the ROTFLAGS_ALLOWANYCLIENT flag in its call to <c>Register</c>
            to allow any client to connect to it. A server setting this bit must have its executable name in the AppID section of the
            registry that refers to the AppID for the executable. An "activate as activator" server (not registered as LocalService or
            RunAs) must not set this flag in its call to <c>Register</c>. For details on installing services, see Installing as a Service Application.
            </para>
            <para>
            Registering a second object with the same moniker, or re-registering the same object with the same moniker, creates a second
            entry in the ROT. In this case, <c>Register</c> returns MK_S_MONIKERALREADYREGISTERED. Each call to <c>Register</c> must be
            matched by a call to IRunningObjectTable::Revoke because even duplicate entries have different pdwRegister identifiers. A
            problem with duplicate registrations is that there is no way to determine which object will be returned if the moniker is
            specified in a subsequent call to IRunningObjectTable::IsRunning.
            </para>
            <para>Notes to Callers</para>
            <para>
            If you are a moniker provider (that is, you hand out monikers identifying your objects to make them accessible to others),
            you must call the <c>Register</c> method to register your objects when they begin running. You must also call this method if
            you rename your objects while they are loaded.
            </para>
            <para>
            The most common type of moniker provider is a compound-document link source. This includes server applications that support
            linking to their documents (or portions of a document) and container applications that support linking to embeddings within
            their documents. Server applications that do not support linking can also use the ROT to cooperate with container
            applications that support linking to embeddings.
            </para>
            <para>
            If you are writing a server application, you should register an object with the ROT when it begins running, typically in your
            implementation of IOleObject::DoVerb. The object must be registered under its full moniker, which requires getting the
            moniker of its container document using IOleClientSite::GetMoniker. You should also revoke and re-register the object in your
            implementation of IOleObject::SetMoniker, which is called if the container document is renamed.
            </para>
            <para>
            If you are writing a container application that supports linking to embeddings, you should register your document with the
            ROT when it is loaded. If your document is renamed, you should revoke and re-register it with the ROT and call
            IOleObject::SetMoniker for any embedded objects in the document to give them an opportunity to re-register themselves.
            </para>
            <para>
            Objects registered in the ROT must be explicitly revoked when the object is no longer running or when its moniker changes.
            This revocation is important because there is no way for the system to automatically remove entries from the ROT. You must
            cache the identifier that is written through pdwRegister and use it in a call to IRunningObjectTable::Revoke to revoke the
            registration. For a strong registration, a strong reference is released when the objects registration is revoked.
            </para>
            <para>
            As of Windows Server 2003, if there are stale entries that remain in the ROT due to unexpected server problems, COM will
            automatically remove these stale entries from the ROT.
            </para>
            <para>
            The system's implementation of <c>Register</c> calls IMoniker::Reduce on the pmkObjectName parameter to ensure that the
            moniker is fully reduced before registration. If an object is known by more than one fully reduced moniker, it should be
            registered under all such monikers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.Revoke(System.UInt32)">
            <summary>Removes an entry from the running object table (ROT) that was previously registered by a call to IRunningObjectTable::Register.</summary>
            <param name="dwRegister">The identifier of the ROT entry to be revoked.</param>
            <returns>This method can return the standard return values E_INVALIDARG and S_OK.</returns>
            <remarks>
            <para>
            This method undoes the effect of a call to IRunningObjectTable::Register, removing both the moniker and the pointer to the
            object identified by that moniker.
            </para>
            <para>Notes to Callers</para>
            <para>
            A moniker provider (hands out monikers identifying its objects to make them accessible to others) must call the <c>Revoke</c>
            method to revoke the registration of its objects when it stops running. It must have previously called
            IRunningObjectTable::Register and stored the identifier returned by that method; it uses that identifier when calling <c>Revoke</c>.
            </para>
            <para>
            The most common type of moniker provider is a compound-document link source. This includes server applications that support
            linking to their documents (or portions of a document) and container applications that support linking to embeddings within
            their documents. Server applications that do not support linking can also use the ROT to cooperate with container
            applications that support linking to embeddings.
            </para>
            <para>
            If you are writing a container application, you must revoke a document's registration when the document is closed. You must
            also revoke a document's registration before re-registering it when it is renamed.
            </para>
            <para>
            If you are writing a server application, you must revoke an object's registration when the object is closed. You must also
            revoke an object's registration before re-registering it when its container document is renamed (see IOleObject::SetMoniker).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.IsRunning(System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>Determines whether the object identified by the specified moniker is currently running.</summary>
            <param name="pmkObjectName">A pointer to the IMoniker interface on the moniker.</param>
            <returns>If the object is in the running state, the return value is <c>TRUE</c>. Otherwise, it is <c>FALSE</c>.</returns>
            <remarks>
            <para>
            This method simply indicates whether a object is running. To retrieve a pointer to a running object, use the
            IRunningObjectTable::GetObject method.
            </para>
            <para>Notes to Callers</para>
            <para>
            Generally, you call the <c>IsRunning</c> method only if you are writing your own moniker class (that is, implementing the
            IMoniker interface). You typically call this method from your implementation of IMoniker::IsRunning. However, you should do
            so only if the pmkToLeft parameter of <c>IMoniker::IsRunning</c> is <c>NULL</c>. Otherwise, you should call
            <c>IMoniker::IsRunning</c> on your pmkToLeft parameter instead.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.GetObject(System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>
            Determines whether the object identified by the specified moniker is running, and if it is, retrieves a pointer to that object.
            </summary>
            <param name="pmkObjectName">A pointer to the IMoniker interface on the moniker.</param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates that pmkObjectName was found in the ROT and a pointer was retrieved.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>
            There is no entry for pmkObjectName in the ROT, or that the object it identifies is no longer running (in which case, the
            entry is revoked).
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method checks the ROT for the moniker specified by pmkObjectName. If that moniker had previously been registered with a
            call to IRunningObjectTable::Register, this method returns the pointer that was registered at that time.
            </para>
            <para>Notes to Callers</para>
            <para>
            Generally, you call the <c>IRunningObjectTable::GetObject</c> method only if you are writing your own moniker class (that is,
            implementing the IMoniker interface). You typically call this method from your implementation of IMoniker::BindToObject.
            </para>
            <para>
            However, note that not all implementations of IMoniker::BindToObject need to call this method. If you expect your moniker to
            have a prefix (indicated by a non- <c>NULL</c> pmkToLeft parameter to <c>IMoniker::BindToObject</c>), you should not check
            the ROT. The reason for this is that only complete monikers are registered with the ROT, and if your moniker has a prefix,
            your moniker is part of a composite and thus not complete. Instead, your moniker should request services from the object
            identified by the prefix (for example, the container of the object identified by your moniker).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.NoteChangeTime(System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            Records the time that a running object was last modified. The object must have previously been registered with the running
            object table (ROT). This method stores the time of last change in the ROT.
            </summary>
            <param name="dwRegister">The identifier of the ROT entry of the changed object. This value was previously returned by IRunningObjectTable::Register.</param>
            <param name="pfiletime">A pointer to a FILETIME structure containing the object's last change time.</param>
            <returns>This method can return the standard return values E_INVALIDARG and S_OK.</returns>
            <remarks>
            <para>The time recorded by this method can be retrieved by calling IRunningObjectTable::GetTimeOfLastChange.</para>
            <para>Notes to Callers</para>
            <para>
            A moniker provider (hands out monikers identifying its objects to make them accessible to others) must call the
            <c>NoteChangeTime</c> method whenever its objects are modified. It must have previously called IRunningObjectTable::Register
            and stored the identifier returned by that method; it uses that identifier when calling <c>NoteChangeTime</c>.
            </para>
            <para>
            The most common type of moniker provider is a compound-document link source. This includes server applications that support
            linking to their documents (or portions of a document) and container applications that support linking to embeddings within
            their documents. Server applications that do not support linking can also use the ROT to cooperate with container
            applications that support linking to embeddings.
            </para>
            <para>
            When an object is first registered in the ROT, the ROT records its last change time as the value returned by calling
            IMoniker::GetTimeOfLastChange on the moniker being registered.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.GetTimeOfLastChange(System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>Retrieves the time that an object was last modified.</summary>
            <param name="pmkObjectName">A pointer to the IMoniker interface on the moniker.</param>
            <returns>A pointer to a FILETIME structure that receives the object's last change time.</returns>
            <remarks>
            <para>
            This method returns the change time that was last reported for this object by a call to IRunningObjectTable::NoteChangeTime.
            If <c>NoteChangeTime</c> has not been called previously, the method returns the time that was recorded when the object was registered.
            </para>
            <para>
            This method is provided to enable checking whether a connection between two objects (represented by one object holding a
            moniker that identifies the other) is up-to-date. For example, if one object is holding cached information about the other
            object, this method can be used to check whether the object has been modified since the cache was last updated. See IMoniker::GetTimeOfLastChange.
            </para>
            <para>Notes to Callers</para>
            <para>
            Generally, you call <c>GetTimeOfLastChange</c> only if you are writing your own moniker class (that is, implementing the
            IMoniker interface). You typically call this method from your implementation of IMoniker::GetTimeOfLastChange. However, you
            should do so only if the pmkToLeft parameter of <c>IMoniker::GetTimeOfLastChange</c> is <c>NULL</c>. Otherwise, you should
            call <c>IMoniker::GetTimeOfLastChange</c> on your pmkToLeft parameter instead.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IRunningObjectTable.EnumRunning">
            <summary>
            Creates and returns a pointer to an enumerator that can list the monikers of all the objects currently registered in the
            running object table (ROT).
            </summary>
            <returns>
            A pointer to an IEnumMoniker pointer variable that receives the interface pointer to the new enumerator for the ROT. When
            successful, the implementation calls AddRef on the enumerator; it is the caller's responsibility to call Release. If an error
            occurs; the implementation sets *ppenumMoniker to <c>NULL</c>.
            </returns>
            <remarks>
            <para>
            <c>IRunningObjectTable::EnumRunning</c> must create and return a pointer to an IEnumMoniker interface on an enumerator
            object. The standard enumerator methods can then be called to enumerate the monikers currently registered in the registry.
            The enumerator cannot be used to enumerate monikers that are registered in the ROT after the enumerator has been created.
            </para>
            <para>
            The <c>EnumRunning</c> method is intended primarily for the use by the system in implementing the alert object table. Note
            that OLE 2 does not include an implementation of the alert object table.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ISequentialStream">
            <summary>
            The <c>ISequentialStream</c> interface supports simplified sequential access to stream objects. The IStream interface inherits
            its Read and Write methods from <c>ISequentialStream</c>.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ISequentialStream.Read(System.Byte[],System.UInt32,System.UInt32@)">
            <summary>
            The <c>Read</c> method reads a specified number of bytes from the stream object into memory, starting at the current seek pointer.
            </summary>
            <param name="pv">A pointer to the buffer which the stream data is read into.</param>
            <param name="cb">The number of bytes of data to read from the stream object.</param>
            <param name="pcbRead">
            <para>A pointer to a <c>ULONG</c> variable that receives the actual number of bytes read from the stream object.</para>
            <para><c>Note</c> The number of bytes read may be zero.</para>
            </param>
            <remarks>
            <para>
            This method reads bytes from this stream object into memory. The stream object must be opened in <c>STGM_READ</c> mode. This
            method adjusts the seek pointer by the actual number of bytes read.
            </para>
            <para>The number of bytes actually read is also returned in the pcbRead parameter.</para>
            <para>Notes to Callers</para>
            <para>
            The actual number of bytes read can be less than the number of bytes requested if an error occurs or if the end of the stream
            is reached during the read operation. The number of bytes returned should always be compared to the number of bytes
            requested. If the number of bytes returned is less than the number of bytes requested, it usually means the <c>Read</c>
            method attempted to read past the end of the stream.
            </para>
            <para>The application should handle both a returned error and <c>S_OK</c> return values on end-of-stream read operations.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ISequentialStream.Write(System.Byte[],System.UInt32,System.UInt32@)">
            <summary>
            The <c>Write</c> method writes a specified number of bytes into the stream object starting at the current seek pointer.
            </summary>
            <param name="pv">
            A pointer to the buffer that contains the data that is to be written to the stream. A valid pointer must be provided for this
            parameter even when cb is zero.
            </param>
            <param name="cb">The number of bytes of data to attempt to write into the stream. This value can be zero.</param>
            <param name="pcbWritten">
            A pointer to a <c>ULONG</c> variable where this method writes the actual number of bytes written to the stream object. The
            caller can set this pointer to <c>NULL</c>, in which case this method does not provide the actual number of bytes written.
            </param>
            <remarks>
            <para>
            <c>ISequentialStream::Write</c> writes the specified data to a stream object. The seek pointer is adjusted for the number of
            bytes actually written. The number of bytes actually written is returned in the pcbWritten parameter. If the byte count is
            zero bytes, the write operation has no effect.
            </para>
            <para>
            If the seek pointer is currently past the end of the stream and the byte count is nonzero, this method increases the size of
            the stream to the seek pointer and writes the specified bytes starting at the seek pointer. The fill bytes written to the
            stream are not initialized to any particular value. This is the same as the end-of-file behavior in the MS-DOS FAT file system.
            </para>
            <para>
            With a zero byte count and a seek pointer past the end of the stream, this method does not create the fill bytes to increase
            the stream to the seek pointer. In this case, you must call the IStream::SetSize method to increase the size of the stream
            and write the fill bytes.
            </para>
            <para>The pcbWritten parameter can have a value even if an error occurs.</para>
            <para>
            In the COM-provided implementation, stream objects are not sparse. Any fill bytes are eventually allocated on the disk and
            assigned to the stream.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IStorage">
            <summary>
            The IStorage interface supports the creation and management of structured storage objects. Structured storage allows hierarchical
            storage of information within a single file, and is often referred to as "a file system within a file". Elements of a structured
            storage object are storages and streams. Storages are analogous to directories, and streams are analogous to files. Within a
            structured storage there will be a primary storage object that may contain substorages, possibly nested, and streams. Storages
            provide the structure of the object, and streams contain the data, which is manipulated through the IStream interface.
            <para>
            The IStorage interface provides methods for creating and managing the root storage object, child storage objects, and stream
            objects. These methods can create, open, enumerate, move, copy, rename, or delete the elements in the storage object.
            </para>
            <para>
            An application must release its IStorage pointers when it is done with the storage object to deallocate memory used. There are
            also methods for changing the date and time of an element.
            </para>
            <para>
            There are a number of different modes in which a storage object and its elements can be opened, determined by setting values from
            STGM Constants. One aspect of this is how changes are committed. You can set direct mode, in which changes to an object are
            immediately written to it, or transacted mode, in which changes are written to a buffer until explicitly committed. The IStorage
            interface provides methods for committing changes and reverting to the last-committed version. For example, a stream can be
            opened in read-only mode or read/write mode. For more information, see STGM Constants.
            </para>
            <para>Other methods provide access to information about a storage object and its elements through the STATSTG structure.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.CreateStream(System.String,Vanara.PInvoke.STGM,System.UInt32,System.UInt32)">
            <summary>
            The CreateStream method creates and opens a stream object with the specified name contained in this storage object. All
            elements within a storage objects, both streams and other storage objects, are kept in the same name space.
            </summary>
            <param name="pwcsName">
            A string that contains the name of the newly created stream. The name can be used later to open or reopen the stream. The
            name must not exceed 31 characters in length, not including the string terminator. The 000 through 01f characters, serving as
            the first character of the stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a
            structured storage restriction.
            </param>
            <param name="grfMode">
            Specifies the access mode to use when opening the newly created stream. For more information and descriptions of the possible
            values, see STGM Constants.
            </param>
            <param name="reserved1">Reserved for future use; must be zero.</param>
            <param name="reserved2">Reserved for future use; must be zero.</param>
            <returns>On return, the new IStream interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.OpenStream(System.String,System.IntPtr,Vanara.PInvoke.STGM,System.UInt32)">
            <summary>The OpenStream method opens an existing stream object within this storage object in the specified access mode.</summary>
            <param name="pwcsName">
            A string that contains the name of the stream to open. The 000 through 01f characters, serving as the first character of the
            stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a structured storage restriction.
            </param>
            <param name="reserved1">Reserved for future use; must be NULL.</param>
            <param name="grfMode">
            Specifies the access mode to be assigned to the open stream. For more information and descriptions of possible values, see
            STGM Constants. Other modes you choose must at least specify STGM_SHARE_EXCLUSIVE when calling this method in the compound
            file implementation.
            </param>
            <param name="reserved2">Reserved for future use; must be zero.</param>
            <returns>A IStream interface pointer to the newly opened stream object.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.CreateStorage(System.String,Vanara.PInvoke.STGM,System.UInt32,System.UInt32)">
            <summary>
            The CreateStorage method creates and opens a new storage object nested within this storage object with the specified name in
            the specified access mode.
            </summary>
            <param name="pwcsName">
            A string that contains the name of the newly created storage object. The name can be used later to reopen the storage object.
            The name must not exceed 31 characters in length, not including the string terminator. The 000 through 01f characters,
            serving as the first character of the stream/storage name, are reserved for use by OLE. This is a compound file restriction,
            not a structured storage restriction.
            </param>
            <param name="grfMode">
            A value that specifies the access mode to use when opening the newly created storage object. For more information and a
            description of possible values, see STGM Constants.
            </param>
            <param name="reserved1">Reserved for future use; must be zero.</param>
            <param name="reserved2">Reserved for future use; must be zero.</param>
            <returns>On return, the new IStorage interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.OpenStorage(System.String,Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.SNB,System.UInt32)">
            <summary>The OpenStorage method opens an existing storage object with the specified name in the specified access mode.</summary>
            <param name="pwcsName">
            A string that contains the name of the storage object to open. The 000 through 01f characters, serving as the first character
            of the stream/storage name, are reserved for use by OLE. This is a compound file restriction, not a structured storage
            restriction. It is ignored if pstgPriority is non-NULL.
            </param>
            <param name="pstgPriority">Must be NULL. A non-NULL value will return STG_E_INVALIDPARAMETER.</param>
            <param name="grfMode">
            Specifies the access mode to use when opening the storage object. For descriptions of the possible values, see STGM
            Constants. Other modes you choose must at least specify STGM_SHARE_EXCLUSIVE when calling this method.
            </param>
            <param name="snbExclude">Must be NULL. A non-NULL value will return STG_E_INVALIDPARAMETER.</param>
            <param name="reserved">Reserved for future use; must be zero.</param>
            <returns>On return, the IStorage interface pointer to the opened storage.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.CopyTo(System.UInt32,System.Guid[],Vanara.PInvoke.Ole32.SNB,Vanara.PInvoke.Ole32.IStorage)">
            <summary>The CopyTo method copies the entire contents of an open storage object to another storage object.</summary>
            <param name="ciidExclude">
            The number of elements in the array pointed to by rgiidExclude. If rgiidExclude is NULL, then ciidExclude is ignored.
            </param>
            <param name="rgiidExclude">
            An array of interface identifiers (IIDs) that either the caller knows about and does not want copied or that the storage
            object does not support, but whose state the caller will later explicitly copy. The array can include IStorage, indicating
            that only stream objects are to be copied, and IStream, indicating that only storage objects are to be copied. An array
            length of zero indicates that only the state exposed by the IStorage object is to be copied; all other interfaces on the
            object are to be ignored. Passing NULL indicates that all interfaces on the object are to be copied.
            </param>
            <param name="snbExclude">
            A string name block (refer to SNB) that specifies a block of storage or stream objects that are not to be copied to the
            destination. These elements are not created at the destination. If IID_IStorage is in the rgiidExclude array, this parameter
            is ignored. This parameter may be NULL.
            </param>
            <param name="pstgDest">
            A pointer to the open storage object into which this storage object is to be copied. The destination storage object can be a
            different implementation of the IStorage interface from the source storage object. Thus, IStorage::CopyTo can use only
            publicly available methods of the destination storage object. If pstgDest is open in transacted mode, it can be reverted by
            calling its IStorage::Revert method.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.MoveElementTo(System.String,Vanara.PInvoke.Ole32.IStorage,System.String,Vanara.PInvoke.Ole32.STGMOVE)">
            <summary>
            The MoveElementTo method copies or moves a substorage or stream from this storage object to another storage object.
            </summary>
            <param name="pwcsName">A string that contains the name of the element in this storage object to be moved or copied.</param>
            <param name="pstgDest">IStorage pointer to the destination storage object.</param>
            <param name="pwcsNewName">A string that contains the new name for the element in its new storage object.</param>
            <param name="grfFlags">
            Specifies whether the operation should be a move (STGMOVE_MOVE) or a copy (STGMOVE_COPY). See the STGMOVE enumeration.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.Commit(Vanara.PInvoke.Ole32.STGC)">
            <summary>
            The Commit method ensures that any changes made to a storage object open in transacted mode are reflected in the parent
            storage. For nonroot storage objects in direct mode, this method has no effect. For a root storage, it reflects the changes
            in the actual device; for example, a file on disk. For a root storage object opened in direct mode, always call the
            IStorage::Commit method prior to Release. IStorage::Commit flushes all memory buffers to the disk for a root storage in
            direct mode and will return an error code upon failure. Although Release also flushes memory buffers to disk, it has no
            capacity to return any error codes upon failure. Therefore, calling Release without first calling Commit causes indeterminate results.
            </summary>
            <param name="grfCommitFlags">
            Controls how the changes are committed to the storage object. See the STGC enumeration for a definition of these values.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.Revert">
            <summary>The Revert method discards all changes that have been made to the storage object since the last commit operation.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.EnumElements(System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            The EnumElements method retrieves a pointer to an enumerator object that can be used to enumerate the storage and stream
            objects contained within this storage object.
            </summary>
            <param name="reserved1">Reserved for future use; must be zero.</param>
            <param name="reserved2">Reserved for future use; must be <c>NULL</c>.</param>
            <param name="reserved3">Reserved for future use; must be zero.</param>
            <returns>The interface pointer to the new enumerator object.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.DestroyElement(System.String)">
            <summary>The DestroyElement method removes the specified storage or stream from this storage object.</summary>
            <param name="pwcsName">A string that contains the name of the storage or stream to be removed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.RenameElement(System.String,System.String)">
            <summary>The RenameElement method renames the specified substorage or stream in this storage object.</summary>
            <param name="pwcsOldName">A string that contains the name of the substorage or stream to be changed.</param>
            <param name="pwcsNewName">A string that contains the new name for the specified substorage or stream.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.SetElementTimes(System.String,System.Runtime.InteropServices.ComTypes.FILETIME[],System.Runtime.InteropServices.ComTypes.FILETIME[],System.Runtime.InteropServices.ComTypes.FILETIME[])">
            <summary>
            The SetElementTimes method sets the modification, access, and creation times of the specified storage element, if the
            underlying file system supports this method.
            </summary>
            <param name="pwcsName">
            The name of the storage object element whose times are to be modified. If NULL, the time is set on the root storage rather
            than one of its elements.
            </param>
            <param name="pctime">
            Either the new creation time as the first element of the array for the element or NULL if the creation time is not to be modified.
            </param>
            <param name="patime">
            Either the new access time as the first element of the array for the element or NULL if the access time is not to be modified.
            </param>
            <param name="pmtime">
            Either the new modification time as the first element of the array for the element or NULL if the modification time is not to
            be modified.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.SetClass(System.Guid@)">
            <summary>The SetClass method assigns the specified class identifier (CLSID) to this storage object.</summary>
            <param name="clsid">The CLSID that is to be associated with the storage object.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.SetStateBits(System.UInt32,System.UInt32)">
            <summary>
            The SetStateBits method stores up to 32 bits of state information in this storage object. This method is reserved for future use.
            </summary>
            <param name="grfStateBits">
            Specifies the new values of the bits to set. No legal values are defined for these bits; they are all reserved for future use
            and must not be used by applications.
            </param>
            <param name="grfMask">A binary mask indicating which bits in grfStateBits are significant in this call.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IStorage.Stat(System.Runtime.InteropServices.ComTypes.STATSTG@,Vanara.PInvoke.Ole32.STATFLAG)">
            <summary>The Stat method retrieves the STATSTG structure for this open storage object.</summary>
            <param name="pstatstg">
            On return, pointer to a STATSTG structure where this method places information about the open storage object. This parameter
            is NULL if an error occurs.
            </param>
            <param name="grfStatFlag">
            Specifies that some of the members in the STATSTG structure are not returned, thus saving a memory allocation operation.
            Values are taken from the STATFLAG enumeration.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ISurrogate">
            <summary>
            Used to dynamically load new DLL servers into an existing surrogate and free the surrogate when it is no longer needed.
            </summary>
            <remarks>
            A surrogate is an EXE process into which a DLL server can be loaded to give the DLL server the advantages of an EXE server
            without the coding overhead. It can also allow independent DLL servers to be located together within a single process, reducing
            the total number of processes needed. DLL servers are easy to write using standard development tools, like Microsoft Visual
            Studio, and running them in a surrogate process provides the benefits of an executable implementation, including fault isolation,
            the ability to serve multiple clients simultaneously, and allowing the server to provide services to remote clients in a
            distributed environment.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ISurrogate.LoadDllServer(System.Guid@)">
            <summary>
            Loads a DLL server into the implementing surrogate. COM calls this method when there is an activation request for the DLL
            server's class, if the class is registered as DllSurrogate.
            </summary>
            <param name="Clsid">The CLSID of the DLL server to be loaded.</param>
            <remarks>
            <para>Upon receiving a load request through <c>LoadDllServer</c>, the surrogate must perform the following steps:</para>
            <list type="number">
            <item>
            <term>Create a class factory object that supports IUnknown, IClassFactory, and IMarshal.</term>
            </item>
            <item>
            <term>Call CoRegisterClassObject to register the new class factory object as the class factory for the requested CLSID.</term>
            </item>
            </list>
            <para>
            This class factory's implementation of IClassFactory::CreateInstance will create an instance of the requested CLSID method by
            calling CoGetClassObject to get the class factory which creates an actual object for the given CLSID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ISurrogate.FreeSurrogate">
            <summary>Unloads a DLL server.</summary>
            <remarks>
            <para>
            COM calls <c>FreeSurrogate</c> when there are no more DLL servers running in the surrogate process. When <c>FreeSurrogate</c>
            is called, the method must properly revoke all of the class factories registered in the surrogate, and then cause the
            surrogate process to exit.
            </para>
            <para>
            Surrogate processes must call the CoFreeUnusedLibraries function periodically to unload DLL servers that are no longer in
            use. The surrogate process assumes this responsibility, which would normally be the client's responsibility.
            <c>CoFreeUnusedLibraries</c> calls the DllCanUnloadNow function on any loaded DLL servers. Because
            <c>CoFreeUnusedLibraries</c> depends on the existence and proper implementation of <c>DllCanUnloadNow</c> in DLL servers, it
            is not guaranteed to unload all DLL servers that should be unloaded --not every server implements <c>DllCanUnloadNow</c>, and
            this function is unreliable for free-threaded DLLs. Additionally, the surrogate has no way of being informed when all DLL
            servers are gone. COM, however, can determine when all DLL servers have been unloaded, and will then call the
            <c>FreeSurrogate</c> method.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.Enumerate(Vanara.PInvoke.Ole32.IEnumContextProps)">
            <summary>Enumerates the values in a <see cref="T:Vanara.PInvoke.Ole32.IEnumContextProps"/> instance.</summary>
            <param name="e">The <see cref="T:Vanara.PInvoke.Ole32.IEnumContextProps"/> instance.</param>
            <returns>The enumerated values.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.Enumerate(Vanara.PInvoke.Ole32.IEnumSTATSTG)">
            <summary>Enumerates the values in a <see cref="T:Vanara.PInvoke.Ole32.IEnumSTATSTG"/> instance.</summary>
            <param name="e">The <see cref="T:Vanara.PInvoke.Ole32.IEnumSTATSTG"/> instance.</param>
            <returns>The enumerated values.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.Enumerate(Vanara.PInvoke.Ole32.IEnumUnknown)">
            <summary>Enumerates the values in a <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/> instance.</summary>
            <param name="e">The <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/> instance.</param>
            <returns>The enumerated values.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.Enumerate``1(Vanara.PInvoke.Ole32.IEnumUnknown)">
            <summary>Enumerates the values in a <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/> instance.</summary>
            <typeparam name="T">The COM interface type to query for from each item in the collection. Note that if this type cannot be retrieved, an exception will be thrown.</typeparam>
            <param name="e">The <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/> instance.</param>
            <returns>The enumerated values.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.ContextProperty">
            <summary>Structure returned by IEnumContextProps::Enum</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ContextProperty.policyId">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ContextProperty.flags">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.ContextProperty.pUnk">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.DVTARGETDEVICE">
            <summary>
            Specifies information about the target device for which data is being composed. <c>DVTARGETDEVICE</c> contains enough information
            about a Windows target device so a handle to a device context ( <c>HDC</c>) can be created using the CreateDC function.
            </summary>
            <remarks>
            Some OLE 1 client applications incorrectly construct target devices by allocating too few bytes in the DEVMODE structure for the
            <c>DVTARGETDEVICE</c>. They typically only supply the number of bytes in the <c>dmSize</c> member of <c>DEVMODE</c>. The number
            of bytes to be allocated should be the sum of <c>dmSize</c> + <c>dmDriverExtra</c>. When a call is made to the CreateDC function
            with an incorrect target device, the printer driver tries to access the additional bytes and unpredictable results can occur. To
            help protect against a crash and make the additional bytes available, OLE pads the size of OLE 2 target devices created from OLE
            1 target devices.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdSize">
            <summary>
            The size, in bytes, of the <c>DVTARGETDEVICE</c> structure. The initial size is included so the structure can be copied more easily.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdDriverNameOffset">
            <summary>
            The offset, in bytes, from the beginning of the structure to the device driver name, which is stored as a NULL-terminated
            string in the <c>tdData</c> buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdDeviceNameOffset">
            <summary>
            The offset, in bytes, from the beginning of the structure to the device name, which is stored as a NULL-terminated string in
            the <c>tdData</c> buffer. This value can be zero to indicate no device name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdPortNameOffset">
            <summary>
            The offset, in bytes, from the beginning of the structure to the port name, which is stored as a NULL-terminated string in
            the <c>tdData</c> buffer. This value can be zero to indicate no port name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdExtDevmodeOffset">
            <summary>The offset, in bytes, from the beginning of the structure to the DEVMODE structure retrieved by calling DocumentProperties.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DVTARGETDEVICE.tdData">
            <summary>
            An array of bytes containing data for the target device. It is not necessary to include empty strings in <c>tdData</c> (for
            names where the offset value is zero).
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_INFO">
            <summary>
            Identifies an authentication service, authorization service, and the authentication information for the specified authentication service.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_INFO.dwAuthnSvc">
            <summary>
            <para>The authentication service. This member can be a single value from the Authentication Service Constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_INFO.dwAuthzSvc">
            <summary>
            <para>The authorization service. This member can be a single value from the Authorization Constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_INFO.pAuthInfo">
            <summary>
            <para>A pointer to the authentication information, whose type is specific to the authentication service identified by <c>dwAuthnSvc</c>.</para>
            <para>
            For Schannel (RPC_C_AUTHN_GSS_SCHANNEL), this member either points to a CERT_CONTEXT structure that contains the client's
            X.509 certificate or is <c>NULL</c> if the client has no certificate or wishes to remain anonymous to the server.
            </para>
            <para>
            For NTLMSSP (RPC_C_AUTHN_WINNT) and Kerberos (RPC_C_AUTHN_GSS_KERBEROS), this member points to a SEC_WINNT_AUTH_IDENTITY or
            SEC_WINNT_AUTH_IDENTITY_EX structure that contains the user name and password.
            </para>
            <para>
            For Snego (RPC_C_AUTHN_GSS_NEGOTIATE), this member is either <c>NULL</c>, points to a SEC_WINNT_AUTH_IDENTITY structure, or
            points to a SEC_WINNT_AUTH_IDENTITY_EX structure. If it is <c>NULL</c>, Snego will pick a list of authentication services
            based on those available on the client computer. If it points to a <c>SEC_WINNT_AUTH_IDENTITY_EX</c> structure, the
            structure's <c>PackageList</c> member must point to a string containing a comma-separated list of authentication service
            names and the <c>PackageListLength</c> member must give the number of bytes in the <c>PackageList</c> string. If
            <c>PackageList</c> is <c>NULL</c>, all calls using Snego will fail.
            </para>
            <para>
            For authentication services not registered with DCOM, <c>pAuthInfo</c> must be set to <c>NULL</c> and DCOM will use the
            process identity to represent the client. For more information, see COM and Security Packages.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_LIST">
            <summary>
            Indicates the default authentication information to use with each authentication service. When DCOM negotiates the default
            authentication service for a proxy, it picks the default authentication information from this list.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_LIST.cAuthInfo">
            <summary>
            <para>The count of pointers in the array pointed to by <c>aAuthInfo</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_LIST.aAuthInfo">
            <summary>
            An array of SOLE_AUTHENTICATION_INFO structures. Each of these structures contains an identifier for an authentication
            service, an identifier for the authorization service, and a pointer to authentication information to use with the specified
            authentication service.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE">
            <summary>
            <para>Identifies an authentication service that a server is willing to use to communicate to a client.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE.dwAuthnSvc">
            <summary>
            <para>The authentication service. This member can be a single value from the Authentication Service Constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE.dwAuthzSvc">
            <summary>
            <para>The authorization service. This member can be a single value from the Authorization Constants.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE.pPrincipalName">
            <summary>
            The principal name to be used with the authentication service. If the principal name is <c>NULL</c>, the current user
            identifier is assumed. A <c>NULL</c> principal name is allowed for NTLMSSP, Kerberos, and Snego authentication services but
            may not work for other authentication services. For Schannel, this member must point to a CERT_CONTEXT structure that
            contains the server's certificate; if it <c>NULL</c> and if a certificate for the current user does not exist,
            RPC_E_NO_GOOD_SECURITY_PACKAGES is returned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.SOLE_AUTHENTICATION_SERVICE.hr">
            <summary>
            When used in CoInitializeSecurity, set on return to indicate the status of the call to register the authentication services.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.StorageLayout">
            <summary>
            The <c>StorageLayout</c> structure describes a single block of data, including its name, location, and length. To optimize a
            compound file, an application or layout tool passes an array of <c>StorageLayout</c> structures in a call to ILayoutStorage::LayoutScript.
            </summary>
            <remarks>
            <para>An array of <c>StorageLayout</c> structures might appear as follows.</para>
            <para>
            <c>Note</c> The parameters cOffset and cBytes are <c>LARGE_INTEGER</c> structures, used to represent a 64-bit signed integer
            value as a union of two 32-bit members. The two 32-bit members must be represented as a <c>LARGE_INTEGER</c> structure with
            <c>DWORD</c> LowPart and <c>LONG</c> HighPart as the structure members. (LowPart specifies the low-order 32 bits and HighPart
            specifies the high-order 32 bits.) If your compiler has built-in support for 64-bit integers, use the <c>QuadPart</c> member of
            the <c>LARGE_INTEGER</c> structure to store the 64-bit integer.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.StorageLayout.LayoutType">
            <summary>
            The type of element to be written. Values are taken from the STGTY enumeration. <c>STGTY_STREAM</c> means read the block of
            data named by <c>pwcsElementName</c>. <c>STGTY_STORAGE</c> means open the storage specified in <c>pwcsElementName</c>.
            <c>STGTY_REPEAT</c> is used in multimedia applications to interface audio, video, text, and other elements. An opening
            <c>STGTY_REPEAT</c> value means that the elements that follow are to be repeated a specified number of times. The closing
            <c>STGTY_REPEAT</c> value marks the end of those elements that are to be repeated. Nested <c>STGTY_REPEAT</c> value pairs are permitted.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.StorageLayout.pwcsElementName">
            <summary>
            The null-terminated Unicode string name of the storage or stream. If the element is a substorage or embedded object, the
            fully qualified storage path must be specified; for example, "RootStorageName\SubStorageName\Substream".
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.StorageLayout.cOffset">
            <summary>
            <para>
            Where the value of the <c>LayoutType</c> member is <c>STGTY_STREAM</c>, this flag specifies the beginning offset into the
            steam named in the <c>pwscElementName</c> member.
            </para>
            <para>Where <c>LayoutType</c> is <c>STGTY_STORAGE</c>, this flag should be set to zero.</para>
            <para>Where <c>LayoutType</c> is <c>STGTY_REPEAT</c>, this flag should be set to zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.StorageLayout.cBytes">
            <summary>
            <para>Length, in bytes, of the data block named in <c>pwcsElementName</c>.</para>
            <para>
            Where <c>LayoutType</c> is <c>STGTY_STREAM</c>, <c>cBytes</c> specifies the number of bytes to read at <c>cOffset</c> from
            the stream named in <c>pwcsElementName</c>.
            </para>
            <para>Where <c>LayoutType</c> is <c>STGTY_STORAGE</c>, this flag is ignored.</para>
            <para>
            Where <c>LayoutType</c> is <c>STGTY_REPEAT</c>, a positive <c>cBytes</c> specifies the beginning of a repeat block.
            <c>STGTY_REPEAT</c> with zero <c>cBytes</c> marks the end of a repeat block.
            </para>
            <para>
            A beginning block value of <c>STG_TOEND</c> specifies that elements in a following block are to be repeated after each stream
            has been completely read.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.BIND_OPTS_V">
            <summary>
            <para>Contains parameters used during a moniker-binding operation.</para>
            <para>The BIND_OPTS2 or BIND_OPTS3 structure can be used in place of the <c>BIND_OPTS</c> structure.</para>
            </summary>
            <remarks>
            <para>
            A <c>BIND_OPTS</c> structure is stored in a bind context; the same bind context is used by each component of a composite moniker
            during binding, allowing the same parameters to be passed to all components of a composite moniker. See IBindCtx for more
            information about bind contexts.
            </para>
            <para>
            Moniker clients (use a moniker to acquire an interface pointer to an object) typically do not need to specify values for the
            members of this structure. The CreateBindCtx function creates a bind context with the bind options set to default values that are
            suitable for most situations; the BindMoniker function does the same thing when creating a bind context for use in binding a
            moniker. If you want to modify the values of these bind options, you can do so by passing a <c>BIND_OPTS</c> structure to the
            IBindCtx::SetBindOptions method. Moniker implementers can pass a <c>BIND_OPTS</c> structure to the IBindCtx::GetBindOptions
            method to retrieve the values of these bind options.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS_V.cbStruct">
            <summary>The size of this structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS_V.grfFlags">
            <summary>
            Flags that control aspects of moniker binding operations. This value is any combination of the bit flags in the BIND_FLAGS
            enumeration. The CreateBindCtx function initializes this member to zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS_V.grfMode">
            <summary>
            Flags that should be used when opening the file that contains the object identified by the moniker. Possible values are the
            STGM constants. The binding operation uses these flags in the call to IPersistFile::Load when loading the file. If the object
            is already running, these flags are ignored by the binding operation. The CreateBindCtx function initializes this field to STGM_READWRITE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS_V.dwTickCountDeadline">
            <summary>
            <para>
            The clock time by which the caller would like the binding operation to be completed, in milliseconds. This member lets the
            caller limit the execution time of an operation when speed is of primary importance. A value of zero indicates that there is
            no deadline. Callers most often use this capability when calling the IMoniker::GetTimeOfLastChange method, though it can be
            usefully applied to other operations as well. The CreateBindCtx function initializes this field to zero.
            </para>
            <para>
            Typical deadlines allow for a few hundred milliseconds of execution. This deadline is a recommendation, not a requirement;
            however, operations that exceed their deadline by a large amount may cause delays for the end user. Each moniker
            implementation should try to complete its operation by the deadline, or fail with the error MK_E_EXCEEDEDDEADLINE.
            </para>
            <para>
            If a binding operation exceeds its deadline because one or more objects that it needs are not running, the moniker
            implementation should register the objects responsible in the bind context using the IBindCtx::RegisterObjectParam. The
            objects should be registered under the parameter names "ExceededDeadline", "ExceededDeadline1", "ExceededDeadline2", and so
            on. If the caller later finds the object in the running object table, the caller can retry the binding operation.
            </para>
            <para>
            The GetTickCount function indicates the number of milliseconds since system startup, and wraps back to zero after 2^31
            milliseconds. Consequently, callers should be careful not to inadvertently pass a zero value (which indicates no deadline),
            and moniker implementations should be aware of clock wrapping problems.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BIND_OPTS_V.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS_V"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BIND_OPTS_V.op_Implicit(Vanara.PInvoke.Ole32.BIND_OPTS_V)~System.Runtime.InteropServices.ComTypes.BIND_OPTS">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS_V"/> to <see cref="T:System.Runtime.InteropServices.ComTypes.BIND_OPTS"/>.</summary>
            <param name="bo">The <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS_V"/> instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BIND_OPTS_V.op_Implicit(System.Runtime.InteropServices.ComTypes.BIND_OPTS)~Vanara.PInvoke.Ole32.BIND_OPTS_V">
            <summary>Performs an implicit conversion from <see cref="T:System.Runtime.InteropServices.ComTypes.BIND_OPTS"/> to <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS_V"/>.</summary>
            <param name="bo">The <see cref="T:System.Runtime.InteropServices.ComTypes.BIND_OPTS"/> instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.BIND_OPTS2">
            <summary>Contains parameters used during a moniker-binding operation.</summary>
            <remarks>
            <para>
            A <c>BIND_OPTS2</c> structure is stored in a bind context; the same bind context is used by each component of a composite moniker
            during binding, allowing the same parameters to be passed to all components of a composite moniker. See IBindCtx for more
            information about bind contexts.
            </para>
            <para>
            Moniker clients (use a moniker to acquire an interface pointer to an object) typically do not need to specify values for the
            members of this structure. The CreateBindCtx function creates a bind context with the bind options set to default values that are
            suitable for most situations; the BindMoniker function does the same thing when creating a bind context for use in binding a
            moniker. If you want to modify the values of these bind options, you can do so by passing a <c>BIND_OPTS2</c> structure to the
            IBindCtx::SetBindOptions method. Moniker implementers can pass a <c>BIND_OPTS2</c> structure to the IBindCtx::GetBindOptions
            method to retrieve the values of these bind options.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS2.dwTrackFlags">
            <summary>
            <para>
            A moniker can use this value during link tracking. If the original persisted data that the moniker is referencing has been
            moved, the moniker can attempt to reestablish the link by searching for the original data though some adequate mechanism.
            This member provides additional information on how the link should be resolved. See the documentation of the fFlags parameter
            in IShellLink::Resolve.
            </para>
            <para>COM's file moniker implementation uses the shell link mechanism to reestablish links and passes these flags to IShellLink::Resolve.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS2.dwClassContext">
            <summary>
            The class context, taken from the CLSCTX enumeration, that is to be used for instantiating the object. Monikers typically
            pass this value to the dwClsContext parameter of CoCreateInstance.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS2.locale">
            <summary>
            The LCID value indicating the client's preference for the locale to be used by the object to which they are binding. A
            moniker passes this value to IClassActivator::GetClassObject.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS2.pServerInfo">
            <summary>
            A pointer to a COSERVERINFO structure. This member allows clients calling IMoniker::BindToObject to specify server
            information. Clients may pass a <c>BIND_OPTS2</c> structure to the IBindCtx::SetBindOptions method. If a server name is
            specified in the <c>COSERVERINFO</c> structure, the moniker bind will be forwarded to the specified computer.
            <c>SetBindOptions</c> only copies the struct members of <c>BIND_OPTS2</c>, not the <c>COSERVERINFO</c> structure and the
            pointers it contains. Callers may not free any of these pointers until the bind context is released. COM's new class moniker
            does not currently honor the <c>pServerInfo</c> flag.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BIND_OPTS2.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS2"/> class.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.BIND_OPTS3">
            <summary>Contains parameters used during a moniker-binding operation.</summary>
            <remarks>
            <para>
            A <c>BIND_OPTS3</c> structure is stored in a bind context; the same bind context is used by each component of a composite moniker
            during binding, allowing the same parameters to be passed to all components of a composite moniker. See IBindCtx for more
            information about bind contexts.
            </para>
            <para>
            Moniker clients (use a moniker to acquire an interface pointer to an object) typically do not need to specify values for the
            members of this structure. The CreateBindCtx function creates a bind context with the bind options set to default values that are
            suitable for most situations; the BindMoniker function does the same thing when creating a bind context for use in binding a
            moniker. If you want to modify the values of these bind options, you can do so by passing a <c>BIND_OPTS3</c> structure to the
            IBindCtx::SetBindOptions method. Moniker implementers can pass a <c>BIND_OPTS3</c> structure to the IBindCtx::GetBindOptions
            method to retrieve the values of these bind options.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BIND_OPTS3.hwnd">
            <summary>
            A handle to the window that becomes the owner of the elevation UI, if applicable. If <c>hwnd</c> is <c>NULL</c>, COM will
            call the GetActiveWindow function to find a window handle associated with the current thread. This case might occur if the
            client is a script, which cannot fill in a <c>BIND_OPTS3</c> structure. In this case, COM will try to use the window
            associated with the script thread.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.BIND_OPTS3.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.BIND_OPTS3"/> class.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.INTERFACEINFO">
            <summary>Contains information about incoming calls.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.INTERFACEINFO.pUnk">
            <summary>A pointer to the IUnknown interface on the object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.INTERFACEINFO.iid">
            <summary>The identifier of the requested interface.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.INTERFACEINFO.wMethod">
            <summary>The interface method.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.SNB">
            <summary>
            A string name block (SNB) is a pointer to an array of pointers to strings, that ends in a NULL pointer. String name blocks are
            used by the IStorage interface and by function calls that open storage objects. The strings point to contained storage objects or
            streams that are to be excluded in the open calls.
            </summary>
            <seealso cref="T:System.IDisposable"/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.SNB"/> class.</summary>
            <param name="names">The list of names to associate with this instance.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.#ctor">
            <summary>Prevents a default instance of the <see cref="T:Vanara.PInvoke.Ole32.SNB"/> class from being created.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.SNB"/> class.</summary>
            <param name="p">The native pointer.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.SNB.Names">
            <summary>Gets the names.</summary>
            <value>The names.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ole32.SNB">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ole32.SNB"/>.</summary>
            <param name="p">The native pointer to take ownership of.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.op_Implicit(System.String[])~Vanara.PInvoke.Ole32.SNB">
            <summary>Performs an implicit conversion from <see cref="T:System.Collections.Generic.IEnumerable`1"/> to <see cref="T:Vanara.PInvoke.Ole32.SNB"/>.</summary>
            <param name="names">The names.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SNB.System#IDisposable#Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1">
            <summary>Simple generic implementation of <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/>.</summary>
            <typeparam name="T">The type to enumerate.</typeparam>
            <seealso cref="T:System.Collections.Generic.IReadOnlyList`1"/>
            <seealso cref="T:Vanara.PInvoke.Ole32.IEnumUnknown"/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1"/> class using an existing enumeration.</summary>
            <param name="items">The items to enumerate.</param>
            <exception cref="T:System.ArgumentNullException">items</exception>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Item(System.Int32)">
            <summary>Gets the element at the specified index in the read-only list.</summary>
            <value>The element at the specified index in the read-only list.</value>
            <param name="index">The zero-based index of the element to get.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Count">
            <summary>Gets the number of elements in the collection.</summary>
            <value>The number of elements in the collection.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Vanara#PInvoke#Ole32#IEnumUnknown#Next(System.UInt32,System.IntPtr[],System.UInt32@)">
            <summary>Retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">
            The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method
            retrieves the remaining elements.
            </param>
            <param name="rgelt">
            <para>An array of enumerated items.</para>
            <para>
            The enumerator is responsible for calling AddRef, and the caller is responsible for calling Release through each pointer
            enumerated. If celt is greater than 1, the caller must also pass a non-NULL pointer passed to pceltFetched to know how many
            pointers to release.
            </para>
            </param>
            <param name="pceltFetched">
            The number of items that were retrieved. This parameter is always less than or equal to the number of items requested.
            </param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">rgelt - The length is not large enough for the requested number of items.</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Vanara#PInvoke#Ole32#IEnumUnknown#Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Vanara#PInvoke#Ole32#IEnumUnknown#Reset">
            <summary>Resets the enumeration sequence to the beginning.</summary>
            <remarks>
            There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static
            collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to
            guarantee this condition.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.Vanara#PInvoke#Ole32#IEnumUnknown#Clone">
            <summary>
            <para>Creates a new enumerator that contains the same enumeration state as the current one.</para>
            <para>
            This method makes it possible to record a point in the enumeration sequence in order to return to that point at a later time.
            The caller must release this new enumerator separately from the first enumerator.
            </para>
            </summary>
            <returns>A pointer to the cloned enumerator object.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumUnknownImpl`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IChannelHook">
            <summary>Provides a mechanism to intercept and modify calls when the COM engine processes the calls.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ClientGetSize(System.Guid@,System.Guid@,System.UInt32@)">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ClientFillBuffer(System.Guid@,System.Guid@,System.UInt32@,System.IntPtr)">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ClientNotify(System.Guid@,System.Guid@,System.UInt32,System.IntPtr,System.UInt32,Vanara.PInvoke.HRESULT)">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ServerNotify(System.Guid@,System.Guid@,System.UInt32,System.IntPtr,System.UInt32)">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ServerGetSize(System.Guid@,System.Guid@,Vanara.PInvoke.HRESULT,System.UInt32@)">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IChannelHook.ServerFillBuffer(System.Guid@,System.Guid@,System.UInt32@,System.IntPtr,Vanara.PInvoke.HRESULT)">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.EMBDHLP">
            <summary>Specify the role and creation context for the embedding helper.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EMBDHLP.EMBDHLP_INPROC_HANDLER">
            <summary>
            Creates an embedding helper that can be used with DLL object applications; specifically, the helper exposes the caching
            features of the default object handler.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EMBDHLP.EMBDHLP_INPROC_SERVER">
            <summary>Creates an embedding helper that is to be used as part of an in-process server. pCF cannot be NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EMBDHLP.EMBDHLP_CREATENOW">
            <summary>Creates the secondary object using pCF immediately; if pCF is NULL, the standard proxy manager is used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.EMBDHLP.EMBDHLP_DELAYCREATE">
            <summary>
            Delays creation of the secondary object until it is needed (when the helper is put into the running state) to enhance speed
            and memory use. pCF must not be NULL. The EMBDHLP_INPROC_HANDLER flag cannot be used with this flag.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLECREATE">
            <summary>Flags for OleCreateEx.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECREATE.OLECREATE_LEAVERUNNING">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateDataAdviseHolder(Vanara.PInvoke.Ole32.IDataAdviseHolder@)">
            <summary>Retrieves a pointer to the OLE implementation of IDataAdviseHolder on the data advise holder object.</summary>
            <param name="ppDAHolder">
            Address of an IDataAdviseHolder pointer variable that receives the interface pointer to the new advise holder object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Call <c>CreateDataAdviseHolder</c> in your implementation of IDataObject::DAdvise to get a pointer to the OLE implementation of
            IDataAdviseHolder interface. With this pointer, you can then complete the implementation of <c>IDataObject::DAdvise</c> by
            calling the IDataAdviseHolder::Advise method, which creates an advisory connection between the calling object and the data object.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CreateOleAdviseHolder(Vanara.PInvoke.Ole32.IOleAdviseHolder@)">
            <summary>
            Creates an advise holder object for managing compound document notifications. It returns a pointer to the object's OLE
            implementation of the IOleAdviseHolder interface.
            </summary>
            <param name="ppOAHolder">
            Address of IOleAdviseHolder pointer variable that receives the interface pointer to the new advise holder object.
            </param>
            <returns>This function returns S_OK on success and supports the standard return value E_OUTOFMEMORY.</returns>
            <remarks>
            The function <c>CreateOleAdviseHolder</c> creates an instance of an advise holder, which supports the OLE implementation of the
            IOleAdviseHolder interface. The methods of this interface are intended to be used to implement the advisory methods of
            IOleObject, and, when advisory connections have been set up with objects supporting an advisory sink, to send notifications of
            changes in the object to the advisory sink. The advise holder returned by <c>CreateOleAdviseHolder</c> will suffice for the great
            majority of applications. The OLE-provided implementation does not, however, support IOleAdviseHolder::EnumAdvise, so if you need
            to use this method, you will need to implement your own advise holder.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.DoDragDrop(System.Runtime.InteropServices.ComTypes.IDataObject,Vanara.PInvoke.Ole32.IDropSource,Vanara.PInvoke.Ole32.DROPEFFECT,Vanara.PInvoke.Ole32.DROPEFFECT@)">
            <summary>
            <para>Carries out an OLE drag and drop operation.</para>
            <para><c>Note</c> You must call OleInitialize before calling this function.</para>
            </summary>
            <param name="pDataObj">Pointer to the IDataObject interface on a data object that contains the data being dragged.</param>
            <param name="pDropSource">
            Pointer to an implementation of the IDropSource interface, which is used to communicate with the source during the drag operation.
            </param>
            <param name="dwOKEffects">
            Effects the source allows in the OLE drag-and-drop operation. Most significant is whether it permits a move. The dwOKEffect and
            pdwEffect parameters obtain values from the DROPEFFECT enumeration. For a list of values, see <c>DROPEFFECT</c>.
            </param>
            <param name="pdwEffect">
            Pointer to a value that indicates how the OLE drag-and-drop operation affected the source data. The pdwEffect parameter is set
            only if the operation is not canceled.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DRAGDROP_S_DROP</term>
            <term>The OLE drag-and-drop operation was successful.</term>
            </item>
            <item>
            <term>DRAGDROP_S_CANCEL</term>
            <term>The OLE drag-and-drop operation was canceled.</term>
            </item>
            <item>
            <term>E_UNSPEC</term>
            <term>Unexpected error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If you are developing an application that can act as a data source for an OLE drag-and-drop operation, you must call
            <c>DoDragDrop</c> when you detect that the user has started an OLE drag-and-drop operation.
            </para>
            <para>
            The <c>DoDragDrop</c> function enters a loop in which it calls various methods in the IDropSource and IDropTarget interfaces.
            (For a successful drag-and-drop operation, the application acting as the data source must also implement <c>IDropSource</c>,
            while the target application must implement <c>IDropTarget</c>.)
            </para>
            <list type="number">
            <item>
            <term>
            The <c>DoDragDrop</c> function determines the window under the current cursor location. It then checks to see if this window is a
            valid drop target.
            </term>
            </item>
            <item>
            <term>
            If the window is a valid drop target, <c>DoDragDrop</c> calls IDropTarget::DragEnter. This method supplies an effect code
            indicating what would happen if the drop actually occurred. For a list of valid drop effects, see the DROPEFFECT enumeration.
            </term>
            </item>
            <item>
            <term>
            <c>DoDragDrop</c> calls IDropSource::GiveFeedback with the effect code so that the drop source interface can provide appropriate
            visual feedback to the user. The pDropSource pointer passed into <c>DoDragDrop</c> specifies the appropriate IDropSource interface.
            </term>
            </item>
            <item>
            <term><c>DoDragDrop</c> tracks mouse cursor movements and changes in the keyboard or mouse button state.</term>
            </item>
            <item>
            <term>
            If there is a change in the keyboard or mouse button state, <c>DoDragDrop</c> calls IDropSource::QueryContinueDrag and determines
            whether to continue the drag, to drop the data, or to cancel the operation based on the return value.
            </term>
            </item>
            </list>
            <para><c>DoDragDrop</c> does not support invoking drag and drop support when you handle touch or pen input.</para>
            <para>
            To support touch or pen input, do not call <c>DoDragDrop</c> from your touch handler. Instead, call <c>DoDragDrop</c> from your
            handler for those mouse messages that the system synthesizes upon touch input.
            </para>
            <para>
            The application can identify synthesized messages by calling the GetMessageExtraInfo function. For more information about using
            <c>GetMessageExtraInfo</c> to distinguish between mouse input and Windows Touch input, see Troubleshooting Applications.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IsAccelerator(Vanara.PInvoke.HACCEL,System.Int32,Vanara.PInvoke.MSG@,System.UInt16@)">
            <summary>Determines whether the specified keystroke maps to an accelerator in the specified accelerator table.</summary>
            <param name="hAccel">A handle to the accelerator table.</param>
            <param name="cAccelEntries">The number of entries in the accelerator table.</param>
            <param name="lpMsg">A pointer to the keystroke message to be translated.</param>
            <param name="lpwCmd">
            A pointer to a variable to receive the corresponding command identifier if there is an accelerator for the keystroke. This
            parameter may be <c>NULL</c>.
            </param>
            <returns>
            If the message is for the object application, the return value is <c>TRUE</c>. If the message is not for the object and should be
            forwarded to the container, the return value is <c>FALSE</c>.
            </returns>
            <remarks>
            <para>
            While an object is active in-place, the object always has first chance to translate the keystrokes into accelerators. If the
            keystroke corresponds to one of its accelerators, the object must not call the OleTranslateAccelerator function â€” even if its
            call to the TranslateAccelerator function fails. Failure to process keystrokes in this manner can lead to inconsistent behavior.
            </para>
            <para>
            If the keystroke is not one of the object's accelerators, then the object must call OleTranslateAccelerator to let the container
            try its accelerator translation.
            </para>
            <para>
            The object's server can call <c>IsAccelerator</c> to determine if the accelerator message belongs to it. Some servers do
            accelerator translation on their own and do not call TranslateAccelerator. Those applications will not call <c>IsAccelerator</c>,
            because they already have the information.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleConvertIStorageToOLESTREAM(Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.Ole32.OLESTREAM@)">
            <summary>
            The <c>OleConvertIStorageToOLESTREAM</c> function converts the specified storage object from OLE 2 structured storage to the OLE
            1 storage object model but does not include the presentation data. This is one of several compatibility functions.
            </summary>
            <param name="pstg">Pointer to the IStorage interface on the storage object to be converted to an OLE 1 storage.</param>
            <param name="lpolestream">
            Pointer to an OLE 1 stream structure where the persistent representation of the object is saved using the OLE 1 storage model.
            </param>
            <returns>This function supports the standard return value E_INVALIDARG, in addition to the following:</returns>
            <remarks>
            <para>
            This function converts an OLE 2 storage object to OLE 1 format. The <c>OLESTREAM</c> structure code implemented for OLE 1 must be available.
            </para>
            <para>
            On entry, the stream to which lpolestm points should be created and positioned just as it would be for an OleSaveToStream call.
            On exit, the stream contains the persistent representation of the object using OLE 1 storage.
            </para>
            <para>
            <c>Note</c> Paintbrush objects are dealt with differently from other objects because their native data is in device-independent
            bitmap (DIB) format. When Paintbrush objects are converted using <c>OleConvertIStorageToOLESTREAM</c>, no presentation data is
            added to the <c>OLESTREAM</c> structure. To include presentation data, use the OleConvertIStorageToOLESTREAMEx function instead.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleConvertIStorageToOLESTREAMEx(Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.CLIPFORMAT,System.Int32,System.Int32,System.UInt32,System.Runtime.InteropServices.ComTypes.STGMEDIUM@,Vanara.PInvoke.Ole32.OLESTREAM@)">
            <summary>
            The <c>OleConvertIStorageToOLESTREAMEx</c> function converts the specified storage object from OLE 2 structured storage to the
            OLE 1 storage object model, including the presentation data. This is one of several functions included in Structured Storage to
            ensure compatibility between OLE1 and OLE2.
            </summary>
            <param name="pstg">Pointer to the IStorage interface on the storage object to be converted to an OLE 1 storage.</param>
            <param name="cfFormat">
            Format of the presentation data. May be <c>NULL</c>, in which case the lWidth, lHeight, dwSize, and pmedium parameters are ignored.
            </param>
            <param name="lWidth">Width of the object presentation data in HIMETRIC units.</param>
            <param name="lHeight">Height of the object presentation data in HIMETRIC units.</param>
            <param name="dwSize">Size of the data, in bytes, to be converted.</param>
            <param name="pmedium">Pointer to the STGMEDIUM structure for the serialized data to be converted.</param>
            <param name="polestm">
            Pointer to a stream where the persistent representation of the object is saved using the OLE 1 storage model.
            </param>
            <returns>This function supports the standard return value E_INVALIDARG, in addition to the following:</returns>
            <remarks>
            <para>
            The <c>OleConvertIStorageToOLESTREAMEx</c> function converts an OLE 2 storage object to OLE 1 format. It differs from the
            OleConvertIStorageToOLESTREAM function in that the <c>OleConvertIStorageToOLESTREAMEx</c> function also passes the presentation
            data to the OLE 1 storage object, whereas the <c>OleConvertIStorageToOLESTREAM</c> function does not.
            </para>
            <para>
            Because <c>OleConvertIStorageToOLESTREAMEx</c> can specify which presentation data to convert, it can be used by applications
            that do not use OLE default caching resources but do use OLE's conversion resources.
            </para>
            <para>
            The value of the <c>tymed</c> member of STGMEDIUM must be either TYMED_HGLOBAL or TYMED_ISTREAM; refer to the TYMED enumeration
            for more information. The medium is not released by the <c>OleConvertIStorageToOLESTREAMEx</c> function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleConvertOLESTREAMToIStorage(Vanara.PInvoke.Ole32.OLESTREAM@,Vanara.PInvoke.Ole32.IStorage@,Vanara.PInvoke.Ole32.DVTARGETDEVICE@)">
            <summary>
            <para>
            The <c>OleConvertOLESTREAMToIStorage</c> function converts the specified object from the OLE 1 storage model to an OLE 2
            structured storage object without specifying presentation data.
            </para>
            <para><c>Note</c> This is one of several compatibility functions.</para>
            </summary>
            <param name="lpolestream">
            A pointer to a stream that contains the persistent representation of the object in the OLE 1 storage format.
            </param>
            <param name="pstg">A pointer to the IStorage interface on the OLE 2 structured storage object.</param>
            <param name="ptd">
            A pointer to the DVTARGETDEVICE structure that specifies the target device for which the OLE 1 object is rendered.
            </param>
            <returns>This function supports the standard return value <c>E_INVALIDARG</c>, in addition to the following:</returns>
            <remarks>
            <para>
            This function converts an OLE 1 object to an OLE 2 structured storage object. Use this function to update OLE 1 objects to OLE 2
            objects when a new version of the object application supports OLE 2.
            </para>
            <para>
            On entry, the lpolestm parameter should be created and positioned just as it would be for an OleLoadFromStream function call. On
            exit, the lpolestm parameter is positioned just as it would be on exit from an <c>OleLoadFromStream</c> function, and the pstg
            parameter contains the uncommitted persistent representation of the OLE 2 storage object.
            </para>
            <para>
            For OLE 1 objects that use native data for their presentation, the <c>OleConvertOLESTREAMToIStorage</c> function returns
            <c>CONVERT10_S_NO_PRESENTATION</c>. On receiving this return value, callers should call IOleObject::Update to get the
            presentation data so it can be written to storage.
            </para>
            <para>
            Applications that do not use the OLE default caching resources, but use the conversion resources, can use an alternate function,
            OleConvertOLESTREAMToIStorageEx, which can specify the presentation data to convert. In the
            <c>OleConvertOLESTREAMToIStorageEx</c> function, the presentation data read from the <c>OLESTREAM</c> structure is passed out and
            the newly created OLE 2 storage object does not contain a presentation stream.
            </para>
            <para>The following procedure describes the conversion process using <c>OleConvertOLESTREAMToIStorage</c>.</para>
            <para><c>Converting an OLE 1 object to an OLE 2 storage object</c></para>
            <list type="number">
            <item>
            <term>Create a root IStorage object by calling the StgCreateDocfile function (..., &amp;pstg).</term>
            </item>
            <item>
            <term>Open the OLE 1 file (using OpenFile or another OLE 1 technique).</term>
            </item>
            <item>
            <term>Read from the file, using the OLE 1 procedure for reading files, until an OLE object is found.</term>
            </item>
            <item>
            <term>Allocate an IStorage object from the root <c>IStorage</c> created in Step 1.</term>
            </item>
            <item>
            <term>Repeat Step 3 until the file is completely read.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleConvertOLESTREAMToIStorageEx(Vanara.PInvoke.Ole32.OLESTREAM@,Vanara.PInvoke.Ole32.IStorage@,Vanara.PInvoke.CLIPFORMAT@,System.Int32@,System.Int32@,System.UInt32@,System.Runtime.InteropServices.ComTypes.STGMEDIUM@)">
            <summary>
            The <c>OleConvertOLESTREAMToIStorageEx</c> function converts the specified object from the OLE 1 storage model to an OLE 2
            structured storage object including presentation data. This is one of several compatibility functions.
            </summary>
            <param name="polestm">
            Pointer to the stream that contains the persistent representation of the object in the OLE 1 storage format.
            </param>
            <param name="pstg">Pointer to the OLE 2 structured storage object.</param>
            <param name="pcfFormat">
            Pointer to where the format of the presentation data is returned. May be <c>NULL</c>, indicating the absence of presentation data.
            </param>
            <param name="plwWidth">Pointer to where the width value (in HIMETRIC) of the presentation data is returned.</param>
            <param name="plHeight">Pointer to where the height value (in HIMETRIC) of the presentation data is returned.</param>
            <param name="pdwSize">Pointer to where the size in bytes of the converted data is returned.</param>
            <param name="pmedium">Pointer to where the STGMEDIUM structure for the converted serialized data is returned.</param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>
            This function converts an OLE 1 object to an OLE 2 structured storage object. You can use this function to update OLE 1 objects
            to OLE 2 objects when a new version of the object application supports OLE 2.
            </para>
            <para>
            This function differs from the OleConvertOLESTREAMToIStorage function in that the presentation data read from the
            <c>OLESTREAM</c> structure is passed out and the newly created OLE 2 storage object does not contain a presentation stream.
            </para>
            <para>
            Since this function can specify which presentation data to convert, it can be used by applications that do not use OLE's default
            caching resources but do use the conversion resources.
            </para>
            <para>
            The <c>tymed</c> member of STGMEDIUM can only be TYMED_NULL or TYMED_ISTREAM. If it is TYMED_NULL, the data will be returned in a
            global handle through the <c>hGlobal</c> member of <c>STGMEDIUM</c>, otherwise data will be written into the <c>pstm</c> member
            of this structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreate(System.Guid@,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Creates an embedded object identified by a CLSID. You use it typically to implement the menu item that allows the end user to
            insert a new object.
            </summary>
            <param name="rclsid">CLSID of the embedded object that is to be created.</param>
            <param name="riid">
            Reference to the identifier of the interface, usually IID_IOleObject (defined in the OLE headers as the interface identifier for
            IOleObject), through which the caller communicates with the new object.
            </param>
            <param name="renderopt">
            Value from the enumeration OLERENDER, indicating the locally cached drawing capabilities the newly created object is to have. The
            OLERENDER value chosen affects the possible values for the pFormatEtc parameter.
            </param>
            <param name="pFormatEtc">
            Depending on which OLERENDER flag is used as the value of <paramref name="renderopt"/>, this is a pointer to an FORMATETC
            enumeration value. For restrictions, see the OLERENDER enumeration.
            <para>This parameter, along with the <paramref name="renderopt"/> parameter, specifies what the new object can cache initially.</para>
            </param>
            <param name="pClientSite">
            If you want OleCreate to call IOleObject::SetClientSite, pClientSite is the pointer to the IOleClientSite interface on the container.
            <para>The value can be NULL, in which case you must specifically call IOleClientSite::SetClientSite before attempting operations.</para>
            </param>
            <param name="pStg">
            Pointer to an instance of the IStorage interface on the storage object.
            <para>This parameter cannot be NULL.</para>
            </param>
            <param name="ppvObj">
            Pointer to the pointer variable that receives the interface pointer requested in <paramref name="riid"/>.
            <para>Upon successful return, *ppvObject contains the requested interface pointer.</para>
            </param>
            <returns>
            <para>This function returns S_OK on success and supports the standard return value E_OUTOFMEMORY.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleCreate</c> function creates a new embedded object, and is typically called to implement the menu item Insert New
            Object. When <c>OleCreate</c> returns, the object it has created is blank (contains no data), unless <paramref name="renderopt"/>
            is OLERENDER_DRAW or OLERENDER_FORMAT, and is loaded. Containers typically then call the OleRun function or IOleObject::DoVerb to
            show the object for initial editing.
            </para>
            <para>
            The <paramref name="rclsid"/> parameter specifies the CLSID of the requested object. CLSIDs of registered objects are stored in
            the system registry. When an application user selects Insert Object, a selection box allows the user to select the type of object
            desired from those in the registry. When <c>OleCreate</c> is used to implement the Insert Object menu item, the CLSID associated
            with the selected item is assigned to the <paramref name="rclsid"/> parameter of <c>OleCreate</c>.
            </para>
            <para>
            The <paramref name="riid"/> parameter specifies the interface the client will use to communicate with the new object. Upon
            successful return, the ppvObject parameter holds a pointer to the requested interface.
            </para>
            <para>
            The created object's cache contains information that allows a presentation of a contained object when the container is opened.
            Information about what should be cached is passed in the <paramref name="renderopt"/> and pFormatetc values. When
            <c>OleCreate</c> returns, the created object's cache is not necessarily filled. Instead, the cache is filled the first time the
            object enters the running state. The caller can add additional cache control with a call to IOleCache::Cache after the return of
            <c>OleCreate</c> and before the object is run. If <paramref name="renderopt"/> is OLERENDER_DRAW or OLERENDER_FORMAT,
            <c>OleCreate</c> requires that the object support the IOleCache interface. There is no such requirement for any other value of <paramref name="renderopt"/>.
            </para>
            <para>
            If pClientSite is non- <c>NULL</c>, <c>OleCreate</c> calls IOleObject::SetClientSite through the pClientSite pointer.
            IOleClientSite is the primary interface by which an object requests services from its container. If pClientSite is <c>NULL</c>,
            you must make a specific call to <c>IOleObject::SetClientSite</c> before attempting any operations.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateDefaultHandler(System.Guid@,System.Object,System.Guid@,System.Object@)">
            <summary>
            Creates a new instance of the default embedding handler. This instance is initialized so it creates a local server when the
            embedded object enters the running state.
            </summary>
            <param name="clsid">CLSID identifying the OLE server to be loaded when the embedded object enters the running state.</param>
            <param name="pUnkOuter">
            Pointer to the controlling IUnknown interface if the handler is to be aggregated; <c>NULL</c> if it is not to be aggregated.
            </param>
            <param name="riid">
            Reference to the identifier of the interface, usually IID_IOleObject, through which the caller will communicate with the handler.
            </param>
            <param name="lplpObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the newly created handler.
            </param>
            <returns>This function returns NOERROR on success and supports the standard return value E_OUTOFMEMORY.</returns>
            <remarks>
            <para>
            <c>OleCreateDefaultHandler</c> creates a new instance of the default embedding handler, initialized so it creates a local server
            identified by the clsid parameter when the embedded object enters the running state. If you are writing a handler and want to use
            the services of the default handler, call <c>OleCreateDefaultHandler</c>. OLE also calls it internally when the CLSID specified
            in an object creation call is not registered.
            </para>
            <para>
            If the given class does not have a special handler, a call to <c>OleCreateDefaultHandler</c> produces the same results as a call
            to the CoCreateInstance function with the class context parameter assigned the value CLSCTX_INPROC_HANDLER.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateEmbeddingHelper(System.Guid@,System.Object,Vanara.PInvoke.Ole32.EMBDHLP,Vanara.PInvoke.Ole32.IClassFactory,System.Guid@,System.Object@)">
            <summary>
            Creates an OLE embedding helper object using application-supplied code aggregated with pieces of the OLE default object handler.
            This helper object can be created and used in a specific context and role, as determined by the caller.
            </summary>
            <param name="clsid">CLSID of the class to be helped.</param>
            <param name="pUnkOuter">
            If the embedding helper is to be aggregated, pointer to the outer object's controlling IUnknown interface. If it is not to be
            aggregated, although this is rare, the value should be <c>NULL</c>.
            </param>
            <param name="flags">
            DWORD containing flags that specify the role and creation context for the embedding helper. For legal values, see the following
            Remarks section.
            </param>
            <param name="pCF">
            Pointer to the IClassFactory interface on the class object the function uses to create the secondary object. In some situations,
            this value may be <c>NULL</c>. For more information, see the following Remarks section.
            </param>
            <param name="riid">Reference to the identifier of the interface desired by the caller.</param>
            <param name="lplpObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the newly created embedding helper.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleCreateEmbeddingHelper</c> function creates an object that supports the same interface implementations found in the
            default handler, but which has additional hooks that allow it to be used more generally than just as a handler object. The
            following two calls produce the same result:
            </para>
            <para>
            The embedding helper is aggregatable; pUnkOuter is the controlling IUnknown of the aggregate of which the embedding helper is to
            be a part. It is used to create a new instance of the OLE default handler, which can be used to support objects in various roles.
            The caller passes a pointer to its IClassFactory implementation to <c>OleCreateEmbeddingHelper</c>. This object and the default
            handler are then aggregated to create the new embedding helper object.
            </para>
            <para>The <c>OleCreateEmbeddingHelper</c> function is usually used to support one of the following implementations:</para>
            <list type="bullet">
            <item>
            <term>
            An EXE object application that is being used as both a container and a server, and which supports inserting objects into itself.
            For this case, <c>CreateEmbeddingHelper</c> allows the object to support the interfaces usually supported only in the handler. To
            accomplish this, the application must first register its CLSID for different contexts, making two registration calls to the
            CoRegisterClassObject function, rather than one, as follows:
            </term>
            </item>
            <item>
            <term>
            A custom in-process object handler, in which case, the DLL creates the embedding helper by passing in a pointer to a private
            implementation of IClassFactory in pCF.
            </term>
            </item>
            </list>
            <para>
            The flags parameter indicates how the embedding helper is to be used and how and when the embedding helper is initialized. The
            values for flags are obtained by OR-ing together values from the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Values for flags Parameter</term>
            <term>Purpose</term>
            </listheader>
            <item>
            <term>EMBDHLP_INPROC_HANDLER</term>
            <term>
            Creates an embedding helper that can be used with DLL object applications; specifically, the helper exposes the caching features
            of the default object handler.
            </term>
            </item>
            <item>
            <term>EMBDHLP_INPROC_SERVER</term>
            <term>Creates an embedding helper that is to be used as part of an in-process server. pCF cannot be NULL.</term>
            </item>
            <item>
            <term>EMBDHLP_CREATENOW</term>
            <term>Creates the secondary object using pCF immediately; if pCF is NULL, the standard proxy manager is used.</term>
            </item>
            <item>
            <term>EMBDHLP_DELAYCREATE</term>
            <term>
            Delays creation of the secondary object until it is needed (when the helper is put into the running state) to enhance speed and
            memory use. pCF must not be NULL. The EMBDHLP_INPROC_HANDLER flag cannot be used with this flag.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateEx(System.Guid@,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends OleCreate functionality by supporting more efficient instantiation of objects in containers requiring caching of multiple
            presentation formats or data, instead of the single format supported by <c>OleCreate</c>.
            </summary>
            <param name="rclsid">Identifies the class of the object to create.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This value can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array,
            which must be at least one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, points to an array of cFormats DWORD elements, each of which is a
            combination of values from the ADVF enumeration. Each element of this array is passed in as the <paramref name="rgAdvf"/>
            parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non-
            <c>NULL</c> (see below). In all other cases, this parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, points to an array of cFormats FORMATETC structures. When pAdviseSink is
            <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This
            populates the data and presentation cache managed by the objects in-process handler (typically the default handler) with
            presentation or other cacheable data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the
            pFormatEtc parameter to a call to IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching
            or processing of data received from the object. In all other cases, this parameter must be <c>NULL</c>.
            </param>
            <param name="lpAdviseSink">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or
            processing of data advises, or <c>NULL</c>, indicating default caching of data formats. In all other cases, this parameter must
            be <c>NULL</c>.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the pAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. Must be <c>NULL</c>,
            if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter may be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it. This parameter may
            not be <c>NULL</c>.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in <paramref name="riid"/>. Upon successful
            return, *ppvObj contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreate:</para>
            <para>is equivalent to the following call to OleCreateEx:</para>
            <para>
            Existing instantiation functions, (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData) create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage), during instantiation. Plus, these caches must be created when the object
            next enters the running state. Since most applications require caching at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. <c>OleCreateEx</c>, OleCreateFromFileEx, OleCreateFromDataEx,
            OleCreateLinkEx, OleCreateLinkToFileEx, and OleCreateLinkFromDataEx contain the following new parameters: dwFlags to indicate
            additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the advise
            flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data (non-default-handler)
            caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and pFormatEtc, an array of formats rather than a
            single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            pFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateFromData(System.Runtime.InteropServices.ComTypes.IDataObject,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Creates an embedded object from a data transfer object retrieved either from the clipboard or as part of an OLE drag-and-drop
            operation. It is intended to be used to implement a paste from an OLE drag-and-drop operation.
            </summary>
            <param name="pSrcDataObj">
            Pointer to the IDataObject interface on the data transfer object that holds the data from which the object is created.
            </param>
            <param name="riid">
            Reference to the identifier of the interface the caller later uses to communicate with the new object (usually IID_IOleObject,
            defined in the OLE headers as the interface identifier for IOleObject).
            </param>
            <param name="renderopt">
            Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the newly created
            object is to have. Additional considerations are described in the following Remarks section.
            </param>
            <param name="pFormatEtc">
            Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
            newly created object is to have. The <c>OLERENDER</c> value chosen affects the possible values for the pFormatEtc parameter.
            </param>
            <param name="pClientSite">
            Pointer to an instance of IOleClientSite, the primary interface through which the object will request services from its
            container. This parameter can be <c>NULL</c>.
            </param>
            <param name="pStg">Pointer to the IStorage interface on the storage object. This parameter may not be <c>NULL</c>.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in <paramref name="riid"/>. Upon successful return,
            *ppvObj contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_STATIC</term>
            <term>Indicates OLE can create only a static object.</term>
            </item>
            <item>
            <term>DV_E_FORMATETC</term>
            <term>No acceptable formats are available for object creation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleCreateFromData</c> function creates an embedded object from a data transfer object supporting the IDataObject
            interface. The data object in this case is either the type retrieved from the clipboard with a call to the OleGetClipboard
            function or is part of an OLE drag-and-drop operation (the data object is passed to a call to IDropTarget::Drop).
            </para>
            <para>
            If either the FileName or FileNameW clipboard format (CF_FILENAME) is present in the data transfer object, and CF_EMBEDDEDOBJECT
            or CF_EMBEDSOURCE do not exist, <c>OleCreateFromData</c> first attempts to create a package containing the indicated file.
            Generally, it takes the first available format.
            </para>
            <para>
            If <c>OleCreateFromData</c> cannot create a package, it tries to create an object using the CF_EMBEDDEDOBJECT format. If that
            format is not available, <c>OleCreateFromData</c> tries to create it with the CF_EMBEDSOURCE format. If neither of these formats
            is available and the data transfer object supports the IPersistStorage interface, <c>OleCreateFromData</c> calls the object's
            IPersistStorage::Save to have the object save itself.
            </para>
            <para>
            If an existing linked object is selected, then copied, it appears on the clipboard as just another embeddable object.
            Consequently, a paste operation that invokes <c>OleCreateFromData</c> may create a linked object. After the paste operation, the
            container should call the QueryInterface function, requesting IID_IOleLink (defined in the OLE headers as the interface
            identifier for IOleLink), to determine if a linked object was created.
            </para>
            <para>
            Use the <paramref name="renderopt"/> and pFormatetc parameters to control the caching capability of the newly created object. For
            general information about using the interaction of these parameters to determine what is to be cached, refer to the OLERENDER
            enumeration. There are, however, some additional specific effects of these parameters on the way <c>OleCreateFromData</c>
            initializes the cache.
            </para>
            <para>
            When <c>OleCreateFromData</c> uses either the CF_EMBEDDEDOBJECT or the CF_EMBEDSOURCE clipboard format to create the embedded
            object, the main difference between the two is where the cache-initialization data is stored:
            </para>
            <list type="bullet">
            <item>
            <term>
            CF_EMBEDDEDOBJECT indicates that the source is an existing embedded object. It already has in its cache the appropriate data, and
            OLE uses this data to initialize the cache of the new object.
            </term>
            </item>
            <item>
            <term>
            CF_EMBEDSOURCE indicates that the source data object contains the cache-initialization information in formats other than
            CF_EMBEDSOURCE. <c>OleCreateFromData</c> uses these to initialize the cache of the newly embedded object.
            </term>
            </item>
            </list>
            <para>The <paramref name="renderopt"/> values affect cache initialization as follows.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLERENDER_DRAW &amp; OLERENDER_FORMAT</term>
            <term>
            If the presentation information to be cached is currently present in the appropriate cache-initialization pool, it is used.
            (Appropriate locations are in the source data object cache for CF_EMBEDDEDOBJECT, and in the other formats in the source data
            object for CF_EMBEDSOURCE.) If the information is not present, the cache is initially empty, but will be filled the first time
            the object is run. No other formats are cached in the newly created object.
            </term>
            </item>
            <item>
            <term>OLERENDER_NONE</term>
            <term>
            Nothing is to be cached in the newly created object. If the source has the CF_EMBEDDEDOBJECT format, any existing cached data
            that has been copied is removed.
            </term>
            </item>
            <item>
            <term>OLERENDER_ASIS</term>
            <term>
            If the source has the CF_EMBEDDEDOBJECT format, the cache of the new object is to contain the same cache data as the source
            object. For CF_EMBEDSOURCE, nothing is to be cached in the newly created object. This option should be used by more sophisticated
            containers. After this call, such containers would call IOleCache::Cache and IOleCache::Uncache to set up exactly what is to be
            cached. For CF_EMBEDSOURCE, they would then also call IOleCache::InitCache.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateFromDataEx(System.Runtime.InteropServices.ComTypes.IDataObject,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends OleCreateFromData functionality by supporting more efficient instantiation of objects in containers requiring caching of
            multiple formats of presentation or data, instead of the single format supported by <c>OleCreateFromData</c>.
            </summary>
            <param name="pSrcDataObj">Pointer to the data transfer object holding the new data used to create the new object. (see OleCreateFromData).</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array,
            which must be at least one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, points to an array of <c>DWORD</c> elements, each of which is a
            combination of values from the ADVF enumeration. Each element of this array is passed in as the <paramref name="rgAdvf"/>
            parameter to a call to either IOleCache::Cache or IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non-
            <c>NULL</c> (see below). In all other cases, this parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, points to an array of FORMATETC structures. When pAdviseSink is
            <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This
            populates the data and presentation cache managed by the object's in-process handler (typically the default handler) with
            presentation or other cacheable data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the
            pFormatEtc parameter to a call to IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching
            or processing of data received from the object.
            </param>
            <param name="lpAdviseSink">
            When <paramref name="renderopt"/> is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or
            processing of data advises, or <c>NULL</c>, indicating default caching of data formats.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the IAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. This parameter must be
            <c>NULL</c> if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter may be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in <paramref name="riid"/>. Upon successful
            return, *ppvObj contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreateFromData:</para>
            <para>is equivalent to the following call to <c>OleCreateFromDataEx</c>:</para>
            <para>
            Existing instantiation functions (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData) create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage) during instantiation. Plus, these caches must be created when the object next
            enters the running state. Because most applications require caching at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. OleCreateEx, OleCreateFromFileEx, <c>OleCreateFromDataEx</c>,
            OleCreateLinkEx, OleCreateLinkToFileEx, and OleCreateLinkFromDataEx, contain the following new parameters: dwFlags to indicate
            additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the advise
            flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data (non-default-handler)
            caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and rgFormatEtc, an array of formats rather than a
            single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            rgFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically,
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateFromFile(System.Guid@,System.String,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>Creates an embedded object from the contents of a named file.</summary>
            <param name="rclsid">This parameter is reserved and must be CLSID_NULL.</param>
            <param name="lpszFileName">Pointer to the name of the file from which the new object should be initialized.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="lpFormatEtc">
            Depending on which OLERENDER flag is used as the value of <paramref name="renderopt"/>, this is a pointer to an FORMATETC
            enumeration value. For restrictions, see the OLERENDER enumeration.
            <para>This parameter, along with the <paramref name="renderopt"/> parameter, specifies what the new object can cache initially.</para>
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter may be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj
            contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>STG_E_FILENOTFOUND</term>
            <term>File not bound.</term>
            </item>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>Not able to bind to source.</term>
            </item>
            <item>
            <term>STG_E_MEDIUMFULL</term>
            <term>The medium is full.</term>
            </item>
            <item>
            <term>DV_E_TYMED</term>
            <term>Invalid TYMED.</term>
            </item>
            <item>
            <term>DV_E_LINDEX</term>
            <term>Invalid LINDEX.</term>
            </item>
            <item>
            <term>DV_E_FORMATETC</term>
            <term>Invalid FORMATETC structure.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleCreateFromFile</c> function creates a new embedded object from the contents of a named file. If the ProgID in the
            registration database contains the PackageOnFileDrop key, it creates a package. If not, the function calls the GetClassFile
            function to get the CLSID associated with the lpszFileName parameter, and then creates an OLE 2-embedded object associated with
            that CLSID. The rclsid parameter of <c>OleCreateFromFile</c> will always be ignored, and should be set to CLSID_NULL.
            </para>
            <para>
            As for other OleCreateXxx functions, the newly created object is not shown to the user for editing, which requires a DoVerb
            operation. It is used to implement insert file operations.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateFromFileEx(System.Guid@,System.String,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends OleCreateFromFile functionality by supporting more efficient instantiation of objects in containers requiring caching of
            multiple presentation formats or data, instead of the single format supported by <c>OleCreateFromFile</c>.
            </summary>
            <param name="rclsid">This parameter is reserved and must be CLSID_NULL.</param>
            <param name="lpszFileName">Pointer to the name of the file from which the new object should be initialized.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When renderopt is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array, which must be at least
            one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When renderopt is OLERENDER_FORMAT, points to an array of <c>DWORD</c> elements, each of which is a combination of values from
            the ADVF enumeration. Each element of this array is passed in as the advf parameter to a call to either IOleCache::Cache or
            IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non- <c>NULL</c> (see below). In all other cases, this
            parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When renderopt is OLERENDER_FORMAT, points to an array of FORMATETC structures. When pAdviseSink is <c>NULL</c>, each element of
            this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This populates the data and
            presentation cache managed by the objects in-process handler (typically the default handler) with presentation or other cacheable
            data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to
            IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of data received
            from the object.
            </param>
            <param name="lpAdviseSink">
            When renderopt is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or processing of data
            advises, or <c>NULL</c>, indicating default caching of data formats.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the pAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. This parameter must be
            <c>NULL</c> if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter may be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj
            contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreateFromFile:</para>
            <para>is equivalent to the following call to <c>OleCreateFromFileEx</c>:</para>
            <para>
            Existing instantiation functions (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData) create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage), during instantiation. Plus, these caches must be created when the object
            next enters the running state. Because most applications require caching at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. OleCreateEx, <c>OleCreateFromFileEx</c>, OleCreateFromDataEx,
            OleCreateLinkEx, OleCreateLinkToFileEx, and OleCreateLinkFromDataEx, contain the following new parameters: dwFlags to indicate
            additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the advise
            flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data (non-default-handler)
            caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and rgFormatEtc, an array of formats rather than a
            single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            rgFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically,
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLink(System.Runtime.InteropServices.ComTypes.IMoniker,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>Creates an OLE compound-document linked object.</summary>
            <param name="pmkLinkSrc">
            Pointer to the IMoniker interface on the moniker that can be used to locate the source of the linked object.
            </param>
            <param name="riid">
            Reference to the identifier of the interface the caller later uses to communicate with the new object (usually IID_IOleObject,
            defined in the OLE headers as the interface identifier for IOleObject).
            </param>
            <param name="renderopt">
            Specifies a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
            newly created object is to have. Additional considerations are described in the Remarks section below.
            </param>
            <param name="lpFormatEtc">
            Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
            newly created object is to have. The <c>OLERENDER</c> value chosen affects the possible values for the lpFormatEtc parameter.
            </param>
            <param name="pClientSite">
            Pointer to an instance of IOleClientSite, the primary interface through which the object will request services from its
            container. This parameter can be <c>NULL</c>.
            </param>
            <param name="pStg">Pointer to the IStorage interface on the storage object. This parameter cannot be <c>NULL</c>.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in <paramref name="riid"/>. Upon successful return,
            *ppvObj contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>Not able to bind to source.</term>
            </item>
            </list>
            </returns>
            <remarks>Call <c>OleCreateLink</c> to allow a container to create a link to an object.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLinkEx(System.Runtime.InteropServices.ComTypes.IMoniker,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends <c>OleCreateLink</c> functionality by supporting more efficient instantiation of objects in containers requiring caching
            of multiple formats of presentations or data, instead of the single format supported by OleCreateLink.
            </summary>
            <param name="pmkLinkSrc">Pointer to a moniker to the object to create a link to.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When renderopt is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array, which must be at least
            one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When renderopt is OLERENDER_FORMAT, points to an array of <c>DWORD</c> elements, each of which is a combination of values from
            the ADVF enumeration. Each element of this array is passed in as the advf parameter to a call to either IOleCache::Cache or
            IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non- <c>NULL</c> (see below). In all other cases, this
            parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When renderopt is OLERENDER_FORMAT, points to an array of FORMATETC structures. When pAdviseSink is <c>NULL</c>, each element of
            this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This populates the data and
            presentation cache managed by the objects in-process handler (typically the default handler) with presentation or other cacheable
            data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to
            IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of data received
            from the object.
            </param>
            <param name="lpAdviseSink">
            When renderopt is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or processing of data
            advises, or <c>NULL</c>, indicating default caching of data formats.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the IAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. This parameter must be
            <c>NULL</c> if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter can be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj
            contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreateLink:</para>
            <para>is equivalent to the following call to <c>OleCreateLinkEx</c>:</para>
            <para>
            Existing instantiation functions (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData) create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage) during instantiation. Plus, these caches must be created when the object next
            enters the running state. Because most applications require caching in at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. OleCreateEx, OleCreateFromFileEx, OleCreateFromDataEx,
            <c>OleCreateLinkEx</c>, OleCreateLinkToFileEx, and OleCreateLinkFromDataEx, contain the following new parameters: dwFlags to
            indicate additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the
            advise flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data
            (non-default-handler) caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and rgFormatEtc, an array of
            formats rather than a single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            rgFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically,
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLinkFromData(System.Runtime.InteropServices.ComTypes.IDataObject,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Creates a linked object from a data transfer object retrieved either from the clipboard or as part of an OLE drag-and-drop operation.
            </summary>
            <param name="pSrcDataObj">
            Pointer to the IDataObject interface on the data transfer object from which the linked object is to be created.
            </param>
            <param name="riid">
            Reference to the identifier of interface the caller later uses to communicate with the new object (usually IID_IOleObject,
            defined in the OLE headers as the interface identifier for IOleObject).
            </param>
            <param name="renderopt">
            Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the newly created
            object is to have. Additional considerations are described in the following Remarks section.
            </param>
            <param name="pFormatEtc">
            Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
            newly created object is to have. The <c>OLERENDER</c> value chosen affects the possible values for the pFormatEtc parameter.
            </param>
            <param name="pClientSite">
            Pointer to an instance of IOleClientSite, the primary interface through which the object will request services from its
            container. This parameter can be <c>NULL</c>.
            </param>
            <param name="pStg">Pointer to the IStorage interface on the storage object. This parameter cannot be <c>NULL</c>.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, ppvObj contains the
            requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CLIPBRD_E_CANT_OPEN</term>
            <term>Not able to open the clipboard.</term>
            </item>
            <item>
            <term>OLE_E_CANT_GETMONIKER</term>
            <term>Not able to extract the object's moniker.</term>
            </item>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>Not able to bind to source. Binding is necessary to get the cache's initialization data.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleCreateLinkFromData</c> function is used to implement either a paste-link or a drag-link operation. Its operation is
            similar to that of the OleCreateFromData function, except that it creates a link, and looks for different data formats. If the
            CF_LINKSOURCE format is not present, and either the FileName or FileNameW clipboard format is present in the data transfer
            object, <c>OleCreateLinkFromData</c> creates a package containing the link to the indicated file.
            </para>
            <para>
            You use the renderopt and pFormatetc parameters to control the caching capability of the newly created object. For general
            information on how to determine what is to be cached, refer to the OLERENDER enumeration for a description of the interaction
            between renderopt and pFormatetc. There are, however, some additional specific effects of these parameters on the way
            <c>OleCreateLinkFromData</c> initializes the cache, as follows.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLERENDER_DRAW, OLERENDER_FORMAT</term>
            <term>
            If the presentation information is in the other formats in the source data object, this information is used. If the information
            is not present, the cache is initially empty, but will be filled the first time the object is run. No other formats are cached in
            the newly created object.
            </term>
            </item>
            <item>
            <term>OLERENDER_NONE, OLERENDER_ASIS</term>
            <term>Nothing is to be cached in the newly created object.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLinkFromDataEx(System.Runtime.InteropServices.ComTypes.IDataObject,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends OleCreateLinkFromData functionality by supporting more efficient instantiation of objects in containers requiring caching
            of multiple formats of presentations or data, instead of the single format supported by <c>OleCreateLinkFromData</c>.
            </summary>
            <param name="pSrcDataObj">Pointer to the data object to create a link object from.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When renderopt is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array, which must be at least
            one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When renderopt is OLERENDER_FORMAT, points to an array of <c>DWORD</c> elements, each of which is a combination of values from
            the ADVF enumeration. Each element of this array is passed in as the advf parameter to a call to either IOleCache::Cache or
            IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non- <c>NULL</c> (see below). In all other cases, this
            parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When renderopt is OLERENDER_FORMAT, points to an array of FORMATETC structures. When pAdviseSink is <c>NULL</c>, each element of
            this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This populates the data and
            presentation cache managed by the objects in-process handler (typically the default handler) with presentation or other cacheable
            data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to
            IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of data received
            from the object.
            </param>
            <param name="lpAdviseSink">
            When renderopt is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or processing of data
            advises, or <c>NULL</c>, indicating default caching of data formats.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the pAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. This parameter must be
            <c>NULL</c> if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter can be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj
            contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreateLinkFromData:</para>
            <para>is equivalent to the following call to <c>OleCreateLinkFromDataEx</c>:</para>
            <para>
            Existing instantiation functions (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData), create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage) during instantiation. Plus, these caches must be created when the object next
            enters the running state. Because most applications require caching at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. OleCreateEx, OleCreateFromFileEx, OleCreateFromDataEx,
            OleCreateLinkEx, OleCreateLinkToFileEx, and <c>OleCreateLinkFromDataEx</c>, contain the following new parameters: dwFlags to
            indicate additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the
            advise flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data
            (non-default-handler) caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and rgFormatEtc, an array of
            formats rather than a single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            rgFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLinkToFile(System.String,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>Creates an object that is linked to a file.</summary>
            <param name="lpszFileName">Pointer to a string naming the source file to be linked to.</param>
            <param name="riid">
            Reference to the identifier of the interface the caller later uses to communicate with the new object (usually IID_IOleObject,
            defined in the OLE headers as the interface identifier for IOleObject).
            </param>
            <param name="renderopt">
            Value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the newly created
            object is to have. Additional considerations are described in the following Remarks section.
            </param>
            <param name="lpFormatEtc">
            Pointer to a value from the enumeration OLERENDER that indicates the locally cached drawing or data-retrieval capabilities the
            newly created object is to have. The <c>OLERENDER</c> value chosen affects the possible values for the pFormatEtc parameter.
            </param>
            <param name="pClientSite">
            Pointer to an instance of IOleClientSite, the primary interface through which the object will request services from its
            container. This parameter can be <c>NULL</c>.
            </param>
            <param name="pStg">Pointer to the IStorage interface on the storage object. This parameter cannot be <c>NULL</c>.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>STG_E_FILENOTFOUND</term>
            <term>The file name is invalid.</term>
            </item>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>Not able to bind to source.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>OleCreateLinkToFile</c> function differs from the OleCreateLink function because it can create links both to files that
            are not aware of OLE, as well as to those that are using the Windows Packager.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateLinkToFileEx(System.String,System.Guid@,Vanara.PInvoke.Ole32.OLECREATE,Vanara.PInvoke.Ole32.OLERENDER,System.UInt32,System.Runtime.InteropServices.ComTypes.ADVF[],System.Runtime.InteropServices.ComTypes.FORMATETC[],System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32[],Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            Extends OleCreateLinkToFile functionality by supporting more efficient instantiation of objects in containers requiring caching
            of multiple formats of presentations or data, instead of the single format supported by <c>OleCreateLinkToFile</c>.
            </summary>
            <param name="lpszFileName">Pointer to the name of the file to create a link to.</param>
            <param name="riid">Reference to the identifier of the interface of the object to return.</param>
            <param name="dwFlags">This parameter can be 0 or OLECREATE_LEAVERUNNING (0x00000001).</param>
            <param name="renderopt">Value taken from the OLERENDER enumeration.</param>
            <param name="cFormats">
            When renderopt is OLERENDER_FORMAT, indicates the number of FORMATETC structures in the rgFormatEtc array, which must be at least
            one. In all other cases, this parameter must be zero.
            </param>
            <param name="rgAdvf">
            When renderopt is OLERENDER_FORMAT, points to an array of <c>DWORD</c> elements, each of which is a combination of values from
            the ADVF enumeration. Each element of this array is passed in as the advf parameter to a call to either IOleCache::Cache or
            IDataObject::DAdvise, depending on whether pAdviseSink is <c>NULL</c> or non- <c>NULL</c> (see below). In all other cases, this
            parameter must be <c>NULL</c>.
            </param>
            <param name="rgFormatEtc">
            When renderopt is OLERENDER_FORMAT, points to an array of FORMATETC structures. When pAdviseSink is <c>NULL</c>, each element of
            this array is passed as the pFormatEtc parameter to a call to the object's IOleCache::Cache. This populates the data and
            presentation cache managed by the objects in-process handler (typically the default handler) with presentation or other cacheable
            data. When pAdviseSink is non- <c>NULL</c>, each element of this array is passed as the pFormatEtc parameter to a call to
            IDataObject::DAdvise. This allows the caller (typically an OLE Container) to do its own caching or processing of data received
            from the object.
            </param>
            <param name="lpAdviseSink">
            When renderopt is OLERENDER_FORMAT, may be either a valid IAdviseSink pointer, indicating custom caching or processing of data
            advises, or <c>NULL</c>, indicating default caching of data formats.
            </param>
            <param name="rgdwConnection">
            Location to return the array of dwConnection values returned when the IAdviseSink interface is registered for each advisory
            connection using IDataObject::DAdvise, or <c>NULL</c> if the returned advisory connections are not needed. This parameter must be
            <c>NULL</c> if pAdviseSink is <c>NULL</c>.
            </param>
            <param name="pClientSite">
            Pointer to the primary interface through which the object will request services from its container. This parameter may be
            <c>NULL</c>, in which case it is the caller's responsibility to establish the client site as soon as possible using IOleObject::SetClientSite.
            </param>
            <param name="pStg">
            Pointer to the storage to use for the object and any default data or presentation caching established for it.
            </param>
            <param name="ppvObj">
            Address of output pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj
            contains the requested interface pointer on the newly created object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following call to OleCreateLinkToFile:</para>
            <para>is equivalent to the following call to <c>OleCreateLinkToFileEx</c>:</para>
            <para>
            Existing instantiation functions (OleCreate, OleCreateFromFile, OleCreateFromData, OleCreateLink, OleCreateLinkToFile, and
            OleCreateLinkFromData) create only a single presentation or data format cache in the default cache location (within the
            '\001OlePresXXX' streams of the passed-in IStorage) during instantiation. Plus, these caches must be created when the object next
            enters the running state. Because most applications require caching at least two presentations (screen and printer) and may
            require caching data in a different format or location from the handler, applications must typically launch and shut down the
            object server multiple times in order to prime their data caches during object creation, i.e., Insert Object, Insert Object from
            File, and Paste Object.
            </para>
            <para>
            Extended versions of these creation functions solve this problem. OleCreateEx, OleCreateFromFileEx, OleCreateFromDataEx,
            OleCreateLinkEx, <c>OleCreateLinkToFileEx</c>, and OleCreateLinkFromDataEx, contain the following new parameters: dwFlags to
            indicate additional options, cFormats to indicate how many formats to cache, rgAdvf, from the ADVF enumeration, to specify the
            advise flags for each format to be cached, pAdviseSink to indicate whether presentation (default-handler) or data
            (non-default-handler) caching is required, rgdwConnection to return IDataObject::DAdvise cookies, and rgFormatEtc, an array of
            formats rather than a single format.
            </para>
            <para>
            Containers requiring that multiple presentations be cached on their behalf by the object's handler can simply call these
            functions and specify the number of formats in cFormats, the ADVF flags for each format in rgAdvf, and the set of formats in
            rgFormatEtc. These containers pass <c>NULL</c> for pAdviseSink.
            </para>
            <para>
            Containers performing all their own data- or presentation-caching perform these same steps, but pass a non- <c>NULL</c>
            pAdviseSink. They perform their own caching or manipulation of the object or data during IAdviseSink::OnDataChange. Typically,
            such containers never establish the advisory connections with ADVF_NODATA, although they are not prevented from doing so.
            </para>
            <para>
            These new functions are for OLE Compound Documents. Using these functions, applications can avoid the repeated launching and
            initialization steps required by the current functions. They are targeted at OLE Compound Document container applications that
            use default data- and presentation-caching, and also at applications that provide their own caching and data transfer from the
            underlying IDataObject::DAdvise support.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateMenuDescriptor(Vanara.PInvoke.HMENU,Vanara.PInvoke.Ole32.OLEMENUGROUPWIDTHS@)">
            <summary>
            Creates and returns an OLE menu descriptor (that is, an OLE-provided data structure that describes the menus) for OLE to use when
            dispatching menu messages and commands.
            </summary>
            <param name="hmenuCombined">Handle to the combined menu created by the object.</param>
            <param name="lpMenuWidths">Pointer to an array of six <c>LONG</c> values giving the number of menus in each group.</param>
            <returns>Returns the handle to the descriptor, or <c>NULL</c> if insufficient memory is available.</returns>
            <remarks>
            The <c>OleCreateMenuDescriptor</c> function can be called by the object to create a descriptor for the composite menu. OLE then
            uses this descriptor to dispatch menu messages and commands. To free the shared menu descriptor when it is no longer needed, the
            container should call the companion helper function, OleDestroyMenuDescriptor.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleCreateStaticFromData(System.Runtime.InteropServices.ComTypes.IDataObject,System.Guid@,Vanara.PInvoke.Ole32.OLERENDER,System.Runtime.InteropServices.ComTypes.FORMATETC@,Vanara.PInvoke.Ole32.IOleClientSite,Vanara.PInvoke.Ole32.IStorage,System.Object@)">
            <summary>
            <para>Creates a static object, that contains only a representation, with no native data, from a data transfer object.</para>
            <para><c>Note</c> The OLESTREAM to IStorage conversion functions also convert static objects.</para>
            </summary>
            <param name="pSrcDataObj">
            Pointer to the IDataObject interface on the data transfer object that holds the data from which the object will be created.
            </param>
            <param name="iid">
            Reference to the identifier of the interface with which the caller is to communicate with the new object (usually IID_IOleObject,
            defined in the OLE headers as the interface identifier for IOleObject).
            </param>
            <param name="renderopt">
            Value from the enumeration OLERENDER indicating the locally cached drawing or data-retrieval capabilities that the container
            wants in the newly created component. It is an error to pass the render options OLERENDER_NONE or OLERENDER_ASIS to this function.
            </param>
            <param name="pFormatEtc">
            Depending on which of the OLERENDER flags is used as the value of renderopt, may be a pointer to one of the FORMATETC enumeration
            values. Refer to the <c>OLERENDER</c> enumeration for restrictions.
            </param>
            <param name="pClientSite">
            Pointer to an instance of IOleClientSite, the primary interface through which the object will request services from its
            container. This parameter can be <c>NULL</c>.
            </param>
            <param name="pStg">Pointer to the IStorage interface for storage for the object. This parameter cannot be <c>NULL</c>.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the newly created object.
            </param>
            <returns>This function returns S_OK on success.</returns>
            <remarks>
            <para>
            The <c>OleCreateStaticFromData</c> function can convert any object, as long as it provides an IDataObject interface, to a static
            object. It is useful in implementing the Convert To Picture option for OLE linking or embedding.
            </para>
            <para>
            Static objects can be created only if the source supports one of the OLE-rendered clipboard formats: CF_METAFILEPICT, CF_DIB, or
            CF_ BITMAP, and CF_ENHMETAFILE.
            </para>
            <para>
            You can also call <c>OleCreateStaticFromData</c> to paste a static object from the clipboard. To determine whether an object is
            static, call the OleQueryCreateFromData function, which returns OLE_S_STATIC if one of CF_METAFILEPICT, CF_DIB, CF_BITMAP, or
            CF_ENHMETAFILE is present and an OLE format is not present. This indicates that you should call <c>OleCreateStaticFromData</c>
            rather than the OleCreateFromData function to create the object.
            </para>
            <para>
            The new static object is of class CLSID_StaticMetafile in the case of CF_METAFILEPICT, CLSID_StaticDib in the case of CF_DIB or
            CF_BITMAP, or CLSID_Picture_EnhMetafile in the case of CF_ENHMETAFILE. The static object sets the OLEMISC_STATIC and
            OLE_CANTLINKINSIDE bits returned from IOleObject::GetMiscStatus. The static object will have the aspect DVASPECT_CONTENT and a
            LINDEX of -1.
            </para>
            <para>
            The pSrcDataObject is still valid after <c>OleCreateStaticFromData</c> returns. It is the caller's responsibility to free
            pSrcDataObject â€” OLE does not release it.
            </para>
            <para>There cannot be more than one presentation stream in a static object.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleDestroyMenuDescriptor(Vanara.PInvoke.Ole32.HOLEMENU)">
            <summary>Called by the container to free the shared menu descriptor allocated by the OleCreateMenuDescriptor function.</summary>
            <param name="holemenu">Handle to the shared menu descriptor that was returned by the OleCreateMenuDescriptor function.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleDoAutoConvert(Vanara.PInvoke.Ole32.IStorage,System.Guid@)">
            <summary>Automatically converts an object to a new class if automatic conversion for that object class is set in the registry.</summary>
            <param name="pStg">A pointer to the IStorage interface on the storage object to be converted.</param>
            <param name="pClsidNew">
            A pointer to the new CLSID for the object being converted. If there was no automatic conversion, this may be the same as the
            original class.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>No conversion is needed or a conversion was successfully completed.</term>
            </item>
            <item>
            <term>REGDB_E_KEYMISSING</term>
            <term>The function cannot read a key from the registry.</term>
            </item>
            </list>
            <para>
            This function can also return any of the error values returned by the OleGetAutoConvert function. When accessing storage and
            stream objects, see the IStorage::OpenStorage and IStorage::OpenStream methods for possible errors. When it is not possible to
            determine the existing CLSID or when it is not possible to update the storage object with new information, see the IStream
            interface for other error return values.
            </para>
            </returns>
            <remarks>
            <para>
            <c>OleDoAutoConvert</c> automatically converts an object if automatic conversion has previously been specified in the registry by
            the OleSetAutoConvert function. Object conversion means that the object is permanently associated with a new CLSID. Automatic
            conversion is typically specified by the setup program for a new version of an object application, so that objects created by its
            older versions can be automatically updated.
            </para>
            <para>The storage object must be in the unloaded state when <c>OleDoAutoConvert</c> is called.</para>
            <para>
            A container application that supports object conversion should call <c>OleDoAutoConvert</c> each time it loads an object. If the
            container uses the OleLoad helper function, it need not call <c>OleDoAutoConvert</c> explicitly because <c>OleLoad</c> calls it internally.
            </para>
            <para>
            <c>OleDoAutoConvert</c> first determines whether any conversion is required by calling the OleGetAutoConvert function, which, if
            no conversion is required, returns S_OK. If the object requires conversion, <c>OleDoAutoConvert</c> modifies and converts the
            storage object by activating the new object application. The new object application reads the existing data format, but saves the
            object in the new native format for the object application.
            </para>
            <para>
            If the object to be automatically converted is an OLE 1 object, the ItemName string is stored in a stream called
            "\1Ole10ItemName." If this stream does not exist, the object's item name is <c>NULL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleDraw(System.Object,System.Runtime.InteropServices.ComTypes.DVASPECT,Vanara.PInvoke.HDC,Vanara.PInvoke.RECT@)">
            <summary>Enables drawing objects more easily. You can use it instead of calling IViewObject::Draw directly.</summary>
            <param name="pUnknown">Points to the view object that is to be drawn.</param>
            <param name="dwAspect">
            Specifies how the object is to be represented. Representations include content, an icon, a thumbnail, or a printed document.
            Valid values are taken from the enumeration DVASPECT. See DVASPECT for more information.
            </param>
            <param name="hdcDraw">Specifies the device context on which to draw. Cannot be a metafile device context.</param>
            <param name="lprcBounds">
            Points to a RECT structure specifying the rectangle in which the object should be drawn. This parameter is converted to a RECTL
            structure and passed to IViewObject::Draw.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_BLANK</term>
            <term>No data to draw from.</term>
            </item>
            <item>
            <term>E_ABORT</term>
            <term>The draw operation was aborted.</term>
            </item>
            <item>
            <term>VIEW_E_DRAW</term>
            <term>No data to draw from.</term>
            </item>
            <item>
            <term>OLE_E_INVALIDRECT</term>
            <term>The rectangle is invalid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>DV_E_NOIVIEWOBJECT</term>
            <term>The object doesn't support the IViewObject interface.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The OleDraw helper function calls the QueryInterface method for the object specified (pUnk), asking for an IViewObject interface
            on that object. Then, <c>OleDraw</c> converts the RECT structure to a RECTL structure, and calls IViewObject::Draw as follows:
            </para>
            <para>Do not use this function to draw into a metafile because it does not specify the parameter required for drawing into metafiles.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleDuplicateData(Vanara.PInvoke.HANDLE,Vanara.PInvoke.CLIPFORMAT,Vanara.PInvoke.Kernel32.GMEM)">
            <summary>
            Duplicates the data found in the specified handle and returns a handle to the duplicated data. The source data is in a clipboard
            format. Use this function to help implement some of the data transfer interfaces such as IDataObject.
            </summary>
            <param name="hSrc">Handle of the source data.</param>
            <param name="cfFormat">Clipboard format of the source data.</param>
            <param name="uiFlags">
            Flags to be used to allocate global memory for the copied data. These flags are passed to GlobalAlloc. If the value of uiFlags is
            <c>NULL</c>, GMEM_MOVEABLE is used as a default flag.
            </param>
            <returns>On success the HANDLE to the source data is returned; on failure a <c>NULL</c> value is returned.</returns>
            <remarks>
            The CF_METAFILEPICT, CF_PALETTE, or CF_BITMAP formats receive special handling. They are GDI handles and a new GDI object must be
            created instead of just copying the bytes. All other formats are duplicated byte-wise.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleFlushClipboard">
            <summary>
            Carries out the clipboard shutdown sequence. It also releases the IDataObject pointer that was placed on the clipboard by the
            OleSetClipboard function.
            </summary>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CLIPBRD_E_CANT_OPEN</term>
            <term>The Windows OpenClipboard function used within OleFlushClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_CLOSE</term>
            <term>The Windows CloseClipboard function used within OleFlushClipboard failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>OleFlushClipboard</c> renders the data from a data object onto the clipboard and releases the IDataObject pointer to the data
            object. While the application that put the data object on the clipboard is running, the clipboard holds only a pointer to the
            data object, thus saving memory. If you are writing an application that acts as the source of a clipboard operation, you can call
            the <c>OleFlushClipboard</c> function when your application is closed, such as when the user exits from your application. Calling
            <c>OleFlushClipboard</c> enables pasting and paste-linking of OLE objects after application shutdown.
            </para>
            <para>
            Before calling <c>OleFlushClipboard</c>, you can easily determine if your data is still on the clipboard with a call to the
            OleIsCurrentClipboard function.
            </para>
            <para>
            <c>OleFlushClipboard</c> leaves all formats offered by the data transfer object, including the OLE 1 compatibility formats, on
            the clipboard so they are available after application shutdown. In addition to OLE 1 compatibility formats, these include all
            formats offered on a global handle medium (all except for TYMED_FILE) and formatted with a <c>NULL</c> target device. For
            example, if a data-source application offers a particular clipboard format (say cfFOO) on an IStorage object, and calls the
            <c>OleFlushClipboard</c> function, the storage object is copied into memory and the hglobal memory handle is put on the clipboard.
            </para>
            <para>
            To retrieve the information on the clipboard, you can call the OleGetClipboard function from another application, which creates a
            default data object, and the hglobal from the clipboard again becomes a storage object. Furthermore, the FORMATETC enumerator and
            the IDataObject::QueryGetData method would all correctly indicate that the original clipboard format (cfFOO) is again available
            on a TYMED_ISTORAGE.
            </para>
            <para>
            To empty the clipboard, call the OleSetClipboard function specifying a <c>NULL</c> value for its parameter. The application
            should call this when it closes if there is no need to leave data on the clipboard after shutdown, or if data will be placed on
            the clipboard using the standard Windows clipboard functions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleGetAutoConvert(System.Guid@,System.Guid@)">
            <summary>
            Determines whether the registry is set for objects of a specified CLSID to be automatically converted to another CLSID, and if
            so, retrieves the new CLSID.
            </summary>
            <param name="clsidOld">The CLSID for the object.</param>
            <param name="pClsidNew">
            A pointer to a variable to receive the new CLSID, if any. If auto-conversion for clsidOld is not set in the registry, clsidOld is
            returned. The pClsidNew parameter is never <c>NULL</c>.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A value was successfully returned through the pclsidNew parameter.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>The CLSID is not properly registered in the registry.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>Error reading from the registry.</term>
            </item>
            <item>
            <term>REGDB_E_KEYMISSING</term>
            <term>Auto-convert is not active or there was no registry entry for the clsidOld parameter.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>OleGetAutoConvert</c> returns the <c>AutoConvertTo</c> entry in the registry for the specified object. The
            <c>AutoConvertTo</c> subkey specifies whether objects of a given CLSID are to be automatically converted to a new CLSID. This is
            usually used to convert files created by older versions of an application to the current version. If there is no
            <c>AutoConvertTo</c> entry, this function returns the value of clsidOld.
            </para>
            <para>
            The OleDoAutoConvert function calls <c>OleGetAutoConvert</c> to determine whether the object specified is to be converted. A
            container application that supports object conversion should call <c>OleDoAutoConvert</c> each time it loads an object. If the
            container uses the OleLoad helper function, it need not call <c>OleDoAutoConvert</c> explicitly because <c>OleLoad</c> calls it internally.
            </para>
            <para>
            To set up automatic conversion of a given class, you can call the OleSetAutoConvert function (typically in the setup program of
            an application installation). This function uses the <c>AutoConvertTo</c> subkey to tag a class of objects for automatic
            conversion to a different class of objects. This is a subkey of the CLSID key.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleGetClipboard(System.Runtime.InteropServices.ComTypes.IDataObject@)">
            <summary>Retrieves a data object that you can use to access the contents of the clipboard.</summary>
            <param name="ppDataObj">Address of IDataObject pointer variable that receives the interface pointer to the clipboard data object.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CLIPBRD_E_CANT_OPEN</term>
            <term>The OpenClipboard function used within OleFlushClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_CLOSE</term>
            <term>The CloseClipboard function used within OleFlushClipboard failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para><c>Caution</c> Clipboard data is not trusted. Parse the data carefully before using it in your application.</para>
            <para>
            If you are writing an application that can accept data from the clipboard, call the <c>OleGetClipboard</c> function to get a
            pointer to the IDataObject interface that you can use to retrieve the contents of the clipboard.
            </para>
            <para><c>OleGetClipboard</c> handles three cases:</para>
            <list type="bullet">
            <item>
            <term>The application that placed data on the clipboard with the OleSetClipboard function is still running.</term>
            </item>
            <item>
            <term>
            The application that placed data on the clipboard with the OleSetClipboard function has subsequently called the OleFlushClipboard function.
            </term>
            </item>
            <item>
            <term>There is data from a non-OLE application on the clipboard.</term>
            </item>
            </list>
            <para>
            In the first case, the clipboard data object returned by <c>OleGetClipboard</c> may forward calls as necessary to the original
            data object placed on the clipboard and, thus, can potentially make RPC calls.
            </para>
            <para>
            In the second case, OLE creates a default data object and returns it to the user. Because the data on the clipboard originated
            from an OleSetClipboard call, the OLE-provided data object contains more accurate information about the type of data on the
            clipboard. In particular, the original medium (TYMED) on which the data was offered is known. Thus, if a data-source application
            offers a particular clipboard format, for example cfFOO, on a storage object and calls the OleFlushClipboard function, the
            storage object is copied into memory and the hglobal memory handle is put on the clipboard. Then, when the <c>OleGetClipboard</c>
            function creates its default data object, the hglobal from the clipboard again becomes an IStorage object. Furthermore, the
            FORMATETC enumerator and the IDataObject::QueryGetData method would all correctly indicate that the original clipboard format
            (cfFOO) is again available on a TYMED_ISTORAGE.
            </para>
            <para>
            In the third case, OLE still creates a default data object, but there is no special information about the data in the clipboard
            formats (particularly for application-defined Clipboard formats). Thus, if an hGlobal-based storage medium were put on the
            clipboard directly by a call to the SetClipboardData function, the FORMATETC enumerator and the IDataObject::QueryGetData method
            would not indicate that the data was available on a storage medium. A call to the IDataObject::GetData method for TYMED_ISTORAGE
            would succeed, however. Because of these limitations, it is strongly recommended that OLE-aware applications interact with the
            clipboard using the OLE clipboard functions.
            </para>
            <para>
            The clipboard data object created by the <c>OleGetClipboard</c> function has a fairly extensive IDataObject implementation. The
            OLE-provided data object can convert OLE 1 clipboard format data into the representation expected by an OLE 2 caller. Also, any
            structured data is available on any structured or flat medium, and any flat data is available on any flat medium. However, GDI
            objects (such as metafiles and bitmaps) are only available on their respective mediums.
            </para>
            <para>
            Note that the tymed member of the FORMATETC structure used in the <c>FORMATETC</c> enumerator contains the union of supported
            mediums. Applications looking for specific information (such as whether CF_TEXT is available on TYMED_HGLOBAL) should do the
            appropriate bitmasking when checking this value.
            </para>
            <para>
            If you call the <c>OleGetClipboard</c> function, you should only hold on to the returned IDataObject for a very short time. It
            consumes resources in the application that offered it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleGetClipboardWithEnterpriseInfo(System.Runtime.InteropServices.ComTypes.IDataObject@,Vanara.InteropServices.StrPtrUni@,Vanara.InteropServices.StrPtrUni@,Vanara.InteropServices.StrPtrUni@,Vanara.InteropServices.StrPtrUni@)">
            <summary>
            <para>
            Enables Windows Information Protection enlightened applications to retrieve an IDataObject from the OLE Clipboard accompanied by
            Windows Information Protection information about the data and the source application. This information allows the enlightened
            application to take over responsibility for applying Windows Information Protection policy, including flying any appropriate UI
            prompts, and auditing cases where the user explicitly approves copying enterprise data into a personal context.
            </para>
            <para>
            If the calling application is not enlightened, or is configured as "unallowed" to access enterprise data, then this call behaves
            exactly like OleGetClipboard - applying policy before deciding what IDataObject to return, and supplying empty strings as output.
            </para>
            </summary>
            <param name="dataObject">
            Address of IDataObject pointer variable that receives the interface pointer to the clipboard data object.
            </param>
            <param name="dataEnterpriseId">
            The enterprise id of the application that set the clipboard data. If the data is personal, this will be an empty string.
            </param>
            <param name="sourceDescription">The description of the application that set the clipboard.</param>
            <param name="targetDescription">The description of the caller's application to be used in auditing.</param>
            <param name="dataDescription">The description of the data object to be used in auditing.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CLIPBRD_E_CANT_OPEN</term>
            <term>The OpenClipboard function used within OleFlushClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_CLOSE</term>
            <term>The CloseClipboard function used within OleFlushClipboard failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para><c>Caution</c> Clipboard data is not trusted. Parse the data carefully before using it in your application.</para>
            <para>
            If you are writing an application that can accept data from the clipboard, call the <c>OleGetClipboardWithEnterpriseInfo</c>
            function to get a pointer to the IDataObject interface that you can use to retrieve the contents of the clipboard.
            </para>
            <para><c>OleGetClipboardWithEnterpriseInfo</c> handles three cases:</para>
            <list type="bullet">
            <item>
            <term>The application that placed data on the clipboard with the OleSetClipboard function is still running.</term>
            </item>
            <item>
            <term>
            The application that placed data on the clipboard with the OleSetClipboard function has subsequently called the OleFlushClipboard function.
            </term>
            </item>
            <item>
            <term>There is data from a non-OLE application on the clipboard.</term>
            </item>
            </list>
            <para>
            In the first case, the clipboard data object returned by <c>OleGetClipboardWithEnterpriseInfo</c> may forward calls as necessary
            to the original data object placed on the clipboard and, thus, can potentially make RPC calls.
            </para>
            <para>
            In the second case, OLE creates a default data object and returns it to the user. Because the data on the clipboard originated
            from an OleSetClipboard call, the OLE-provided data object contains more accurate information about the type of data on the
            clipboard. In particular, the original medium (TYMED) on which the data was offered is known. Thus, if a data-source application
            offers a particular clipboard format, for example cfFOO, on a storage object and calls the OleFlushClipboard function, the
            storage object is copied into memory and the hglobal memory handle is put on the clipboard. Then, when the
            <c>OleGetClipboardWithEnterpriseInfo</c> function creates its default data object, the hglobal from the clipboard again becomes
            an IStorage object. Furthermore, the FORMATETC enumerator and the IDataObject::QueryGetData method would all correctly indicate
            that the original clipboard format (cfFOO) is again available on a TYMED_ISTORAGE.
            </para>
            <para>
            In the third case, OLE still creates a default data object, but there is no special information about the data in the clipboard
            formats (particularly for application-defined Clipboard formats). Thus, if an hGlobal-based storage medium were put on the
            clipboard directly by a call to the SetClipboardData function, the FORMATETC enumerator and the IDataObject::QueryGetData method
            would not indicate that the data was available on a storage medium. A call to the IDataObject::GetData method for TYMED_ISTORAGE
            would succeed, however. Because of these limitations, it is strongly recommended that OLE-aware applications interact with the
            clipboard using the OLE clipboard functions.
            </para>
            <para>
            The clipboard data object created by the <c>OleGetClipboardWithEnterpriseInfo</c> function has a fairly extensive IDataObject
            implementation. The OLE-provided data object can convert OLE 1 clipboard format data into the representation expected by an OLE 2
            caller. Also, any structured data is available on any structured or flat medium, and any flat data is available on any flat
            medium. However, GDI objects (such as metafiles and bitmaps) are only available on their respective mediums.
            </para>
            <para>
            Note that the tymed member of the FORMATETC structure used in the <c>FORMATETC</c> enumerator contains the union of supported
            mediums. Applications looking for specific information (such as whether CF_TEXT is available on TYMED_HGLOBAL) should do the
            appropriate bitmasking when checking this value.
            </para>
            <para>
            If you call the <c>OleGetClipboardWithEnterpriseInfo</c> function, you should only hold on to the returned IDataObject for a very
            short time. It consumes resources in the application that offered it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleGetIconOfClass(System.Guid@,System.String,System.Boolean)">
            <summary>Returns a handle to a metafile containing an icon and a string label for the specified CLSID.</summary>
            <param name="rclsid">The CLSID for which the icon and string are to be requested.</param>
            <param name="lpszLabel">A pointer to the label for the icon.</param>
            <param name="fUseTypeAsLabel">Indicates whether to use the user type string in the CLSID as the icon label.</param>
            <returns>
            If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the specified CLSID.
            Otherwise, the function returns <c>NULL</c>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleGetIconOfFile(System.String,System.Boolean)">
            <summary>Returns a handle to a metafile containing an icon and string label for the specified file name.</summary>
            <param name="lpszPath">A pointer to a file for which the icon and string are to be requested.</param>
            <param name="fUseFileAsLabel">Indicates whether to use the file name as the icon label.</param>
            <returns>
            If the function succeeds, the return value is a handle to a metafile that contains and icon and label for the specified file. If
            there is no CLSID in the registration database for the file, then the function returns the string "Document". If lpszPath is
            <c>NULL</c>, the function returns <c>NULL</c>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleInitialize(System.IntPtr)">
            <summary>
            Initializes the COM library on the current apartment, identifies the concurrency model as single-thread apartment (STA), and
            enables additional functionality described in the Remarks section below. Applications must initialize the COM library before they
            can call COM library functions other than CoGetMalloc and memory allocation functions.
            </summary>
            <param name="pvReserved">This parameter is reserved and must be <c>NULL</c>.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_FALSE</term>
            <term>The COM library is already initialized on this apartment.</term>
            </item>
            <item>
            <term>OLE_E_WRONGCOMPOBJ</term>
            <term>The versions of COMPOBJ.DLL and OLE2.DLL on your machine are incompatible with each other.</term>
            </item>
            <item>
            <term>RPC_E_CHANGED_MODE</term>
            <term>
            A previous call to CoInitializeEx specified the concurrency model for this apartment as multithread apartment (MTA). This could
            also mean that a change from neutral threaded apartment to single threaded apartment occurred.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Applications that use the following functionality must call <c>OleInitialize</c> before calling any other function in the COM library:
            </para>
            <list type="bullet">
            <item>
            <term>Clipboard</term>
            </item>
            <item>
            <term>Drag and Drop</term>
            </item>
            <item>
            <term>Object linking and embedding (OLE)</term>
            </item>
            <item>
            <term>In-place activation</term>
            </item>
            </list>
            <para>
            <c>OleInitialize</c> calls CoInitializeEx internally to initialize the COM library on the current apartment. Because OLE
            operations are not thread-safe, <c>OleInitialize</c> specifies the concurrency model as single-thread apartment.
            </para>
            <para>
            Once the concurrency model for an apartment is set, it cannot be changed. A call to <c>OleInitialize</c> on an apartment that was
            previously initialized as multithreaded will fail and return RPC_E_CHANGED_MODE.
            </para>
            <para>
            You need to initialize the COM library on an apartment before you call any of the library functions except CoGetMalloc, to get a
            pointer to the standard allocator, and the memory allocation functions.
            </para>
            <para>
            Typically, the COM library is initialized on an apartment only once. Subsequent calls will succeed, as long as they do not
            attempt to change the concurrency model of the apartment, but will return S_FALSE. To close the COM library gracefully, each
            successful call to <c>OleInitialize</c>, including those that return S_FALSE, must be balanced by a corresponding call to OleUninitialize.
            </para>
            <para>
            Because there is no way to control the order in which in-process servers are loaded or unloaded, do not call <c>OleInitialize</c>
            or OleUninitialize from the DllMain function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleIsCurrentClipboard(System.Runtime.InteropServices.ComTypes.IDataObject)">
            <summary>
            Determines whether the data object pointer previously placed on the clipboard by the OleSetClipboard function is still on the clipboard.
            </summary>
            <param name="pDataObj">
            Pointer to the IDataObject interface on the data object containing clipboard data of interest, which the caller previously placed
            on the clipboard.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_FALSE</term>
            <term>The specified pointer is not on the clipboard.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>OleIsCurrentClipboard</c> only works for the data object used in the OleSetClipboard function. It cannot be called by the
            consumer of the data object to determine if the object that was on the clipboard at the previous OleGetClipboard call is still on
            the clipboard.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleIsRunning(Vanara.PInvoke.Ole32.IOleObject)">
            <summary>Determines whether a compound document object is currently in the running state.</summary>
            <param name="pObject">Pointer to the IOleObject interface on the object of interest.</param>
            <returns>The return value is <c>TRUE</c> if the object is running; otherwise, it is <c>FALSE</c>.</returns>
            <remarks>
            You can use <c>OleIsRunning</c> and IRunnableObject::IsRunning interchangeably. <c>OleIsRunning</c> queries the object for a
            pointer to the IRunnableObject interface and calls its <c>IRunnableObject::IsRunning</c> method. If successful, the function
            returns the results of the call to <c>IRunnableObject::IsRunning</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleLoad(Vanara.PInvoke.Ole32.IStorage,System.Guid@,Vanara.PInvoke.Ole32.IOleClientSite,System.Object@)">
            <summary>Loads into memory an object nested within a specified storage object.</summary>
            <param name="pStg">Pointer to the IStorage interface on the storage object from which to load the specified object.</param>
            <param name="riid">
            Reference to the identifier of the interface that the caller wants to use to communicate with the object after it is loaded.
            </param>
            <param name="pClientSite">Pointer to the IOleClientSite interface on the client site object being loaded.</param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the newly loaded object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support the specified interface.</term>
            </item>
            </list>
            <para>Additionally, this function can return any of the error values returned by the IPersistStorage::Load method.</para>
            </returns>
            <remarks>
            <para>
            OLE containers load objects into memory by calling this function. When calling the <c>OleLoad</c> function, the container
            application passes in a pointer to the open storage object in which the nested object is stored. Typically, the nested object to
            be loaded is a child storage object to the container's root storage object. Using the OLE information stored with the object, the
            object handler (usually, the default handler) attempts to load the object. On completion of the <c>OleLoad</c> function, the
            object is said to be in the loaded state with its object application not running.
            </para>
            <para>
            Some applications load all of the object's native data. Containers often defer loading the contained objects until required to do
            so. For example, until an object is scrolled into view and needs to be drawn, it does not need to be loaded.
            </para>
            <para>The <c>OleLoad</c> function performs the following steps:</para>
            <list type="bullet">
            <item>
            <term>If necessary, performs an automatic conversion of the object (see the OleDoAutoConvert function).</term>
            </item>
            <item>
            <term>Gets the CLSID from the open storage object by calling the IStorage::Stat method.</term>
            </item>
            <item>
            <term>
            Calls the CoCreateInstance function to create an instance of the handler. If the handler code is not available, the default
            handler is used (see the OleCreateDefaultHandler function).
            </term>
            </item>
            <item>
            <term>Calls the IOleObject::SetClientSite method with the pClientSite parameter to inform the object of its client site.</term>
            </item>
            <item>
            <term>
            Calls the QueryInterface method for the IPersistStorage interface. If successful, the IPersistStorage::Load method is invoked for
            the object.
            </term>
            </item>
            <item>
            <term>Queries and returns the interface identified by the riid parameter.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleLockRunning(System.Object,System.Boolean,System.Boolean)">
            <summary>Locks an already running object into its running state or unlocks it from its running state.</summary>
            <param name="pUnknown">Pointer to the IUnknown interface on the object, which the function uses to query for a pointer to IRunnableObject.</param>
            <param name="fLock"><c>TRUE</c> locks the object into its running state. <c>FALSE</c> unlocks the object from its running state.</param>
            <param name="fLastUnlockCloses">
            <c>TRUE</c> specifies that if the connection being released is the last external lock on the object, the object should close.
            <c>FALSE</c> specifies that the object should remain open until closed by the user or another process.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleLockRunning</c> function saves you the trouble of calling the IRunnableObject::LockRunning method. You can use
            <c>OleLockRunning</c> and <c>IRunnableObject::LockRunning</c> interchangeably. With the IUnknown pointer passed in with the
            pUnknown parameter, <c>OleLockRunning</c> queries for an IRunnableObject pointer. If successful, it calls
            <c>IRunnableObject::LockRunning</c> and returns the results of the call.
            </para>
            <para>For more information on using this function, see IRunnableObject::LockRunning.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleMetafilePictFromIconAndLabel(Vanara.PInvoke.HICON,System.String,System.String,System.UInt32)">
            <summary>Creates a metafile in which the specified icon and label are drawn.</summary>
            <param name="hIcon">
            Handle to the icon that is to be drawn into the metafile. This parameter can be <c>NULL</c>. If hIcon is <c>NULL</c>, this
            function returns <c>NULL</c> without creating a metafile.
            </param>
            <param name="lpszLabel">
            The icon label. This parameter can be <c>NULL</c>. If lpszLabel is <c>NULL</c>, the resulting metafile will not include a label.
            </param>
            <param name="lpszSourceFile">
            The path and file name of the icon file. This string can be obtained through the user interface or from the registration
            database. This parameter can be <c>NULL</c>.
            </param>
            <param name="iIconIndex">
            The location of the icon within the file named by lpszSourceFile, expressed as an offset in bytes from the beginning of file.
            </param>
            <returns>
            <para>
            A global handle to a METAFILEPICT structure containing the icon and label. The metafile uses the MM_ANISOTROPIC mapping mode.
            </para>
            <para>
            If an error occurs, the returned handle is <c>NULL</c>. In this case, the caller can call GetLastError to obtain further information.
            </para>
            </returns>
            <remarks>
            <para>This function is called by OleGetIconOfFile and OleGetIconOfClass.</para>
            <para>
            If lpszSourceFile is not <c>NULL</c> and iIconIndex is not 0, the name of the source file passed in lpszSourceFile and the index
            passed by iIconIndex are added to the created metafile as a comment record.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleNoteObjectVisible(System.Object,System.Boolean)">
            <summary>Increments or decrements an external reference that keeps an object in the running state.</summary>
            <param name="pUnknown">Pointer to the IUnknown interface on the object that is to be locked or unlocked.</param>
            <param name="fVisible">
            Whether the object is visible. If <c>TRUE</c>, OLE increments the reference count to hold the object visible and alive regardless
            of external or internal IUnknown::AddRef and IUnknown::Release operations, registrations, or revocation. If <c>FALSE</c>, OLE
            releases its hold (decrements the reference count) and the object can be closed.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>OleNoteObjectVisible</c> function calls the CoLockObjectExternal function. It is provided as a separate function to
            reinforce the need to lock an object when it becomes visible to the user and to release the object when it becomes invisible.
            This creates a strong lock on behalf of the user to ensure that the object cannot be closed by its container while it is visible.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleQueryCreateFromData(System.Runtime.InteropServices.ComTypes.IDataObject)">
            <summary>
            Checks whether a data object has one of the formats that would allow it to become an embedded object through a call to either the
            OleCreateFromData or OleCreateStaticFromData function.
            </summary>
            <param name="pSrcDataObject">Pointer to the IDataObject interface on the data transfer object to be queried.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_FALSE</term>
            <term>No formats are present that support either embedded- or static-object creation.</term>
            </item>
            <item>
            <term>OLE_S_STATIC</term>
            <term>Formats that support static-object creation are present.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When an application retrieves a data transfer object through a call to the OleGetClipboard function, the application should call
            <c>OleQueryCreateFromData</c> as part of the process of deciding to enable or disable the <c>Edit/Paste</c> or <c>Edit/Paste
            Special...</c> commands. It tests for the presence of the following formats in the data object:
            </para>
            <list type="bullet">
            <item>
            <term>CF_EMBEDDEDOBJECT</term>
            </item>
            <item>
            <term>CF_EMBEDSOURCE</term>
            </item>
            <item>
            <term>cfFileName</term>
            </item>
            <item>
            <term>CF_METAFILEPICT</term>
            </item>
            <item>
            <term>CF_DIB</term>
            </item>
            <item>
            <term>CF_BITMAP</term>
            </item>
            <item>
            <term>CF_ENHMETAFILE</term>
            </item>
            </list>
            <para>
            Determining that the data object has one of these formats does not absolutely guarantee that the object creation will succeed,
            but is intended to help the process.
            </para>
            <para>
            If <c>OleQueryCreateFromData</c> finds one of the CF_METAFILEPICT, CF_BITMAP, CF_DIB, or CF_ENHMETAFILE formats and none of the
            other formats, it returns OLE_S_STATIC, indicating that you should call the OleCreateStaticFromData function to create the
            embedded object.
            </para>
            <para>
            If <c>OleQueryCreateFromData</c> finds one of the other formats (CF_EMBEDDEDOBJECT, CF_EMBEDSOURCE, or cfFileName), even in
            combination with the static formats, it returns S_OK, indicating that you should call the OleCreateFromData function to create
            the embedded object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleQueryLinkFromData(System.Runtime.InteropServices.ComTypes.IDataObject)">
            <summary>
            Determines whether an OLE linked object (rather than an OLE embedded object) can be created from a clipboard data object.
            </summary>
            <param name="pSrcDataObject">
            Pointer to the IDataObject interface on the clipboard data object from which the object is to be created.
            </param>
            <returns>Returns S_OK if the OleCreateLinkFromData function can be used to create the linked object; otherwise S_FALSE.</returns>
            <remarks>
            The <c>OleQueryLinkFromData</c> function is similar to the OleQueryCreateFromData function, but determines whether an OLE linked
            object (rather than an OLE embedded object) can be created from the clipboard data object. If the return value is S_OK, the
            application can then attempt to create the object with a call to OleCreateLinkFromData. A successful return from
            <c>OleQueryLinkFromData</c> does not, however, guarantee the successful creation of a link.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleRegEnumFormatEtc(System.Guid@,System.Runtime.InteropServices.ComTypes.DATADIR,System.Runtime.InteropServices.ComTypes.IEnumFORMATETC@)">
            <summary>
            Creates an enumeration object that can be used to enumerate data formats that an OLE object server has registered in the system
            registry. An object application or object handler calls this function when it must enumerate those formats. Developers of custom
            DLL object applications use this function to emulate the behavior of the default object handler.
            </summary>
            <param name="clsid">CLSID of the class whose formats are being requested.</param>
            <param name="dwDirection">
            Indicates whether to enumerate formats that can be passed to IDataObject::GetData or formats that can be passed to
            IDataObject::SetData. Possible values are taken from the enumeration DATADIR.
            </param>
            <param name="ppenum">Address of IEnumFORMATETC pointer variable that receives the interface pointer to the enumeration object.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>There is no CLSID registered for the class object.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading the registry.</term>
            </item>
            <item>
            <term>OLE_E_REGDB_KEY</term>
            <term>The DataFormats/GetSet key is missing from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Object applications can ask OLE to create an enumeration object for FORMATETC structures to enumerate supported data formats in
            one of two ways. One way is to call <c>OleRegEnumFormatEtc</c>. The other is to return OLE_S_USEREG in response to calls by the
            default object handler to IDataObject::EnumFormatEtc. OLE_S_USEREG instructs the default handler to call
            <c>OleRegEnumFormatEtc</c>. Because DLL object applications cannot return OLE_S_USEREG, they must call <c>OleRegEnumFormatEtc</c>
            rather than delegating the job to the object handler. With the supplied IEnumFORMATETC pointer to the object, you can call the
            standard enumeration object methods to do the enumeration.
            </para>
            <para>
            The <c>OleRegEnumFormatEtc</c> function and its sibling functions, OleRegGetUserType, OleRegGetMiscStatus, and OleRegEnumVerbs,
            provide a way for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting
            information about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and
            the pitfalls inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these
            functions without having to code them yourself.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleRegEnumVerbs(System.Guid@,Vanara.PInvoke.Ole32.IEnumOLEVERB@)">
            <summary>
            Supplies an enumeration of the registered verbs for the specified class. Developers of custom DLL object applications use this
            function to emulate the behavior of the default object handler.
            </summary>
            <param name="clsid">Class identifier whose verbs are being requested.</param>
            <param name="ppenum">Address of IEnumOLEVERB* pointer variable that receives the interface pointer to the new enumeration object.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLEOBJ_E_NOVERBS</term>
            <term>No verbs are registered for the class.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>No CLSID is registered for the class object.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>An error occurred reading the registry.</term>
            </item>
            <item>
            <term>OLE_E_REGDB_KEY</term>
            <term>The DataFormats/GetSet key is missing from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Object applications can ask OLE to create an enumeration object for OLEVERB structures to enumerate supported verbs in one of two
            ways. One way is to call <c>OleRegEnumVerbs</c>. The other way is to return OLE_S_USEREG in response to calls by the default
            object handler to IOleObject::EnumVerbs. OLE_S_USEREG instructs the default handler to call <c>OleRegEnumVerbs</c>. Because DLL
            object applications cannot return OLE_S_USEREG, they must call <c>OleRegEnumVerbs</c> rather than delegating the job to the
            object handler. With the supplied IEnumOLEVERB pointer to the object, you can call the standard enumeration object methods to do
            the enumeration.
            </para>
            <para>
            The <c>OleRegEnumVerbs</c> function and its sibling functions, OleRegGetUserType, OleRegGetMiscStatus, and OleRegEnumFormatEtc,
            provide a way for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting
            information about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and
            the pitfalls inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these
            functions without having to code them yourself.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleRegGetMiscStatus(System.Guid@,System.Runtime.InteropServices.ComTypes.DVASPECT,System.UInt32@)">
            <summary>
            <para>Returns miscellaneous information about the presentation and behaviors supported by the specified CLSID from the registry.</para>
            <para>This function is used by developers of custom DLL object applications to emulate the behavior of the OLE default handler.</para>
            </summary>
            <param name="clsid">The CLSID of the class for which status information is to be requested.</param>
            <param name="dwAspect">
            The presentation aspect of the class for which information is requested. Possible values are taken from the DVASPECT enumeration.
            </param>
            <param name="pdwStatus">A pointer to the variable that receives the status information.</param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The status information was returned successfully.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>No CLSID is registered for the class object.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading from the registry.</term>
            </item>
            <item>
            <term>OLE_E_REGDB_KEY</term>
            <term>The GetMiscStatus key is missing from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Object applications can ask OLE to get miscellaneous status information in one of two ways. One way is to call
            <c>OleRegGetMiscStatus</c>. The other is to return OLE_S_USEREG in response to calls by the default object handler to
            IOleObject::GetMiscStatus. OLE_S_USEREG instructs the default handler to call <c>OleRegGetMiscStatus</c>. Because DLL object
            applications cannot return OLE_S_USEREG, they must call <c>OleRegGetMiscStatus</c> rather than delegating the job to the object handler.
            </para>
            <para>
            <c>OleRegGetMiscStatus</c> and its sibling functions, OleRegGetUserType, OleRegEnumFormatEtc, and OleRegEnumVerbs, provide a way
            for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting information
            about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and the pitfalls
            inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these functions
            without having to code them yourself.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleRegGetUserType(System.Guid@,Vanara.PInvoke.Ole32.USERCLASSTYPE,System.String@)">
            <summary>
            <para>Gets the user type of the specified class from the registry.</para>
            <para>Developers of custom DLL object applications use this function to emulate the behavior of the OLE default handler.</para>
            </summary>
            <param name="clsid">The CLSID of the class for which the user type is to be requested.</param>
            <param name="dwFormOfType">The form of the user-presentable string. Possible values are taken from the enumeration USERCLASSTYPE.</param>
            <param name="pszUserType">A pointer to a string that receives the user type.</param>
            <returns>
            <para>This function can return the standard return value E_OUTOFMEMORY, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The user type was returned successfully.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>No CLSID is registered for the class object.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>There was an error reading from the registry.</term>
            </item>
            <item>
            <term>OLE_E_REGDB_KEY</term>
            <term>The ProgID = MainUserTypeName and CLSID = MainUserTypeName keys are missing from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Object applications can ask OLE to get the user type name of a specified class in one of two ways. One way is to call
            <c>OleRegGetUserType</c>. The other is to return OLE_S_USEREG in response to calls by the default object handler to
            IOleObject::GetUserType. OLE_S_USEREG instructs the default handler to call <c>OleRegGetUserType</c>. Because DLL object
            applications cannot return OLE_S_USEREG, they must call <c>OleRegGetUserType</c>, rather than delegating the job to the object handler.
            </para>
            <para>
            The <c>OleRegGetUserType</c> function and its sibling functions, OleRegGetMiscStatus, OleRegEnumFormatEtc, and OleRegEnumVerbs,
            provide a way for developers of custom DLL object applications to emulate the behavior of OLE's default object handler in getting
            information about objects from the registry. By using these functions, you avoid the considerable work of writing your own, and
            the pitfalls inherent in working directly in the registry. In addition, you get future enhancements and optimizations of these
            functions without having to code them yourself.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleRun(System.Object)">
            <summary>Puts an OLE compound document object into the running state.</summary>
            <param name="pUnknown">
            Pointer to the IUnknown interface on the object, with which it will query for a pointer to the IRunnableObject interface, and
            then call its Run method.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_CLASSDIFF</term>
            <term>The source of an OLE link has been converted to a different class.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleRun</c> function puts an object in the running state. The implementation of <c>OleRun</c> was changed in OLE 2.01 to
            coincide with the publication of the IRunnableObject interface. You can use <c>OleRun</c> and IRunnableObject::Run
            interchangeably. <c>OleRun</c> queries the object for a pointer to <c>IRunnableObject</c>. If successful, the function returns
            the results of calling the <c>IRunnableObject::Run</c> method.
            </para>
            <para>For more information on using this function, see IRunnableObject::Run.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSave(Vanara.PInvoke.Ole32.IPersistStorage,Vanara.PInvoke.Ole32.IStorage,System.Boolean)">
            <summary>Saves an object opened in transacted mode into the specified storage object.</summary>
            <param name="pPS">Pointer to the IPersistStorage interface on the object to be saved.</param>
            <param name="pStg">
            Pointer to the IStorage interface on the destination storage object to which the object indicated in pPS is to be saved.
            </param>
            <param name="fSameAsLoad">
            <c>TRUE</c> indicates that pStg is the same storage object from which the object was loaded or created; <c>FALSE</c> indicates
            that pStg was loaded or created from a different storage object.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>STGMEDIUM_E_FULL</term>
            <term>
            The object could not be saved due to lack of disk space. This function can also return any of the error values returned by the
            IPersistStorage::Save method.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>OleSave</c> helper function handles the common situation in which an object is open in transacted mode and is then to be
            saved into the specified storage object which uses the OLE-provided compound file implementation. Transacted mode means that
            changes to the object are buffered until either of the IStorage::Commit or IStorage::Revert is called. Callers can handle other
            situations by calling the IPersistStorage and IStorage interfaces directly.
            </para>
            <para><c>OleSave</c> does the following:</para>
            <list type="bullet">
            <item>
            <term>Calls the IPersist::GetClassID method to get the CLSID of the object.</term>
            </item>
            <item>
            <term>Writes the CLSID to the storage object using the WriteClassStg function.</term>
            </item>
            <item>
            <term>Calls the IPersistStorage::Save method to save the object.</term>
            </item>
            <item>
            <term>If there were no errors on the save; calls the IStorage::Commit method to commit the changes.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Static objects are saved into a stream called CONTENTS. Static metafile objects get saved in "placeable metafile
            format" and static DIB data gets saved in "DIB file format." These formats are defined to be the OLE standards for metafile and
            DIB. All data transferred using an IStream interface or a file (that is, via IDataObject::GetDataHere) must be in these formats.
            Also, all objects whose default file format is a metafile or DIB must write their data into a CONTENTS stream using these
            standard formats.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSaveToStream(Vanara.PInvoke.Ole32.IPersistStream,System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>Saves an object with the IPersistStream interface on it to the specified stream.</summary>
            <param name="pPStm"/>
            <param name="pStm"/>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>STGMEDIUM_E_FULL</term>
            <term>The object could not be saved due to lack of disk space.</term>
            </item>
            <item>
            <term>OLE_E_BLANK</term>
            <term>The pPStm parameter is NULL.</term>
            </item>
            </list>
            <para>
            This function can also return any of the error values returned by the WriteClassStm function or the IPersistStream::Save method.
            </para>
            </returns>
            <remarks>
            <para>
            This function simplifies saving an object that implements the IPersistStream interface to a stream. In this stream, the object's
            CLSID precedes its data. When the stream is retrieved, the CLSID permits the proper code to be associated with the data. The
            <c>OleSaveToStream</c> function does the following:
            </para>
            <list type="bullet">
            <item>
            <term>Calls the IPersist::GetClassID method to get the object's CLSID.</term>
            </item>
            <item>
            <term>Writes the CLSID to the stream with the WriteClassStm function.</term>
            </item>
            <item>
            <term>Calls the IPersistStream::Save method with fClearDirty set to <c>TRUE</c>, which clears the dirty bit in the object.</term>
            </item>
            </list>
            <para>The companion helper, OleLoadFromStream, loads objects saved in this way.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSetAutoConvert(System.Guid@,System.Guid@)">
            <summary>Specifies a CLSID for automatic conversion to a different class when an object of that class is loaded.</summary>
            <param name="clsidOld">The CLSID of the object class to be converted.</param>
            <param name="clsidNew">
            The CLSID of the object class that should replace clsidOld. This new CLSID replaces any existing auto-conversion information in
            the registry for clsidOld. If this value is CLSID_NULL, any existing auto-conversion information for clsidOld is removed from the registry.
            </param>
            <returns>
            <para>
            This function can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The object was tagged successfully.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>The CLSID is not properly registered in the registry.</term>
            </item>
            <item>
            <term>REGDB_E_READREGDB</term>
            <term>Error reading from the registry.</term>
            </item>
            <item>
            <term>REGDB_E_WRITEREGDB</term>
            <term>Error writing to the registry.</term>
            </item>
            <item>
            <term>REGDB_E_KEYMISSING</term>
            <term>Cannot read a key from the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>OleSetAutoConvert</c> goes to the system registry, finds the <c>AutoConvertTo</c> subkey under the CLSID specified by
            clsidOld, and sets it to clsidNew. This function does not validate whether an appropriate registry entry for clsidNew currently
            exists. These entries appear in the registry as subkeys of the CLSID key.
            </para>
            <para>
            Object conversion means that the object's data is permanently associated with a new CLSID. Automatic conversion is typically
            specified in the setup program of a new version of an object application, so objects created by its older versions can be
            automatically updated to the new version.
            </para>
            <para>
            For example, it may be necessary to convert spreadsheets that were created with earlier versions of a spreadsheet application to
            the new version. The spreadsheet objects from earlier versions have different CLSIDs than the new version. For each earlier
            version that you want automatically updated, you would call <c>OleSetAutoConvert</c> in the setup program, specifying the CLSID
            of the old version, and that of the new one. Then, whenever a user loads an object from a previous version, it would be
            automatically updated. To support automatic conversion of objects, a server that supports conversion must be prepared to manually
            convert objects that have the format of an earlier version of the server. Automatic conversion relies internally on this
            manual-conversion support.
            </para>
            <para>
            Before setting the desired <c>AutoConvertTo</c> value, setup programs should also call <c>OleSetAutoConvert</c> to remove any
            existing conversion for the new class, by specifying the new class as the clsidOld parameter, and setting the clsidNew parameter
            to CLSID_NULL.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSetClipboard(System.Runtime.InteropServices.ComTypes.IDataObject)">
            <summary>
            Places a pointer to a specific data object onto the clipboard. This makes the data object accessible to the OleGetClipboard function.
            </summary>
            <param name="pDataObj">
            Pointer to the IDataObject interface on the data object from which the data to be placed on the clipboard can be obtained. This
            parameter can be <c>NULL</c>; in which case the clipboard is emptied.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>CLIPBRD_E_CANT_OPEN</term>
            <term>The OpenClipboard function used within OleSetClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_EMPTY</term>
            <term>The EmptyClipboard function used within OleSetClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_CLOSE</term>
            <term>The CloseClipboard function used within OleSetClipboard failed.</term>
            </item>
            <item>
            <term>CLIPBRD_E_CANT_SET</term>
            <term>The SetClipboardData function used within OleSetClipboard failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>If you are writing an application that can act as the source of a clipboard operation, you must do the following:</para>
            <list type="bullet">
            <item>
            <term>
            Create a data object (on which is the IDataObject interface) for the data being copied or cut to the clipboard. This object
            should be the same object used in OLE drag-and-drop operations.
            </term>
            </item>
            <item>
            <term>
            Call <c>OleSetClipboard</c> to place the IDataObject pointer onto the clipboard, so it is accessible to the OleGetClipboard
            function. <c>OleSetClipboard</c> also calls the IUnknown::AddRef method on your data object.
            </term>
            </item>
            <item>
            <term>
            If you wish, release the data object after you have placed it on the clipboard to free the IUnknown::AddRef counter in your application.
            </term>
            </item>
            <item>
            <term>
            If the user is cutting data (deleting it from the document and putting it on to the clipboard), remove the data from the document.
            </term>
            </item>
            </list>
            <para>
            All formats are offered on the clipboard using delayed rendering (the clipboard contains only a pointer to the data object unless
            a call to OleFlushClipboard renders the data onto the clipboard). The formats necessary for OLE 1 compatibility are synthesized
            from the OLE 2 formats that are present and are also put on the clipboard.
            </para>
            <para>
            The <c>OleSetClipboard</c> function assigns ownership of the clipboard to an internal OLE window handle. The reference count of
            the data object is increased by 1, to enable delayed rendering. The reference count is decreased by a call to the
            OleFlushClipboard function or by a subsequent call to <c>OleSetClipboard</c> specifying <c>NULL</c> as the parameter value (which
            clears the clipboard).
            </para>
            <para>
            When an application opens the clipboard (either directly or indirectly by calling the OpenClipboard function), the clipboard
            cannot be used by any other application until it is closed. If the clipboard is currently open by another application,
            <c>OleSetClipboard</c> fails. The internal OLE window handle satisfies WM_RENDERFORMAT messages by delegating them to the
            IDataObject implementation on the data object that is on the clipboard.
            </para>
            <para>
            Specifying <c>NULL</c> as the parameter value for <c>OleSetClipboard</c> empties the current clipboard. If the contents of the
            clipboard are the result of a previous <c>OleSetClipboard</c> call and the clipboard has been released, the IDataObject pointer
            that was passed to the previous call is released. The clipboard owner should use this as a signal that the data it previously
            offered is no longer on the clipboard.
            </para>
            <para>
            If you need to leave the data on the clipboard after your application is closed, you should call OleFlushClipboard rather than
            calling <c>OleSetClipboard</c> with a <c>NULL</c> parameter value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSetContainedObject(System.Object,System.Boolean)">
            <summary>
            Notifies an object that it is embedded in an OLE container, which ensures that reference counting is done correctly for
            containers that support links to embedded objects.
            </summary>
            <param name="pUnknown">Pointer to the IUnknown interface of the object.</param>
            <param name="fContained"><c>TRUE</c> if the object is an embedded object; <c>FALSE</c> otherwise.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>OleSetContainedObject</c> function notifies an object that it is embedded in an OLE container. The implementation of
            <c>OleSetContainedObject</c> was changed in OLE 2.01 to coincide with the publication of the IRunnableObject interface. You can
            use <c>OleSetContainedObject</c> and the IRunnableObject::SetContainedObject method interchangeably. The
            <c>OleSetContainedObject</c> function queries the object for a pointer to the <c>IRunnableObject</c> interface. If successful,
            the function returns the results of calling <c>IRunnableObject::SetContainedObject</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleSetMenuDescriptor(Vanara.PInvoke.Ole32.HOLEMENU,Vanara.PInvoke.HWND,Vanara.PInvoke.HWND,Vanara.PInvoke.Ole32.IOleInPlaceFrame,Vanara.PInvoke.Ole32.IOleInPlaceActiveObject)">
            <summary>Installs or removes OLE dispatching code from the container's frame window.</summary>
            <param name="holemenu">
            Handle to the composite menu descriptor returned by the OleCreateMenuDescriptor function. If <c>NULL</c>, the dispatching code is unhooked.
            </param>
            <param name="hwndFrame">Handle to the container's frame window where the in-place composite menu is to be installed.</param>
            <param name="hwndActiveObject">
            Handle to the object's in-place activation window. OLE dispatches menu messages and commands to this window.
            </param>
            <param name="lpFrame">Pointer to the IOleInPlaceFrame interface on the container's frame window.</param>
            <param name="lpActiveObj">Pointer to the IOleInPlaceActiveObject interface on the active in-place object.</param>
            <returns>This function returns S_OK on success.</returns>
            <remarks>
            <para>
            The container should call <c>OleSetMenuDescriptor</c> to install the dispatching code on hwndFrame when the object calls the
            IOleInPlaceFrame::SetMenu method, or to remove the dispatching code by passing <c>NULL</c> as the value for holemenu to <c>OleSetMenuDescriptor</c>.
            </para>
            <para>
            If both the lpFrame and lpActiveObj parameters are non- <c>NULL</c>, OLE installs the context-sensitive help F1 message filter
            for the application. Otherwise, the application must supply its own message filter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleTranslateAccelerator(Vanara.PInvoke.Ole32.IOleInPlaceFrame,Vanara.PInvoke.Ole32.OIFI@,Vanara.PInvoke.MSG@)">
            <summary>
            Called by the object application, allows an object's container to translate accelerators according to the container's accelerator table.
            </summary>
            <param name="lpFrame">Pointer to the IOleInPlaceFrame interface to which the keystroke might be sent.</param>
            <param name="lpFrameInfo">Pointer to an OLEINPLACEFRAMEINFO structure containing the accelerator table obtained from the container.</param>
            <param name="lpmsg">Pointer to an MSG structure containing the keystroke.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The object should continue processing this message.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Object servers call <c>OleTranslateAccelerator</c> to allow the object's container to translate accelerator keystrokes according
            to the container's accelerator table, pointed to by lpFrameInfo. While a contained object is the active object, the object's
            server always has first chance at translating any messages received. If this is not desired, the server calls
            <c>OleTranslateAccelerator</c> to give the object's container a chance. If the keyboard input matches an accelerator found in the
            container-provided accelerator table, <c>OleTranslateAccelerator</c> passes the message and its command identifier on to the
            container through the IOleInPlaceFrame::TranslateAccelerator method. This method returns S_OK if the keystroke is consumed;
            otherwise it returns S_FALSE.
            </para>
            <para>
            Accelerator tables for containers should be defined so they will work properly with object applications that do their own
            accelerator keystroke translations. These tables should take the form:
            </para>
            <para>
            This is the most common way to describe keyboard accelerators. Failure to do so can result in keystrokes being lost or sent to
            the wrong object during an in-place session.
            </para>
            <para>Objects can call the IsAccelerator function to see whether the accelerator keystroke belongs to the object or the container.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.OleUninitialize">
            <summary>
            Closes the COM library on the apartment, releases any class factories, other COM objects, or servers held by the apartment,
            disables RPC on the apartment, and frees any resources the apartment maintains.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ReadFmtUserTypeStg(Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.CLIPFORMAT@,System.String@)">
            <summary>
            The <c>ReadFmtUserTypeStg</c> function returns the clipboard format and user type previously saved with the WriteFmtUserTypeStg function.
            </summary>
            <param name="pstg">Pointer to the IStorage interface on the storage object from which the information is to be read.</param>
            <param name="pcf">
            Pointer to where the clipboard format is to be written on return. It can be <c>NULL</c>, indicating the format is of no interest
            to the caller.
            </param>
            <param name="lplpszUserType">
            Address of <c>LPWSTR</c> pointer variable that receives a pointer to the null-terminated Unicode user-type string. The caller can
            specify <c>NULL</c> for this parameter, which indicates that the user type is of no interest. This function allocates memory for
            the string. The caller is responsible for freeing the memory with CoTaskMemFree.
            </param>
            <returns>
            <para>This function supports the standard return values E_FAIL, E_INVALIDARG, and E_OUTOFMEMORY, in addition to the following:</para>
            <para>This function also returns any of the error values returned by the ISequentialStream::Read method.</para>
            </returns>
            <remarks>
            <c>ReadFmtUserTypeStg</c> returns the clipboard format and the user type string from the specified storage object. The
            WriteClassStg function must have been called before calling the <c>ReadFmtUserTypeStg</c> function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RegisterDragDrop(Vanara.PInvoke.HWND,Vanara.PInvoke.Ole32.IDropTarget)">
            <summary>
            Registers the specified window as one that can be the target of an OLE drag-and-drop operation and specifies the IDropTarget
            instance to use for drop operations.
            </summary>
            <param name="hwnd">Handle to a window that can be a target for an OLE drag-and-drop operation.</param>
            <param name="pDropTarget">
            Pointer to the IDropTarget interface on the object that is to be the target of a drag-and-drop operation in a specified window.
            This interface is used to communicate OLE drag-and-drop information for that window.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DRAGDROP_E_INVALIDHWND</term>
            <term>Invalid handle returned in the hwnd parameter.</term>
            </item>
            <item>
            <term>DRAGDROP_E_ALREADYREGISTERED</term>
            <term>The specified window has already been registered as a drop target.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            </list>
            <para>
            <c>Note</c> If you use CoInitialize or CoInitializeEx instead of OleInitialize to initialize COM, <c>RegisterDragDrop</c> will
            always return an E_OUTOFMEMORY error.
            </para>
            </returns>
            <remarks>
            <para>
            If your application can accept dropped objects during OLE drag-and-drop operations, you must call the <c>RegisterDragDrop</c>
            function. Do this whenever one of your application windows is available as a potential drop target, i.e., when the window appears
            unobscured on the screen.
            </para>
            <para>
            The application thread that calls the <c>RegisterDragDrop</c> function must be pumping messages, presumably by calling the
            GetMessage function with a <c>NULL</c> hWnd parameter, because OLE creates windows on the thread that need messages processed. If
            this requirement is not met, any application that drags an object over the window that is registered as a drop target will hang
            until the target application closes.
            </para>
            <para>
            The <c>RegisterDragDrop</c> function only registers one window at a time, so you must call it for each application window capable
            of accepting dropped objects.
            </para>
            <para>
            As the mouse passes over unobscured portions of the target window during an OLE drag-and-drop operation, the DoDragDrop function
            calls the specified IDropTarget::DragOver method for the current window. When a drop operation actually occurs in a given window,
            the <c>DoDragDrop</c> function calls IDropTarget::Drop.
            </para>
            <para>The <c>RegisterDragDrop</c> function also calls the IUnknown::AddRef method on the IDropTarget pointer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.ReleaseStgMedium(System.Runtime.InteropServices.ComTypes.STGMEDIUM@)">
            <summary>Frees the specified storage medium.</summary>
            <param name="pMedium">Pointer to the storage medium that is to be freed.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RevokeDragDrop(Vanara.PInvoke.HWND)">
            <summary>Revokes the registration of the specified application window as a potential target for OLE drag-and-drop operations.</summary>
            <param name="hwnd">Handle to a window previously registered as a target for an OLE drag-and-drop operation.</param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DRAGDROP_E_NOTREGISTERED</term>
            <term>An attempt was made to revoke a drop target that has not been registered.</term>
            </item>
            <item>
            <term>DRAGDROP_E_INVALIDHWND</term>
            <term>Invalid handle returned in the hwnd parameter.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There is insufficient memory for the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When your application window is no longer available as a potential target for an OLE drag-and-drop operation, you must call <c>RevokeDragDrop</c>.
            </para>
            <para>This function calls the IUnknown::Release method for your drop target interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.SetConvertStg(Vanara.PInvoke.Ole32.IStorage,System.Boolean)">
            <summary>
            The <c>SetConvertStg</c> function sets the convert bit in a storage object to indicate that the object is to be converted to a
            new class when it is opened. The setting can be retrieved with a call to the GetConvertStg function.
            </summary>
            <param name="pStg">IStorage pointer to the storage object in which to set the conversion bit.</param>
            <param name="fConvert">
            If <c>TRUE</c>, sets the conversion bit for the object to indicate the object is to be converted when opened. If <c>FALSE</c>,
            clears the conversion bit.
            </param>
            <returns>
            See the IStorage::CreateStream, IStorage::OpenStream, ISequentialStream::Read, and ISequentialStream::Write methods for possible
            storage and stream access errors.
            </returns>
            <remarks>
            <para>
            The <c>SetConvertStg</c> function determines the status of the convert bit in a contained object. It is called by both the
            container application and the server in the process of converting an object from one class to another. When a user specifies
            through a <c>Convert To</c> dialog (which the container produces with a call to the OleUIConvert function) that an object is to
            be converted, the container must take the following steps:
            </para>
            <list type="number">
            <item>
            <term>Unload the object if it is currently loaded.</term>
            </item>
            <item>
            <term>Call WriteClassStg to write the new CLSID to the object storage.</term>
            </item>
            <item>
            <term>Call WriteFmtUserTypeStg to write the new user-type name and the existing main format to the storage.</term>
            </item>
            <item>
            <term>
            Call <c>SetConvertStg</c> with the fConvert parameter set to <c>TRUE</c> to indicate that the object has been tagged for
            conversion to a new class the next time it is loaded.
            </term>
            </item>
            <item>
            <term>
            Just before the object is loaded, call OleDoAutoConvert to handle any needed object conversion, unless you call OleLoad, which
            calls it internally.
            </term>
            </item>
            </list>
            <para>
            When an object is initialized from a storage object and the server is the destination of a convert-to operation, the object
            server should do the following:
            </para>
            <list type="number">
            <item>
            <term>Call the GetConvertStg function to retrieve the value of the conversion bit.</term>
            </item>
            <item>
            <term>If the bit is set, the server reads the data out of the object according to the format associated with the new CLSID.</term>
            </item>
            <item>
            <term>
            When the object is asked to save itself, the object should call the WriteFmtUserTypeStg function using the normal native format
            and user type of the object.
            </term>
            </item>
            <item>
            <term>
            The object should then call <c>SetConvertStg</c> with the fConvert parameter set to <c>FALSE</c> to reset the object's conversion bit.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.WriteFmtUserTypeStg(Vanara.PInvoke.Ole32.IStorage,Vanara.PInvoke.CLIPFORMAT,System.String)">
            <summary>The <c>WriteFmtUserTypeStg</c> function writes a clipboard format and user type to the storage object.</summary>
            <param name="pstg">IStorage pointer to the storage object where the information is to be written.</param>
            <param name="cf">
            Specifies the clipboard format that describes the structure of the native area of the storage object. The format tag includes the
            policy for the names of streams and substorages within this storage object and the rules for interpreting data within those streams.
            </param>
            <param name="lpszUserType">
            Pointer to a null-terminated Unicode string that specifies the object's current user type. The user type value, itself, cannot be
            <c>NULL</c>. This is the type returned by the IOleObject::GetUserType method. If this function is transported to a remote machine
            where the object class does not exist, this persistently stored user type can be shown to the user in dialog boxes.
            </param>
            <returns>This function returns HRESULT.</returns>
            <remarks>
            <para>
            The <c>WriteFmtUserTypeStg</c> function must be called in an object's implementation of the IPersistStorage::Save method. It must
            also be called by document-level objects that use structured storage for their persistent representation in their save sequence.
            </para>
            <para>To read the information saved, applications call the ReadFmtUserTypeStg function.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.HOLEMENU">
            <summary>Provides a handle to a menu descriptor.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.HOLEMENU"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.HOLEMENU.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ole32.HOLEMENU"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.HOLEMENU.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.op_Explicit(Vanara.PInvoke.Ole32.HOLEMENU)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ole32.HOLEMENU"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ole32.HOLEMENU">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ole32.HOLEMENU"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.op_Inequality(Vanara.PInvoke.Ole32.HOLEMENU,Vanara.PInvoke.Ole32.HOLEMENU)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.op_Equality(Vanara.PInvoke.Ole32.HOLEMENU,Vanara.PInvoke.Ole32.HOLEMENU)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.HOLEMENU.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLESTREAM">
            <summary>Provides a handle to an OLE 1 stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLESTREAM.lpstbl">
            <summary>A pointer to an OLESTREAMVTBL instance.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.DllRegisterServer">
            <summary>Instructs an in-process server to create its registry entries for all classes supported in this server module.</summary>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The registry entries were created successfully.</term>
            </item>
            <item>
            <term>SELFREG_E_TYPELIB</term>
            <term>The server was unable to complete the registration of all the type libraries used by its classes.</term>
            </item>
            <item>
            <term>SELFREG_E_CLASS</term>
            <term>The server was unable to complete the registration of all the object classes.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>E_NOTIMPL is not a valid return code.</para>
            <para>If this function fails, the state of the registry for all its classes is undefined.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.DllUnregisterServer">
            <summary>Instructs an in-process server to remove only those entries created through DllRegisterServer.</summary>
            <returns>
            <para>This function can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The registry entries were deleted successfully.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>Unregistration of this server's known entries was successful, but other entries still exist for this server's classes.</term>
            </item>
            <item>
            <term>SELFREG_E_TYPELIB</term>
            <term>The server was unable to remove the entries of all the type libraries used by its classes.</term>
            </item>
            <item>
            <term>SELFREG_E_CLASS</term>
            <term>The server was unable to remove the entries of all the object classes.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The server must not disturb any entries that it did not create which currently exist for its object classes. For example,
            between registration and unregistration, the user may have specified a Treat As relationship between this class and another. In
            that case, unregistration can remove all entries except the <c>TreatAs</c> key and any others that were not explicitly created
            in DllRegisterServer. The registry functions specifically disallow the deletion of an entire populated tree in the registry. The
            server can attempt, as the last step, to remove the CLSID key, but if other entries still exist, the key will remain.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.DROPEFFECT">
            <summary>
            <para>
            Represents information about the effects of a drag-and-drop operation. The <c>DoDragDrop</c> function and many of the methods in
            the <c>IDropSource</c> and <c>IDropTarget</c> use the values of this enumeration.
            </para>
            </summary>
            <remarks>
            <para>
            Your application should always mask values from the <c>DROPEFFECT</c> enumeration to ensure compatibility with future
            implementations. Presently, only some of the positions in a <c>DROPEFFECT</c> value have meaning. In the future, more
            interpretations for the bits will be added. Drag sources and drop targets should carefully mask these values appropriately before
            comparing. They should never compare a <c>DROPEFFECT</c> against, say, DROPEFFECT_COPY by doing the following:
            </para>
            <para>Instead, the application should always mask for the value or values being sought as using one of the following techniques:</para>
            <para>This allows for the definition of new drop effects, while preserving backward compatibility with existing code.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DROPEFFECT.DROPEFFECT_NONE">
            <summary>Drop target cannot accept the data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DROPEFFECT.DROPEFFECT_COPY">
            <summary>Drop results in a copy. The original data is untouched by the drag source.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DROPEFFECT.DROPEFFECT_MOVE">
            <summary>Drag source should remove the data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DROPEFFECT.DROPEFFECT_LINK">
            <summary>Drag source should create a link to the original data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.DROPEFFECT.DROPEFFECT_SCROLL">
            <summary>
            Scrolling is about to start or is currently occurring in the target. This value is used in addition to the other values.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLECLOSE">
            <summary>Indicates whether an object should be saved before closing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECLOSE.OLECLOSE_SAVEIFDIRTY">
            <summary>The object should be saved if it is dirty.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECLOSE.OLECLOSE_NOSAVE">
            <summary>The object should not be saved, even if it is dirty. This flag is typically used when an object is being deleted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECLOSE.OLECLOSE_PROMPTSAVE">
            <summary>
            If the object is dirty, the IOleObject::Close implementation should display a dialog box to let the end user determine
            whether to save the object. However, if the object is in the running state but its user interface is invisible, the end user
            should not be prompted, and the close should be handled as if OLECLOSE_SAVEIFDIRTY had been specified.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLECONTF">
            <summary>Indicates the type of objects to be enumerated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECONTF.OLECONTF_EMBEDDINGS">
            <summary>Enumerates the embedded objects in the container.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECONTF.OLECONTF_LINKS">
            <summary>Enumerates the linked objects in the container.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECONTF.OLECONTF_OTHERS">
            <summary>
            Enumerates all objects in the container that are not OLE compound document objects (i.e., objects other than linked or
            embedded objects). Use this flag to enumerate the container's pseudo-objects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECONTF.OLECONTF_ONLYUSER">
            <summary>
            Enumerates only those objects the user is aware of. For example, hidden named-ranges in Microsoft Excel would not be
            enumerated using this value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLECONTF.OLECONTF_ONLYIFRUNNING">
            <summary>Enumerates only those linked or embedded objects that are currently in the running state for this container.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEGETMONIKER">
            <summary>Controls aspects of the behavior of the IOleObject::GetMoniker and IOleClientSite::GetMoniker methods.</summary>
            <remarks>
            If the OLEGETMONIKER_FORCEASSIGN flag causes a container to create a moniker for the object, the container should notify the
            object by calling the IOleObject::GetMoniker method.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEGETMONIKER.OLEGETMONIKER_ONLYIFTHERE">
            <summary>
            If a moniker for the object or container does not exist, IOleClientSite::GetMoniker should return E_FAIL and not assign a moniker.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEGETMONIKER.OLEGETMONIKER_FORCEASSIGN">
            <summary>If a moniker for the object or container does not exist, IOleClientSite::GetMoniker should create one.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEGETMONIKER.OLEGETMONIKER_UNASSIGN">
            <summary>
            IOleClientSite::GetMoniker can release the object's moniker (although it is not required to do so). This constant is not
            valid in IOleObject::GetMoniker.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEGETMONIKER.OLEGETMONIKER_TEMPFORUSER">
            <summary>
            If a moniker for the object does not exist, IOleObject::GetMoniker can create a temporary moniker that can be used for
            display purposes (IMoniker::GetDisplayName) but not for binding. This enables the object server to return a descriptive name
            for the object without incurring the overhead of creating and maintaining a moniker until a link is actually created.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEMISC">
            <summary>
            Describes miscellaneous characteristics of an object or class of objects. A container can call the IOleObject::GetMiscStatus
            method to determine the <c>OLEMISC</c> bits set for an object. The values specified in an object server's CLSID\MiscStatus entry
            in the registration database are based on the <c>OLEMISC</c> enumeration. These constants are also used in the <c>dwStatus</c>
            member of the OBJECTDESCRIPTOR structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_RECOMPOSEONRESIZE">
            <summary>
            When the container resizes the space allocated to displaying one of the object's presentations, the object wants to
            recompose the presentation. This means that on resize, the object wants to do more than scale its picture. If this bit is
            set, the container should force the object to the running state and call IOleObject::SetExtent with the new size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ONLYICONIC">
            <summary>
            The object has no useful content view other than its icon. From the user's perspective, the Display As Icon check box (in
            the Paste Special dialog box) for this object should always be checked, and should not be uncheckable. Note that such an
            object should still have a drawable content aspect; it will look the same as its icon view.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_INSERTNOTREPLACE">
            <summary>
            The object has initialized itself from the data in the container's current selection. Containers should examine this bit
            after calling IOleObject::InitFromData to initialize an object from the current selection. If set, the container should
            insert the object beside the current selection rather than replacing the current selection. If this bit is not set, the
            object being inserted replaces the current selection.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_STATIC">
            <summary>
            This object is a static object, which is an object that contains only a presentation; it contains no native data. See OleCreateStaticFromData.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_CANTLINKINSIDE">
            <summary>
            This object cannot be the link source that when bound to activates (runs) the object. If the object is selected and copied
            to the clipboard, the object's container can offer a link in a clipboard data transfer that, when bound, must connect to the
            outside of the object. The user would see the object selected in its container, not open for editing. Rather than doing
            this, the container can simply refuse to offer a link source when transferring objects with this bit set. Examples of
            objects that have this bit set include OLE1 objects, static objects, and links.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_CANLINKBYOLE1">
            <summary>
            This object can be linked to by OLE 1 containers. This bit is used in the dwStatus member of the OBJECTDESCRIPTOR structure
            transferred with the Object and Link Source Descriptor formats. An object can be linked to by OLE 1 containers if it is an
            untitled document, a file, or a selection of data within a file. Embedded objects or pseudo-objects that are contained
            within an embedded object cannot be linked to by OLE 1 containers (i.e., OLE 1 containers cannot link to link sources that,
            when bound, require more than one object server to be run.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ISLINKOBJECT">
            <summary>
            This object is a link object. This bit is significant to OLE 1 and is set by the OLE 2 link object; object applications have
            no need to set this bit.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_INSIDEOUT">
            <summary>
            This object is capable of activating in-place, without requiring installation of menus and toolbars to run. Several such
            objects can be active concurrently. Some containers, such as forms, may choose to activate such objects automatically.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ACTIVATEWHENVISIBLE">
            <summary>
            This bit is set only when OLEMISC_INSIDEOUT is set, and indicates that this object prefers to be activated whenever it is
            visible. Some containers may always ignore this hint.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_RENDERINGISDEVICEINDEPENDENT">
            <summary>This object does not pay any attention to target devices. Its presention data will be the same in all cases.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_INVISIBLEATRUNTIME">
            <summary>
            This value is used with controls. It indicates that the control has no run-time user interface, but that it should be
            visible at design time. For example, a timer control that fires a specific event periodically would not show itself at run
            time, but it needs a design-time user interface so a form designer can set the event period and other properties.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ALWAYSRUN">
            <summary>
            This value is used with controls. It tells the container that this control always wants to be running. As a result, the
            container should call OleRun when loading or creating the object.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ACTSLIKEBUTTON">
            <summary>
            This value is used with controls. It indicates that the control is buttonlike in that it understands and obeys the
            container's DisplayAsDefault ambient property.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ACTSLIKELABEL">
            <summary>
            This value is used with controls. It marks the control as a label for whatever control comes after it in the form's
            ordering. Pressing a mnemonic key for a label control activates the control after it.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_NOUIACTIVATE">
            <summary>
            This value is used with controls. It indicates that the control has no UI active state, meaning that it requires no in-place
            tools, no shared menu, and no accelerators. It also means that the control never needs the focus.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_ALIGNABLE">
            <summary>
            This value is used with controls. It indicates that the control understands how to align itself within its display
            rectangle, according to alignment properties such as left, center, and right.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_SIMPLEFRAME">
            <summary>
            This value is used with controls. It indicates that the control is a simple grouping of other controls and does little more
            than pass Windows messages to the control container managing the form. Controls of this sort require the implementation of
            ISimpleFrameSite on the container's site.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_SETCLIENTSITEFIRST">
            <summary>
            This value is used with controls. It indicates that the control wants to use IOleObject::SetClientSite as its initialization
            function, even before a call such as IPersistStreamInit::InitNew or IPersistStorage::InitNew. This allows the control to
            access a container's ambient properties before loading information from persistent storage. Note that the current
            implementations of OleCreate, OleCreateFromData, OleCreateFromFile, OleLoad, and the default handler do not understand this
            value. Control containers that wish to honor this value must currently implement their own versions of these functions in
            order to establish the correct initialization sequence for the control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_IMEMODE">
            <summary>
            Obsolete. A control that works with an Input Method Editor (IME) system component can control the state of the IME through
            the IMEMode property rather than using this value in the OLEMISC enumeration. You can use an IME component to enter
            information in Asian character sets with a regular keyboard. A Japanese IME, for example, allows you to type a word such as
            "sushi," on a regular keyboard and when you hit the spacebar, the IME component converts that word to appropriate kanji or
            proposes possible choices. The OLEMISC_IMEMODE value was previously used to mark a control as capable of controlling an IME
            mode system component.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_IGNOREACTIVATEWHENVISIBLE">
            <summary>
            For new ActiveX controls to work in an older container, the control may need to have the OLEMISC_ACTIVATEWHENVISIBLE value
            set. However, in a newer container that understands and uses IPointerInactive, the control does not wish to be in-place
            activated when it becomes visible. To allow the control to work in both kinds of containers, the control can set this value.
            Then, the container ignores OLEMISC_ACTIVATEWHENVISIBLE and does not in-place activate the control when it becomes visible.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_WANTSTOMENUMERGE">
            <summary>A control that can merge its menu with its container sets this value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMISC.OLEMISC_SUPPORTSMULTILEVELUNDO">
            <summary>A control that supports multi-level undo sets this value.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLERENDER">
            <summary>Indicates the type of caching requested for newly created objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLERENDER.OLERENDER_NONE">
            <summary>
            The client is not requesting any locally cached drawing or data retrieval capabilities in the object. The pFormatEtc
            parameter of the calls is ignored when this value is specified for the renderopts parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLERENDER.OLERENDER_DRAW">
            <summary>
            The client will draw the content of the object on the screen (a NULL target device) using IViewObject::Draw. The object
            itself determines the data formats that need to be cached. With this render option, only the ptd and dwAspect members of
            pFormatEtc are significant, since the object may cache things differently depending on the parameter values. However,
            pFormatEtc can legally be NULL here, in which case the object is to assume the display target device and the DVASPECT_CONTENT aspect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLERENDER.OLERENDER_FORMAT">
            <summary>
            The client will pull one format from the object using IDataObject::GetData. The format of the data to be cached is passed in
            pFormatEtc, which may not in this case be NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLERENDER.OLERENDER_ASIS">
            <summary>
            The client is not requesting any locally cached drawing or data retrieval capabilities in the object. pFormatEtc is ignored
            for this option. The difference between this and the OLERENDER_FORMAT value is important in such functions as
            OleCreateFromData and OleCreateLinkFromData.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEVERBATTRIB">
            <summary>Describes the attributes of a specified verb for an object.</summary>
            <remarks>Values are used in the enumerator (which supports the IEnumOLEVERB interface) that is created by a call to IOleObject::EnumVerbs.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERBATTRIB.OLEVERBATTRIB_NEVERDIRTIES">
            <summary>
            Executing this verb will not cause the object to become dirty and is therefore in need of saving to persistent storage.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERBATTRIB.OLEVERBATTRIB_ONCONTAINERMENU">
            <summary>
            Indicates a verb that should appear in the container's menu of verbs for this object. OLEIVERB_HIDE, OLEIVERB_SHOW, and
            OLEIVERB_OPEN never have this value set.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEWHICHMK">
            <summary>Indicates which part of an object's moniker is being set or retrieved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEWHICHMK.OLEWHICHMK_CONTAINER">
            <summary>
            The moniker of the object's container. Typically, this is a file moniker. This moniker is not persistently stored inside the
            object, since the container can be renamed even while the object is not loaded.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEWHICHMK.OLEWHICHMK_OBJREL">
            <summary>
            The moniker of the object relative to its container. Typically, this is an item moniker, and it is part of the persistent
            state of the object. If this moniker is composed on to the end of the container's moniker, the resulting moniker is the full
            moniker of the object.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEWHICHMK.OLEWHICHMK_OBJFULL">
            <summary>
            The full moniker of the object. Binding to this moniker results in a connection to the object. This moniker is not
            persistently stored inside the object, since the container can be renamed even while the object is not loaded.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.USERCLASSTYPE">
            <summary>Indicates the different variants of the display name associated with a class of objects.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.USERCLASSTYPE.USERCLASSTYPE_FULL">
            <summary>The full type name of the class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.USERCLASSTYPE.USERCLASSTYPE_SHORT">
            <summary>A short name (maximum of 15 characters) that is used for popup menus and the Links dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.USERCLASSTYPE.USERCLASSTYPE_APPNAME">
            <summary>The name of the application servicing the class and is used in the result text in dialog boxes.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IDropSource">
            <summary>
            <para>
            The <c>IDropSource</c> interface is one of the interfaces you implement to provide drag-and-drop operations in your application.
            It contains methods used in any application used as a data source in a drag-and-drop operation. The data source application in a
            drag-and-drop operation is responsible for:
            </para>
            <list type="bullet">
            <item>
            <term>Determining the data being dragged based on the user's selection.</term>
            </item>
            <item>
            <term>Initiating the drag-and-drop operation based on the user's mouse actions.</term>
            </item>
            <item>
            <term>
            Generating some of the visual feedback during the drag-and-drop operation, such as setting the cursor and highlighting the data
            selected for the drag-and-drop operation.
            </term>
            </item>
            <item>
            <term>Canceling or completing the drag-and-drop operation based on the user's mouse actions.</term>
            </item>
            <item>
            <term>Performing any action on the original data caused by the drop operation, such as deleting the data on a drag move.</term>
            </item>
            </list>
            <para>
            <c>IDropSource</c> contains the methods for generating visual feedback to the end user and for canceling or completing the
            drag-and-drop operation. You also need to call the DoDragDrop, RegisterDragDrop, and RevokeDragDrop functions in drag-and-drop operations.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropSource.QueryContinueDrag(System.Boolean,System.UInt32)">
            <summary>
            <para>
            Determines whether a drag-and-drop operation should be continued, canceled, or completed. You do not call this method
            directly. The OLE DoDragDrop function calls this method during a drag-and-drop operation.
            </para>
            </summary>
            <param name="fEscapePressed">
            <para>
            Indicates whether the Esc key has been pressed since the previous call to <c>QueryContinueDrag</c> or to DoDragDrop if this
            is the first call to <c>QueryContinueDrag</c>. A <c>TRUE</c> value indicates the end user has pressed the escape key; a
            <c>FALSE</c> value indicates it has not been pressed.
            </para>
            </param>
            <param name="grfKeyState">
            <para>
            The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags
            MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
            </para>
            </param>
            <returns>
            <para>This method can return the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>
            The drag operation should continue. This result occurs if no errors are detected, the mouse button starting the drag-and-drop
            operation has not been released, and the Esc key has not been detected.
            </term>
            </item>
            <item>
            <term>DRAGDROP_S_DROP</term>
            <term>
            The drop operation should occur completing the drag operation. This result occurs if grfKeyState indicates that the key that
            started the drag-and-drop operation has been released.
            </term>
            </item>
            <item>
            <term>DRAGDROP_S_CANCEL</term>
            <term>
            The drag operation should be canceled with no drop operation occurring. This result occurs if fEscapePressed is TRUE,
            indicating the Esc key has been pressed.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The DoDragDrop function calls <c>QueryContinueDrag</c> whenever it detects a change in the keyboard or mouse button state
            during a drag-and-drop operation. <c>QueryContinueDrag</c> must determine whether the drag-and-drop operation should be
            continued, canceled, or completed based on the contents of the parameters grfKeyState and fEscapePressed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropSource.GiveFeedback(Vanara.PInvoke.Ole32.DROPEFFECT)">
            <summary>
            <para>
            Enables a source application to give visual feedback to the end user during a drag-and-drop operation by providing the
            DoDragDrop function with an enumeration value specifying the visual effect.
            </para>
            </summary>
            <param name="dwEffect">
            <para>The DROPEFFECT value returned by the most recent call to IDropTarget::DragEnter, IDropTarget::DragOver, or IDropTarget::DragLeave.</para>
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>DRAGDROP_S_USEDEFAULTCURSORS</term>
            <term>
            Indicates successful completion of the method, and requests OLE to update the cursor using the OLE-provided default cursors.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When your application detects that the user has started a drag-and-drop operation, it should call the DoDragDrop function.
            <c>DoDragDrop</c> enters a loop, calling IDropTarget::DragEnter when the mouse first enters a drop target window,
            IDropTarget::DragOver when the mouse changes its position within the target window, and IDropTarget::DragLeave when the mouse
            leaves the target window.
            </para>
            <para>
            For every call to either IDropTarget::DragEnter or IDropTarget::DragOver, DoDragDrop calls <c>IDropSource::GiveFeedback</c>,
            passing it the DROPEFFECT value returned from the drop target call.
            </para>
            <para>
            DoDragDrop calls IDropTarget::DragLeave when the mouse has left the target window. Then, <c>DoDragDrop</c> calls
            <c>IDropSource::GiveFeedback</c> and passes the DROPEFFECT_NONE value in the dwEffect parameter.
            </para>
            <para>
            The dwEffect parameter can include DROPEFFECT_SCROLL, indicating that the source should put up the drag-scrolling variation
            of the appropriate pointer.
            </para>
            <para>Notes to Implementers</para>
            <para>
            This function is called frequently during the DoDragDrop loop, so you can gain performance advantages if you optimize your
            implementation as much as possible.
            </para>
            <para>
            <c>IDropSource::GiveFeedback</c> is responsible for changing the cursor shape or for changing the highlighted source based on
            the value of the dwEffect parameter. If you are using default cursors, you can return DRAGDROP_S_USEDEFAULTCURSORS, which
            causes OLE to update the cursor for you, using its defaults.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IDropTarget">
            <summary>
            <para>
            The <c>IDropTarget</c> interface is one of the interfaces you implement to provide drag-and-drop operations in your application.
            It contains methods used in any application that can be a target for data during a drag-and-drop operation. A drop-target
            application is responsible for:
            </para>
            <list type="bullet">
            <item>
            <term>Determining the effect of the drop on the target application.</term>
            </item>
            <item>
            <term>Incorporating any valid dropped data when the drop occurs.</term>
            </item>
            <item>
            <term>
            Communicating target feedback to the source so the source application can provide appropriate visual feedback such as setting the cursor.
            </term>
            </item>
            <item>
            <term>Implementing drag scrolling.</term>
            </item>
            <item>
            <term>Registering and revoking its application windows as drop targets.</term>
            </item>
            </list>
            <para>
            The <c>IDropTarget</c> interface contains methods that handle all these responsibilities except registering and revoking the
            application window as a drop target, for which you must call the RegisterDragDrop and the RevokeDragDrop functions.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropTarget.DragEnter(System.Runtime.InteropServices.ComTypes.IDataObject,System.UInt32,System.Drawing.Point,Vanara.PInvoke.Ole32.DROPEFFECT@)">
            <summary>Indicates whether a drop can be accepted, and, if so, the effect of the drop.</summary>
            <param name="pDataObj">
            A pointer to the IDataObject interface on the data object. This data object contains the data being transferred in the
            drag-and-drop operation. If the drop occurs, this data object will be incorporated into the target.
            </param>
            <param name="grfKeyState">
            The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags
            MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
            </param>
            <param name="pt">A POINTL structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">
            On input, pointer to the value of the pdwEffect parameter of the DoDragDrop function. On return, must contain one of the
            DROPEFFECT flags, which indicates what the result of the drop operation would be.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pdwEffect parameter is NULL on input.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There was insufficient memory available for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You do not call <c>DragEnter</c> directly; instead the DoDragDrop function calls it to determine the effect of a drop the
            first time the user drags the mouse into the registered window of a drop target.
            </para>
            <para>
            To implement <c>DragEnter</c>, you must determine whether the target can use the data in the source data object by checking
            three things:
            </para>
            <list type="bullet">
            <item>
            <term>The format and medium specified by the data object</term>
            </item>
            <item>
            <term>The input value of pdwEffect</term>
            </item>
            <item>
            <term>The state of the modifier keys</term>
            </item>
            </list>
            <para>
            To check the format and medium, use the IDataObject pointer passed in the pDataObject parameter to call
            IDataObject::EnumFormatEtc so you can enumerate the FORMATETC structures the source data object supports. Then call
            IDataObject::QueryGetData to determine whether the data object can render the data on the target by examining the formats and
            medium specified for the data object.
            </para>
            <para>
            On entry to <c>IDropTarget::DragEnter</c>, the pdwEffect parameter is set to the effects given to the pdwOkEffect parameter
            of the DoDragDrop function. The <c>IDropTarget::DragEnter</c> method must choose one of these effects or disable the drop.
            </para>
            <para>The following modifier keys affect the result of the drop.</para>
            <list type="table">
            <listheader>
            <term>Key Combination</term>
            <term>User-Visible Feedback</term>
            <term>Drop Effect</term>
            </listheader>
            <item>
            <term>CTRL + SHIFT</term>
            <term>=</term>
            <term>DROPEFFECT_LINK</term>
            </item>
            <item>
            <term>CTRL</term>
            <term>+</term>
            <term>DROPEFFECT_COPY</term>
            </item>
            <item>
            <term>No keys or SHIFT</term>
            <term>None</term>
            <term>DROPEFFECT_MOVE</term>
            </item>
            </list>
            <para>
            On return, the method must write the effect, one of the DROPEFFECT flags, to the pdwEffect parameter. DoDragDrop then takes
            this parameter and writes it to its pdwEffect parameter. You communicate the effect of the drop back to the source through
            <c>DoDragDrop</c> in the pdwEffect parameter. The <c>DoDragDrop</c> function then calls IDropSource::GiveFeedback so that the
            source application can display the appropriate visual feedback to the user through the target window.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropTarget.DragOver(System.UInt32,System.Drawing.Point,Vanara.PInvoke.Ole32.DROPEFFECT@)">
            <summary>
            Provides target feedback to the user and communicates the drop's effect to the DoDragDrop function so it can communicate the
            effect of the drop back to the source.
            </summary>
            <param name="grfKeyState">
            The current state of the keyboard modifier keys on the keyboard. Valid values can be a combination of any of the flags
            MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
            </param>
            <param name="pt">A POINTL structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">
            On input, pointer to the value of the pdwEffect parameter of the DoDragDrop function. On return, must contain one of the
            DROPEFFECT flags, which indicates what the result of the drop operation would be.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pdwEffect value is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There was insufficient memory available for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You do not call <c>DragOver</c> directly. The DoDragDrop function calls this method each time the user moves the mouse across
            a given target window. <c>DoDragDrop</c> exits the loop if the drag-and-drop operation is canceled, if the user drags the
            mouse out of the target window, or if the drop is completed.
            </para>
            <para>
            In implementing <c>IDropTarget::DragOver</c>, you must provide features similar to those in IDropTarget::DragEnter. You must
            determine the effect of dropping the data on the target by examining the FORMATETC defining the data object's formats and
            medium, along with the state of the modifier keys. The mouse position may also play a role in determining the effect of a
            drop. The following modifier keys affect the result of the drop.
            </para>
            <list type="table">
            <listheader>
            <term>Key Combination</term>
            <term>User-Visible Feedback</term>
            <term>Drop Effect</term>
            </listheader>
            <item>
            <term>CTRL + SHIFT</term>
            <term>=</term>
            <term>DROPEFFECT_LINK</term>
            </item>
            <item>
            <term>CTRL</term>
            <term>+</term>
            <term>DROPEFFECT_COPY</term>
            </item>
            <item>
            <term>No keys or SHIFT</term>
            <term>None</term>
            <term>DROPEFFECT_MOVE</term>
            </item>
            </list>
            <para>
            You communicate the effect of the drop back to the source through DoDragDrop in pdwEffect. The <c>DoDragDrop</c> function
            then calls IDropSource::GiveFeedback so the source application can display the appropriate visual feedback to the user.
            </para>
            <para>
            On entry to <c>IDropTarget::DragOver</c>, the pdwEffect parameter must be set to the allowed effects passed to the
            pdwOkEffect parameter of the DoDragDrop function. The <c>IDropTarget::DragOver</c> method must be able to choose one of these
            effects or disable the drop.
            </para>
            <para>
            Upon return, pdwEffect is set to one of the DROPEFFECT flags. This value is then passed to the pdwEffect parameter of
            DoDragDrop. Reasonable values are DROPEFFECT_COPY to copy the dragged data to the target, DROPEFFECT_LINK to create a link to
            the source data, or DROPEFFECT_MOVE to allow the dragged data to be permanently moved from the source application to the target.
            </para>
            <para>
            You may also wish to provide appropriate visual feedback in the target window. There may be some target feedback already
            displayed from a previous call to <c>IDropTarget::DragOver</c> or from the initial IDropTarget::DragEnter. If this feedback
            is no longer appropriate, you should remove it.
            </para>
            <para>
            For efficiency reasons, a data object is not passed in <c>IDropTarget::DragOver</c>. The data object passed in the most
            recent call to IDropTarget::DragEnter is available and can be used.
            </para>
            <para>
            When <c>IDropTarget::DragOver</c> has completed its operation, the DoDragDrop function calls IDropSource::GiveFeedback so the
            source application can display the appropriate visual feedback to the user.
            </para>
            <para>Notes to Implementers</para>
            <para>
            This function is called frequently during the DoDragDrop loop so it makes sense to optimize your implementation of the
            <c>DragOver</c> method as much as possible.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropTarget.DragLeave">
            <summary>Removes target feedback and releases the data object.</summary>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There is insufficient memory available for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>You do not call this method directly. The DoDragDrop function calls this method in either of the following cases:</para>
            <list type="bullet">
            <item>
            <term>When the user drags the cursor out of a given target window.</term>
            </item>
            <item>
            <term>When the user cancels the current drag-and-drop operation.</term>
            </item>
            </list>
            <para>
            To implement <c>IDropTarget::DragLeave</c>, you must remove any target feedback that is currently displayed. You must also
            release any references you hold to the data transfer object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IDropTarget.Drop(System.Runtime.InteropServices.ComTypes.IDataObject,System.UInt32,System.Drawing.Point,Vanara.PInvoke.Ole32.DROPEFFECT@)">
            <summary>Incorporates the source data into the target window, removes target feedback, and releases the data object.</summary>
            <param name="pDataObj">
            A pointer to the IDataObject interface on the data object being transferred in the drag-and-drop operation.
            </param>
            <param name="grfKeyState">
            The current state of the keyboard modifier keys on the keyboard. Possible values can be a combination of any of the flags
            MK_CONTROL, MK_SHIFT, MK_ALT, MK_BUTTON, MK_LBUTTON, MK_MBUTTON, and MK_RBUTTON.
            </param>
            <param name="pt">A POINTL structure containing the current cursor coordinates in screen coordinates.</param>
            <param name="pdwEffect">
            On input, pointer to the value of the pdwEffect parameter of the DoDragDrop function. On return, must contain one of the
            DROPEFFECT flags, which indicates what the result of the drop operation would be.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pdwEffect parameter is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There is insufficient memory available for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You do not call this method directly. The DoDragDrop function calls this method when the user completes the drag-and-drop operation.
            </para>
            <para>
            In implementing <c>Drop</c>, you must incorporate the data object into the target. Use the formats available in IDataObject,
            available through pDataObj, along with the current state of the modifier keys to determine how the data is to be
            incorporated, such as linking or embedding.
            </para>
            <para>In addition to incorporating the data, you must also clean up as you do in the IDropTarget::DragLeave method:</para>
            <list type="bullet">
            <item>
            <term>Remove any target feedback that is currently displayed.</term>
            </item>
            <item>
            <term>Release any references to the data object.</term>
            </item>
            </list>
            <para>
            You also pass the effect of this operation back to the source application through DoDragDrop, so the source application can
            clean up after the drag-and-drop operation is complete:
            </para>
            <list type="bullet">
            <item>
            <term>Remove any source feedback that is being displayed.</term>
            </item>
            <item>
            <term>Make any necessary changes to the data, such as removing the data if the operation was a move.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumOLEVERB">
            <summary>
            Enumerates the different verbs available for an object in order of ascending verb number. An enumerator that implements the
            <c>IEnumOLEVERB</c> interface is returned by IOleObject::EnumVerbs.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumOLEVERB.Next(System.UInt32,Vanara.PInvoke.Ole32.OLEVERB[],System.UInt32@)">
            <summary>Retrieves the specified number of items in the enumeration sequence.</summary>
            <param name="celt">
            The number of items to be retrieved. If there are fewer than the requested number of items left in the sequence, this method
            retrieves the remaining elements.
            </param>
            <param name="rgelt">
            An array of enumerated items.
            <para>
            The enumerator is responsible for allocating any memory, and the caller is responsible for freeing it.If celt is greater than
            1, the caller must also pass a non-NULL pointer passed to pceltFetched to know how many pointers to release.
            </para>
            </param>
            <param name="pceltFetched">
            The number of items that were retrieved. This parameter is always less than or equal to the number of items requested. This
            parameter can be NULL if celt is 1.
            </param>
            <returns>If the method retrieves the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumOLEVERB.Skip(System.UInt32)">
            <summary>Skips over the specified number of items in the enumeration sequence.</summary>
            <param name="celt">The number of items to be skipped.</param>
            <returns>If the method skips the number of items requested, the return value is S_OK. Otherwise, it is S_FALSE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumOLEVERB.Reset">
            <summary>Resets the enumeration sequence to the beginning.</summary>
            <remarks>
            There is no guarantee that the same set of objects will be enumerated after the reset operation has completed. A static
            collection is reset to the beginning, but it can be too expensive for some collections, such as files in a directory, to
            guarantee this condition.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumOLEVERB.Clone">
            <summary>
            Enumerates the different verbs available for an object in order of ascending verb number. An enumerator that implements the
            <c>IEnumOLEVERB</c> interface is returned by IOleObject::EnumVerbs.
            </summary>
            <returns>
            A pointer to an IEnumOLEVERB pointer variable that receives the interface pointer to the enumeration object. If the method is
            unsuccessful, the value of this output variable is undefined.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleAdviseHolder">
            <summary>
            Manages advisory connections and compound document notifications in an object server. Its methods are intended to be used to
            implement the advisory methods of IOleObject. <c>IOleAdviseHolder</c> is implemented on an advise holder object. Its methods
            establish and delete advisory connections from the object managed by the server to the object's container, which must contain an
            advise sink (support the IAdviseSink interface). The advise holder object must also keep track of which advise sinks are
            interested in which notifications and pass along the notifications as appropriate.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.Advise(System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32@)">
            <summary>
            Establishes an advisory connection between an OLE object and the calling object's advise sink. Through that sink, the calling
            object can receive notification when the OLE object is renamed, saved, or closed.
            </summary>
            <param name="pAdvise">A pointer to the IAdviseSink interface on the advisory sink that should be informed of changes.</param>
            <param name="pdwConnection">
            A pointer to a token that can be passed to the IOleAdviseHolder::Unadvise method to delete the advisory connection. The
            calling object is responsible for calling both IUnknown::AddRef and IUnknown::Release on this pointer.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_INVALIDARG</term>
            <term>The supplied IAdviseSink interface pointer is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Containers, object handlers, and link objects all create advise sinks to receive notification of changes in compound-document
            objects of interest, such as embedded or linked objects. OLE objects of interest to these objects must implement the
            IOleObject interface, which includes several advisory methods, including IOleObject::Advise. A call to this method must set
            up an advisory connection with any advise sink that calls it, and maintain each connection until it is closed. It must be
            able to handle more than one advisory connection at a time.
            </para>
            <para>
            <c>IOleAdviseHolder::Advise</c> is intended to be used to simplify the implementation of IOleObject::Advise. You can get a
            pointer to the OLE implementation of IOleAdviseHolder by calling CreateOleAdviseHolder, and then, to implement
            <c>IOleObject::Advise</c>, just delegate the call to <c>IOleAdviseHolder::Advise</c>. Other IOleAdviseHolder methods are
            intended to implement other IOleObject advisory methods.
            </para>
            <para>
            If the attempt to establish an advisory connection is successful, the object receiving the call returns a nonzero value
            through pdwConnection. If the attempt fails, the object returns a zero. To delete an advisory connection, the object with the
            advise sink passes this nonzero token back to the object by calling <c>IOleAdviseHolder::Advise</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.Unadvise(System.UInt32)">
            <summary>Deletes a previously established advisory connection.</summary>
            <param name="dwConnection">The value previously returned by IOleAdviseHolder::Advise in pdwConnection.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_NOCONNECTION</term>
            <term>The dwConnection parameter does not represent a valid advisory connection.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>IOleAdviseHolder::Unadvise</c> is intended to be used to implement IOleObject::Unadvise to delete an advisory connection.
            In general, you would use the OLE advise holder having obtained a pointer through a call to CreateOleAdviseHolder.
            </para>
            <para>
            Typically, containers call this method at shutdown or when an object is deleted. In certain cases, containers could call this
            method on objects that are running but not currently visible, as a way of reducing the overhead of maintaining multiple
            advisory connections.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.EnumAdvised(System.Runtime.InteropServices.ComTypes.IEnumSTATDATA@)">
            <summary>Creates an enumerator that can be used to enumerate the advisory connections currently established for an object.</summary>
            <param name="ppenumAdvise">
            A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator. If this parameter
            is NULL, there are presently no advisory connections on the object, or an error occurred. The advise holder is responsible
            for incrementing the reference count on the IEnumSTATDATA pointer this method supplies. It is the caller's responsibility to
            call IUnknown::Release when it is finished with the pointer.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para>
            <c>IOleAdviseHolder::EnumAdvise</c> creates an enumerator that can be used to enumerate an object's established advisory
            connections. The method supplies a pointer to the IEnumSTATDATA interface on this enumerator. Advisory connection information
            for each connection is stored in the STATDATA structure, and the enumerator must be able to enumerate these structures.
            </para>
            <para>
            For this method, the only relevant structure members are <c>pAdvise</c> and <c>dwConnection</c>. Other members contain data
            advisory information. When you call the enumeration methods, and while an enumeration is in progress, the effect of
            registering or revoking advisory connections on what is to be enumerated is undefined.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.SendOnRename(System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>
            Sends notification to all advisory sinks currently registered with the advise holder that the name of object has changed.
            </summary>
            <param name="pmk">A pointer to the new full moniker of the object.</param>
            <returns>This method returns S_OK if advise sinks were sent IAdviseSink::OnRename notifications.</returns>
            <remarks>
            <c>SendOnRename</c> calls IAdviseSink::OnRename to advise the calling object, which must have already established an advisory
            connection, that the object has a new moniker. If you are using the OLE advise holder (having obtained a pointer through a
            call to CreateOleAdviseHolder), you can call <c>SendOnRename</c> in the implementation of IOleObject::SetMoniker, when you
            have determined that the operation is successful.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.SendOnSave">
            <summary>
            Sends notification to all advisory sinks currently registered with the advise holder that the object has been saved.
            </summary>
            <returns>This method returns S_OK if advise sinks were sent IAdviseSink::OnSave notifications.</returns>
            <remarks>
            <para>
            <c>SendOnSave</c> calls IAdviseSink::OnSave to advise the calling object (client), which must have already established an
            advisory connection, that the object has been saved. If you are using the OLE advise holder (having obtained a pointer
            through a call to CreateOleAdviseHolder), you can call <c>SendOnSave</c> whenever you save the object the advise holder is
            associated with.
            </para>
            <para>
            To take the object from the running state to the loaded state, the client calls IOleObject::Close. Within that
            implementation, if the user wants to save the object to persistent storage, the object calls IOleClientSite::SaveObject,
            followed by the call to <c>SendOnSave</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleAdviseHolder.SendOnClose">
            <summary>Sends notification to all advisory sinks currently registered with the advise holder that the object has closed.</summary>
            <returns>
            This method returns S_OK if advise sinks were notified of the close operation through a call to the IAdviseSink::OnClose method.
            </returns>
            <remarks>
            <c>SendOnClose</c> must call IAdviseSink::OnClose on all advise sinks that have a valid advisory connection with the object,
            whenever the object goes from the running state to the loaded state. This occurs through a call to IOleObject::Close, so you
            can call <c>SendOnClose</c> when you determine that a Close operation has been successful.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleCache">
            <summary>
            Provides control of the presentation data that gets cached inside of an object. Cached presentation data is available to the
            container of the object even when the server application is not running or is unavailable.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleCache.Cache(System.Runtime.InteropServices.ComTypes.FORMATETC@,System.Runtime.InteropServices.ComTypes.ADVF)">
            <summary>Specifies the format and other data to be cached inside an embedded object.</summary>
            <param name="pformatetc">
            A pointer to a FORMATETC structure that specifies the format and other data to be cached. View caching is specified by
            passing a zero clipboard format in pformatetc.
            </param>
            <param name="advf">
            A group of flags that control the caching. Possible values come from the ADVF enumeration. When used in this context, for a
            cache, these values have specific meanings, which are outlined in Remarks. Refer to the <c>ADVF</c> enumeration for a more
            detailed description.
            </param>
            <returns>
            A variable that receives the identifier of this connection, which can later be used to turn caching off (by passing it to
            IOleCache::Uncache). If this value is 0, the connection was not established. The OLE-provided implementation uses nonzero
            numbers for connection identifiers.
            </returns>
            <remarks>
            <para>
            <c>IOleCache::Cache</c> can specify either data caching or view (presentation) caching. To specify data caching, a valid data
            format must be passed in pformatetc. For view caching, the cache object itself decides on the format to cache, so a caller
            would pass a zero data format in pformatetc as follows:
            </para>
            <para>
            A custom object handler can choose not to store data in a given format. Instead, it can synthesize it on demand when requested.
            </para>
            <para>
            The advf value specifies a member of the ADVF enumeration. When one of these values (or an OR'd combination of more than one
            value) is used in this context, these values mean the following.
            </para>
            <list type="table">
            <listheader>
            <term>ADVF Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ADVF_NODATA</term>
            <term>
            The cache is not to be updated by changes made to the running object. Instead, the container will update the cache by
            explicitly calling IOleCache::SetData, IDataObject::SetData, or IOleCache2::UpdateCache. This flag is usually used when the
            iconic aspect of an object is being cached.
            </term>
            </item>
            <item>
            <term>ADVF_ONLYONCE</term>
            <term>
            Update the cache one time only. After the update is complete, the advisory connection between the object and the cache is
            disconnected. The source object for the advisory connection calls the Release method.
            </term>
            </item>
            <item>
            <term>ADVF_PRIMEFIRST</term>
            <term>
            The object is not to wait for the data or view to change before updating the cache. OR'd with ADVF_ONLYONCE, this parameter
            provides an asynchronous IDataObject::GetData call.
            </term>
            </item>
            <item>
            <term>ADVFCACHE_NOHANDLER</term>
            <term>Synonym for ADVFCACHE_FORCEBUILTIN.</term>
            </item>
            <item>
            <term>ADVFCACHE_FORCEBUILTIN</term>
            <term>
            Used by DLL object applications and object handlers that draw their objects to cache presentation data to ensure that there
            is a presentation in the cache. This ensures that the data can be retrieved even when the object or handler code is not available.
            </term>
            </item>
            <item>
            <term>ADVFCACHE_ONSAVE</term>
            <term>
            Updates the cached representation only when the object containing the cache is saved. The cache is also updated when the OLE
            object changes from the running state back to the loaded state (because a subsequent save operation would require running the
            object again).
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleCache.Uncache(System.UInt32)">
            <summary>Removes a cache connection created previously using IOleCache::Cache.</summary>
            <param name="dwConnection">
            The cache connection to be removed. This nonzero value was returned by IOleCache::Cache when the cache was originally established.
            </param>
            <remarks>
            The <c>IOleCache::Uncache</c> method removes a cache connection that was created in a prior call to IOleCache::Cache. It uses
            the dwConnection parameter that was returned by the prior call to <c>IOleCache::Cache</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleCache.EnumCache">
            <summary>Creates an enumerator that can be used to enumerate the current cache connections.</summary>
            <returns>
            A pointer to an IEnumSTATDATA pointer variable that receives the interface pointer to the new enumerator object. If this
            parameter is NULL, there are no cache connections at this time.
            </returns>
            <remarks>
            The enumerator object returned by this method implements the IEnumSTATDATA interface. <c>IEnumSTATDATA</c> enumerates the
            data stored in an array of STATDATA structures containing information about current cache connections.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleCache.InitCache(System.Runtime.InteropServices.ComTypes.IDataObject)">
            <summary>Fills the cache as needed using the data provided by the specified data object.</summary>
            <param name="pDataObject">A pointer to the IDataObject interface on the data object from which the cache is to be initialized.</param>
            <remarks>
            <c>InitCache</c> is usually used when creating an object from a drag-and-drop operation or from a clipboard paste operation.
            It fills the cache as needed with presentation data from all the data formats provided by the data object provided on the
            clipboard or in the drag-and-drop operation. Helper functions like OleCreateFromData or OleCreateLinkFromData call this
            method when needed. If a container does not use these helper functions to create compound document objects, it can use
            IOleCache::Cache to set up the cache entries which are then filled by <c>InitCache</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleCache.SetData(System.Runtime.InteropServices.ComTypes.FORMATETC@,System.Runtime.InteropServices.ComTypes.STGMEDIUM@,System.Boolean)">
            <summary>Initializes the cache with data in a specified format and on a specified medium.</summary>
            <param name="pformatetc">
            A pointer to a FORMATETC structure that specifies the format of the presentation data being placed in the cache.
            </param>
            <param name="pmedium">
            A pointer to a STGMEDIUM structure that specifies the storage medium that contains the presentation data.
            </param>
            <param name="fRelease">
            Indicates the ownership of the storage medium after completion of the method. If fRelease is <c>TRUE</c>, the cache takes
            ownership, freeing the medium when it is finished using it. When fRelease is <c>FALSE</c>, the caller retains ownership and
            is responsible for freeing the medium. The cache can only use the storage medium for the duration of the call.
            </param>
            <remarks>
            <para>
            <c>IOleCache::SetData</c> is usually called when an object is created from the clipboard or through a drag-and-drop
            operation, and Embed Source data is used to create the object.
            </para>
            <para>
            <c>IOleCache::SetData</c> and IOleCache::InitCache are very similar. There are two main differences. The first difference is
            that while <c>IOleCache::InitCache</c> initializes the cache with the presentation format provided by the data object,
            <c>IOleCache::SetData</c> initializes it with a single format. Second, the <c>IOleCache::SetData</c> method ignores the
            ADVF_NODATA flag while <c>IOleCache::InitCache</c> obeys this flag.
            </para>
            <para>A container can use this method to maintain a single aspect of an object, such as the icon aspect of the object.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleClientSite">
            <summary>
            <para>
            Provides the primary means by which an embedded object obtains information about the location and extent of its display site, its
            moniker, its user interface, and other resources provided by its container. An object server calls <c>IOleClientSite</c> to
            request services from the container. A container must provide one instance of <c>IOleClientSite</c> for every compound-document
            object it contains.
            </para>
            <para><c>Note</c> This interface is not supported for use across machine boundaries.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.SaveObject">
            <summary>
            Saves the embedded object associated with the client site. This function is synchronous; by the time it returns, the save
            will be completed.
            </summary>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation has failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            An embedded object calls <c>SaveObject</c> to ask its container to save it to persistent storage when an end user chooses the
            File Update or Exit commands. The call is synchronous, meaning that by the time it returns, the save operation will be completed.
            </para>
            <para>
            Calls to <c>SaveObject</c> occur in most implementations of IOleObject::Close. Normally, when a container tells an object to
            close, the container passes a flag specifying whether the object should save itself before closing, prompt the user for
            instructions, or close without saving itself. If an object is instructed to save itself, either by its container or an end
            user, it calls <c>SaveObject</c> to ask the container application to save the object's contents before the object closes
            itself. If a container instructs an object not to save itself, the object should not call <c>SaveObject</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.GetMoniker(Vanara.PInvoke.Ole32.OLEGETMONIKER,Vanara.PInvoke.Ole32.OLEWHICHMK,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>
            Retrieves a moniker for the object's client site. An object can force the assignment of its own or its container's moniker by
            specifying a value for dwAssign.
            </summary>
            <param name="dwAssign">
            Specifies whether to get a moniker only if one already exists, force assignment of a moniker, create a temporary moniker, or
            remove a moniker that has been assigned. In practice, you will usually request that the container force assignment of the
            moniker. Possible values are taken from the OLEGETMONIKER enumeration.
            </param>
            <param name="dwWhichMoniker">
            Specifies whether to return the container's moniker, the object's moniker relative to the container, or the object's full
            moniker. In practice, you will usually request the object's full moniker. Possible values are taken from the OLEWHICHMK enumeration.
            </param>
            <param name="ppmk">
            A pointer to an IMoniker pointer variable that receives the interface pointer to the moniker for the object's client site. If
            an error occurs, the implementation must set ppmk to <c>NULL</c>. Each time a container receives a call to
            <c>IOleClientSite::GetMoniker</c>, it must increase the reference count on the ppmk pointer it returns. It is the caller's
            responsibility to call Release when it is finished with the pointer.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOTIMPL</term>
            <term>This container cannot assign monikers to objects. This is the case with OLE 1 containers.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Containers implement <c>GetMoniker</c> as a way of passing out monikers for their embedded objects to clients that need to
            link to those objects.
            </para>
            <para>
            When a link is made to an embedded object or to a pseudo-object within it (a range of cells in a spreadsheet, for example),
            the object needs a moniker to construct the composite moniker indicating the source of the link. If the embedded object does
            not already have a moniker, it can call <c>GetMoniker</c> to request one.
            </para>
            <para>
            Every container that expects to contain links to embeddings should support <c>GetMoniker</c> to give out
            OLEWHICHMK_CONTAINER, thus enabling link tracking when the link client and link source files move, but maintain the same
            relative position.
            </para>
            <para>
            An object must not persistently store its full moniker or its container's moniker, because these can change while the object
            is not loaded. For example, either the container or the object could be renamed, in which event, storing the container's
            moniker or the object's full moniker would make it impossible for a client to track a link to the object.
            </para>
            <para>
            In some very specialized cases, an object may no longer need a moniker previously assigned to it and may wish to have it
            removed as an optimization. In such cases, the object can call <c>GetMoniker</c> with OLEGETMONIKER_UNASSIGN to have the
            moniker removed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.GetContainer(Vanara.PInvoke.Ole32.IOleContainer@)">
            <summary>Retrieves a pointer to the object's container.</summary>
            <param name="ppContainer">
            Address of IOleContainer pointer variable that receives the interface pointer to the container object. If an error occurs,
            the implementation must set ppContainer to <c>NULL</c>.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_NOT_SUPPORTED</term>
            <term>The client site is in an OLE 1 container.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The container does not implement the IOleContainer interface.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a container supports links to its embedded objects, implementing <c>GetContainer</c> enables link clients to enumerate the
            container's objects and recursively traverse a containment hierarchy. This method is optional but recommended for all
            containers that expect to support links to their embedded objects.
            </para>
            <para>
            Link clients can traverse a hierarchy of compound-document objects by recursively calling <c>GetContainer</c> to get a
            pointer to the link source's container; followed by QueryInterface to get a pointer to the container's IOleObject interface
            and, finally, IOleObject::GetClientSite to get the container's client site in its container.
            </para>
            <para>
            Simple containers that do not support links to their embedded objects probably do not need to implement this method. Instead,
            they can return E_NOINTERFACE and set ppContainer to <c>NULL</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.ShowObject">
            <summary>
            Asks a container to display its object to the user. This method ensures that the container itself is visible and not minimized.
            </summary>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_NOT_SUPPORTED</term>
            <term>Client site is in an OLE 1 container.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            After a link client binds to a link source, it commonly calls IOleObject::DoVerb on the link source, usually requesting the
            source to perform some action requiring that it display itself to the user. As part of its implementation of
            <c>IOleObject::DoVerb</c>, the link source can call <c>ShowObject</c>, which forces the client to show the link source as
            best it can. If the link source's container is itself an embedded object, it will recursively invoke <c>ShowObject</c> on its
            own container.
            </para>
            <para>
            Having called the <c>ShowObject</c> method, a link source has no guarantee of being appropriately displayed because its
            container may not be able to do so at the time of the call. The <c>ShowObject</c> method does not guarantee visibility, only
            that the container will do the best it can.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.OnShowWindow(System.Boolean)">
            <summary>
            Notifies a container when an embedded object's window is about to become visible or invisible. This method does not apply to
            an object that is activated in place and therefore has no window separate from that of its container.
            </summary>
            <param name="fShow">Indicates whether an object's window is open (TRUE) or closed (FALSE).</param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            An embedded object calls <c>OnShowWindow</c> to keep its container informed when the object is open in a window. This window
            may or may not be currently visible to the end user. The container uses this information to shade the object's client site
            when the object is displayed in a window, and to remove the shading when the object is not. A shaded object, having received
            this notification, knows that it already has an open window and therefore can respond to being double-clicked by bringing
            this window quickly to the top, instead of launching its application in order to obtain a new one.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleClientSite.RequestNewObjectLayout">
            <summary>Asks a container to resize the display site for embedded objects.</summary>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOTIMPL</term>
            <term>Client site does not support requests for new layout.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This method can either increase or decrease the space. Currently, there is no standard mechanism by which a container can
            negotiate how much room an object would like. When such a negotiation is defined, responding to this method will be optional
            for containers.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleContainer">
            <summary>
            Enumerates objects in a compound document or lock a container in the running state. Container and object applications both
            implement this interface.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleContainer.ParseDisplayName(System.Runtime.InteropServices.ComTypes.IBindCtx,System.String,System.UInt32@,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Parses the specified display name and creates a corresponding moniker.</summary>
            <param name="pbc">A pointer to the bind context to be used in this binding operation. See IBindCtx.</param>
            <param name="pszDisplayName">The display name to be parsed.</param>
            <param name="pchEaten">
            A pointer to a variable that receives the number of characters in the display name that correspond to the ppmkOut moniker.
            </param>
            <param name="ppmkOut">
            A pointer to an IMoniker pointer variable that receives the interface pointer to the resulting moniker. If an error occurs,
            the implementation sets *ppmkOut to <c>NULL</c>. If *ppmkOut is non- <c>NULL</c>, the implementation must call AddRef; it is
            the caller's responsibility to call Release.
            </param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>
            There is a syntax error in the display name. Parsing failed because pszDisplayName could only be partially resolved into a
            moniker. In this case, *pchEaten has the number of characters that were successfully parsed into a moniker prefix. The
            parameter ppmkOut should be NULL.
            </term>
            </item>
            <item>
            <term>MK_E_NOOBJECT</term>
            <term>The display name does not identify a component in this namespace.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            In general, the maximum prefix of pszDisplayName that is syntactically valid and that represents an object should be consumed
            by this method and converted to a moniker.
            </para>
            <para>
            Typically, this method is called by MkParseDisplayName or MkParseDisplayNameEx. In the initial step of the parsing operation,
            these functions can retrieve the IParseDisplayName interface directly from an instance of a class identified with either the
            "@ProgID" or "ProgID" notation. Subsequent parsing steps can query for the interface on an intermediate object.
            </para>
            <para>
            The main loops of MkParseDisplayName and MkParseDisplayNameEx find the next moniker piece by calling the equivalent method in
            the IMoniker interface, that is, IMoniker::ParseDisplayName, on the moniker that it currently holds. In this call to
            <c>IMoniker::ParseDisplayName</c>, the <c>MkParseDisplayName</c> or <c>MkParseDisplayNameEx</c> function passes <c>NULL</c>
            in the pmkToLeft parameter. If the moniker currently held is a generic composite, the call to
            <c>IMoniker::ParseDisplayName</c> is forwarded by that composite onto its last piece, passing the prefix of the composite to
            the left of the piece in pmkToLeft.
            </para>
            <para>
            Some moniker classes will be able to handle this parsing internally to themselves because they are designed to designate only
            certain kinds of objects. Others will need to bind to the object that they designate to accomplish the parsing process. As is
            usual, these objects should not be released by IMoniker::ParseDisplayName but instead should be transferred to the bind
            context via IBindCtx::RegisterObjectBound or IBindCtx::GetRunningObjectTable followed by IRunningObjectTable::Register for
            release at a later time.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleContainer.EnumObjects(Vanara.PInvoke.Ole32.OLECONTF,Vanara.PInvoke.Ole32.IEnumUnknown@)">
            <summary>Enumerates the objects in the current container.</summary>
            <param name="grfFlags">Specifies which objects in a container are to be enumerated, as defined in the enumeration OLECONTF.</param>
            <param name="ppenum">
            A pointer to an IEnumUnknown pointer variable that receives the interface pointer to the enumerator object. Each time a
            container receives a successful call to EnumObjects, it must increase the reference count on the ppenum pointer the method
            returns. It is the caller's responsibility to call IUnknown::Release when it is done with the pointer. If an error is
            returned, the implementation must set ppenum to NULL.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            A container should implement <c>EnumObjects</c> to enable programmatic clients to find out what objects it holds. This
            method, however, is not called in standard linking scenarios.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleContainer.LockContainer(System.Boolean)">
            <summary>Keeps the container for embedded objects running until explicitly released.</summary>
            <param name="fLock">Indicates whether to lock ( <c>TRUE</c>) or unlock ( <c>FALSE</c>) a container.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory available for the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            An embedded object calls <c>LockContainer</c> to keep its container running when the object has link clients that require an
            update. If an end user selects <c>File Close</c> from the container's menu, however, the container ignores all outstanding
            <c>LockContainer</c> locks and closes the document anyway.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject">
            <summary>
            Provides a direct channel of communication between an in-place object and the associated application's outer-most frame window
            and the document window within the application that contains the embedded object. The communication involves the translation of
            messages, the state of the frame window (activated or deactivated), and the state of the document window (activated or
            deactivated). Also, it informs the object when it needs to resize its borders, and manages modeless dialog boxes.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.GetWindow">
            <summary>
            Retrieves a handle to one of the windows participating in in-place activation (frame, document, parent, or in-place object window).
            </summary>
            <returns>A pointer to a variable that receives the window handle.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.ContextSensitiveHelp(System.Boolean)">
            <summary>Determines whether context-sensitive help mode should be entered during an in-place activation session.</summary>
            <param name="fEnterMode"><c>true</c> if help mode should be entered; <c>false</c> if it should be exited.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.TranslateAccelerator(Vanara.PInvoke.MSG@)">
            <summary>Processes menu accelerator-key messages from the container's message queue. This method should only be used for objects created by a DLL object application.</summary>
            <param name="lpmsg">A pointer to an MSG structure for the message that might need to be translated.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_FALSE</term>
            <term>The message was not translated.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The specified parameter values are not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>IThere is insufficient memory available for the operation.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Notes to Callers</para>
            <para>Active in-place objects must always be given the first chance at translating accelerator keystrokes. You can provide this opportunity by calling <c>IOleInPlaceActiveObject::TranslateAccelerator</c> from your container's message loop before doing any other translation. You should apply your own translation only when this method returns S_FALSE.</para>
            <para>If you call <c>IOleInPlaceActiveObject::TranslateAccelerator</c> for an object that is not created by a DLL object application, the default object handler returns S_FALSE.</para>
            <para>Notes to Implementers</para>
            <para>An object created by an EXE object application gets keystrokes from its own message pump, so the container does not get those messages.</para>
            <para>If you need to implement this method, you can do so by simply wrapping the call to the TranslateAccelerator function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.OnFrameWindowActivate(System.Boolean)">
            <summary>
            Notifies the object when the container's top-level frame window is activated or deactivated.
            </summary>
            <param name="fActivate">The state of the container's top-level frame window. This parameter is <c>TRUE</c> if the window is activating and <c>FALSE</c> if it is deactivating.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.OnDocWindowActivate(System.Boolean)">
            <summary>
            Notifies the active in-place object when the container's document window is activated or deactivated.
            </summary>
            <param name="fActivate">The state of the MDI child document window. If this parameter is <c>TRUE</c>, the window is in the act of activating; if it is <c>FALSE</c>, it is in the act of deactivating.</param>
            <remarks>
            <para>Notes to Callers</para>
            <para>Call <c>IOleInPlaceActiveObject::OnDocWindowActivate</c> when the MDI child document window is activated or deactivated and the object is currently the active object for the document.</para>
            <para>Notes to Implementers</para>
            <para>You should include code in this method that installs frame-level tools during object activation. These tools include the shared composite menu and/or optional toolbars and frame adornments. You should then take focus. When deactivating, the object should remove the frame-level tools. Note that if you do not call IOleInPlaceUIWindow::SetBorderSpace with pborderwidths set to <c>NULL</c>, you can avoid having to renegotiate border space.</para>
            <para>While executing <c>IOleInPlaceActiveObject::OnDocWindowActivate</c>, do not make calls to the PeekMessage or GetMessage functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface methods and functions can be called from within <c>IOleInPlaceActiveObject::OnDocWindowActivate</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.ResizeBorder(Vanara.PInvoke.RECT@,Vanara.PInvoke.Ole32.IOleInPlaceUIWindow,System.Boolean)">
            <summary>Alerts the object that it needs to resize its border space.</summary>
            <param name="prcBorder">A pointer to a RECT structure containing the new outer rectangle within which the object can request border space for its tools.</param>
            <param name="pUIWindow">A pointer to an IOleInPlaceUIWindow interface pointer for the frame or document window object whose border has changed.</param>
            <param name="fFrameWindow">This parameter is <c>TRUE</c> if the frame window object is calling <c>IOleInPlaceActiveObject::ResizeBorder</c>; otherwise, it is <c>FALSE</c>.</param>
            <remarks>
            <para>Notes to Callers</para>
            <para><c>IOleInPlaceActiveObject::ResizeBorder</c> is called by the top-level container's document or frame window object when the border space allocated to the object should change. Because the active in-place object is not informed about which window has changed (the frame- or document-level window), <c>IOleInPlaceActiveObject::ResizeBorder</c> must be passed the pointer to the window's IOleInPlaceUIWindow interface.</para>
            <para>Notes to Implemeters</para>
            <para>In most cases, resizing only requires that you grow, shrink, or scale your object's frame adornments. However, for more complicated adornments, you may be required to renegotiate for border space with calls to IOleInPlaceUIWindow::SetBorderSpace and <c>IOleInPlaceUIWindow::SetBorderSpace</c>.</para>
            <para><c>Note</c> While executing <c>IOleInPlaceActiveObject::ResizeBorder</c>, do not make calls to the PeekMessage or GetMessage functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface methods and functions can be called from within <c>IOleInPlaceActiveObject::ResizeBorder</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceActiveObject.EnableModeless(System.Boolean)">
            <summary>Enables or disables modeless dialog boxes when the container creates or destroys a modal dialog box.</summary>
            <param name="fEnable">Indicates whether to enable modeless dialog box windows (<c>TRUE</c>) or disable them <c>FALSE</c>.</param>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleInPlaceFrame">
            <summary>
            Controls the container's top-level frame window. This control involves allowing the container to insert its menu group into the
            composite menu, install the composite menu into the appropriate window frame, and remove the container's menu elements from the
            composite menu. It sets and displays status text relevant to the in-place object. It also enables or disables the frame's
            modeless dialog boxes, and translates accelerator keystrokes intended for the container's frame.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.GetWindow">
            <summary>
            Retrieves a handle to one of the windows participating in in-place activation (frame, document, parent, or in-place object window).
            </summary>
            <returns>A pointer to a variable that receives the window handle.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.ContextSensitiveHelp(System.Boolean)">
            <summary>Determines whether context-sensitive help mode should be entered during an in-place activation session.</summary>
            <param name="fEnterMode"><c>true</c> if help mode should be entered; <c>false</c> if it should be exited.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.GetBorder(Vanara.PInvoke.RECT@)">
            <summary>Retrieves the outer rectange for toolbars and controls while the object is active in place.</summary>
            <param name="lprectBorder">
            A pointer to a RECT structure where the outer rectangle is to be returned. The structure's coordinates are relative to the
            window being represented by the interface.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The <c>IOleInPlaceUIWindow::GetBorder</c> function, when called on a document or frame window object, returns the outer
            rectangle (relative to the window) where the object can put toolbars or similar controls.
            </para>
            <para>
            If the object is to install these tools, it should negotiate space for the tools within this rectangle using
            IOleInPlaceUIWindow::RequestBorderSpace and then call IOleInPlaceUIWindow::SetBorderSpace to get this space allocated.
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::GetBorder</c>, do not make calls to the PeekMessage or GetMessage
            functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface
            methods and functions can be called from within <c>GetBorder</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.RequestBorderSpace(Vanara.PInvoke.RECT@)">
            <summary>
            Determines whether there is space available for tools to be installed around the object's window frame while the object is
            active in place.
            </summary>
            <param name="pborderwidths">
            A pointer to a BORDERWIDTHS structure containing the requested widths (in pixels) needed on each side of the window for the tools.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The active in-place object calls <c>IOleInPlaceUIWindow::RequestBorderSpace</c> to ask if tools can be installed inside the
            window frame. These tools would be allocated between the rectangle returned by IOleInPlaceUIWindow::GetBorder and the
            BORDERWIDTHS structure specified in the argument to this call.
            </para>
            <para>
            The space for the tools is not actually allocated to the object until it calls IOleInPlaceUIWindow::SetBorderSpace, allowing
            the object to negotiate for space (such as while dragging toolbars around), but deferring the moving of tools until the
            action is completed.
            </para>
            <para>
            The object can install these tools by passing the width in pixels that is to be used on each side. For example, if the object
            required 10 pixels on the top, 0 pixels on the bottom, and 5 pixels on the left and right sides, it would pass the following
            BORDERWIDTHS structure to <c>IOleInPlaceUIWindow::RequestBorderSpace</c>:
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::RequestBorderSpace</c>, do not make calls to the PeekMessage or
            GetMessage functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE
            interface methods and functions can be called from within <c>IOleInPlaceUIWindow::RequestBorderSpace</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>
            If the amount of space an active object uses for its toolbars is irrelevant to the container, it can simply return NOERROR as
            shown in the following <c>IOleInPlaceUIWindow::RequestBorderSpace</c> example. Containers should not unduly restrict the
            display of tools by an active in-place object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.SetBorderSpace(Vanara.PInvoke.RECT@)">
            <summary>Allocates space for the border requested in the call to IOleInPlaceUIWindow::RequestBorderSpace.</summary>
            <param name="pborderwidths">
            Pointer to a BORDERWIDTHS structure containing the requested width of the tools, in pixels. It can be <c>NULL</c>, indicating
            the object does not need any space.
            </param>
            <remarks>
            <para>The object must call <c>IOleInPlaceUIWindow::SetBorderSpace</c>. It can do any one of the following:</para>
            <list type="bullet">
            <item>
            <term>Use its own toolbars, requesting border space of a specific size.</term>
            </item>
            <item>
            <term>
            Use no toolbars, but force the container to remove its toolbars by passing a valid BORDERWIDTHS structure containing nothing
            but zeros in the pborderwidths parameter.
            </term>
            </item>
            <item>
            <term>
            Use no toolbars but allow the in-place container to leave its toolbars up by passing <c>NULL</c> as the pborderwidths parameter.
            </term>
            </item>
            </list>
            <para>
            The BORDERWIDTHS structure used in this call would generally have been passed in a previous call to
            IOleInPlaceUIWindow::RequestBorderSpace, which must have returned S_OK.
            </para>
            <para>
            If an object must renegotiate space on the border, it can call <c>IOleInPlaceUIWindow::SetBorderSpace</c> again with the new
            widths. If the call to <c>IOleInPlaceUIWindow::SetBorderSpace</c> fails, the object can do a full negotiation for border
            space with calls to IOleInPlaceUIWindow::GetBorder, IOleInPlaceUIWindow::RequestBorderSpace, and <c>IOleInPlaceUIWindow::SetBorderSpace</c>.
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::SetBorderSpace</c>, do not make calls to the PeekMessage or GetMessage
            functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface
            methods and functions can be called from within <c>IOleInPlaceUIWindow::SetBorderSpace</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.SetActiveObject(Vanara.PInvoke.Ole32.IOleInPlaceActiveObject,System.String)">
            <summary>Provides a direct channel of communication between the object and each of the frame and document windows.</summary>
            <param name="pActiveObject">A pointer to the IOleInPlaceActiveObject interface on the active in-place object.</param>
            <param name="pszObjName">
            A pointer to a string containing a name that describes the object an embedding container can use in composing its window
            title. It can be <c>NULL</c> if the object does not require the container to change its window titles. Containers should
            ignore this parameter and always use their own name in the title bar.
            </param>
            <remarks>
            <para>
            Generally, an embedded object should pass <c>NULL</c> for the pszObjName parameter (see Notes to Implementers below).
            However, if you are working in conjunction with a container that does display the name of the in-place active object in its
            title bar, then you should compose a string in the following form: &lt;application name&gt; â€“ &lt;object short-type name&gt;.
            </para>
            <para>Notes to Callers</para>
            <para>
            <c>IOleInPlaceUIWindow::SetActiveObject</c> is called by the object to establish a direct communication link between itself
            and the document and frame windows.
            </para>
            <para>
            When deactivating, the object calls <c>IOleInPlaceUIWindow::SetActiveObject</c>, passing <c>NULL</c> for the pActiveObject
            and pszObjName parameters.
            </para>
            <para>
            An object must call <c>IOleInPlaceUIWindow::SetActiveObject</c> before calling IOleInPlaceFrame::SetMenu to give the
            container the pointer to the active object. The container then uses this pointer in processing
            <c>IOleInPlaceFrame::SetMenu</c> and to pass to OleSetMenuDescriptor.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The Microsoft Windows User Interface Design Guide recommends that an in-place container ignore the pszObjName parameter
            passed in this method. The guide says "The title bar is not affected by in-place activation. It always displays the top-level
            container's name."
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.InsertMenus(Vanara.PInvoke.HMENU,Vanara.PInvoke.Ole32.OLEMENUGROUPWIDTHS@)">
            <summary>Enables the container to insert menu groups into the composite menu to be used during the in-place session.</summary>
            <param name="hmenuShared">A handle to an empty menu.</param>
            <param name="lpMenuWidths">
            A pointer to an OLEMENUGROUPWIDTHS array with six elements. The container fills in elements 0, 2, and 4 to reflect the number
            of menu elements it provided in the <c>File</c>, <c>View</c>, and <c>Window</c> menu groups.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            This method is called by object applications when they are first being activated. They call it to insert their menus into the
            frame-level user interface.
            </para>
            <para>
            The object application asks the container to add its menus to the menu specified in hmenuShared and to set the group counts
            in the OLEMENUGROUPWIDTHS array pointed to by lpMenuWidths. The object application then adds its own menus and counts.
            Objects can call <c>IOleInPlaceFrame::InsertMenus</c> as many times as necessary to build up the composite menus. The
            container should use the initial menu handle associated with the composite menu for all menu items in the drop-down menus.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.SetMenu(Vanara.PInvoke.HMENU,Vanara.PInvoke.Ole32.HOLEMENU,Vanara.PInvoke.HWND)">
            <summary>Adds a composite menu to the window frame containing the object being activated in place.</summary>
            <param name="hmenuShared">
            A handle to the composite menu constructed by calls to IOleInPlaceFrame::InsertMenus and the InsertMenu function.
            </param>
            <param name="holemenu">A handle to the menu descriptor returned by the OleCreateMenuDescriptor function.</param>
            <param name="hwndActiveObject">
            A handle to a window owned by the object and to which menu messages, commands, and accelerators are to be sent.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The object calls <c>IOleInPlaceFrame::SetMenu</c> to ask the container to install the composite menu structure set up by
            calls to IOleInPlaceFrame::InsertMenus.
            </para>
            <para>Notes to Implementers</para>
            <para>
            An SDI container's implementation of this method should call the SetMenu function. An MDI container should send a
            WM_MDISETMENU message, using hmenuShared as the menu to install. The container should call OleSetMenuDescriptor to install
            the OLE dispatching code.
            </para>
            <para>
            When deactivating, the container must call <c>IOleInPlaceFrame::SetMenu</c>, specifying <c>NULL</c> to remove the shared
            menu. This is done to help minimize window repaints. The container should also call OleSetMenuDescriptor, specifying
            <c>NULL</c> to unhook the dispatching code. Finally, the object application calls OleDestroyMenuDescriptor to free the data structure.
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceFrame::SetMenu</c>, do not make calls to the PeekMessage or GetMessage functions,
            or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface methods and
            functions can be called from within <c>IOleInPlaceFrame::SetMenu</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.RemoveMenus(Vanara.PInvoke.HMENU)">
            <summary>Removes a container's menu elements from the composite menu.</summary>
            <param name="hmenuShared">
            A handle to the in-place composite menu that was constructed by calls to IOleInPlaceFrame::InsertMenus and the InsertMenu function.
            </param>
            <remarks>
            <para>
            The object should always give the container a chance to remove its menu elements from the composite menu before deactivating
            the shared user interface.
            </para>
            <para>Notes to Callers</para>
            <para>This method is called by the object application while it is being UI-deactivated to remove its menus.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.SetStatusText(System.String)">
            <summary>Sets and displays status text about the in-place object in the container's frame window status line.</summary>
            <param name="pszStatusText">The message to be displayed.</param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            You should call <c>IOleInPlaceFrame::SetStatusText</c> when you need to ask the container to display object text in its
            frame's status line, if it has one. Because the container's frame window owns the status line, calling
            <c>IOleInPlaceFrame::SetStatusText</c> is the only way an object can display status information in the container's frame
            window. If the container refuses the object's request, the object application can, however, negotiate for border space to
            display its own status window.
            </para>
            <para>
            When switching between menus owned by the container and the in-place active object, the status bar text is not reflected
            properly if the object does not call the container's <c>IOleInPlaceFrame::SetStatusText</c> method. For example, if, during
            an in-place session, the user were to select the <c>File</c> menu, the status bar would reflect the action that would occur
            if the user selected this menu. If the user then selects the <c>Edit</c> menu (which is owned by the in-place object), the
            status bar text would not change unless the <c>IOleInPlaceFrame::SetStatusText</c> happened to be called. This is because
            there is no way for the container to recognize that one of the object's menus has been made active because all the messages
            that the container would trap are now going to the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            To avoid potential problems, all objects being activated in place should process the WM_MENUSELECT message and call
            <c>IOleInPlaceFrame::SetStatusText</c> â€”even if the object does not usually provide status information (in which case the
            object can just pass a <c>NULL</c> string for the requested status text).
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceFrame::SetStatusText</c>, do not make calls to the PeekMessage or GetMessage
            functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface
            methods and functions can be called from within IOleInPlaceUIWindow::GetBorder.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.EnableModeless(System.Boolean)">
            <summary>Enables or disables a frame's modeless dialog boxes.</summary>
            <param name="fEnable">
            Specifies whether the modeless dialog box windows are to be enabled ( <c>TRUE</c>) or disabled ( <c>FALSE</c>).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceFrame.TranslateAccelerator(Vanara.PInvoke.MSG@,System.UInt16@)">
            <summary>Translates accelerator keystrokes intended for the container's frame while an object is active in place.</summary>
            <param name="lpmsg">A pointer to the MSG structure that contains the keystroke message.</param>
            <param name="wID">
            The command identifier value corresponding to the keystroke in the container-provided accelerator table. Containers should
            use this value instead of translating again.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The <c>IOleInPlaceFrame::TranslateAccelerator</c> method is called indirectly by OleTranslateAccelerator when a keystroke
            accelerator intended for the container (frame) is received.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The container application should perform its usual accelerator processing, or use wID directly, and then return, indicating
            whether the keystroke accelerator was processed. If the container is an MDI application and the TranslateAccelerator function
            fails, the container can call the TranslateMDISysAccel function, just as it does for its usual message processing.
            </para>
            <para>
            In-place objects should be given first chance at translating accelerator messages. However, because objects implemented by
            DLL object applications do not have their own message pump, they receive their messages from the container's message queue.
            To ensure that the object has first chance at translating messages, a container should always call
            <c>IOleInPlaceFrame::TranslateAccelerator</c> before doing its own accelerator translation. Conversely, an executable object
            application should call OleTranslateAccelerator after calling TranslateAccelerator, calling TranslateMessage and
            DispatchMessage only if both translation functions fail.
            </para>
            <para>
            You should define accelerator tables for containers so they will work properly with object applications that do their own
            accelerator keystroke translations. Tables should be defined as follows.
            </para>
            <para>
            This is the most common way to describe keyboard accelerators. Failure to do so can result in keystrokes being lost or sent
            to the wrong object during an in-place session.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow">
            <summary>
            Implemented by container applications and used by object applications to negotiate border space on the document or frame window.
            The container provides a RECT structure in which the object can place toolbars and other similar controls, determines if tools
            can in fact be installed around the object's window frame, allocates space for the border, and establishes a communication
            channel between the object and each frame and document window.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.GetWindow">
            <summary>
            Retrieves a handle to one of the windows participating in in-place activation (frame, document, parent, or in-place object window).
            </summary>
            <returns>A pointer to a variable that receives the window handle.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.ContextSensitiveHelp(System.Boolean)">
            <summary>Determines whether context-sensitive help mode should be entered during an in-place activation session.</summary>
            <param name="fEnterMode"><c>true</c> if help mode should be entered; <c>false</c> if it should be exited.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.GetBorder(Vanara.PInvoke.RECT@)">
            <summary>Retrieves the outer rectange for toolbars and controls while the object is active in place.</summary>
            <param name="lprectBorder">
            A pointer to a RECT structure where the outer rectangle is to be returned. The structure's coordinates are relative to the
            window being represented by the interface.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The <c>IOleInPlaceUIWindow::GetBorder</c> function, when called on a document or frame window object, returns the outer
            rectangle (relative to the window) where the object can put toolbars or similar controls.
            </para>
            <para>
            If the object is to install these tools, it should negotiate space for the tools within this rectangle using
            IOleInPlaceUIWindow::RequestBorderSpace and then call IOleInPlaceUIWindow::SetBorderSpace to get this space allocated.
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::GetBorder</c>, do not make calls to the PeekMessage or GetMessage
            functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface
            methods and functions can be called from within <c>GetBorder</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.RequestBorderSpace(Vanara.PInvoke.RECT@)">
            <summary>
            Determines whether there is space available for tools to be installed around the object's window frame while the object is
            active in place.
            </summary>
            <param name="pborderwidths">
            A pointer to a BORDERWIDTHS structure containing the requested widths (in pixels) needed on each side of the window for the tools.
            </param>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            The active in-place object calls <c>IOleInPlaceUIWindow::RequestBorderSpace</c> to ask if tools can be installed inside the
            window frame. These tools would be allocated between the rectangle returned by IOleInPlaceUIWindow::GetBorder and the
            BORDERWIDTHS structure specified in the argument to this call.
            </para>
            <para>
            The space for the tools is not actually allocated to the object until it calls IOleInPlaceUIWindow::SetBorderSpace, allowing
            the object to negotiate for space (such as while dragging toolbars around), but deferring the moving of tools until the
            action is completed.
            </para>
            <para>
            The object can install these tools by passing the width in pixels that is to be used on each side. For example, if the object
            required 10 pixels on the top, 0 pixels on the bottom, and 5 pixels on the left and right sides, it would pass the following
            BORDERWIDTHS structure to <c>IOleInPlaceUIWindow::RequestBorderSpace</c>:
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::RequestBorderSpace</c>, do not make calls to the PeekMessage or
            GetMessage functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE
            interface methods and functions can be called from within <c>IOleInPlaceUIWindow::RequestBorderSpace</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>
            If the amount of space an active object uses for its toolbars is irrelevant to the container, it can simply return NOERROR as
            shown in the following <c>IOleInPlaceUIWindow::RequestBorderSpace</c> example. Containers should not unduly restrict the
            display of tools by an active in-place object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.SetBorderSpace(Vanara.PInvoke.RECT@)">
            <summary>Allocates space for the border requested in the call to IOleInPlaceUIWindow::RequestBorderSpace.</summary>
            <param name="pborderwidths">
            Pointer to a BORDERWIDTHS structure containing the requested width of the tools, in pixels. It can be <c>NULL</c>, indicating
            the object does not need any space.
            </param>
            <remarks>
            <para>The object must call <c>IOleInPlaceUIWindow::SetBorderSpace</c>. It can do any one of the following:</para>
            <list type="bullet">
            <item>
            <term>Use its own toolbars, requesting border space of a specific size.</term>
            </item>
            <item>
            <term>
            Use no toolbars, but force the container to remove its toolbars by passing a valid BORDERWIDTHS structure containing nothing
            but zeros in the pborderwidths parameter.
            </term>
            </item>
            <item>
            <term>
            Use no toolbars but allow the in-place container to leave its toolbars up by passing <c>NULL</c> as the pborderwidths parameter.
            </term>
            </item>
            </list>
            <para>
            The BORDERWIDTHS structure used in this call would generally have been passed in a previous call to
            IOleInPlaceUIWindow::RequestBorderSpace, which must have returned S_OK.
            </para>
            <para>
            If an object must renegotiate space on the border, it can call <c>IOleInPlaceUIWindow::SetBorderSpace</c> again with the new
            widths. If the call to <c>IOleInPlaceUIWindow::SetBorderSpace</c> fails, the object can do a full negotiation for border
            space with calls to IOleInPlaceUIWindow::GetBorder, IOleInPlaceUIWindow::RequestBorderSpace, and <c>IOleInPlaceUIWindow::SetBorderSpace</c>.
            </para>
            <para>
            <c>Note</c> While executing <c>IOleInPlaceUIWindow::SetBorderSpace</c>, do not make calls to the PeekMessage or GetMessage
            functions, or a dialog box. Doing so may cause the system to deadlock. There are further restrictions on which OLE interface
            methods and functions can be called from within <c>IOleInPlaceUIWindow::SetBorderSpace</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleInPlaceUIWindow.SetActiveObject(Vanara.PInvoke.Ole32.IOleInPlaceActiveObject,System.String)">
            <summary>Provides a direct channel of communication between the object and each of the frame and document windows.</summary>
            <param name="pActiveObject">A pointer to the IOleInPlaceActiveObject interface on the active in-place object.</param>
            <param name="pszObjName">
            A pointer to a string containing a name that describes the object an embedding container can use in composing its window
            title. It can be <c>NULL</c> if the object does not require the container to change its window titles. Containers should
            ignore this parameter and always use their own name in the title bar.
            </param>
            <remarks>
            <para>
            Generally, an embedded object should pass <c>NULL</c> for the pszObjName parameter (see Notes to Implementers below).
            However, if you are working in conjunction with a container that does display the name of the in-place active object in its
            title bar, then you should compose a string in the following form: &lt;application name&gt; â€“ &lt;object short-type name&gt;.
            </para>
            <para>Notes to Callers</para>
            <para>
            <c>IOleInPlaceUIWindow::SetActiveObject</c> is called by the object to establish a direct communication link between itself
            and the document and frame windows.
            </para>
            <para>
            When deactivating, the object calls <c>IOleInPlaceUIWindow::SetActiveObject</c>, passing <c>NULL</c> for the pActiveObject
            and pszObjName parameters.
            </para>
            <para>
            An object must call <c>IOleInPlaceUIWindow::SetActiveObject</c> before calling IOleInPlaceFrame::SetMenu to give the
            container the pointer to the active object. The container then uses this pointer in processing
            <c>IOleInPlaceFrame::SetMenu</c> and to pass to OleSetMenuDescriptor.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The Microsoft Windows User Interface Design Guide recommends that an in-place container ignore the pszObjName parameter
            passed in this method. The guide says "The title bar is not affected by in-place activation. It always displays the top-level
            container's name."
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleObject">
            <summary>
            Serves as the principal means by which an embedded object provides basic functionality to, and communicates with, its container.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.SetClientSite(Vanara.PInvoke.Ole32.IOleClientSite)">
            <summary>Informs an embedded object of its display location, called a "client site," within its container.</summary>
            <param name="pClientSite">Pointer to the IOleClientSite interface on the container application's client-site.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Within a compound document, each embedded object has its own client site â€” the place where it is displayed and through
            which it receives information about its storage, user interface, and other resources. <c>IOleObject::SetClientSite</c> is the
            only method enabling an embedded object to obtain a pointer to its client site.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container can notify an object of its client site either at the time the object is created or, subsequently, when the
            object is initialized.
            </para>
            <para>
            When creating or loading an object, a container may pass a client-site pointer (along with other arguments) to one of the
            following helper functions: OleCreate, OleCreateFromFile, OleCreateFromData or OleLoad. These helper functions load an object
            handler for the new object and call <c>IOleObject::SetClientSite</c> on the container's behalf before returning a pointer to
            the new object.
            </para>
            <para>
            Passing a client-site pointer informs the object handler that the client site is ready to process requests. If the client
            site is unlikely to be ready immediately after the handler is loaded, you may want your container to pass a <c>NULL</c>
            client-site pointer to the helper function. The <c>NULL</c> pointer says that no client site is available and thereby defers
            notifying the object handler of the client site until the object is initialized. In response, the helper function returns a
            pointer to the object, but upon receiving that pointer the container must call <c>IOleObject::SetClientSite</c> as part of
            initializing the new object.
            </para>
            <para>Notes to Implementers</para>
            <para>Implementation consists simply of incrementing the reference count on, and storing, the pointer to the client site.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetClientSite(Vanara.PInvoke.Ole32.IOleClientSite@)">
            <summary>Retrieves a pointer to an embedded object's client site.</summary>
            <param name="ppClientSite">
            Address of IOleClientSite pointer variable that receives the interface pointer to the object's client site. If an object does
            not yet know its client site, or if an error has occurred, ppClientSite must be set to <c>NULL</c>. Each time an object
            receives a call to <c>IOleObject::GetClientSite</c>, it must increase the reference count on ppClientSite. It is the caller's
            responsibility to call Release when it is done with ppClientSite.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para>
            Link clients most commonly call the <c>IOleObject::GetClientSite</c> method in conjunction with the
            IOleClientSite::GetContainer method to traverse a hierarchy of nested objects. A link client calls
            <c>IOleObject::GetClientSite</c> to get a pointer to the link source's client site. The client then calls
            <c>IOleClientSite::GetContainer</c> to get a pointer to the link source's container. Finally, the client calls QueryInterface
            to get IOleObject and <c>IOleObject::GetClientSite</c> to get the container's client site within its container. By repeating
            this sequence of calls, the caller can eventually retrieve a pointer to the master container in which all the other objects
            are nested.
            </para>
            <para>Notes to Callers</para>
            <para>
            The returned client-site pointer will be <c>NULL</c> if an embedded object has not yet been informed of its client site. This
            will be the case with a newly loaded or created object when a container has passed a <c>NULL</c> client-site pointer to one
            of the object-creation helper functions but has not yet called IOleObject::SetClientSite as part of initializing the object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.SetHostNames(System.String,System.String)">
            <summary>Provides an object with the names of its container application and the compound document in which it is embedded.</summary>
            <param name="szContainerApp">Pointer to the name of the container application in which the object is running.</param>
            <param name="szContainerObj">
            Pointer to the name of the compound document that contains the object. If you do not wish to display the name of the compound
            document, you can set this parameter to <c>NULL</c>.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            <para>Notes for Callers</para>
            <para>
            Call <c>IOleObject::SetHostNames</c> only for embedded objects, because for linked objects, the link source provides its own
            separate editing window and title bar information.
            </para>
            <para>Notes to Implementers</para>
            <para>
            An object's application of <c>IOleObject::SetHostNames</c> should include whatever modifications to its user interface may be
            appropriate to an object's embedded state. Such modifications typically will include adding and removing menu commands and
            altering the text displayed in the title bar of the editing window.
            </para>
            <para>
            The complete window title for an embedded object in an SDI container application or an MDI application with a maximized child
            window should appear as follows:
            </para>
            <para>Otherwise, the title should be:</para>
            <para>
            The "object short type" refers to a form of an object's name short enough to be displayed in full in a list box. Because
            these identifying strings are not stored as part of the persistent state of the object, <c>IOleObject::SetHostNames</c> must
            be called each time the object loads or runs.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.Close(Vanara.PInvoke.Ole32.OLECLOSE)">
            <summary>Changes an embedded object from the running to the loaded state. Disconnects a linked object from its link source.</summary>
            <param name="dwSaveOption">
            <para>
            Indicates whether the object is to be saved as part of the transition to the loaded state. Valid values are taken from the
            enumeration OLECLOSE.
            </para>
            <para>
            <c>Note</c> The OLE 2 user model recommends that object applications do not prompt users before saving linked or embedded
            objects, including those activated in place. This policy represents a change from the OLE 1 user model, in which object
            applications always prompt the user to decide whether to save changes.
            </para>
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_PROMPTSAVECANCELLED</term>
            <term>The user was prompted to save but chose the Cancel button from the prompt message box.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Notes to Callers</para>
            <para>
            A container application calls <c>IOleObject::Close</c> when it wants to move the object from a running to a loaded state.
            Following such a call, the object still appears in its container but is not open for editing. Calling
            <c>IOleObject::Close</c> on an object that is loaded but not running has no effect. Closing a linked object simply means
            disconnecting it.
            </para>
            <para>Notes to Implementers</para>
            <para>Upon receiving a call to <c>IOleObject::Close</c>, a running object should do the following:</para>
            <list type="bullet">
            <item>
            <term>
            If the object has been changed since it was last opened for editing, it should request to be saved, or not, according to
            instructions specified in dwSaveOption. If the option is to save the object, then it should call its container's
            IOleClientSite::SaveObject interface.
            </term>
            </item>
            <item>
            <term>
            If the object has IDataObject::DAdvise connections with ADVF_DATAONSTOP flags, then it should send an
            IAdviseSink::OnDataChange notification. See <c>IDataObject::DAdvise</c> for details.
            </term>
            </item>
            <item>
            <term>If the object currently owns the Clipboard, it should empty it by calling OleFlushClipboard.</term>
            </item>
            <item>
            <term>
            If the object is currently visible, notify its container by calling IOleClientSite::OnShowWindow with the fshow argument set
            to <c>FALSE</c>.
            </term>
            </item>
            <item>
            <term>Send IAdviseSink::OnClose notifications to appropriate advise sinks.</term>
            </item>
            <item>
            <term>Finally, forcibly cut off all remoting clients by calling CoDisconnectObject.</term>
            </item>
            </list>
            <para>
            If the object application is a local server (an EXE rather than a DLL), closing the object should also shut down the object
            application unless the latter is supporting other running objects or has another reason to remain in the running state. Such
            reasons might include the presence of IClassFactory::LockServer locks, end-user control of the application, or the existence
            of other open documents requiring access to the application.
            </para>
            <para>
            Calling <c>IOleObject::Close</c> on a linked object disconnects it from, but does not shut down, its source application. A
            source application that is visible to the user when the object is closed remains visible and running after the disconnection
            and does not send an IAdviseSink::OnClose notification to the link container.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.SetMoniker(Vanara.PInvoke.Ole32.OLEWHICHMK,System.Runtime.InteropServices.ComTypes.IMoniker)">
            <summary>
            Notifies an object of its container's moniker, the object's own moniker relative to the container, or the object's full moniker.
            </summary>
            <param name="dwWhichMoniker">The moniker is passed in pmk. Possible values are from the enumeration OLEWHICHMK.</param>
            <param name="pmk">Pointer to where to return the moniker.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A container that supports links to embedded objects must be able to inform an embedded object when its moniker has changed.
            Otherwise, subsequent attempts by link clients to bind to the object will fail. The <c>IOleObject::SetMoniker</c> method
            provides one way for a container to communicate this information.
            </para>
            <para>
            The container can pass either its own moniker, an object's moniker relative to the container, or an object's full moniker. In
            practice, if a container passes anything other than an object's full moniker, each object calls the container back to request
            assignment of the full moniker, which the object requires to register itself in the running object table.
            </para>
            <para>
            The moniker of an object relative to its container is stored by the object handler as part of the object's persistent state.
            The moniker of the object's container, however, must not be persistently stored inside the object because the container can
            be renamed at any time.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container calls <c>IOleObject::SetMoniker</c> when the container has been renamed, and the container's embedded objects
            currently or can potentially serve as link sources. Containers call SetMoniker mainly in the context of linking because an
            embedded object is already aware of its moniker. Even in the context of linking, calling this method is optional because
            objects can call IOleClientSite::GetMoniker to force assignment of a new moniker.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Upon receiving a call to <c>IOleObject::SetMoniker</c>, an object should register its full moniker in the running object
            table and send IAdviseSink::OnRename notification to all advise sinks that exist for the object.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetMoniker(Vanara.PInvoke.Ole32.OLEGETMONIKER,Vanara.PInvoke.Ole32.OLEWHICHMK,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Retrieves an embedded object's moniker, which the caller can use to link to the object.</summary>
            <param name="dwAssign">
            <para>
            Determines how the moniker is assigned to the object. Depending on the value of dwAssign, <c>IOleObject::GetMoniker</c> does
            one of the following:
            </para>
            <list type="bullet">
            <item>
            <term>Obtains a moniker only if one has already been assigned.</term>
            </item>
            <item>
            <term>Forces assignment of a moniker, if necessary, in order to satisfy the call.</term>
            </item>
            <item>
            <term>Obtains a temporary moniker.</term>
            </item>
            </list>
            <para>Values for</para>
            <para>dwAssign</para>
            <para>are specified in the enumeration</para>
            <para>OLEGETMONIKER</para>
            <para>.</para>
            <para>
            <c>Note</c> You cannot pass OLEGETMONIKER_UNASSIGN when calling <c>IOleObject::GetMoniker</c>. This value is valid only when
            calling <c>IOleObject::GetMoniker</c>.
            </para>
            </param>
            <param name="dwWhichMoniker">
            Specifies the form of the moniker being requested. Possible values are taken from the enumeration OLEWHICHMK.
            </param>
            <param name="ppmk">
            Address of IMoniker pointer variable that receives the interface pointer to the object's moniker. If an error occurs, ppmk
            must be set to <c>NULL</c>. Each time an object receives a call to <c>IOleObject::GetMoniker</c>, it must increase the
            reference count on ppmk. It is the caller's responsibility to call Release when it is done with ppmk.
            </param>
            <returns>This method returns S_OK on success.</returns>
            <remarks>
            The <c>IOleObject::GetMoniker</c> method returns an object's moniker. Like IOleObject::SetMoniker, this method is important
            only in the context of managing links to embedded objects and even in that case is optional. A potential link client that
            requires an object's moniker to bind to the object can call this method to obtain that moniker. The default implementation of
            <c>IOleObject::GetMoniker</c> calls the IOleClientSite::GetMoniker, returning E_UNEXPECTED if the object is not running or
            does not have a valid pointer to a client site.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.InitFromData(System.Runtime.InteropServices.ComTypes.IDataObject,System.Boolean,System.UInt32)">
            <summary>
            Initializes a newly created object with data from a specified data object, which can reside either in the same container or
            on the Clipboard.
            </summary>
            <param name="pDataObject">
            Pointer to the IDataObject interface on the data object from which the initialization data is to be obtained. This parameter
            can be <c>NULL</c>, which indicates that the caller wants to know if it is worthwhile trying to send data; that is, whether
            the container is capable of initializing an object from data passed to it. The data object to be passed can be based on
            either the current selection within the container document or on data transferred to the container from an external source.
            </param>
            <param name="fCreation">
            <c>TRUE</c> indicates the container is inserting a new object inside itself and initializing that object with data from the
            current selection; <c>FALSE</c> indicates a more general programmatic data transfer, most likely from a source other than the
            current selection.
            </param>
            <param name="dwReserved">This parameter is reserved and must be zero.</param>
            <returns>
            <para>
            This method returns S_OK if pDataObject is not <c>NULL</c>, the object successfully attempted to initialize itself from the
            provided data; if pDataObject is <c>NULL</c>, the object is able to attempt a successful initialization.. Other possible
            return values include the following.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_FALSE</term>
            <term>
            If pDataObject is not NULL, the object made no attempt to initialize itself; if pDataObject is NULL, the object cannot
            attempt to initialize itself from the data provided.
            </term>
            </item>
            <item>
            <term>E_NOTIMPL</term>
            <term>The object does not support InitFromData.</term>
            </item>
            <item>
            <term>OLE_E_NOTRUNNING</term>
            <term>The object is not running and therefore cannot perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method enables a container document to insert within itself a new object whose content is based on a current data
            selection within the container. For example, a spreadsheet document may want to create a graph object based on data in a
            selected range of cells.
            </para>
            <para>
            Using this method, a container can also replace the contents of an embedded object with data transferred from another source.
            This provides a convenient way of updating an embedded object.
            </para>
            <para>Notes to Callers</para>
            <para>
            Following initialization, the container should call IOleObject::GetMiscStatus to check the value of the
            OLEMISC_INSERTNOTREPLACE bit. If the bit is on, the new object inserts itself following the selected data. If the bit is off,
            the new object replaces the selected data.
            </para>
            <para>Notes to Implementers</para>
            <para>
            A container specifies whether to base a new object on the current selection by passing either <c>TRUE</c> or <c>FALSE</c> to
            the fCreation parameter.
            </para>
            <para>
            If fCreation is <c>TRUE</c>, the container is attempting to create a new instance of an object, initializing it with the
            selected data specified by the data object.
            </para>
            <para>
            If fCreation is <c>FALSE</c>, the caller is attempting to replace the object's current contents with that pointed to by
            pDataObject. The usual constraints that apply to an object during a paste operation should be applied here. For example, if
            the type of the data provided is unacceptable, the object should fail to initialize and return S_FALSE.
            </para>
            <para>If the object returns S_FALSE, it cannot initialize itself from the provided data.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetClipboardData(System.UInt32,System.Runtime.InteropServices.ComTypes.IDataObject@)">
            <summary>
            Retrieves a data object containing the current contents of the embedded object on which this method is called. Using the
            pointer to this data object, it is possible to create a new embedded object with the same data as the original.
            </summary>
            <param name="dwReserved">This parameter is reserved and must be zero.</param>
            <param name="ppDataObject">
            Address of IDataObject pointer variable that receives the interface pointer to the data object. If an error occurs,
            ppDataObject must be set to <c>NULL</c>. Each time an object receives a call to <c>IOleObject::GetClipboardData</c>, it must
            increase the reference count on ppDataObject. It is the caller's responsibility to call Release when it is done with ppDataObject.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOTIMPL</term>
            <term>GetClipboardData is not supported.</term>
            </item>
            <item>
            <term>OLE_E_NOTRUNNING</term>
            <term>The object is not running.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You can use the <c>IOleObject::GetClipboardData</c> method to convert a linked object to an embedded object, in which case
            the container application would call <c>IOleObject::GetClipboardData</c> and then pass the data received to
            OleCreateFromData. This method returns a pointer to a data object that is identical to what would have been passed to the
            clipboard by a standard copy operation.
            </para>
            <para>Notes to Callers</para>
            <para>
            If you want a stable snapshot of the current contents of an embedded object, call <c>IOleObject::GetClipboardData</c>. Should
            the data change, you will need to call the function again for an updated snapshot. If you want the caller to be informed of
            changes that occur to the data, call QueryInterface, then call IDataObject::DAdvise.
            </para>
            <para>Notes to Implementers</para>
            <para>If you implement this function, you must return an IDataObject pointer for an object whose data will not change.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.DoVerb(System.Int32,Vanara.PInvoke.MSG@,Vanara.PInvoke.Ole32.IOleClientSite,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            Requests that an object perform an action in response to an end-user's action. The possible actions are enumerated for the
            object in IOleObject::EnumVerbs.
            </summary>
            <param name="iVerb">Number assigned to the verb in the OLEVERB structure returned by IOleObject::EnumVerbs.</param>
            <param name="lpmsg">
            Pointer to the MSG structure describing the event (such as a double-click) that invoked the verb. The caller should pass the
            <c>MSG</c> structure unmodified, without attempting to interpret or alter the values of any of the structure members.
            </param>
            <param name="pActiveSite">
            Pointer to the IOleClientSite interface on the object's active client site, where the event occurred that invoked the verb.
            </param>
            <param name="lindex">This parameter is reserved and must be zero.</param>
            <param name="hwndParent">
            Handle of the document window containing the object. This and lprcPosRect together make it possible to open a temporary
            window for an object, where hwndParent is the parent window in which the object's window is to be displayed, and lprcPosRect
            defines the area available for displaying the object window within that parent. A temporary window is useful, for example, to
            a multimedia object that opens itself for playback but not for editing.
            </param>
            <param name="lprcPosRect">
            Pointer to the RECT structure containing the coordinates, in pixels, that define an object's bounding rectangle in
            hwndParent. This and hwndParent together enable opening multimedia objects for playback but not for editing.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_NOT_INPLACEACTIVE</term>
            <term>iVerb set to OLEIVERB_UIACTIVATE or OLEIVERB_INPLACEACTIVATE and object is not already visible.</term>
            </item>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>The object handler or link object cannot connect to the link source.</term>
            </item>
            <item>
            <term>DV_E_LINDEX</term>
            <term>Invalid lindex.</term>
            </item>
            <item>
            <term>OLEOBJ_S_CANNOT_DOVERB_NOW</term>
            <term>The verb is valid, but in the object's current state it cannot carry out the corresponding action.</term>
            </item>
            <item>
            <term>OLEOBJ_S_INVALIDHWND</term>
            <term>DoVerb was successful but hwndParent is invalid.</term>
            </item>
            <item>
            <term>OLEOBJ_E_NOVERBS</term>
            <term>The object does not support any verbs.</term>
            </item>
            <item>
            <term>OLEOBJ_S_INVALIDVERB</term>
            <term>Link source is across a network that is not connected to a drive on this computer.</term>
            </item>
            <item>
            <term>MK_E_CONNECT</term>
            <term>Link source is across a network that is not connected to a drive on this computer.</term>
            </item>
            <item>
            <term>OLE_E_CLASSDIFF</term>
            <term>Class for source of link has undergone a conversion.</term>
            </item>
            <item>
            <term>E_NOTIMPL</term>
            <term>Object does not support in-place activation or does not recognize a negative verb number.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A "verb" is an action that an OLE object takes in response to a message from its container. An object's container, or a
            client linked to the object, normally calls <c>IOleObject::DoVerb</c> in response to some end-user action, such as
            double-clicking on the object. The various actions that are available for a given object are enumerated in an OLEVERB
            structure, which the container obtains by calling IOleObject::EnumVerbs. <c>IOleObject::DoVerb</c> matches the value of iVerb
            against the iVerb member of the structure to determine which verb to invoke.
            </para>
            <para>
            Through IOleObject::EnumVerbs, an object, rather than its container, determines which verbs (i.e., actions) it supports. OLE
            2 defines seven verbs that are available, but not necessarily useful, to all objects. In addition, each object can define
            additional verbs that are unique to it. The following table describes the verbs defined by OLE.
            </para>
            <list type="table">
            <listheader>
            <term>Verb</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLEIVERB_PRIMARY (0L)</term>
            <term>
            Specifies the action that occurs when an end user double-clicks the object in its container. The object, not the container,
            determines this action. If the object supports in-place activation, the primary verb usually activates the object in place.
            </term>
            </item>
            <item>
            <term>OLEIVERB_SHOW (-1)</term>
            <term>
            Instructs an object to show itself for editing or viewing. Called to display newly inserted objects for initial editing and
            to show link sources. Usually an alias for some other object-defined verb.
            </term>
            </item>
            <item>
            <term>OLEIVERB_OPEN (-2)</term>
            <term>
            Instructs an object, including one that otherwise supports in-place activation, to open itself for editing in a window
            separate from that of its container. If the object does not support in-place activation, this verb has the same semantics as OLEIVERB_SHOW.
            </term>
            </item>
            <item>
            <term>OLEIVERB_HIDE (-3)</term>
            <term>Causes an object to remove its user interface from the view. Applies only to objects that are activated in-place.</term>
            </item>
            <item>
            <term>OLEIVERB_UIACTIVATE (-4)</term>
            <term>
            Activates an object in place, along with its full set of user-interface tools, including menus, toolbars, and its name in the
            title bar of the container window. If the object does not support in-place activation, it should return E_NOTIMPL.
            </term>
            </item>
            <item>
            <term>OLEIVERB_INPLACEACTIVATE (-5)</term>
            <term>
            Activates an object in place without displaying tools, such as menus and toolbars, that end users need to change the behavior
            or appearance of the object. Single-clicking such an object causes it to negotiate the display of its user-interface tools
            with its container. If the container refuses, the object remains active but without its tools displayed.
            </term>
            </item>
            <item>
            <term>OLEIVERB_DISCARDUNDOSTATE (-6)</term>
            <term>Used to tell objects to discard any undo state that they may be maintaining without deactivating the object.</term>
            </item>
            </list>
            <para>Notes to Callers</para>
            <para>
            Containers call <c>IOleObject::DoVerb</c> as part of initializing a newly created object. Before making the call, containers
            should first call IOleObject::SetClientSite to inform the object of its display location and IOleObject::SetHostNames to
            alert the object that it is an embedded object and to trigger appropriate changes to the user interface of the object
            application in preparation for opening an editing window.
            </para>
            <para>
            <c>IOleObject::DoVerb</c> automatically runs the OLE server application. If an error occurs during verb execution, the object
            application is shut down.
            </para>
            <para>
            If an end user invokes a verb by some means other than selecting a command from a menu (say, by double-clicking or, more
            rarely, single-clicking an object), the object's container should pass a pointer to a Windows MSG structure containing the
            appropriate message. For example, if the end user invokes a verb by double-clicking the object, the container should pass a
            <c>MSG</c> structure containing WM_LBUTTONDBLCLK, WM_MBUTTONDBLCLK, or WM_RBUTTONDBLCLK. If the container passes no message,
            lpmsg should be set to <c>NULL</c>. The object should ignore the <c>hwnd</c> member of the passed <c>MSG</c> structure, but
            can use all the other MSG members.
            </para>
            <para>
            If the object's embedding container calls <c>IOleObject::DoVerb</c>, the client-site pointer (pClientSite) passed to
            <c>IOleObject::DoVerb</c> is the same as that of the embedding site. If the embedded object is a link source, the pointer
            passed to <c>IOleObject::DoVerb</c> is that of the linking client's client site.
            </para>
            <para>
            When <c>IOleObject::DoVerb</c> is invoked on an OLE link, it may return OLE_E_CLASSDIFF or MK_CONNECTMANUALLY. The link
            object returns the former error when the link source has been subjected to some sort of conversion while the link was
            passive. The link object returns the latter error when the link source is located on a network drive that is not currently
            connected to the caller's computer. The only way to connect a link under these conditions is to first call
            IUnknown::QueryInterface, ask for IOleLink, allocate a bind context, and run the link source by calling IOleLink::BindToSource.
            </para>
            <para>
            Container applications that do not support general in-place activation can still use the hwndParent and lprcPosRect
            parameters to support in-place playback of multimedia files. Containers must pass valid hwndParent and lprcPosRect parameters
            to <c>IOleObject::DoVerb</c>.
            </para>
            <para>
            Some code samples pass a lindex value of -1 instead of zero. The value -1 works but should be avoided in favor of zero. The
            lindex parameter is a reserved parameter, and for reasons of consistency Microsoft recommends assigning a zero value to all
            reserved parameters.
            </para>
            <para>Notes to Implementers</para>
            <para>
            In addition to the above verbs, an object can define in its OLEVERB structure additional verbs that are specific to itself.
            Positive numbers designate these object-specific verbs. An object should treat any unknown positive verb number as if it were
            the primary verb and return OLEOBJ_S_INVALIDVERB to the calling function. The object should ignore verbs with negative
            numbers that it does not recognize and return E_NOTIMPL.
            </para>
            <para>
            If the verb being executed places the object in the running state, you should register the object in the running object table
            (ROT) even if its server application doesn't support linking. Registration is important because the object at some point may
            serve as the source of a link in a container that supports links to embeddings. Registering the object with the ROT enables
            the link client to get a pointer to the object directly, instead of having to go through the object's container. To perform
            the registration, call IOleClientSite::GetMoniker to get the full moniker of the object, call the GetRunningObjectTable
            function to get a pointer to the ROT, and then call IRunningObjectTable::Register.
            </para>
            <para>
            <c>Note</c> When the object leaves the running state, remember to revoke the object's registration with the ROT by calling
            IOleObject::Close. If the object's container document is renamed while the object is running, you should revoke the object's
            registration and re-register it with the ROT, using its new name. The container should inform the object of its new moniker
            either by calling IOleObject::SetMoniker or by responding to the object's calling IOleClientSite::GetMoniker.
            </para>
            <para>
            When showing a window as a result of <c>IOleObject::DoVerb</c>, it is very important for the object to explicitly call
            SetForegroundWindow on its editing window. This ensures that the object's window will be visible to the user even if another
            process originally obscured it. For more information see <c>SetForegroundWindow</c> and SetActiveWindow.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.EnumVerbs(Vanara.PInvoke.Ole32.IEnumOLEVERB@)">
            <summary>Exposes a pull-down menu listing the verbs available for an object in ascending order by verb number.</summary>
            <param name="ppEnumOleVerb">
            Address of IEnumOLEVERB pointer variable that receives the interface pointer to the new enumerator object. Each time an
            object receives a call to IOleObject::EnumVerbs, it must increase the reference count on ppEnumOleVerb. It is the caller's
            responsibility to call IUnknown::Release when it is done with ppEnumOleVerb. If an error occurs, ppEnumOleVerb must be set to NULL.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_S_USEREG</term>
            <term>Delegate to the default handler to use the entries in the registry to provide the enumeration.</term>
            </item>
            <item>
            <term>OLEOBJ_E_NOVERBS</term>
            <term>The object does not support any verbs.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.Update">
            <summary>Updates an object handler's or link object's data or view caches.</summary>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            <item>
            <term>OLE_E_CANT_BINDTOSOURCE</term>
            <term>Cannot run object to get updated data. The object is for some reason unavailable to the caller.</term>
            </item>
            <item>
            <term>CACHE_E_NOCACHE_UPDATED</term>
            <term>No caches were updated.</term>
            </item>
            <item>
            <term>CACHE_S_SOMECACHES_NOTUPDATED</term>
            <term>Some caches were not updated.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>Update</c> method provides a way for containers to keep data updated in their linked and embedded objects. A link
            object can become out-of-date if the link source has been updated. An embedded object that contains links to other objects
            can also become out of date. An embedded object that does not contain links cannot become out of date because its data is not
            linked to another source.
            </para>
            <para>Notes to Implementers</para>
            <para>
            When a container calls a link object's <c>IOleObject::Update</c> method, the link object finds the link source and gets a new
            presentation from it. This process may also involve running one or more object applications, which could be time-consuming.
            </para>
            <para>
            When a container calls an embedded object's <c>IOleObject::Update</c> method, it is requesting the object to update all link
            objects it may contain. In response, the object handler recursively calls <c>IOleObject::Update</c> for each of its own
            linked objects, running each one as needed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.IsUpToDate">
            <summary>Checks whether an object is up to date.</summary>
            <returns>
            <para>
            This method returns S_OK if the object is up to date; otherwise, S_FALSE. Other possible return values include the following.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_E_UNAVAILABLE</term>
            <term>The status of object cannot be determined in a timely manner.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>IOleObject::IsUpToDate</c> method provides a way for containers to check recursively whether all objects are up to
            date. That is, when the container calls this method on the first object, the object in turn calls it for all its own objects,
            and they in turn for all of theirs, until all objects have been checked.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Because of the recursive nature of <c>IOleObject::IsUpToDate</c>, determining whether an object is out-of-date, particularly
            one containing one or more other objects, can be as time-consuming as simply updating the object in the first place. If you
            would rather avoid lengthy queries of this type, make sure that <c>IOleObject::IsUpToDate</c> returns OLE_E_UNAVAILABLE. In
            cases where the object to be queried is small and contains no objects itself, thereby making an efficient query possible,
            this method can return either S_OK or S_FALSE.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetUserClassID(System.Guid@)">
            <summary>
            Retrieves an object's class identifier, the CLSID corresponding to the string identifying the object to an end user.
            </summary>
            <param name="pClsid">
            Pointer to the class identifier (CLSID) to be returned. An object's CLSID is the binary equivalent of the user-type name
            returned by IOleObject::GetUserType.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>IOleObject::GetUserClassID</c> returns the CLSID associated with the object in the registration database. Normally, this
            value is identical to the CLSID stored with the object, which is returned by IPersist::GetClassID. For linked objects, this
            is the CLSID of the last bound link source. If the object is running in an application different from the one in which it was
            created and for the purpose of being edited is emulating a class that the container application recognizes, the CLSID
            returned will be that of the class being emulated rather than that of the object's own class.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetUserType(Vanara.PInvoke.Ole32.USERCLASSTYPE,System.String@)">
            <summary>
            Retrieves the user-type name of an object for display in user-interface elements such as menus, list boxes, and dialog boxes.
            </summary>
            <param name="dwFormOfType">
            The form of the user-type name to be presented to users. Possible values are obtained from the USERCLASSTYPE enumeration.
            </param>
            <param name="pszUserType">
            Address of LPOLESTR pointer variable that receives a pointer to the user type string. The caller must free pszUserType using
            the current IMalloc instance. If an error occurs, the implementation must set pszUserType to <c>NULL</c>.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_S_USEREG</term>
            <term>Delegate to the default handler's implementation using the registry to provide the requested information.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Containers call <c>IOleObject::GetUserType</c> in order to represent embedded objects in list boxes, menus, and dialog boxes
            by their normal, user-recognizable names. Examples include "Word Document," "Excel Chart," and "Paintbrush Object." The
            information returned by <c>IOleObject::GetUserType</c> is the user-readable equivalent of the binary class identifier
            returned by IOleObject::GetUserClassID.
            </para>
            <para>Notes to Callers</para>
            <para>
            The default handler's implementation of <c>IOleObject::GetUserType</c> uses the object's class identifier (the pClsid
            parameter returned by IOleObject::GetUserClassID) and the dwFormOfType parameter together as a key into the registry. If an
            entry is found that matches the key exactly, then the user type specified by that entry is returned. If only the CLSID part
            of the key matches, then the lowest-numbered entry available (usually the full name) is used. If the CLSID is not found, or
            there are no user types registered for the class, the user type currently found in the object's storage is used.
            </para>
            <para>
            You should not cache the string returned from <c>IOleObject::GetUserType</c>. Instead, call this method each and every time
            the string is needed. This guarantees correct results when the embedded object is being converted from one type into another
            without the caller's knowledge. Calling this method is inexpensive because the default handler implements it using the registry.
            </para>
            <para>Notes to Implementers</para>
            <para>
            You can use the implementation provided by the default handler by returning OLE_S_USEREG as your application's implementation
            of this method. If the user type name is an empty string, the message "Unknown Object" is returned.
            </para>
            <para>You can call the OLE helper function OleRegGetUserType to return the appropriate user type.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.SetExtent(System.Runtime.InteropServices.ComTypes.DVASPECT,Vanara.PInvoke.SIZE@)">
            <summary>Informs an object of how much display space its container has assigned it.</summary>
            <param name="dwDrawAspect">
            DWORD that describes which form, or "aspect," of an object is to be displayed. The object's container obtains this value from
            the enumeration DVASPECT (refer to the FORMATETC enumeration). The most common aspect is DVASPECT_CONTENT, which specifies a
            full rendering of the object within its container. An object can also be rendered as an icon, a thumbnail version for display
            in a browsing tool, or a print version, which displays the object as it would be rendered using the <c>File Print</c> command.
            </param>
            <param name="psizel">Pointer to the size limit for the object.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            <item>
            <term>OLE_E_NOTRUNNING</term>
            <term>The object is not running.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A container calls <c>IOleObject::SetExtent</c> when it needs to dictate to an embedded object the size at which it will be
            displayed. Often, this call occurs in response to an end user resizing the object window. Upon receiving the call, the
            object, if possible, should recompose itself gracefully to fit the new window.
            </para>
            <para>
            Whenever possible, a container seeks to display an object at its finest resolution, sometimes called the object's native
            size. All objects, however, have a default display size specified by their applications, and in the absence of other
            constraints, this is the size they will use to display themselves. Since an object knows its optimum display size better than
            does its container, the latter normally requests that size from a running object by calling <c>IOleObject::SetExtent</c>.
            Only in cases where the container cannot accommodate the value returned by the object does it override the object's
            preference by calling <c>IOleObject::SetExtent</c>.
            </para>
            <para>Notes to Callers</para>
            <para>
            You can call <c>IOleObject::SetExtent</c> on an object only when the object is running. If a container resizes an object
            while an object is not running, the container should keep track of the object's new size but defer calling
            <c>IOleObject::SetExtent</c> until a user activates the object. If the OLEMISC_RECOMPOSEONRESIZE bit is set on an object, its
            container should force the object to run before calling <c>IOleObject::SetExtent</c>.
            </para>
            <para>
            As noted above, a container may want to delegate responsibility for setting the size of an object's display site to the
            object itself, by calling <c>IOleObject::SetExtent</c>.
            </para>
            <para>Notes to Implementers</para>
            <para>
            You may want to implement this method so that your object rescales itself to match as closely as possible the maximum space
            available to it in its container.
            </para>
            <para>
            If an object's size is fixed, that is, if it cannot be set by its container, <c>IOleObject::SetExtent</c> should return
            E_FAIL. This is always the case with linked objects, whose sizes are set by their link sources, not by their containers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetExtent(System.Runtime.InteropServices.ComTypes.DVASPECT,Vanara.PInvoke.SIZE@)">
            <summary>Retrieves a running object's current display size.</summary>
            <param name="dwDrawAspect">
            The aspect of the object whose limit is to be retrieved; the value is obtained from the enumerations DVASPECT and from
            DVASPECT2. Note that newer objects and containers that support optimized drawing interfaces support the <c>DVASPECT2</c>
            enumeration values. Older objects and containers that do not support optimized drawing interfaces may not support
            <c>DVASPECT2</c>. The most common value for this method is DVASPECT_CONTENT, which specifies a full rendering of the object
            within its container.
            </param>
            <param name="psizel">Pointer to where the object's size is to be returned.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_INVALIDARG</term>
            <term>The supplied dwDrawAspect value is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A container calls <c>IOleObject::GetExtent</c> on a running object to retrieve its current display size. If the container can
            accommodate that size, it will normally do so because the object, after all, knows what size it should be better than the
            container does. A container normally makes this call as part of initializing an object.
            </para>
            <para>
            The display size returned by <c>IOleObject::GetExtent</c> may differ from the size last set by IOleObject::SetExtent because
            the latter method dictates the object's display space at the time the method is called but does not necessarily change the
            object's native size, as determined by its application.
            </para>
            <para>
            If one of the new aspects is requested in dwAspect, this method can either fail or return the same rectangle as for the
            DVASPECT_CONTENT aspect.
            </para>
            <para>
            <c>Note</c> This method must return the same size as DVASPECT_CONTENT for all the new aspects in DVASPECT2.
            IViewObject2::GetExtent must do the same thing.
            </para>
            <para>Notes to Callers</para>
            <para>
            Because a container can make this call only to a running object, the container must instead call IViewObject2::GetExtent if
            it wants to get the display size of a loaded object from its cache.
            </para>
            <para>Notes to Implementers</para>
            <para>Implementation consists of filling the sizel structure with an object's height and width.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.Advise(System.Runtime.InteropServices.ComTypes.IAdviseSink,System.UInt32@)">
            <summary>
            Establishes an advisory connection between a compound document object and the calling object's advise sink, through which the
            calling object receives notification when the compound document object is renamed, saved, or closed.
            </summary>
            <param name="pAdvSink">Pointer to the IAdviseSink interface on the advise sink of the calling object.</param>
            <param name="pdwConnection">Pointer to a token that can be passed to IOleObject::Unadvise to delete the advisory connection.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory available for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>IOleObject::Advise</c> method sets up an advisory connection between an object and its container, through which the
            object informs the container's advise sink of close, save, rename, and link-source change events in the object. A container
            calls this method, normally as part of initializing an object, to register its advisory sink with the object. In return, the
            object sends the container compound-document notifications by calling IAdviseSink or IAdviseSink2.
            </para>
            <para>
            If container and object successfully establish an advisory connection, the object receiving the call returns a nonzero value
            through pdwConnection to the container. If the attempt to establish an advisory connection fails, the object returns zero. To
            delete an advisory connection, the container calls IOleObject::Unadvise and passes this nonzero token back to the object.
            </para>
            <para>
            An object can delegate the job of managing and tracking advisory events to an OLE advise holder, to which you obtain a
            pointer by calling CreateOleAdviseHolder. The returned IOleAdviseHolder interface has three methods for sending advisory
            notifications, as well as IOleAdviseHolder::Advise, IOleAdviseHolder::Unadvise, and IOleAdviseHolder::EnumAdvise methods that
            are identical to those for IOleObject. Calls to <c>IOleObject::Advise</c>, IOleObject::Unadvise, or IOleObject::EnumAdvise
            are delegated to corresponding methods in the advise holder.
            </para>
            <para>To destroy the advise holder, simply call IUnknown::Release on the IOleAdviseHolder interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.Unadvise(System.UInt32)">
            <summary>Deletes a previously established advisory connection.</summary>
            <param name="dwConnection">
            Contains a token of nonzero value, which was previously returned from IOleObject::Advise through its pdwConnection parameter.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_FAIL</term>
            <term>The operation failed.</term>
            </item>
            <item>
            <term>OLE_E_NOCONNECTION</term>
            <term>dwConnection does not represent a valid advisory connection.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Normally, containers call <c>IOleObject::Unadvise</c> at shutdown or when an object is deleted. In certain cases, containers
            can call this method on objects that are running but not currently visible as a way of reducing the overhead of maintaining
            multiple advisory connections. The easiest way to implement this method is to delegate the call to <c>IOleObject::Unadvise</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.EnumAdvise(System.Runtime.InteropServices.ComTypes.IEnumSTATDATA@)">
            <summary>
            Retrieves a pointer to an enumerator that can be used to enumerate the advisory connections registered for an object, so a
            container can know what to release prior to closing down.
            </summary>
            <param name="ppenumAdvise">
            Address of IEnumSTATDATA pointer variable that receives the interface pointer to the enumerator object. If the object does
            not have any advisory connections or if an error occurs, the implementation must set ppenumAdvise to NULL. Each time an
            object receives a successful call to IOleObject::EnumAdvise, it must increase the reference count on ppenumAdvise. It is the
            caller's responsibility to call Release when it is done with the ppenumAdvise.
            </param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOTIMPL</term>
            <term>EnumAdvise is not supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>IOleObject::EnumAdvise</c> method supplies an enumerator that provides a way for containers to keep track of advisory
            connections registered for their objects. A container normally would call this function so that it can instruct an object to
            release each of its advisory connections prior to closing down.
            </para>
            <para>
            The enumerator to which you get access through <c>IOleObject::EnumAdvise</c> enumerates items of type STATDATA. Upon
            receiving the pointer, the container can then loop through <c>STATDATA</c> and call IOleObject::Unadvise for each enumerated connection.
            </para>
            <para>
            The usual way to implement this function is to delegate the call to the IOleAdviseHolder interface. Only the <c>pAdvise</c>
            and <c>dwConnection</c> members of STATDATA are relevant for <c>IOleObject::EnumAdvise</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.GetMiscStatus(System.Runtime.InteropServices.ComTypes.DVASPECT,System.UInt32@)">
            <summary>Retrieves the status of an object at creation and loading.</summary>
            <param name="dwAspect">
            The aspect of an object about which status information is being requested. The value is obtained from the enumeration DVASPECT.
            </param>
            <param name="pdwStatus">Pointer to where the status information is returned. This parameter cannot be <c>NULL</c>.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>OLE_S_USEREG</term>
            <term>Delegate the retrieval of miscellaneous status information to the default handler's implementation of this method.</term>
            </item>
            <item>
            <term>CO_E_CLASSNOTREG</term>
            <term>There is no CLSID registered for the object.</term>
            </item>
            <item>
            <term>CO_E_READREGDB</term>
            <term>Error accessing the registry.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A container normally calls <c>IOleObject::GetMiscStatus</c> when it creates or loads an object in order to determine how to
            display the object and what types of behaviors it supports.
            </para>
            <para>
            Objects store status information in the registry. If the object is not running, the default handler's implementation of
            <c>IOleObject::GetMiscStatus</c> retrieves this information from the registry. If the object is running, the default handler
            invokes <c>IOleObject::GetMiscStatus</c> on the object itself.
            </para>
            <para>
            The information that is actually stored in the registry varies with individual objects. The status values to be returned are
            defined in the enumeration OLEMISC.
            </para>
            <para>
            The default value of <c>IOleObject::GetMiscStatus</c> is used if a subkey corresponding to the specified DVASPECT is not
            found. To set an OLE control, specify DVASPECT==1. This will cause the following to occur in the registry:
            </para>
            <para><c>HKEY_CLASSES_ROOT\CLSID\ . . .</c><c>MiscStatus</c> = 1</para>
            <para>Notes to Implementers</para>
            <para>Implementation normally consists of delegating the call to the default handler.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleObject.SetColorScheme(System.IntPtr)">
            <summary>Specifies the color palette that the object application should use when it edits the specified object.</summary>
            <param name="pLogpal">Pointer to a LOGPALETTE structure that specifies the recommended palette.</param>
            <returns>
            <para>This method returns S_OK on success. Other possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOTIMPL</term>
            <term>Object does not support setting palettes.</term>
            </item>
            <item>
            <term>OLE_E_PALETTE</term>
            <term>Invalid LOGPALETTE structure pointed to by pLogPal.</term>
            </item>
            <item>
            <term>OLE_E_NOTRUNNING</term>
            <term>Object must be running to perform this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>IOleObject::SetColorScheme</c> method sends the container application's recommended color palette to the object
            application, which is not obliged to use it.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IOleWindow">
            <summary>
            The IOleWindow interface provides methods that allow an application to obtain the handle to the various windows that participate
            in in-place activation, and also to enter and exit context-sensitive help mode.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleWindow.GetWindow">
            <summary>
            Retrieves a handle to one of the windows participating in in-place activation (frame, document, parent, or in-place object window).
            </summary>
            <returns>A pointer to a variable that receives the window handle.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IOleWindow.ContextSensitiveHelp(System.Boolean)">
            <summary>Determines whether context-sensitive help mode should be entered during an in-place activation session.</summary>
            <param name="fEnterMode"><c>true</c> if help mode should be entered; <c>false</c> if it should be exited.</param>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IParseDisplayName">
            <summary>
            <para>Parses a displayable name string to convert it into a moniker for custom moniker implementations.</para>
            <para>Display name parsing is necessary when the end user inputs a string to identify a component, as in the following situations:</para>
            <list type="bullet">
            <item>
            <term>
            A compound document application that supports linked components typically supports the <c>Edit:Links...</c> dialog box. Through
            this dialog box, the end user can enter a display name to specify a new link source for a specified linked component. The
            compound document needs to have this input string converted into a moniker.
            </term>
            </item>
            <item>
            <term>
            A script language such as the macro language of a spreadsheet can allow textual references to a component. The language's
            interpreter needs to have such a reference converted into a moniker in order to execute the macro.
            </term>
            </item>
            </list>
            <para>This interface is not supported for use across machine boundaries.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IParseDisplayName.ParseDisplayName(System.Runtime.InteropServices.ComTypes.IBindCtx,System.String,System.UInt32@,System.Runtime.InteropServices.ComTypes.IMoniker@)">
            <summary>Parses the specified display name and creates a corresponding moniker.</summary>
            <param name="pbc">A pointer to the bind context to be used in this binding operation. See IBindCtx.</param>
            <param name="pszDisplayName">The display name to be parsed.</param>
            <param name="pchEaten">
            A pointer to a variable that receives the number of characters in the display name that correspond to the ppmkOut moniker.
            </param>
            <param name="ppmkOut">
            A pointer to an IMoniker pointer variable that receives the interface pointer to the resulting moniker. If an error occurs,
            the implementation sets *ppmkOut to <c>NULL</c>. If *ppmkOut is non- <c>NULL</c>, the implementation must call AddRef; it is
            the caller's responsibility to call Release.
            </param>
            <returns>
            <para>This method can return the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>MK_E_SYNTAX</term>
            <term>
            There is a syntax error in the display name. Parsing failed because pszDisplayName could only be partially resolved into a
            moniker. In this case, *pchEaten has the number of characters that were successfully parsed into a moniker prefix. The
            parameter ppmkOut should be NULL.
            </term>
            </item>
            <item>
            <term>MK_E_NOOBJECT</term>
            <term>The display name does not identify a component in this namespace.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            In general, the maximum prefix of pszDisplayName that is syntactically valid and that represents an object should be consumed
            by this method and converted to a moniker.
            </para>
            <para>
            Typically, this method is called by MkParseDisplayName or MkParseDisplayNameEx. In the initial step of the parsing operation,
            these functions can retrieve the IParseDisplayName interface directly from an instance of a class identified with either the
            "@ProgID" or "ProgID" notation. Subsequent parsing steps can query for the interface on an intermediate object.
            </para>
            <para>
            The main loops of MkParseDisplayName and MkParseDisplayNameEx find the next moniker piece by calling the equivalent method in
            the IMoniker interface, that is, IMoniker::ParseDisplayName, on the moniker that it currently holds. In this call to
            <c>IMoniker::ParseDisplayName</c>, the <c>MkParseDisplayName</c> or <c>MkParseDisplayNameEx</c> function passes <c>NULL</c>
            in the pmkToLeft parameter. If the moniker currently held is a generic composite, the call to
            <c>IMoniker::ParseDisplayName</c> is forwarded by that composite onto its last piece, passing the prefix of the composite to
            the left of the piece in pmkToLeft.
            </para>
            <para>
            Some moniker classes will be able to handle this parsing internally to themselves because they are designed to designate only
            certain kinds of objects. Others will need to bind to the object that they designate to accomplish the parsing process. As is
            usual, these objects should not be released by IMoniker::ParseDisplayName but instead should be transferred to the bind
            context via IBindCtx::RegisterObjectBound or IBindCtx::GetRunningObjectTable followed by IRunningObjectTable::Register for
            release at a later time.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPersist">
            <summary>
            <para>
            Provides the CLSID of an object that can be stored persistently in the system. Allows the object to specify which object handler
            to use in the client process, as it is used in the default implementation of marshaling.
            </para>
            <para>
            <c>IPersist</c> is the base interface for three other interfaces: IPersistStorage, IPersistStream, and IPersistFile. Each of
            these interfaces, therefore, includes the GetClassID method, and the appropriate one of these three interfaces is implemented on
            objects that can be serialized to a storage, a stream, or a file. The methods of these interfaces allow the state of these
            objects to be saved for later instantiations, and load the object using the saved state. Typically, the persistence interfaces
            are implemented by an embedded or linked object, and are called by the container application or the default object handler.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersist.GetClassID">
            <summary>Retrieves the class identifier (CLSID) of the object.</summary>
            <returns>
            <para>
            A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely
            represents an object class that defines the code that can manipulate the object's data.
            </para>
            <para>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetClassID</c> method retrieves the class identifier (CLSID) for an object, used in later operations to load
            object-specific code into the caller's context.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container application might call this method to retrieve the original CLSID of an object that it is treating as a different
            class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the
            container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object.
            Typically, in this case, the container calls the OleSave helper function, which performs all the necessary steps. For this
            reason, most container applications have no need to call this method directly.
            </para>
            <para>
            The exception would be a container that provides an object handler for certain objects. In particular, a container
            application should not get an object's CLSID and then use it to retrieve class specific information from the registry.
            Instead, the container should use IOleObject and IDataObject interfaces to retrieve such class-specific information directly
            from the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's
            <c>TreatAs</c> registry key has been set by an application that supports emulation (and so is treating the object as one of a
            different class), a call to <c>GetClassID</c> must supply the CLSID specified in the <c>TreatAs</c> key. For more information
            on emulation, see CoTreatAsClass.
            </para>
            <para>
            When an object is in the running state, the default handler calls an implementation of <c>GetClassID</c> that delegates the
            call to the implementation in the object. When the object is not running, the default handler instead calls the ReadClassStg
            function to read the CLSID that is saved in the object's storage.
            </para>
            <para>
            If you are writing a custom object handler for your object, you might want to simply delegate this method to the default
            handler implementation (see OleCreateDefaultHandler).
            </para>
            <para>URL Moniker Notes</para>
            <para>This method returns CLSID_StdURLMoniker.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPersistStream">
            <summary>Enables the saving and loading of objects that use a simple serial stream for their storage needs.</summary>
            <remarks>
            <para>
            One way in which this interface is used is to support OLE moniker implementations. Each of the OLE-provided moniker interfaces
            provides an <c>IPersistStream</c> implementation through which the moniker saves or loads itself. An instance of the OLE generic
            composite moniker class calls the <c>IPersistStream</c> methods of its component monikers to load or save the components in the
            proper sequence in a single stream.
            </para>
            <para>IPersistStream URL Moniker Implementation</para>
            <para>
            The URL moniker implementation of <c>IPersistStream</c> is found on an URL moniker object, which supports IUnknown,
            <c>IAsyncMoniker</c>, and IMoniker. The <c>IMoniker</c> interface inherits its definition from <c>IPersistStream</c> and thus,
            the URL moniker also provides an implementation of <c>IPersistStream</c> as part of its implementation of <c>IMoniker</c>.
            </para>
            <para>
            The IAsyncMoniker interface on an URL moniker is simply IUnknown (there are no additional methods); it is used to allow clients
            to determine if a moniker supports asynchronous binding. To get a pointer to the IMoniker interface on this object, call the
            <c>CreateURLMonikerEx</c> function. Then, to get a pointer to <c>IPersistStream</c>, call the QueryInterface method.
            </para>
            <para>
            <c>IPersistStream</c>, in addition to inheriting its definition from IUnknown, also inherits the single method of IPersist, GetClassID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStream.GetClassID">
            <summary>Retrieves the class identifier (CLSID) of the object.</summary>
            <returns>
            <para>
            A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely
            represents an object class that defines the code that can manipulate the object's data.
            </para>
            <para>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetClassID</c> method retrieves the class identifier (CLSID) for an object, used in later operations to load
            object-specific code into the caller's context.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container application might call this method to retrieve the original CLSID of an object that it is treating as a different
            class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the
            container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object.
            Typically, in this case, the container calls the OleSave helper function, which performs all the necessary steps. For this
            reason, most container applications have no need to call this method directly.
            </para>
            <para>
            The exception would be a container that provides an object handler for certain objects. In particular, a container
            application should not get an object's CLSID and then use it to retrieve class specific information from the registry.
            Instead, the container should use IOleObject and IDataObject interfaces to retrieve such class-specific information directly
            from the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's
            <c>TreatAs</c> registry key has been set by an application that supports emulation (and so is treating the object as one of a
            different class), a call to <c>GetClassID</c> must supply the CLSID specified in the <c>TreatAs</c> key. For more information
            on emulation, see CoTreatAsClass.
            </para>
            <para>
            When an object is in the running state, the default handler calls an implementation of <c>GetClassID</c> that delegates the
            call to the implementation in the object. When the object is not running, the default handler instead calls the ReadClassStg
            function to read the CLSID that is saved in the object's storage.
            </para>
            <para>
            If you are writing a custom object handler for your object, you might want to simply delegate this method to the default
            handler implementation (see OleCreateDefaultHandler).
            </para>
            <para>URL Moniker Notes</para>
            <para>This method returns CLSID_StdURLMoniker.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStream.IsDirty">
            <summary>Determines whether an object has changed since it was last saved to its stream.</summary>
            <returns>This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.</returns>
            <remarks>
            <para>
            Use this method to determine whether an object should be saved before closing it. The dirty flag for an object is
            conditionally cleared in the IPersistStream::Save method.
            </para>
            <para>Notes to Callers</para>
            <para>
            You should treat any error return codes as an indication that the object has changed. Unless this method explicitly returns
            S_FALSE, assume that the object must be saved.
            </para>
            <para>
            Note that the OLE-provided implementations of the <c>IPersistStream::IsDirty</c> method in the OLE-provided moniker
            interfaces always return S_FALSE because their internal state never changes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStream.Load(System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>Initializes an object from the stream where it was saved previously.</summary>
            <param name="pstm">The PSTM.</param>
            <remarks>
            <para>
            This method loads an object from its associated stream. The seek pointer is set as it was in the most recent
            IPersistStream::Save method. This method can seek and read from the stream, but cannot write to it.
            </para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStream::Load</c> directly, you typically call the OleLoadFromStream function does the following:
            </para>
            <list type="number">
            <item>
            <term>Calls the ReadClassStm function to get the class identifier from the stream.</term>
            </item>
            <item>
            <term>Calls the CoCreateInstance function to create an instance of the object.</term>
            </item>
            <item>
            <term>Queries the instance for IPersistStream.</term>
            </item>
            <item>
            <term>Calls <c>IPersistStream::Load</c>.</term>
            </item>
            </list>
            <para>
            The OleLoadFromStream function assumes that objects are stored in the stream with a class identifier followed by the object
            data. This storage pattern is used by the generic, composite-moniker implementation provided by OLE.
            </para>
            <para>If the objects are not stored using this pattern, you must call the methods separately yourself.</para>
            <para>URL Moniker Notes</para>
            <para>
            Initializes an URL moniker from data within a stream, usually stored there previously using its IPersistStream::Save (using
            OleSaveToStream). The binary format of the URL moniker is its URL string in Unicode (may be a full or partial URL string, see
            CreateURLMonikerEx for details). This is represented as a <c>ULONG</c> count of characters followed by that many Unicode characters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStream.Save(System.Runtime.InteropServices.ComTypes.IStream,System.Boolean)">
            <summary>Saves an object to the specified stream.</summary>
            <param name="pstm">The PSTM.</param>
            <param name="fClearDirty">
            Indicates whether to clear the dirty flag after the save is complete. If <c>TRUE</c>, the flag should be cleared. If
            <c>FALSE</c>, the flag should be left unchanged.
            </param>
            <remarks>
            <para>
            <c>IPersistStream::Save</c> saves an object into the specified stream and indicates whether the object should reset its dirty flag.
            </para>
            <para>
            The seek pointer is positioned at the location in the stream at which the object should begin writing its data. The object
            calls the ISequentialStream::Write method to write its data.
            </para>
            <para>
            On exit, the seek pointer must be positioned immediately past the object data. The position of the seek pointer is undefined
            if an error returns.
            </para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStream::Save</c> directly, you typically call the OleSaveToStream helper function which does
            the following:
            </para>
            <list type="number">
            <item>
            <term>Calls GetClassID to get the object's CLSID.</term>
            </item>
            <item>
            <term>Calls the WriteClassStm function to write the object's CLSID to the stream.</term>
            </item>
            <item>
            <term>Calls <c>IPersistStream::Save</c>.</term>
            </item>
            </list>
            <para>If you call these methods directly, you can write other data into the stream after the CLSID before calling <c>IPersistStream::Save</c>.</para>
            <para>The OLE-provided implementation of IPersistStream follows this same pattern.</para>
            <para>Notes to Implementers</para>
            <para>
            The <c>IPersistStream::Save</c> method does not write the CLSID to the stream. The caller is responsible for writing the CLSID.
            </para>
            <para>
            The <c>IPersistStream::Save</c> method can read from, write to, and seek in the stream; but it must not seek to a location in
            the stream before that of the seek pointer on entry.
            </para>
            <para>URL Moniker Notes</para>
            <para>
            Saves an URL moniker to a stream. The binary format of URL moniker is its URL string in Unicode (may be a full or partial URL
            string, see CreateURLMonikerEx for details). This is represented as a <c>ULONG</c> count of characters followed by that many
            Unicode characters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStream.GetSizeMax">
            <summary>Retrieves the size of the stream needed to save the object.</summary>
            <returns>The size in bytes of the stream needed to save this object, in bytes.</returns>
            <remarks>
            <para>
            This method returns the size needed to save an object. You can call this method to determine the size and set the necessary
            buffers before calling the IPersistStream::Save method.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The <c>GetSizeMax</c> implementation should return a conservative estimate of the necessary size because the caller might
            call the IPersistStream::Save method with a non-growable stream.
            </para>
            <para>URL Moniker Notes</para>
            <para>
            This method retrieves the maximum number of bytes in the stream that will be required by a subsequent call to
            IPersistStream::Save. This value is sizeof(ULONG)==4 plus sizeof(WCHAR)*n where n is the length of the full or partial URL
            string, including the NULL terminator.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPersistStreamInit">
            <summary>
            <para>A replacement for IPersistStream that adds an initialization method.</para>
            <para>
            This interface is not derived from IPersistStream; it is mutually exclusive with <c>IPersistStream</c>. An object chooses to
            support only one of the two interfaces, based on whether it requires the InitNew method.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.GetClassID">
            <summary>Retrieves the class identifier (CLSID) of the object.</summary>
            <returns>
            <para>
            A pointer to the location that receives the CLSID on return. The CLSID is a globally unique identifier (GUID) that uniquely
            represents an object class that defines the code that can manipulate the object's data.
            </para>
            <para>If the method succeeds, the return value is S_OK. Otherwise, it is E_FAIL.</para>
            </returns>
            <remarks>
            <para>
            The <c>GetClassID</c> method retrieves the class identifier (CLSID) for an object, used in later operations to load
            object-specific code into the caller's context.
            </para>
            <para>Notes to Callers</para>
            <para>
            A container application might call this method to retrieve the original CLSID of an object that it is treating as a different
            class. Such a call would be necessary if a user performed an editing operation that required the object to be saved. If the
            container were to save it using the treat-as CLSID, the original application would no longer be able to edit the object.
            Typically, in this case, the container calls the OleSave helper function, which performs all the necessary steps. For this
            reason, most container applications have no need to call this method directly.
            </para>
            <para>
            The exception would be a container that provides an object handler for certain objects. In particular, a container
            application should not get an object's CLSID and then use it to retrieve class specific information from the registry.
            Instead, the container should use IOleObject and IDataObject interfaces to retrieve such class-specific information directly
            from the object.
            </para>
            <para>Notes to Implementers</para>
            <para>
            Typically, implementations of this method simply supply a constant CLSID for an object. If, however, the object's
            <c>TreatAs</c> registry key has been set by an application that supports emulation (and so is treating the object as one of a
            different class), a call to <c>GetClassID</c> must supply the CLSID specified in the <c>TreatAs</c> key. For more information
            on emulation, see CoTreatAsClass.
            </para>
            <para>
            When an object is in the running state, the default handler calls an implementation of <c>GetClassID</c> that delegates the
            call to the implementation in the object. When the object is not running, the default handler instead calls the ReadClassStg
            function to read the CLSID that is saved in the object's storage.
            </para>
            <para>
            If you are writing a custom object handler for your object, you might want to simply delegate this method to the default
            handler implementation (see OleCreateDefaultHandler).
            </para>
            <para>URL Moniker Notes</para>
            <para>This method returns CLSID_StdURLMoniker.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.IsDirty">
            <summary>
            <para>Determines whether an object has changed since it was last saved to its stream.</para>
            </summary>
            <returns>
            <para>This method returns S_OK to indicate that the object has changed. Otherwise, it returns S_FALSE.</para>
            </returns>
            <remarks>
            <para>
            Use this method to determine whether an object should be saved before closing it. The dirty flag for an object is
            conditionally cleared in the IPersistStreamInit::Save method.
            </para>
            <para>Notes to Callers</para>
            <para>
            You should treat any error return codes as an indication that the object has changed. Unless this method explicitly returns
            S_FALSE, assume that the object must be saved.
            </para>
            <para>
            Note that the OLE-provided implementations of the <c>IPersistStreamInit::IsDirty</c> method in the OLE-provided moniker
            interfaces always return S_FALSE because their internal state never changes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.Load(System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>Initializes an object from the stream where it was saved previously.</summary>
            <param name="pstm">The PSTM.</param>
            <remarks>
            <para>
            This method loads an object from its associated stream. The seek pointer is set as it was in the most recent
            IPersistStreamInit::Save method. This method can seek and read from the stream, but cannot write to it.
            </para>
            <para>Notes to Callers</para>
            <para>
            Rather than calling <c>IPersistStreamInit::Load</c> directly, you typically call the OleLoadFromStream function does the following:
            </para>
            <list type="number">
            <item>
            <term>Calls the ReadClassStm function to get the class identifier from the stream.</term>
            </item>
            <item>
            <term>Calls the CoCreateInstance function to create an instance of the object.</term>
            </item>
            <item>
            <term>Queries the instance for IPersistStreamInit.</term>
            </item>
            <item>
            <term>Calls <c>IPersistStreamInit::Load</c>.</term>
            </item>
            </list>
            <para>
            The OleLoadFromStream function assumes that objects are stored in the stream with a class identifier followed by the object
            data. This storage pattern is used by the generic, composite-moniker implementation provided by OLE.
            </para>
            <para>If the objects are not stored using this pattern, you must call the methods separately yourself.</para>
            <para>URL Moniker Notes</para>
            <para>
            Initializes an URL moniker from data within a stream, usually stored there previously using its IPersistStreamInit::Save
            (using OleSaveToStream). The binary format of the URL moniker is its URL string in Unicode (may be a full or partial URL
            string, see CreateURLMonikerEx for details). This is represented as a <c>ULONG</c> count of characters followed by that many
            Unicode characters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.Save(System.Runtime.InteropServices.ComTypes.IStream,System.Boolean)">
            <summary>Saves an object to the specified stream.</summary>
            <param name="pstm">The PSTM.</param>
            <param name="fClearDirty">
            Indicates whether to clear the dirty flag after the save is complete. If <c>TRUE</c>, the flag should be cleared. If
            <c>FALSE</c>, the flag should be left unchanged.
            </param>
            <remarks>
            <para>
            <c>IPersistStreamInit::Save</c> saves an object into the specified stream and indicates whether the object should reset its
            dirty flag.
            </para>
            <para>
            The seek pointer is positioned at the location in the stream at which the object should begin writing its data. The object
            calls the ISequentialStream::Write method to write its data.
            </para>
            <para>
            On exit, the seek pointer must be positioned immediately past the object data. The position of the seek pointer is undefined
            if an error returns.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The <c>IPersistStreamInit::Save</c> method does not write the CLSID to the stream. The caller is responsible for writing the CLSID.
            </para>
            <para>
            The <c>IPersistStreamInit::Save</c> method can read from, write to, and seek in the stream; but it must not seek to a
            location in the stream before that of the seek pointer on entry.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.GetSizeMax">
            <summary>Retrieves the size of the stream needed to save the object.</summary>
            <returns>The size in bytes of the stream needed to save this object, in bytes.</returns>
            <remarks>
            <para>
            This method returns the size needed to save an object. You can call this method to determine the size and set the necessary
            buffers before calling the IPersistStreamInit::Save method.
            </para>
            <para>Notes to Implementers</para>
            <para>
            The <c>GetSizeMax</c> implementation should return a conservative estimate of the necessary size because the caller might
            call the IPersistStreamInit::Save method with a non-growable stream.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPersistStreamInit.InitNew">
            <summary>Initializes an object to a default state. This method is to be called instead of IPersistStreamInit::Load.</summary>
            <remarks>If the object has already been initialized with IPersistStreamInit::Load, then this method must return E_UNEXPECTED.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OIFI">
            <summary>
            Contains information about the accelerators supported by a container during an in-place session. The structure is used in the
            IOleInPlaceSite::GetWindowContext method and the OleTranslateAccelerator function.
            </summary>
            <remarks>
            When an object is being in-place activated, its server calls the container's IOleInPlaceSite::GetWindowContext method, which
            fills in an <c>OLEINPLACEFRAMEINFO</c> structure. During an in-place session, the message loop of an EXE server passes a pointer
            to the <c>OLEINPLACEFRAMEINFO</c> structure to OleTranslateAccelerator. OLE uses the information in this structure to determine
            whether a message maps to one of the container's accelerators.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OIFI.cb">
            <summary>
            The size of this structure, in bytes. The object server must specify sizeof( <c>OLEINPLACEFRAMEINFO</c>) in the structure it
            passes to IOleInPlaceSite::GetWindowContext. The container can then use this size to determine the structure's version.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OIFI.fMDIApp">
            <summary>Indicates whether the container is an MDI application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OIFI.hwndFrame">
            <summary>A handle to the container's top-level frame window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OIFI.haccel">
            <summary>A handle to the accelerator table that the container wants to use during an in-place editing session.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OIFI.cAccelEntries">
            <summary>The number of accelerators in <c>haccel</c>.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEMENUGROUPWIDTHS">
            <summary>
            Indicates the number of menu items in each of the six menu groups of a menu shared between a container and an object server
            during an in-place editing session. This is the mechanism for building a shared menu.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEMENUGROUPWIDTHS.width">
            <summary>
            An array whose elements contain the number of menu items in each of the six menu groups of a shared in-place editing menu.
            Each menu group can have any number of menu items. The container uses elements 0, 2, and 4 to indicate the number of menu
            items in its File, View, and Window menu groups. The object server uses elements 1, 3, and 5 to indicate the number of menu
            items in its Edit, Object, and Help menu groups.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.OLEVERB">
            <summary>
            Defines a verb that an object supports. The IOleObject::EnumVerbs method creates an enumerator that can enumerate these
            structures for an object, and supplies a pointer to the enumerator's IEnumOLEVERB.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERB.lVerb">
            <summary>Integer identifier associated with this verb.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERB.lpszVerbName">
            <summary>Pointer to a string that contains the verb's name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERB.fuFlags">
            <summary>
            In Windows, a group of flags taken from the flag constants beginning with MF_ defined in AppendMenu. Containers should use
            these flags in building an object's verb menu. All Flags defined in <c>AppendMenu</c> are supported except for MF_BITMAP,
            MF_OWNERDRAW, and MF_POPUP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.OLEVERB.grfAttribs">
            <summary>Combination of the verb attributes in the OLEVERBATTRIB enumeration.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPSETFLAG">
            <summary>
            The PROPSETFLAG constants define characteristics of a property set. The values, listed in the following table, are used in the
            grfFlags parameter of <c>IPropertySetStorage</c> methods, the <c>StgCreatePropStg</c> function, and the <c>StgOpenPropStg</c> function.
            </summary>
            <remarks>
            <para>
            These values can be set and checked using bitwise operations that determine how property sets are created and opened. Property
            sets are created using the <c>IPropertySetStorage::Create</c> method or the <c>StgCreatePropStg</c> function. They are opened
            using the <c>IPropertySetStorage::Open</c> method or the <c>StgOpenPropStg</c> function.
            </para>
            <para>
            It is recommended that property sets be created as Unicode by not setting the <c>PROPSETFLAG_ANSI</c> flag in the grfFlags
            parameter. It is also recommended that you avoid using VT_LPSTR values, and use VT_LPWSTR values instead. When the property set
            code page is Unicode, VT_LPSTR string values are converted to Unicode when stored, and converted back to multibyte string values
            when retrieved. When the code page of the property set is not Unicode, property names, VT_BSTR strings, and nonsimple property
            values are converted to multibyte strings when stored, and converted back to Unicode when retrieved, all using the current system
            ANSI code page.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSETFLAG.PROPSETFLAG_DEFAULT">
            <summary>
            If left unspecified, by default only simple property values may be written to the property set. Using simple property values
            prevents property sets from being transacted in the compound file and stand-alone implementations of IPropertySetStorage.
            Non-e property values must be used for this purpose.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSETFLAG.PROPSETFLAG_NONSIMPLE">
            <summary>
            If specified, nonsimple property values can be written to the property set and the property set is saved in a storage object.
            Non-simple property values include those with a VARTYPE of VT_STORAGE, VT_STREAM, VT_STORED_OBJECT, or VT_STREAMED_OBJECT. If
            this flag is not specified, non-simple types cannot be written into the property set. In the compound file and stand-alone
            implementations, property sets may be transacted only if PROPSETFLAG_NONSIMPLE is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSETFLAG.PROPSETFLAG_ANSI">
            <summary>
            If specified, all string values in the property set that are not explicitly Unicode, that is, those other than VT_LPWSTR, are
            stored with the current system ANSI code page. For more information, see GetACP. Use of this value is not recommended. For
            more information, see Remarks.
            <para>
            If this value is absent, string values in the new property set are stored in Unicode. The degree of control that this value
            provides is necessary so that clients using the property-related interfaces can interoperate with standard property sets such
            as the OLE2 summary information, which may exist in the ANSI code page.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSETFLAG.PROPSETFLAG_UNBUFFERED">
            <summary>
            Used only with the StgCreatePropStg and StgOpenPropStg functions; that is, in the stand-alone implementations of property set
            interfaces. If specified in these functions, changes to the property set are not buffered. Instead, changes are always
            written directly to the property set. Calls to a property set IPropertyStorage methods will change it. However, by default,
            changes are buffered in an internal property set cache and are subsequently written to the property set when the
            IPropertyStorage::Commit method is called.
            <para>
            Setting PROPSETFLAG_UNBUFFERED decreases performance because the property set internal buffer is automatically flushed after
            every change to the property set.However, writing changes directly will prevent coordination problems.For example, if the
            storage object is opened in transacted mode, and the property set is buffered.Then, if you call the IStorage::Commit method
            on the storage object, the property set changes will not be picked up as part of the transaction, because they are in a
            buffer that has not been flushed yet. You must call IPropertyStorage::Commit prior to calling IStorage::Commit to flush the
            property set buffer before committing changes to the storage.As an alternative to making two calls, you can set
            PROPSETFLAG_UNBUFFERED so that changes are always written directly to the property set and are never buffered in the property
            set's internal cache. Then, the changes will be picked up when the transacted storage is committed.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSETFLAG.PROPSETFLAG_CASE_SENSITIVE">
            <summary>
            If specified, property names are case sensitive. Case-sensitive property names are only possible in the version 1 property
            set serialization format. For more information, see Property Set Serialization.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PRSPEC">
            <summary>Values used in PROPSPEC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PRSPEC.PRSPEC_LPWSTR">
            <summary>The lpwstr member is used and set to a string name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PRSPEC.PRSPEC_PROPID">
            <summary>The propid member is used and set to a property ID value.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG">
            <summary>
            <para>
            The <c>IEnumSTATPROPSETSTG</c> interface iterates through an array of STATPROPSETSTG structures. The <c>STATPROPSETSTG</c>
            structures contain statistical data about the property sets managed by the current IPropertySetStorage instance.
            <c>IEnumSTATPROPSETSTG</c> has the same methods as all enumerator interfaces: Next, Skip, Reset, and Clone.
            </para>
            <para>
            The implementation defines the order in which the property sets are enumerated. Property sets that are present when the
            enumerator is created, and are not removed during the enumeration, will be enumerated only once. Property sets added or deleted
            while the enumeration is in progress may or may not be enumerated, but, if enumerated, will not be enumerated more than once.
            </para>
            <para>
            For more information about how the COM compound document implementation of IEnumSTATPROPSETSTG::Next supplies members of the
            STATPROPSETSTG structure, see IEnumSTATPROPSETSTG--Compound File Implementation.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG.Next(System.UInt32,Vanara.PInvoke.Ole32.STATPROPSETSTG[],System.UInt32@)">
            <summary>
            The <c>Next</c> method retrieves a specified number of STATPROPSETSTG structures that follow subsequently in the enumeration
            sequence. If fewer than the requested number of STATPROPSETSTG structures exist in the enumeration sequence, it retrieves the
            remaining <c>STATPROPSETSTG</c> structures.
            </summary>
            <param name="celt">The number of STATPROPSETSTG structures requested.</param>
            <param name="rgelt">An array of STATPROPSETSTG structures returned.</param>
            <param name="pceltFetched">The number of STATPROPSETSTG structures retrieved in the rgelt parameter.</param>
            <returns>
            <para>This method supports the following return values:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The number of STATPROPSETSTG structures returned equals the number specified in the celt parameter.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The number of STATPROPSETSTG structures returned is less than the number specified in the celt parameter.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG.Skip(System.UInt32)">
            <summary>The <c>Skip</c> method skips a specified number of STATPROPSETSTG structures in the enumeration sequence.</summary>
            <param name="celt">The number of STATPROPSETSTG structures to skip.</param>
            <returns>This method supports the following return values:</returns>
            <remarks>
            A positive value for the celt parameter skips forward in the STATPROPSETSTG structure enumeration. A negative value for the
            celt parameter skips backward in the <c>STATPROPSETSTG</c> structure enumeration.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG.Reset">
            <summary>The <c>Reset</c> method resets the enumeration sequence to the beginning of the STATPROPSETSTG structure array.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG.Clone">
            <summary>
            The <c>Clone</c> method creates an enumerator that contains the same enumeration state as the current STATPROPSETSTG
            structure enumerator. Using this method, a client can record a particular point in the enumeration sequence and then return
            to that point later. The new enumerator supports the same IEnumSTATPROPSETSTG interface.
            </summary>
            <returns>The variable that receives the IEnumSTATPROPSETSTG interface pointer.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IEnumSTATPROPSTG">
            <summary>
            <para>
            The <c>IEnumSTATPROPSTG</c> interface iterates through an array of STATPROPSTG structures. The <c>STATPROPSTG</c> structures
            contain statistical data about properties in a property set. <c>IEnumSTATPROPSTG</c> has the same methods as all enumerator
            interfaces: Next, Skip, Reset, and Clone.
            </para>
            <para>
            The implementation defines the order in which the properties in the set are enumerated. Properties that are present when the
            enumerator is created, and are not removed during the enumeration, will be enumerated only once. Properties added or deleted
            while the enumeration is in progress may or may not be enumerated, but will never be enumerated more than once.
            </para>
            <para>
            Reserved property identifiers, properties with a property ID of 0 (dictionary), 1 (code page indicator), or greater than or equal
            to 0x80000000 are not enumerated.
            </para>
            <para>
            Enumeration of a nonsimple property does not necessarily indicate that the property can be read successfully through a call to
            IPropertyStorage::ReadMultiple. This is because the performance overhead of checking existence of the indirect stream or storage
            is prohibitive during property enumeration.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSTG.Next(System.UInt32,Vanara.PInvoke.Ole32.STATPROPSTG[],System.UInt32@)">
            <summary>
            The <c>Next</c> method retrieves a specified number of STATPROPSTG structures, that follow subsequently in the enumeration
            sequence. If fewer than the requested number of STATPROPSTG structures exist in the enumeration sequence, it retrieves the
            remaining <c>STATPROPSTG</c> structures.
            </summary>
            <param name="celt">The number of STATPROPSTG structures requested.</param>
            <param name="rgelt">An array of STATPROPSTG structures returned.</param>
            <param name="pceltFetched">The number of STATPROPSTG structures retrieved in the rgelt parameter.</param>
            <returns>
            <para>This method supports the following return values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The number of STATPROPSTG structures returned is equal to the number specified in the celt parameter.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The number of STATPROPSTG structures returned is less than the number specified in the celt parameter.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSTG.Skip(System.UInt32)">
            <summary>The <c>Skip</c> method skips the specified number of STATPROPSTG structures in the enumeration sequence.</summary>
            <param name="celt">The number of STATPROPSTG structures to skip.</param>
            <returns>This method supports the following return values:</returns>
            <remarks>
            A positive value for the celt parameter skips forward in the STATPROPSTG structure enumeration. A negative value for the celt
            parameter skips backward in the <c>STATPROPSTG</c> structure enumeration.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSTG.Reset">
            <summary>The <c>Reset</c> method resets the enumeration sequence to the beginning of the STATPROPSTG structure array.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IEnumSTATPROPSTG.Clone">
            <summary>
            The <c>Clone</c> method creates an enumerator that contains the same enumeration state as the current STATPROPSTG structure
            enumerator. Using this method, a client can record a particular point in the enumeration sequence and then return to that
            point later. The new enumerator supports the same IEnumSTATPROPSTG interface.
            </summary>
            <returns>
            <para>This method supports the following return values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppenum parameter is NULL.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected exception occurred.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPropertySetStorage">
            <summary>
            The IPropertySetStorage interface creates, opens, deletes, and enumerates property set storages that support instances of the
            IPropertyStorage interface. The IPropertyStorage interface manages a single property set in a property storage subobject; and the
            IPropertySetStorage interface manages the storage of groups of such property sets. Any file system entity can support
            IPropertySetStorage that is currently implemented in the COM compound file object.
            <para>
            The IPropertySetStorage and IPropertyStorage interfaces provide a uniform way to create and manage property sets, whether or not
            these sets reside in a storage object that supports IStorage.When called through an object supporting IStorage (such as
            structured and compound files) or IStream, the property sets created conform to the COM property set format, described in detail
            in Structured Storage Serialized Property Set Format.Similarly, properties written using IStorage to the COM property set format
            are visible through IPropertySetStorage and IPropertyStorage.
            </para>
            <para>
            IPropertySetStorage methods identify property sets through a globally unique identifier (GUID) called a format identifier
            (FMTID). The FMTID for a property set identifies the property identifiers in the property set, their meaning, and any constraints
            on the values. The FMTID of a property set should also provide the means to manipulate that property set. Only one instance of a
            given FMTID may exist at a time within a single property storage.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertySetStorage.Create(System.Guid@,System.IntPtr,Vanara.PInvoke.STGM,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.IPropertyStorage@)">
            <summary>
            <para>The <c>Create</c> method creates and opens a new property set in the property set storage object.</para>
            </summary>
            <param name="rfmtid"/>
            <param name="pclsid">
            <para>
            A pointer to the initial class identifier CLSID for this property set. May be <c>NULL</c>, in which case it is set to all
            zeroes. The CLSID is the CLSID of a class that displays and/or provides programmatic access to the property values. If there
            is no such class, it is recommended that the FMTID be used.
            </para>
            </param>
            <param name="grfFlags">
            <para>The values from PROPSETFLAG Constants.</para>
            </param>
            <param name="grfMode">
            <para>
            An access mode in which the newly created property set is to be opened, taken from certain values of STGM_Constants, as
            described in the following Remarks section.
            </para>
            </param>
            <param name="ppprstg"/>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, as well as the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertySetStorage::Create</c> creates and opens a new property set subobject (supporting the IPropertyStorage interface)
            contained in this property set storage object. The property set automatically contains code page and locale ID properties.
            These are set to the Unicode and the current user default, respectively.
            </para>
            <para>
            The parameter is a combination of values taken from PROPSETFLAG Constants. If the PROPSETFLAG_ANSI value from this
            enumeration is used, the code page is set to the current system default, rather than Unicode.
            </para>
            <para>
            The parameter specifies the access mode in which the newly created set is to be opened. Values for this parameter are as in
            the parameter to IPropertySetStorage::Open, with the addition of the values listed in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGM_FAILIFTHERE</term>
            <term>
            If another property set with the specified parameter exists, the call fails. This is the default action; that is, unless
            STGM_CREATE is specified, STGM_FAILIFTHERE is implied.
            </term>
            </item>
            <item>
            <term>STGM_CREATE</term>
            <term>If another property set with the specified parameter already exists, it is removed and replaced with this new one.</term>
            </item>
            </list>
            <para>
            The created property set is simple by default, but the caller may request a nonsimple property set by specifying the
            PROPSETFLAG_NONSIMPLE value in the parameter. For more information about simple and nonsimple property sets, see Storage and
            Stream Objects for a Property Set.
            </para>
            <para>
            This method is subject to the constraints of the underlying IStorage::CreateStream (for simple property sets) or
            IStorage::CreateStorage (for nonsimple property sets). For example, when using the IPropertySetStorage-Compound File
            Implementation, specify STGM_SHARE_EXCLUSIVE in the parameter to <c>IPropertySetStorage::Create</c>. Conversely, if using the
            IPropertySetStorage-Stand-alone Implementation, <c>IPropertySetStorage::Create</c> is subject to constraints that apply to
            the caller-specified IStorage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertySetStorage.Open(System.Guid@,Vanara.PInvoke.STGM,Vanara.PInvoke.Ole32.IPropertyStorage@)">
            <summary>
            <para>The <c>Open</c> method opens a property set contained in the property set storage object.</para>
            </summary>
            <param name="rfmtid"/>
            <param name="grfMode">
            <para>
            The access mode in which the newly created property set is to be opened. These flags are taken from STGM Constants. Flags
            that may be used and their meanings in the context of this method are described in the following Remarks section.
            </para>
            </param>
            <param name="ppprstg"/>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            The mode in which the property set is to be opened is specified in the parameter . These flags are taken from STGM Constants,
            but, for this method, legal values and their meanings are as follows (only certain combinations of these flag values are legal).
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGM_DIRECT</term>
            <term>
            Opens the property set without an additional level of transaction nesting. This is the default (the behavior if neither
            STGM_DIRECT nor STGM_TRANSACTED is specified).
            </term>
            </item>
            <item>
            <term>STGM_TRANSACTED</term>
            <term>
            Opens the property set with an additional level of transaction nesting (beyond the transaction, if any, on this property set
            storage object). Transacted mode is available only for nonsimple property sets. Changes in the property set must be committed
            with a call to IPropertyStorage::Commit before they are visible to the transaction on this property set storage.
            </term>
            </item>
            <item>
            <term>STGM_READ</term>
            <term>Opens the property set with read access. Read permission is required on the property set storage.</term>
            </item>
            <item>
            <term>STGM_WRITE</term>
            <term>Opens the property set with write access. Not all implementations of IPropertyStorage support this mode.</term>
            </item>
            <item>
            <term>STGM_READWRITE</term>
            <term>
            Opens the property set with read and write access. Be aware that this flag is not the binary OR of the values STGM_READ and STGM_WRITE.
            </term>
            </item>
            <item>
            <term>STGM_SHARE_DENY_NONE</term>
            <term>
            Subsequent openings of the property set from this property set storage are not denied read or write access. (Not available in
            all implementations.)
            </term>
            </item>
            <item>
            <term>STGM_SHARE_DENY_READ</term>
            <term>
            Subsequent openings of the property set from this property set storage are denied read access. Not available in all implementations.
            </term>
            </item>
            <item>
            <term>STGM_SHARE_DENY_WRITE</term>
            <term>
            Subsequent openings of the property set from this property set storage are denied write access. This value is typically used
            in the transacted mode to prevent making unnecessary copies of an object opened by multiple users. That is, if
            STGM_TRANSACTED is specified, but this value is not specified, a snapshot is made, whether there are subsequent openings or
            not. Thus, you can improve performance by specifying this value. Not available in all implementations.
            </term>
            </item>
            <item>
            <term>STGM_SHARE_EXCLUSIVE</term>
            <term>
            Subsequent openings of the property set from this property set storage are not possible. Be aware that this value is not a
            simple binary OR of the STGM_SHARE_DENY_READ and STGM_SHARE_DENY_WRITE elements.
            </term>
            </item>
            </list>
            <para>
            This method is subject to the constraints of the underlying IStorage::OpenStream (for simple property sets) or
            IStorage::OpenStorage (for nonsimple property sets). For more information about simple and nonsimple property sets, see
            Storage and Stream Objects for a Property Set. For example, when using the IPropertySetStorage-Compound File Implementation,
            you must specify STGM_SHARE_EXCLUSIVE in the parameter to <c>IPropertySetStorage::Open</c>. Conversely, if using the
            IPropertySetStorage-Stand-alone Implementation, <c>IPropertySetStorage::Open</c> is subject to constraints that apply to the
            caller-specified IStorage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertySetStorage.Delete(System.Guid@)">
            <summary>
            <para>The <c>Delete</c> method deletes one of the property sets contained in the property set storage object.</para>
            </summary>
            <param name="rfmtid"/>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertySetStorage::Delete</c> deletes the property set specified by its FMTID. Specifying a property set that does not
            exist returns an error. Open substorages and streams(opened through one of the storage- or stream-valued properties) are put
            into the reverted state.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertySetStorage.Enum(Vanara.PInvoke.Ole32.IEnumSTATPROPSETSTG@)">
            <summary>
            <para>
            The <c>Enum</c> method creates an enumerator object which contains information on the property sets stored in this property
            set storage. On return, this method supplies a pointer to the IEnumSTATPROPSETSTG pointer on the enumerator object.
            </para>
            </summary>
            <param name="ppenum">
            <para>
            Pointer to IEnumSTATPROPSETSTG pointer variable that receives the interface pointer to the newly created enumerator object.
            </para>
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertySetStorage::Enum</c> creates an enumerator object that can be used to iterate through STATPROPSETSTG structures.
            These sometimes provide information on the property sets managed by IPropertySetStorage. This method, on return, supplies a
            pointer to the IEnumSTATPROPSETSTG interface on this enumerator object on return.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IPropertyStorage">
            <summary>
            <para>
            The <c>IPropertyStorage</c> interface manages the persistent properties of a single property set. Persistent properties consist
            of information that can be stored persistently in a property set, such as the summary information associated with a file. This
            contrasts with run-time properties associated with Controls and Automation, which can be used to affect system behavior. Use the
            methods of the IPropertySetStorage interface to create or open a persistent property set. An instance of the
            <c>IPropertySetStorage</c> interface can manage zero or more <c>IPropertyStorage</c> instances.
            </para>
            <para>
            Each property within a property set is identified by a property identifier (ID), a four-byte <c>ULONG</c> value unique to that
            set. You can also assign a string name to a property through the <c>IPropertyStorage</c> interface.
            </para>
            <para>
            Property IDs differ from the dispatch IDs used in Automation <c>dispid</c> property name tags. One difference is that the
            general-purpose use of property ID values zero and one is prohibited in <c>IPropertyStorage</c>, while no such restriction exists
            in <c>IDispatch</c>. In addition, while there is significant overlap among the data types for property values that may be used in
            <c>IPropertyStorage</c> and <c>IDispatch</c>, the property sets are not identical. Persistent property data types used in
            <c>IPropertyStorage</c> methods are defined in the PROPVARIANT structure.
            </para>
            <para>
            The <c>IPropertyStorage</c> interface can be used to access both simple and nonsimple property sets. Nonsimple property sets can
            hold several complex property types that cannot be held in a simple property set. For more information see Storage and Stream
            Objects for a Property Set.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.ReadMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[],Vanara.PInvoke.Ole32.PROPVARIANT[])">
            <summary>
            <para>The <c>ReadMultiple</c> method reads specified properties from the current property set.</para>
            </summary>
            <param name="cpspec">
            <para>
            The numeric count of properties to be specified in the array. The value of this parameter can be set to zero; however, that
            defeats the purpose of the method as no properties are thereby read, regardless of the values set in .
            </para>
            </param>
            <param name="rgpspec">
            <para>
            An array of PROPSPEC structures specifies which properties are read. Properties can be specified either by a property ID or
            by an optional string name. It is not necessary to specify properties in any particular order in the array. The array can
            contain duplicate properties, resulting in duplicate property values on return for simple properties. Nonsimple properties
            should return access denied on an attempt to open them a second time. The array can contain a mixture of property IDs and
            string IDs.
            </para>
            </param>
            <param name="rgpropvar">
            <para>
            Caller-allocated array of a PROPVARIANT structure that, on return, contains the values of the properties specified by the
            corresponding elements in the array. The array must be at least large enough to hold values of the parameter of the
            <c>PROPVARIANT</c> structure. The parameter specifies the number of properties set in the array. The caller is not required
            to initialize these <c>PROPVARIANT</c> structure values in any specific order. However, the implementation must fill all
            members correctly on return. If there is no other appropriate value, the implementation must set the <c>vt</c> member of each
            <c>PROPVARIANT</c> structure to <c>VT_EMPTY</c>.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value <c>E_UNEXPECTED</c>, as well as the following:</para>
            <para>
            This function can also return any file system errors or Win32 errors wrapped in an <c>HRESULT</c> data type. For more
            information, see Error Handling Strategies.
            </para>
            <para>For more information, see Property Storage Considerations.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.WriteMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[],Vanara.PInvoke.Ole32.PROPVARIANT[],System.UInt32)">
            <summary>
            <para>
            The <c>WriteMultiple</c> method writes a specified group of properties to the current property set. If a property with a
            specified name or property identifier already exists, it is replaced, even when the old and new types for the property value
            are different. If a property of a given name or property ID does not exist, it is created.
            </para>
            </summary>
            <param name="cpspec">
            <para>
            The number of properties set. The value of this parameter can be set to zero; however, this defeats the purpose of the method
            as no properties are then written.
            </para>
            </param>
            <param name="rgpspec">
            <para>
            An array of the property IDs (PROPSPEC) to which properties are set. These need not be in any particular order, and may
            contain duplicates, however the last specified property ID is the one that takes effect. A mixture of property IDs and string
            names is permitted.
            </para>
            </param>
            <param name="rgpropvar">
            <para>
            An array (of size ) of PROPVARIANT structures that contain the property values to be written. The array must be the size
            specified by .
            </para>
            </param>
            <param name="propidNameFirst">
            <para>
            The minimum value for the property IDs that the method must assign if the parameter specifies string-named properties for
            which no property IDs currently exist. If all string-named properties specified already exist in this set, and thus already
            have property IDs, this value is ignored. When not ignored, this value must be greater than, or equal to, two and less than
            0x80000000. Property IDs 0 and 1 and greater than 0x80000000 are reserved for special use.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            <para>
            This function can also return any file system errors or Win32 errors wrapped in an <c>HRESULT</c> data type. For more
            information, see Error Handling Strategies.
            </para>
            </returns>
            <remarks>
            <para>
            If a specified property already exists, its value is replaced with the one specified in , even when the old and new types for
            the property value are different. If the specified property does not already exist, that property is created. The changes are
            not persisted to the underlying storage until IPropertyStorage::Commit has been called.
            </para>
            <para>
            Property names are stored in a special dictionary section of the property set, which maps such names to property IDs. All
            properties have an ID, but names are optional. A string name is supplied by specifying PRSPEC_LPWSTR in the <c>ulKind</c>
            member of the PROPSPEC structure. If a string name is supplied for a property, and the name does not already exist in the
            dictionary, the method will allocate a property ID, and add the property ID and the name to the dictionary. The property ID
            is allocated in such a way that it does not conflict with other IDs in the property set. The value of the property ID also is
            no less than the value specified by the parameter. If the parameter specifies string-named properties for which no property
            IDs currently exist, the parameter specifies the minimum value for the property IDs that the <c>WriteMultiple</c> method must assign.
            </para>
            <para>
            When a new property set is created, the special <c>codepage (</c> Property ID 1 <c>)</c> and <c>Locale ID (</c> Property ID
            0x80000000 <c>)</c> properties are written to the property set automatically. These properties can subsequently be read,
            using the IPropertyStorage::ReadMultiple method, by specifying property IDs with the header-defined PID_CODEPAGE and
            PID_LOCALE values, respectively. If a property set is non-empty — has one or more properties in addition to the
            <c>codepage</c> and <c>Locale ID</c> properties or has one or more names in its dictionary — the special <c>codepage</c> and
            <c>Locale ID</c> properties cannot be modified by calling <c>IPropertyStorage::WriteMultiple</c>. However, if the property
            set is empty, one or both of these special properties can be modified.
            </para>
            <para>
            If an element in the array is set with a PRSPEC_PROPID value of 0xffffffff (PID_ILLEGAL), the corresponding value in the
            array is ignored by <c>IPropertyStorage::WriteMultiple</c>. For example, if this method is called with the parameter set to
            3, but is set to PRSPEC_PROPID and is set to PID_ILLEGAL, only two properties will be written. The element is silently ignored.
            </para>
            <para>Use the PropVariantInit macro to initialize PROPVARIANT structures.</para>
            <para>
            Property sets, not including the data for nonsimple properties, are limited to 256 KB in size for Windows NT 4.0 and earlier.
            For Windows 2000, Windows XP and Windows Server 2003, OLE property sets are limited to 1 MB. If these limits are exceeded,
            the operation fails and the caller receives an error message. There is no possibility of a memory leak or overrun. For more
            information, see Managing Property Sets.
            </para>
            <para>
            Unless PROPSETFLAG_CASE_SENSITIVE is passed to IPropertySetStorage::Create, property set names are case insensitive.
            Specifying a property by its name in <c>IPropertyStorage::WriteMultiple</c> will result in a case-insensitive search of the
            names in the property set. To compare case-insensitive strings, the locale of the strings must be known. For more
            information, see IPropertyStorage::WritePropertyNames.
            </para>
            <para>For more information, see Property Storage Considerations.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.DeleteMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[])">
            <summary>
            <para>The <c>DeleteMultiple</c> method deletes as many of the indicated properties as exist in this property set.</para>
            </summary>
            <param name="cpspec">
            <para>
            The numerical count of properties to be deleted. The value of this parameter can legally be set to zero, however that defeats
            the purpose of the method as no properties are thereby deleted, regardless of the value set in .
            </para>
            </param>
            <param name="rgpspec">
            <para>
            Properties to be deleted. A mixture of property identifiers and string-named properties is permitted. There may be
            duplicates, and there is no requirement that properties be specified in any order.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::DeleteMultiple</c> must delete as many of the indicated properties as are in the current property set.
            If a deletion of a stream- or storage-valued property occurs while that property is open, the deletion will succeed and place
            the previously returned IStream or IStorage pointer in the reverted state.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.ReadPropertyNames(System.UInt32,System.UInt32[],System.String[])">
            <summary>
            <para>The <c>ReadPropertyNames</c> method retrieves any existing string names for the specified property IDs.</para>
            </summary>
            <param name="cpropid">
            <para>
            The number of elements on input of the array . The value of this parameter can be set to zero, however that defeats the
            purpose of this method as no property names are thereby read.
            </para>
            </param>
            <param name="rgpropid">
            <para>An array of property IDs for which names are to be retrieved.</para>
            </param>
            <param name="rglpwstrName">
            <para>
            A caller-allocated array of size of <c>LPWSTR</c> members. On return, the implementation fills in this array. A given entry
            contains either the corresponding string name of a property ID or it can be empty if the property ID has no string names.
            </para>
            <para>Each <c>LPWSTR</c> member of the array should be freed using the CoTaskMemFree function.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For each property ID in the list of property IDs supplied in the array, <c>ReadPropertyNames</c> retrieves the corresponding
            string name, if there is one. String names are created either by specifying the names in calls to
            IPropertyStorage::WriteMultiple when creating the property, or through a call to IPropertyStorage::WritePropertyNames. In
            either case, the string name is optional, however all properties must have a property ID.
            </para>
            <para>String names mapped to property IDs must be unique within the set.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.WritePropertyNames(System.UInt32,System.UInt32[],System.String[])">
            <summary>
            <para>
            The <c>WritePropertyNames</c> method assigns string IPropertyStoragenames to a specified array of property IDs in the current
            property set.
            </para>
            </summary>
            <param name="cpropid">
            <para>The size on input of the array . Can be zero. However, making it zero causes this method to become non-operational.</para>
            </param>
            <param name="rgpropid">
            <para>An array of the property IDs for which names are to be set.</para>
            </param>
            <param name="rglpwstrName">
            <para>
            An array of new names to be assigned to the corresponding property IDs in the array. These names may not exceed 255
            characters (not including the <c>NULL</c> terminator).
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value <c>E_UNEXPECTED</c>, in addition to the following:</para>
            </returns>
            <remarks>
            <para>For more information about property sets and memory management, see Managing Property Sets.</para>
            <para>
            <c>IPropertyStorage::WritePropertyNames</c> assigns string names to property IDs passed to the method in the array. It
            associates each string name in the array with the respective property ID in . It is explicitly valid to define a name for a
            property ID that is not currently present in the property storage object.
            </para>
            <para>
            It is also valid to change the mapping for an existing string name (determined by a case-insensitive match). That is, you can
            use the <c>WritePropertyNames</c> method to map an existing name to a new property ID, or to map a new name to a property ID
            that already has a name in the dictionary. In either case, the original mapping is deleted. Property names must be unique (as
            are property IDs) within the property set.
            </para>
            <para>
            The storage of string property names preserves the case. Unless <c>PROPSETFLAG_CASE_SENSITIVE</c> is passed to
            IPropertySetStorage::Create, property set names are case insensitive by default. With case-insensitive property sets, the
            name strings passed by the caller are interpreted according to the locale of the property set, as specified by the
            <c>PID_LOCALE</c> property. If the property set has no locale property, the current user is assumed by default. String
            property names are limited in length to 128 characters. Property names that begin with the binary Unicode characters 0x0001
            through 0x001F are reserved for future use.
            </para>
            <para>
            If the value of an element in the array parameter is set to 0xffffffff (PID_ILLEGAL), the corresponding name is ignored by
            <c>IPropertyStorage::WritePropertyNames</c>. For example, if this method is called with a parameter of 3, but the first
            element of the array, , is set to <c>PID_ILLEGAL</c>, then only two property names are written. The element is ignored.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.DeletePropertyNames(System.UInt32,System.UInt32[])">
            <summary>
            <para>The <c>DeletePropertyNames</c> method deletes specified string names from the current property set.</para>
            </summary>
            <param name="cpropid">
            <para>The size on input of the array . If 0, no property names are deleted.</para>
            </param>
            <param name="rgpropid">
            <para>Property identifiers for which string names are to be deleted.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For each property identifier in , <c>IPropertyStorage::DeletePropertyNames</c> removes any corresponding name-to-property ID
            mapping. An attempt is silently ignored to delete the name of a property that either does not exist or does not currently
            have a string name associated with it. This method has no effect on the properties themselves.
            </para>
            <para>
            <c>Note</c> All the stored string property names can be deleted by deleting property identifier zero, but must be equal to 1
            for this to be a valid parameter error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.Commit(System.UInt32)">
            <summary>
            <para>The <c>IPropertyStorage::Commit</c> method saves changes made to a property storage object to the parent storage object.</para>
            </summary>
            <param name="grfCommitFlags">
            <para>
            The flags that specify the conditions under which the commit is to be performed. For more information about specific flags
            and their meanings, see the Remarks section.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, as well as the following:</para>
            </returns>
            <remarks>
            <para>
            Like IStorage::Commit, the <c>IPropertyStorage::Commit</c> method ensures that any changes made to a property storage object
            are reflected in the parent storage.
            </para>
            <para>
            In direct mode in the compound file implementation, a call to this method causes any changes currently in the memory buffers
            to be flushed to the underlying property stream. In the compound-file implementation for nonsimple property sets,
            IStorage::Commit is also called on the underlying substorage object with the passed parameter.
            </para>
            <para>
            In transacted mode, this method causes the changes to be permanently reflected in the persistent image of the storage object.
            The changes that are committed must have been made to this property set since it was opened or since the last commit on this
            opening of the property set. The <c>commit</c> method publishes the changes made on one object level to the next level. Of
            course, this remains subject to any outer-level transaction that may be present on the object in which this property set is
            contained. Write permission must be specified when the property set is opened (through IPropertySetStorage) on the property
            set opening for the commit operation to succeed.
            </para>
            <para>
            If the commit operation fails for any reason, the state of the property storage object remains as it was before the commit.
            </para>
            <para>
            This call has no effect on existing storage- or stream-valued properties opened from this property storage, but it does
            commit them.
            </para>
            <para>Valid values for the parameter are listed in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGC_DEFAULT</term>
            <term>Commits per the usual transaction semantics. Last writer wins. This flag may not be specified with other flag values.</term>
            </item>
            <item>
            <term>STGC_ONLYIFCURRENT</term>
            <term>
            Commits the changes only if the current persistent contents of the property set are the ones on which the changes about to be
            committed are based. That is, does not commit changes if the contents of the property set have been changed by a commit from
            another opening of the property set. The error STG_E_NOTCURRENT is returned if the commit does not succeed for this reason.
            </term>
            </item>
            <item>
            <term>STGC_OVERWRITE</term>
            <term>
            Useful only when committing a transaction that has no further outer nesting level of transactions, though acceptable in all cases.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> Using <c>IPropertyStorage::Commit</c> to write properties to image files on Windows XP does not work. Affected
            image file formats include:Due to a bug in the image file property handler on Windows XP, calling
            <c>IPropertyStorage::Commit</c> actually discards any changes made rather than persisting them.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.Revert">
            <summary>
            <para>
            The <c>Revert</c> method discards all changes to the named property set since it was last opened or discards changes that
            were last committed to the property set. This method has no effect on a direct-mode property set.
            </para>
            </summary>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For transacted-mode property sets, this method discards all changes that have been made in this property set since the set
            was opened or since the time it was last committed, (whichever is later). After this operation, any existing storage- or
            stream-valued properties that have been opened from the property set being reverted are no longer valid and cannot be used.
            The error STG_E_REVERTED will be returned on all calls, except those to <c>Release</c>, using these streams or storages.
            </para>
            <para>For direct-mode property sets, this request is ignored and returns S_OK.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.Enum(Vanara.PInvoke.Ole32.IEnumSTATPROPSTG@)">
            <summary>
            <para>
            The <c>Enum</c> method creates an enumerator object designed to enumerate data of type STATPROPSTG, which contains
            information on the current property set. On return, this method supplies a pointer to the IEnumSTATPROPSTG pointer on this object.
            </para>
            </summary>
            <param name="ppenum">
            <para>Pointer to IEnumSTATPROPSTG pointer variable that receives the interface pointer to the new enumerator object.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::Enum</c> creates an enumeration object that can be used to iterate STATPROPSTG structures. On return,
            this method supplies a pointer to an instance of the IEnumSTATPROPSTG interface on this object, whose methods you can call to
            obtain information about the current property set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.SetTimes(System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            <para>
            The <c>SetTimes</c> method sets the modification, access, and creation times of this property set, if supported by the
            implementation. Not all implementations support all these time values.
            </para>
            </summary>
            <param name="pctime">
            <para>
            Pointer to the new creation time for the property set. May be <c>NULL</c>, indicating that this time is not to be modified by
            this call.
            </para>
            </param>
            <param name="patime">
            <para>
            Pointer to the new access time for the property set. May be <c>NULL</c>, indicating that this time is not to be modified by
            this call.
            </para>
            </param>
            <param name="pmtime">
            <para>
            Pointer to the new modification time for the property set. May be <c>NULL</c>, indicating that this time is not to be
            modified by this call.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            Sets the modification, access, and creation times of the current open property set, if supported by the implementation (not
            all implementations support all these time values). Unsupported time stamps are always reported as zero, enabling the caller
            to test for support. A call to IPropertyStorage::Stat supplies (among other data) time-stamp information.
            </para>
            <para>
            Notice that this functionality is provided as an IPropertyStorage method on a property-storage object that is already open,
            in contrast to being provided as a method in IPropertySetStorage. Normally, when the <c>SetTimes</c> method is not explicitly
            called, the access and modification times are updated as a side effect of reading and writing the property set. When
            <c>SetTimes</c> is used, the latest specified times supersede either default times or time values specified in previous calls
            to <c>SetTimes</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.SetClass(System.Guid@)">
            <summary>
            <para>
            The <c>SetClass</c> method assigns a new CLSID to the current property storage object, and persistently stores the CLSID with
            the object.
            </para>
            </summary>
            <param name="clsid">
            <para>New CLSID to be associated with the property set.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            Assigns a CLSID to the current property storage object. The CLSID has no relationship to the stored property IDs. Assigning a
            CLSID allows a piece of code to be associated with a given instance of a property set; such code, for example, might manage
            the user interface (UI). Different CLSIDs can be associated with different property set instances that have the same FMTID.
            </para>
            <para>
            If the property set is created with the parameter of the IPropertySetStorage::Create method specified as <c>NULL</c>, the
            CLSID is set to all zeroes.
            </para>
            <para>
            The current CLSID on a property storage object can be retrieved with a call to IPropertyStorage::Stat. The initial value for
            the CLSID can be specified at the time that the storage is created with a call to IPropertySetStorage::Create.
            </para>
            <para>
            Setting the CLSID on a nonsimple property set (one that can legally contain storage- or stream-valued properties, as
            described in IPropertySetStorage::Create) also sets the CLSID on the underlying sub-storage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IPropertyStorage.Stat(Vanara.PInvoke.Ole32.STATPROPSETSTG@)">
            <summary>
            <para>The <c>Stat</c> method retrieves information about the current open property set.</para>
            </summary>
            <param name="pstatpsstg">
            <para>Pointer to a STATPROPSETSTG structure, which contains statistics about the current open property set.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::Stat</c> fills in and returns a pointer to a STATPROPSETSTG structure, containing statistics about the
            current property set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PropVariantClear(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            The PropVariantClear function frees all elements that can be freed in a given PROPVARIANT structure. For complex elements with
            known element pointers, the underlying elements are freed prior to freeing the containing element.
            </summary>
            <param name="pvar">
            A pointer to an initialized PROPVARIANT structure for which any deallocatable elements are to be freed. On return, all zeroes are
            written to the PROPVARIANT structure.
            </param>
            <returns>
            <list type="definition">
            <item>
            <term>S_OK</term>
            <definition>The VT types are recognized and all items that can be freed have been freed.</definition>
            </item>
            <item>
            <term>STG_E_INVALID_PARAMETER</term>
            <definition>The variant has an unknown VT type.</definition>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PropVariantCopy(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>The PropVariantCopy function copies the contents of one PROPVARIANT structure to another.</summary>
            <param name="pDst">Pointer to an uninitialized PROPVARIANT structure that receives the copy.</param>
            <param name="pSrc">Pointer to the PROPVARIANT structure to be copied.</param>
            <returns>
            <list type="definition">
            <item>
            <term>S_OK</term>
            <definition>The VT types are recognized and all items that can be freed have been freed.</definition>
            </item>
            <item>
            <term>STG_E_INVALID_PARAMETER</term>
            <definition>The variant has an unknown VT type.</definition>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPSPEC">
            <summary>
            <para>
            The <c>PROPSPEC</c> structure is used by many of the methods of IPropertyStorage to specify a property either by its property
            identifier (ID) or the associated string name.
            </para>
            </summary>
            <remarks>
            <para>
            String names are optional and can be assigned to a set of properties when the property is created with a call to
            IPropertyStorage::WriteMultiple or later with a call to IPropertyStorage::WritePropertyNames.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSPEC.ulKind">
            <summary>
            <para>Indicates the union member used. This member can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PRSPEC_LPWSTR Value: 0</term>
            <term>The lpwstr member is used and set to a string name.</term>
            </item>
            <item>
            <term>PRSPEC_PROPID Value: 1</term>
            <term>The propid member is used and set to a property ID value.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSPEC.union">
            <summary>PROPSPECunion</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPSPEC.PROPSPECunion">
            <summary>PROPSPECunion</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSPEC.PROPSPECunion.propid">
            <summary>
            <para>Specifies the value of the property ID. Use either this value or the following <c>lpwstr</c>, not both.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPSPEC.PROPSPECunion.lpwstr">
            <summary>
            <para>Specifies the string name of the property as a null-terminated Unicode string.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STATPROPSETSTG">
            <summary>
            <para>
            The <c>STATPROPSETSTG</c> structure contains information about a property set. To get this information, call
            IPropertyStorage::Stat, which fills in a buffer containing the information describing the current property set. To enumerate the
            <c>STATPROPSETSTG</c> structures for the property sets in the current property-set storage, call IPropertySetStorage::Enum to get
            a pointer to an enumerator. You can then call the enumeration methods of the IEnumSTATPROPSETSTG interface on the enumerator. The
            structure is defined as follows:
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.fmtid">
            <summary>
            <para>FMTID of the current property set, specified when the property set was initially created.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.clsid">
            <summary>
            <para>
            <c>CLSID</c> associated with this property set, specified when the property set was initially created and possibly modified
            thereafter with IPropertyStorage::SetClass. If not set, the value will be <c>CLSID_NULL</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.grfFlags">
            <summary>
            <para>Flag values of the property set, as specified in IPropertySetStorage::Create.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.mtime">
            <summary>
            <para>Time in Universal Coordinated Time (UTC) when the property set was last modified.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.ctime">
            <summary>
            <para>Time in UTC when this property set was created.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.atime">
            <summary>
            <para>Time in UTC when this property set was last accessed.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSETSTG.dwOSVersion">
            <summary>The OS version.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STATPROPSTG">
            <summary>
            <para>
            The <c>STATPROPSTG</c> structure contains data about a single property in a property set. This data is the property ID and type
            tag, and the optional string name that may be associated with the property.
            </para>
            <para>
            IPropertyStorage::Enum supplies a pointer to the IEnumSTATPROPSTG interface on an enumerator object that can be used to enumerate
            the <c>STATPROPSTG</c> structures for the properties in the current property set. <c>STATPROPSTG</c> is defined as:
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSTG.lpwstrName">
            <summary>
            <para>
            A wide-character null-terminated Unicode string that contains the optional string name associated with the property. May be
            <c>NULL</c>. This member must be freed using CoTaskMemFree.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSTG.propid">
            <summary>
            <para>
            A 32-bit identifier that uniquely identifies the property within the property set. All properties within property sets must
            have unique property identifiers.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATPROPSTG.vt">
            <summary>
            <para>The property type.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.BLOB">
            <summary>
            Structure to mimic behavior of VT_BLOB type. "DWORD count of bytes, followed by that many bytes of data. The byte count does not
            include the four bytes for the length of the count itself; an empty blob member would have a count of zero, followed by zero bytes."
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BLOB.cbSize">
            <summary>The count of bytes</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.BLOB.pBlobData">
            <summary>A pointer to the allocated array of bytes.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CLIPDATA">
            <summary>Structure to hold VT_CLIPDATE content.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLIPDATA.cbSize">
            <summary>The size of the buffer pointed to by pClipData, plus sizeof(ulClipFmt)</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLIPDATA.ulClipFmt">
            <summary>The clipboard format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CLIPDATA.pClipData">
            <summary>The clipboard data.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLIPDATA.#ctor(System.Int32,System.IntPtr,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.CLIPDATA"/> struct.</summary>
            <param name="clipFmt">The clipboard format.</param>
            <param name="dataPtr">A pointer to the data.</param>
            <param name="dataLength">
            Length of the data in bytes. Do not include any length other than that pointed to by <paramref name="dataPtr"/>.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLIPDATA.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.CLIPDATA"/> struct.</summary>
            <param name="clipFmt">The string value to register as a new clipboard format using RegisterClipboardFormat.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.CLIPDATA.ClipboardFormat">
            <summary>The clipboard format.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.CLIPDATA.ClipboardFormatName">
            <summary>The clipboard name.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.CLIPDATA.FMTID">
            <summary>The clipboard format id.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.CLIPDATA.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPVARIANT">
            <summary>
            The PROPVARIANT structure is used in the ReadMultiple and WriteMultiple methods of IPropertyStorage to define the type tag and
            the value of a property in a property set.
            <para>
            The PROPVARIANT structure is also used by the GetValue and SetValue methods of IPropertyStore, which replaces IPropertySetStorage
            as the primary way to program item properties in Windows Vista. For more information, see Property Handlers.
            </para>
            <para>
            There are five members. The first member, the value-type tag, and the last member, the value of the property, are significant.
            The middle three members are reserved for future use.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT.vt">
            <summary>Value type tag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT.wReserved1">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT.wReserved2">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT.wReserved3">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT._decimal">
            <summary>The decimal value when VT_DECIMAL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT._ptr">
            <summary>The raw data pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT._ft">
            <summary>The FILETIME when VT_FILETIME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT._blob">
            <summary>The BLOB when VT_BLOB</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT._ulong">
            <summary>The value when a numeric value less than 8 bytes.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> class as VT_EMPTY.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.#ctor(System.Object,System.Runtime.InteropServices.VarEnum)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> class with an object.</summary>
            <param name="obj">The object to wrap. Based on the object type, it will infer the value type and allocate memory as needed.</param>
            <param name="type">If not VT_EMPTY, this value will override the inferred value type.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Finalize">
            <summary>Finalizes an instance of the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.blob">
            <summary>Gets the BLOB value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.boolVal">
            <summary>Gets the boolean value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.bstrVal">
            <summary>Gets the BSTR value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.bVal">
            <summary>Gets the byte value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cabool">
            <summary>Gets the boolean array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cabstr">
            <summary>Gets the string array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cac">
            <summary>Gets the sbyte array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.caclipdata">
            <summary>Gets the CLIPDATA array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cacy">
            <summary>Gets the decimal array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cadate">
            <summary>Gets the DateTime array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cadbl">
            <summary>Gets the double array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cafiletime">
            <summary>Gets the FILETIME array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.caflt">
            <summary>Gets the float array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cah">
            <summary>Gets the long array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cai">
            <summary>Gets the short array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cal">
            <summary>Gets the int array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.calpstr">
            <summary>Gets the ANSI string array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.calpwstr">
            <summary>Gets the Unicode string array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.capropvar">
            <summary>Gets the PROPVARIANT array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cascode">
            <summary>Gets the Win32Error array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.caub">
            <summary>Gets the byte array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cauh">
            <summary>Gets the ulong array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.caui">
            <summary>Gets the ushort array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.caul">
            <summary>Gets the uint array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cauuid">
            <summary>Gets the Guid array value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cVal">
            <summary>Gets the sbyte value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.cyVal">
            <summary>Gets the decimal value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.date">
            <summary>Gets the date.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.dblVal">
            <summary>Gets the double value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.filetime">
            <summary>Gets the FILETIME.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.fltVal">
            <summary>Gets the float value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.hVal">
            <summary>Gets the long value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.intVal">
            <summary>Gets the int value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.IsByRef">
            <summary>Gets a value indicating whether this instance is by reference.</summary>
            <value><c>true</c> if this instance is null or empty; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.IsNullOrEmpty">
            <summary>Gets a value indicating whether this instance is null or empty.</summary>
            <value><c>true</c> if this instance is null or empty; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.IsString">
            <summary>Gets a value indicating whether this instance is a string.</summary>
            <value><c>true</c> if this instance is a VT_BSTR or VT_LPWSTR; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.IsVector">
            <summary>Gets a value indicating whether this instance has a vector type.</summary>
            <value><c>true</c> if this instance is a VT_ARRAY or VT_VECTOR; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.iVal">
            <summary>Gets the short value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.lVal">
            <summary>Gets the int value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.parray">
            <summary>Gets the array of objects.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pboolVal">
            <summary>Gets the "by value" boolean value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pbstrVal">
            <summary>Gets the "by value" string value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pbVal">
            <summary>Gets the "by value" byte value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pclipdata">
            <summary>Gets the "by value" CLIPDATA value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pcVal">
            <summary>Gets the "by value" sbyte value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pcyVal">
            <summary>Gets the "by value" decimal value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pdate">
            <summary>Gets the "by value" DateTime value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pdblVal">
            <summary>Gets the "by value" double value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pdecVal">
            <summary>Gets the "by value" decimal value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pdispVal">
            <summary>Gets the "by value" pointer value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pfltVal">
            <summary>Gets the "by value" float value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pintVal">
            <summary>Gets the "by value" int value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.piVal">
            <summary>Gets the "by value" short value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.plVal">
            <summary>Gets the "by value" int value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.ppdispVal">
            <summary>Gets the IDispatch value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.ppunkVal">
            <summary>Gets the IUnknown value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pscode">
            <summary>Gets the "by value" Win32Error value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pStorage">
            <summary>Gets the IStorage value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pStream">
            <summary>Gets the IStream value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pszVal">
            <summary>Gets the ANSI string value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.puintVal">
            <summary>Gets the "by value" uint value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.puiVal">
            <summary>Gets the "by value" ushort value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pulVal">
            <summary>Gets the "by value" uint value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.punkVal">
            <summary>Gets the "by value" IUnknown value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.puuid">
            <summary>Gets the "by value" Guid value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pvarVal">
            <summary>Gets the "by value" PROPVARIANT value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pVersionedStream">
            <summary>Gets a stream with a Guid version.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.pwszVal">
            <summary>Gets the Unicode string value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.scode">
            <summary>Gets the Win32Error value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.uhVal">
            <summary>Gets the ulong value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.uintVal">
            <summary>Gets the uint value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.uiVal">
            <summary>Gets the ushort value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.ulVal">
            <summary>Gets the uint value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.Value">
            <summary>Gets the value base on the <see cref="F:Vanara.PInvoke.Ole32.PROPVARIANT.vt"/> value.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPVARIANT.VarType">
            <summary>Gets or sets the type of the variable.</summary>
            <value>The value type.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.FromNativeVariant(System.IntPtr)">
            <summary>Creates a new <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> instance from a pointer to a VARIANT.</summary>
            <param name="pSrcNativeVariant">A pointer to a native in-memory VARIANT.</param>
            <returns>A new <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> instance converted from the VARIANT pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.GetType(Vanara.PInvoke.Ole32.VARTYPE)">
            <summary>Gets the Type for a provided VARTYPE.</summary>
            <param name="vt">The VARTYPE value to lookup.</param>
            <returns>A best fit <see cref="T:System.Type"/> for the provided VARTYPE.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.GetVarType(System.Type)">
            <summary>Gets the VARTYPE for a provided type.</summary>
            <param name="type">The type to analyze.</param>
            <returns>A best fit <see cref="T:Vanara.PInvoke.Ole32.VARTYPE"/> for the provided type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Clear">
            <summary>
            Frees all elements that can be freed in this instance. For complex elements with known element pointers, the underlying
            elements are freed prior to freeing the containing element.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Clone(Vanara.PInvoke.Ole32.PROPVARIANT@)">
            <summary>Copies the contents of one PROPVARIANT structure to another.</summary>
            <param name="clone">The cloned copy.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current
            instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="other">An object to compare with this instance.</param>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning
            Less than zero This instance precedes <paramref name="other"/> in the sort order. Zero This instance occurs in the same
            position in the sort order as <paramref name="other"/>. Greater than zero This instance follows <paramref name="other"/> in
            the sort order.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.Equals(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <param name="other">An object to compare with this object.</param>
            <returns>true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.ToString">
            <summary>Returns a <see cref="T:System.String"/> that represents this instance.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.System#ICloneable#Clone">
            <summary>Creates a new object that is a copy of the current instance.</summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.System#IComparable{Vanara#PInvoke#Ole32#PROPVARIANT}#CompareTo(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Compares the current object with another object of the same type.</summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following
            meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is
            equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT.SetValue(System.Object,System.Runtime.InteropServices.VarEnum)">
            <summary>Sets the value, clearing any existing value.</summary>
            <param name="value">The value.</param>
            <param name="vEnum">
            If this value equals VT_EMPTY, the method will attempt to ascertain the value type from the <paramref name="value"/>.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE">
            <summary>
            The PROPVARIANT structure is used in the ReadMultiple and WriteMultiple methods of IPropertyStorage to define the type tag and
            the value of a property in a property set.
            <para>
            The PROPVARIANT structure is also used by the GetValue and SetValue methods of IPropertyStore, which replaces
            IPropertySetStorage as the primary way to program item properties in Windows Vista. For more information, see Property Handlers.
            </para>
            <para>
            There are five members. The first member, the value-type tag, and the last member, the value of the property, are significant.
            The middle three members are reserved for future use.
            </para>
            <note>This structure is mostly used for arrays where the fixed structure size is critical for interop.</note>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.vt">
            <summary>Value type tag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.wReserved1">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.wReserved2">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.wReserved3">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE._ulong">
            <summary>The value when a numeric value less than 8 bytes.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.op_Implicit(Vanara.PInvoke.Ole32.PROPVARIANT)~Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> to <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE"/>.</summary>
            <param name="pv">The PROPVARIANT instance.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE.op_Explicit(Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE@)~Vanara.PInvoke.Ole32.PROPVARIANT">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT_IMMUTABLE"/> to <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/>.</summary>
            <param name="pv">The PROPVARIANT_IMMUTABLE instance.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> instance from the conversion.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_C_AUTHN">
            <summary>
            Defines authentication services by identifying the security package that provides the service, such as NTLMSSP, Kerberos, or Schannel.
            </summary>
            <remarks>
            These constants are used in the <c>SOLE_AUTHENTICATION_SERVICE</c> and the <c>SOLE_AUTHENTICATION_INFO</c> structures. The
            <c>SOLE_AUTHENTICATION_SERVICE</c> structure is passed by the server to the <c>CoInitializeSecurity</c> function and can be
            retrieved by the <c>CoQueryAuthenticationServices</c> function. A pointer to a <c>SOLE_AUTHENTICATION_INFO</c> structure is
            passed by the client to <c>CoInitializeSecurity</c>. For more information on the security packages identified by these values,
            such as NTLMSSP and Kerberos, see COM and Security Packages.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_NONE">
            <summary>No authentication.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DCE_PRIVATE">
            <summary>DCE private key authentication.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DCE_PUBLIC">
            <summary>DCE public key authentication.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DEC_PUBLIC">
            <summary>DEC public key authentication. Reserved for future use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_GSS_NEGOTIATE">
            <summary>Snego security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_WINNT">
            <summary>NTLMSSP</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_GSS_SCHANNEL">
            <summary>Schannel security support provider. This authentication service supports SSL 2.0, SSL 3.0, TLS, and PCT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_GSS_KERBEROS">
            <summary>Kerberos security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DPA">
            <summary>DPA security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_MSN">
            <summary>MSN security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_KERNEL">
            <summary>Kernel security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DIGEST">
            <summary>Digest security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_NEGO_EXTENDER">
            <summary>NEGO extender security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_PKU2U">
            <summary>PKU2U security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_MQ">
            <summary>MQ security support provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_DEFAULT">
            <summary>
            The system default authentication service. When this value is specified, COM uses its normal security blanket negotiation
            algorithm to pick an authentication service. For more information, see Security Blanket Negotiation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_LIVE_SSP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_LIVEXP_SSP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_CLOUD_AP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN.RPC_C_AUTHN_MSONLINE">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL">
            <summary>
            These values specify an authentication level, which indicates the amount of authentication provided to help protect the integrity
            of the data. Each level includes the protection provided by the previous levels.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_DEFAULT">
            <summary>
            Tells DCOM to choose the authentication level using its normal security blanket negotiation algorithm. For more information,
            see Security Blanket Negotiation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_NONE">
            <summary>Performs no authentication.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_CONNECT">
            <summary>
            Authenticates the credentials of the client only when the client establishes a relationship with the server. Datagram
            transports always use RPC_AUTHN_LEVEL_PKT instead.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_CALL">
            <summary>
            Authenticates only at the beginning of each remote procedure call when the server receives the request. Datagram transports
            use RPC_C_AUTHN_LEVEL_PKT instead.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_PKT">
            <summary>Authenticates that all data received is from the expected client.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_PKT_INTEGRITY">
            <summary>Authenticates and verifies that none of the data transferred between client and server has been modified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHN_LEVEL.RPC_C_AUTHN_LEVEL_PKT_PRIVACY">
            <summary>Authenticates all previous levels and encrypts the argument value of each remote procedure call.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_C_AUTHZ">
            <summary>
            <para>Defines what the server authorizes.</para>
            </summary>
            <remarks>
            <para>
            These constants are used by methods of the <c>IClientSecurity</c> interface. They are used in the
            <c>SOLE_AUTHENTICATION_SERVICE</c> structure, which is retrieved by the <c>CoQueryAuthenticationServices</c> function. They are
            also used in the <c>SOLE_AUTHENTICATION_INFO</c> structure, which in turn is a member of the <c>SOLE_AUTHENTICATION_LIST</c>
            structure. This structure, which is a list of authentication services, the authorization services they perform, and the
            authentication information for each service, is passed to the <c>CoInitializeSecurity</c> function and the
            <c>IClientSecurity::SetBlanket</c> method.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHZ.RPC_C_AUTHZ_NONE">
            <summary>
            The server performs no authorization. Currently, RPC_C_AUTHN_WINNT, RPC_C_AUTHN_GSS_SCHANNEL, and RPC_C_AUTHN_GSS_KERBEROS
            all use only RPC_C_AUTHZ_NONE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHZ.RPC_C_AUTHZ_NAME">
            <summary>The server performs authorization based on the client's principal name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHZ.RPC_C_AUTHZ_DCE">
            <summary>
            The server performs authorization checking using the client's DCE privilege attribute certificate (PAC) information, which is
            sent to the server with each remote procedure call made using the binding handle. Generally, access is checked against DCE
            access control lists (ACLs).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_AUTHZ.RPC_C_AUTHZ_DEFAULT">
            <summary>
            DCOM can choose the authorization level using its normal security blanket negotiation algorithm. For more information, see
            Security Blanket Negotiation.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL">
            <summary>
            Specifies an impersonation level, which indicates the amount of authority given to the server when it is impersonating the client.
            </summary>
            <remarks>
            <para>
            <c>GetUserName</c> will fail while impersonating at identify level. The workaround is to impersonate, call
            <c>OpenThreadToken</c>, revert, call <c>GetTokenInformation</c>, and finally, call <c>LookupAccountSid</c>. Using
            <c>CoSetProxyBlanket</c>, the client sets the impersonation level
            </para>
            <para>
            Using <c>CoSetProxyBlanket</c>, the client sets the impersonation level and proxy identity that will be available when a server
            calls <c>CoImpersonateClient</c>. The identity the server will see when impersonating takes place is described in Cloaking. Note
            that when making a call while impersonating, the callee will normally receive the caller's process token, not the caller's
            impersonation token. To receive the caller's impersonation token, the caller must enable cloaking.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL.RPC_C_IMP_LEVEL_DEFAULT">
            <summary>
            DCOM can choose the impersonation level using its normal security blanket negotiation algorithm. For more information, see
            Security Blanket Negotiation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL.RPC_C_IMP_LEVEL_ANONYMOUS">
            <summary>
            The client is anonymous to the server. The server process can impersonate the client, but the impersonation token will not
            contain any information and cannot be used.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL.RPC_C_IMP_LEVEL_IDENTIFY">
            <summary>
            The server can obtain the client's identity. The server can impersonate the client for ACL checking, but it cannot access
            system objects as the client.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL.RPC_C_IMP_LEVEL_IMPERSONATE">
            <summary>
            The server process can impersonate the client's security context while acting on behalf of the client. This level of
            impersonation can be used to access local resources such as files. When impersonating at this level, the impersonation token
            can only be passed across one machine boundary. The Schannel authentication service only supports this level of impersonation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.RPC_C_IMP_LEVEL.RPC_C_IMP_LEVEL_DELEGATE">
            <summary>
            The server process can impersonate the client's security context while acting on behalf of the client. The server process can
            also make outgoing calls to other servers while acting on behalf of the client, using cloaking. The server may use the
            client's security context on other machines to access local and remote resources as the client. When impersonating at this
            level, the impersonation token can be passed across any number of computer boundaries.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE">
            <summary>Provides a RPC_AUTH_IDENTITY_HANDLE.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.op_Explicit(Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.op_Inequality(Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE,Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.op_Equality(Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE,Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTH_IDENTITY_HANDLE.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE">
            <summary>Provides a RPC_AUTHZ_HANDLE.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.op_Explicit(Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.op_Inequality(Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE,Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.op_Equality(Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE,Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.RPC_AUTHZ_HANDLE.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IClassFactory">
            <summary>Enables a class of objects to be created.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory.CreateInstance(System.Object,System.Guid@,System.Object@)">
            <summary>Creates an uninitialized object.</summary>
            <param name="pUnkOuter">
            If the object is being created as part of an aggregate, specify a pointer to the controlling IUnknown interface of the
            aggregate. Otherwise, this parameter must be <c>NULL</c>.
            </param>
            <param name="riid">
            A reference to the identifier of the interface to be used to communicate with the newly created object. If pUnkOuter is
            <c>NULL</c>, this parameter is generally the IID of the initializing interface; if pUnkOuter is non- <c>NULL</c>, riid must
            be IID_IUnknown.
            </param>
            <param name="ppvObject">
            The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObject
            contains the requested interface pointer. If the object does not support the interface specified in riid, the implementation
            must set *ppvObject to <c>NULL</c>.
            </param>
            <returns>
            <para>
            This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The specified object was created.</term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>The pUnkOuter parameter was non-NULL and the object does not support aggregation.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object that ppvObject points to does not support the interface identified by riid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A COM server's implementation of <c>CreateInstance</c> must return a reference to an object contained in an apartment that
            belongs to the server's DCOM resolver. It must not return a reference to an object that is contained in a remote apartment.
            </para>
            <para>
            The IClassFactory interface is always on a class object. The <c>CreateInstance</c> method creates an uninitialized object of
            the class identified with the specified CLSID. When an object is created in this way, the CLSID must be registered in the
            system registry with the CoRegisterClassObject function.
            </para>
            <para>
            The pUnkOuter parameter indicates whether the object is being created as part of an aggregate. Object definitions are not
            required to support aggregation â€” they must be specifically designed and implemented to support it.
            </para>
            <para>
            The riid parameter specifies the IID (interface identifier) of the interface through which you will communicate with the new
            object. If pUnkOuter is non- <c>NULL</c> (indicating aggregation), the value of the riid parameter must be IID_IUnknown. If
            the object is not part of an aggregate, riid often specifies the interface though which the object will be initialized.
            </para>
            <para>
            For OLE embeddings, the initialization interface is IPersistStorage, but in other situations, other interfaces are used. To
            initialize the object, there must be a subsequent call to an appropriate method in the initializing interface. Common
            initialization functions include IPersistStorage::InitNew (for new, blank embeddable components), IPersistStorage::Load (for
            reloaded embeddable components), IPersistStream::Load, (for objects stored in a stream object) or IPersistFile::Load (for
            objects stored in a file).
            </para>
            <para>
            In general, if an application supports only one class of objects, and the class object is registered for single use, only one
            object can be created. The application must not create other objects, and a request to do so should return an error from
            <c>IClassFactory::CreateInstance</c>. The same is true for applications that support multiple classes, each with a class
            object registered for single use; a call to <c>CreateInstance</c> for one class followed by a call to <c>CreateInstance</c>
            for any of the classes that should return an error.
            </para>
            <para>
            To avoid returning an error, applications that support multiple classes with single-use class objects can revoke the
            registered class object of the first class by calling CoRevokeClassObject when a request for instantiating a second is
            received. For example, suppose there are two classes, A and B. When <c>CreateInstance</c> is called for class A, revoke the
            class object for B. When B is created, revoke the class object for A. This solution complicates shutdown because one of the
            class objects might have already been revoked (and cannot be revoked twice).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory.LockServer(System.Boolean)">
            <summary>Locks an object application open in memory. This enables instances to be created more quickly.</summary>
            <param name="fLock">If <c>TRUE</c>, increments the lock count; if <c>FALSE</c>, decrements the lock count.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.</returns>
            <remarks>
            <para>
            <c>IClassFactory::LockServer</c> controls whether an object's server is kept in memory. Keeping the application alive in
            memory allows instances to be created more quickly.
            </para>
            <para>Notes to Callers</para>
            <para>
            Most clients do not need to call this method. It is provided only for those clients that require special performance in
            creating multiple instances of their objects.
            </para>
            <para>Notes to Implementers</para>
            <para>
            If the lock count is zero, there are no more objects in use, and the application is not under user control, the server can be
            closed. One way to implement <c>LockServer</c> is to call the CoLockObjectExternal function.
            </para>
            <para>
            The process that locks the object application is responsible for unlocking it. After the class object is released, there is
            no mechanism that guarantees the caller connection to the same class later (as in the case where a class object is registered
            as single-use). It is important to count all calls, not just the last one, to <c>LockServer</c>, because calls must be
            balanced before attempting to release the pointer to the IClassFactory interface on the class object or an error results. For
            every call to <c>LockServer</c> with fLock set to <c>TRUE</c>, there must be a call to <c>LockServer</c> with fLock set to
            <c>FALSE</c>. When the lock count and the class object reference count are both zero, the class object can be freed.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.IClassFactory2">
            <summary>
            <para>Enables a class factory object, in any sort of object server, to control object creation through licensing.</para>
            <para>
            This interface is an extension to IClassFactory. This extension enables a class factory executing on a licensed machine to
            provide a license key that can be used later to create an object instance on an unlicensed machine. Such considerations are
            important for objects like controls that are used to build applications on a licensed machine. Subsequently, the application
            built must be able to run on an unlicensed machine. The license key gives only that one client application the right to
            instantiate objects through <c>IClassFactory2</c> when a full machine license does not exist.
            </para>
            </summary>
            <seealso cref="T:Vanara.PInvoke.Ole32.IClassFactory"/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory2.CreateInstance(System.Object,System.Guid@,System.Object@)">
            <summary>Creates an uninitialized object.</summary>
            <param name="pUnkOuter">
            If the object is being created as part of an aggregate, specify a pointer to the controlling IUnknown interface of the
            aggregate. Otherwise, this parameter must be <c>NULL</c>.
            </param>
            <param name="riid">
            A reference to the identifier of the interface to be used to communicate with the newly created object. If pUnkOuter is
            <c>NULL</c>, this parameter is generally the IID of the initializing interface; if pUnkOuter is non- <c>NULL</c>, riid must
            be IID_IUnknown.
            </param>
            <param name="ppvObject">
            The address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObject
            contains the requested interface pointer. If the object does not support the interface specified in riid, the implementation
            must set *ppvObject to <c>NULL</c>.
            </param>
            <returns>
            <para>
            This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The specified object was created.</term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>The pUnkOuter parameter was non-NULL and the object does not support aggregation.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object that ppvObject points to does not support the interface identified by riid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A COM server's implementation of <c>CreateInstance</c> must return a reference to an object contained in an apartment that
            belongs to the server's DCOM resolver. It must not return a reference to an object that is contained in a remote apartment.
            </para>
            <para>
            The IClassFactory interface is always on a class object. The <c>CreateInstance</c> method creates an uninitialized object of
            the class identified with the specified CLSID. When an object is created in this way, the CLSID must be registered in the
            system registry with the CoRegisterClassObject function.
            </para>
            <para>
            The pUnkOuter parameter indicates whether the object is being created as part of an aggregate. Object definitions are not
            required to support aggregation â€” they must be specifically designed and implemented to support it.
            </para>
            <para>
            The riid parameter specifies the IID (interface identifier) of the interface through which you will communicate with the new
            object. If pUnkOuter is non- <c>NULL</c> (indicating aggregation), the value of the riid parameter must be IID_IUnknown. If
            the object is not part of an aggregate, riid often specifies the interface though which the object will be initialized.
            </para>
            <para>
            For OLE embeddings, the initialization interface is IPersistStorage, but in other situations, other interfaces are used. To
            initialize the object, there must be a subsequent call to an appropriate method in the initializing interface. Common
            initialization functions include IPersistStorage::InitNew (for new, blank embeddable components), IPersistStorage::Load (for
            reloaded embeddable components), IPersistStream::Load, (for objects stored in a stream object) or IPersistFile::Load (for
            objects stored in a file).
            </para>
            <para>
            In general, if an application supports only one class of objects, and the class object is registered for single use, only one
            object can be created. The application must not create other objects, and a request to do so should return an error from
            <c>IClassFactory::CreateInstance</c>. The same is true for applications that support multiple classes, each with a class
            object registered for single use; a call to <c>CreateInstance</c> for one class followed by a call to <c>CreateInstance</c>
            for any of the classes that should return an error.
            </para>
            <para>
            To avoid returning an error, applications that support multiple classes with single-use class objects can revoke the
            registered class object of the first class by calling CoRevokeClassObject when a request for instantiating a second is
            received. For example, suppose there are two classes, A and B. When <c>CreateInstance</c> is called for class A, revoke the
            class object for B. When B is created, revoke the class object for A. This solution complicates shutdown because one of the
            class objects might have already been revoked (and cannot be revoked twice).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory2.LockServer(System.Boolean)">
            <summary>Locks an object application open in memory. This enables instances to be created more quickly.</summary>
            <param name="fLock">If <c>TRUE</c>, increments the lock count; if <c>FALSE</c>, decrements the lock count.</param>
            <returns>This method can return the standard return values E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL, and S_OK.</returns>
            <remarks>
            <para>
            <c>IClassFactory::LockServer</c> controls whether an object's server is kept in memory. Keeping the application alive in
            memory allows instances to be created more quickly.
            </para>
            <para>Notes to Callers</para>
            <para>
            Most clients do not need to call this method. It is provided only for those clients that require special performance in
            creating multiple instances of their objects.
            </para>
            <para>Notes to Implementers</para>
            <para>
            If the lock count is zero, there are no more objects in use, and the application is not under user control, the server can be
            closed. One way to implement <c>LockServer</c> is to call the CoLockObjectExternal function.
            </para>
            <para>
            The process that locks the object application is responsible for unlocking it. After the class object is released, there is
            no mechanism that guarantees the caller connection to the same class later (as in the case where a class object is registered
            as single-use). It is important to count all calls, not just the last one, to <c>LockServer</c>, because calls must be
            balanced before attempting to release the pointer to the IClassFactory interface on the class object or an error results. For
            every call to <c>LockServer</c> with fLock set to <c>TRUE</c>, there must be a call to <c>LockServer</c> with fLock set to
            <c>FALSE</c>. When the lock count and the class object reference count are both zero, the class object can be freed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory2.GetLicInfo(Vanara.PInvoke.Ole32.LICINFO@)">
            <summary>Retrieves information about the licensing capabilities of this class factory.</summary>
            <param name="pLicInfo">A pointer to the caller-allocated LICINFO structure to be filled on output.</param>
            <returns>
            <para>This method can return the standard return values E_UNEXPECTED, as well as the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The LICINFO structure was successfully filled in.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in pLicInfo is not valid. For example, it may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Notes to Implementers</para>
            <para>
            E_NOTIMPL is not allowed as a return value because this method provides critical information for the client of a licensed
            class factory.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory2.RequestLicKey(System.UInt32,System.String@)">
            <summary>Creates a license key that the caller can save and use later to create an instance of the licensed object.</summary>
            <param name="dwReserved">This parameter is reserved and must be zero.</param>
            <param name="pBstrKey">
            A pointer to the caller-allocated variable that receives the callee-allocated license key on successful return from this
            method. This parameter is set to <c>NULL</c> on any failure.
            </param>
            <returns>
            <para>
            This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The license key was successfully created.</term>
            </item>
            <item>
            <term>E_NOTIMPL</term>
            <term>This class factory does not support run-time license keys.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address passed in pbstrKey is not valid. For example, it may be NULL.</term>
            </item>
            <item>
            <term>CLASS_E_NOTLICENSED</term>
            <term>
            This class factory supports run-time licensing, but the current machine itself is not licensed. Thus, a run-time key is not
            available on this machine.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The caller can save the license key for subsequent calls to IClassFactory2::CreateInstanceLic to create objects on an
            otherwise unlicensed machine.
            </para>
            <para>Notes to Callers</para>
            <para>
            The caller must free the <c>BSTR</c> with the SysFreeString function when the key is no longer needed. The value of
            fRuntimeKeyAvail is returned through a previous call to IClassFactory2::GetLicInfo.
            </para>
            <para>Notes to Implementers</para>
            <para>
            This method allocates the <c>BSTR</c> key with SysAllocString or SysAllocStringLen, and the caller becomes responsible for
            this <c>BSTR</c> after this method returns successfully.
            </para>
            <para>This method need not be implemented when a class factory does not support run-time license keys.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.IClassFactory2.CreateInstanceLic(System.Object,System.Object,System.Guid@,System.String,System.Object@)">
            <summary>
            Creates an instance of the licensed object for the specified license key. This method is the only possible means to create an
            object on an otherwise unlicensed machine.
            </summary>
            <param name="pUnkOuter">
            A pointer to the controlling IUnknown interface on the outer unknown if this object is being created as part of an aggregate.
            If the object is not part of an aggregate, this parameter must be <c>NULL</c>.
            </param>
            <param name="pUnkReserved">This parameter is unused and must be <c>NULL</c>.</param>
            <param name="riid">A reference to the identifier of the interface to be used to communicate with the newly created object.</param>
            <param name="bstrKey">
            Run-time license key previously obtained from IClassFactory2::RequestLicKey that is required to create an object.
            </param>
            <param name="ppvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains
            the requested interface pointer. If an error occurs, the implementation must set *ppvObj to <c>NULL</c>.
            </param>
            <returns>
            <para>
            This method can return the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The license was successfully created.</term>
            </item>
            <item>
            <term>E_NOTIMPL</term>
            <term>This method is not implemented because objects can only be created on fully licensed machines through IClassFactory::CreateInstance.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>A pointer passed in bstrKey or ppvObj is not valid. For example, it may be NULL.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>
            The object can be created (and the license key is valid) except the object does not support the interface specified by riid.
            </term>
            </item>
            <item>
            <term>CLASS_E_NOAGGREGATION</term>
            <term>The pUnkOuter parameter is non-NULL, but this object class does not support aggregation.</term>
            </item>
            <item>
            <term>CLASS_E_NOTLICENSED</term>
            <term>The key provided in bstrKey is not a valid license key.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Notes to Implementers</para>
            <para>
            If the class factory does not provide a license key (that is, IClassFactory2::RequestLicKey returns E_NOTIMPL and the
            <c>fRuntimeKeyAvail</c> member in LICINFO is set to <c>FALSE</c> in IClassFactory2::GetLicInfo), then this method can also
            return E_NOTIMPL. In such cases, the class factory is implementing IClassFactory2 simply to specify whether the machine is
            licensed at all through the <c>fLicVerified</c> member of <c>LICINFO</c>.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.LICINFO">
            <summary>
            <para>
            Contains parameters that describe the licensing behavior of a class factory that supports licensing. The structure is filled by
            calling the IClassFactory2::GetLicInfo method.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LICINFO.cbLicInfo">
            <summary>
            <para>The size of the structure, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LICINFO.fRuntimeKeyAvail">
            <summary>
            <para>
            Indicates whether this class factory allows the creation of its objects on an unlicensed machine through the use of a license
            key. If <c>TRUE</c>, IClassFactory2::RequestLicKey can be called to obtain the key. If <c>FALSE</c>, objects can be created
            only on a fully licensed machine.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.LICINFO.fLicVerified">
            <summary>
            <para>
            Indicates whether a full machine license exists such that calls to IClassFactory::CreateInstance and
            IClassFactory2::RequestLicKey will succeed. If <c>TRUE</c>, the full machine license exists. Thus, objects can be created
            freely. and a license key is available if <c>fRuntimeKeyAvail</c> is also <c>TRUE</c>. If <c>FALSE</c>, this class factory
            cannot create any instances of objects on this machine unless the proper license key is passed to IClassFactory2::CreateInstanceLic.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.MSHCTX">
            <summary>Specifies the destination context, which is the process in which the unmarshaling is to be done.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_LOCAL">
            <summary>The unmarshaling process is local and has shared memory access with the marshaling process.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_NOSHAREDMEM">
            <summary>The unmarshaling process does not have shared memory access with the marshaling process.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_DIFFERENTMACHINE">
            <summary>
            The unmarshaling process is on a different computer. The marshaling code cannot assume that a particular piece of
            application code is installed on that computer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_INPROC">
            <summary>The unmarshaling will be done in another apartment in the same process.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_CROSSCTX">
            <summary>Create a new context in the current apartment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHCTX.MSHCTX_RESERVED1">
            <summary>Reserved</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.MSHLFLAGS">
            <summary>Specifies why the marshaling is to be done.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_NORMAL">
            <summary>
            The marshaling is occurring because an interface pointer is being passed from one process to another. This is the normal
            case. The data packet produced by the marshaling process will be unmarshaled in the destination process. The marshaled data
            packet can be unmarshaled just once, or not at all. If the receiver unmarshals the data packet successfully, the
            CoReleaseMarshalData function is automatically called on the data packet as part of the unmarshaling process. If the
            receiver does not or cannot unmarshal the data packet, the sender must call CoReleaseMarshalData on the data packet.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_TABLESTRONG">
            <summary>
            The marshaling is occurring because the data packet is to be stored in a globally accessible table from which it can be
            unmarshaled one or more times, or not at all. The presence of the data packet in the table counts as a strong reference to
            the interface being marshaled, meaning that it is sufficient to keep the object alive. When the data packet is removed from
            the table, the table implementer must call the CoReleaseMarshalData function on the data packet.
            <para>
            MSHLFLAGS_TABLESTRONG is used by the RegisterDragDrop function when registering a window as a drop target. This keeps the
            window registered as a drop target no matter how many times the end user drags across the window. The RevokeDragDrop
            function calls CoReleaseMarshalData.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_TABLEWEAK">
            <summary>
            The marshaling is occurring because the data packet is to be stored in a globally accessible table from which it can be
            unmarshaled one or more times, or not at all. However, the presence of the data packet in the table acts as a weak reference
            to the interface being marshaled, meaning that it is not sufficient to keep the object alive. When the data packet is
            removed from the table, the table implementer must call the CoReleaseMarshalData function on the data packet.
            <para>
            MSHLFLAGS_TABLEWEAK is typically used when registering an object in the running object table (ROT). This prevents the
            object's entry in the ROT from keeping the object alive in the absence of any other connections. See
            IRunningObjectTable::Register for more information.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_NOPING">
            <summary>
            Adding this flag to an original object marshaling (as opposed to marshaling a proxy) will disable the ping protocol for that object.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_RESERVED1">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_RESERVED2">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_RESERVED3">
            <summary>Reserved</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.MSHLFLAGS.MSHLFLAGS_RESERVED4">
            <summary>Reserved</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STATFLAG">
            <summary>
            Indicates whether the method should try to return a name in the pwcsName member of the STATSTG structure. The values are used in
            the ILockBytes::Stat, IStorage::Stat, and IStream::Stat methods to save memory when the pwcsName member is not required.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATFLAG.STATFLAG_DEFAULT">
            <summary>Requests that the statistics include the pwcsName member of the STATSTG structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATFLAG.STATFLAG_NONAME">
            <summary>
            Requests that the statistics not include the pwcsName member of the STATSTG structure. If the name is omitted, there is no
            need for the ILockBytes::Stat, IStorage::Stat, and IStream::Stat methods to allocate and free memory for the string value of
            the name, therefore the method reduces time and resources used in an allocation and free operation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STATFLAG.STATFLAG_NOOPEN">
            <summary>Not implemented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STGC">
            <summary>Specify the conditions for performing the commit operation in the IStorage::Commit and IStream::Commit methods.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGC.STGC_DEFAULT">
            <summary>
            You can specify this condition with STGC_CONSOLIDATE, or some combination of the other three flags in this list of elements.
            Use this value to increase the readability of code.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGC.STGC_OVERWRITE">
            <summary>
            The commit operation can overwrite existing data to reduce overall space requirements. This value is not recommended for
            typical usage because it is not as robust as the default value. In this case, it is possible for the commit operation to
            fail after the old data is overwritten, but before the new data is completely committed. Then, neither the old version nor
            the new version of the storage object will be intact.
            <para>You can use this value in the following cases:</para>
            <list type="bullet">
            <item>
            <term>The user is willing to risk losing the data.</term>
            </item>
            <item>
            <term>The low-memory save sequence will be used to safely save the storage object to a smaller file.</term>
            </item>
            <item>
            <term>
            A previous commit returned STG_E_MEDIUMFULL, but overwriting the existing data would provide enough space to commit changes
            to the storage object.
            </term>
            </item>
            </list>
            <para>
            Be aware that the commit operation verifies that adequate space exists before any overwriting occurs. Thus, even with this
            value specified, if the commit operation fails due to space requirements, the old data is safe. It is possible, however, for
            data loss to occur with the STGC_OVERWRITE value specified if the commit operation fails for any reason other than lack of
            disk space.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGC.STGC_ONLYIFCURRENT">
            <summary>
            Prevents multiple users of a storage object from overwriting each other's changes. The commit operation occurs only if there
            have been no changes to the saved storage object because the user most recently opened it. Thus, the saved version of the
            storage object is the same version that the user has been editing. If other users have changed the storage object, the
            commit operation fails and returns the STG_E_NOTCURRENT value. To override this behavior, call the IStorage::Commit or
            IStream::Commit method again using the STGC_DEFAULT value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGC.STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE">
            <summary>
            Commits the changes to a write-behind disk cache, but does not save the cache to the disk. In a write-behind disk cache, the
            operation that writes to disk actually writes to a disk cache, thus increasing performance. The cache is eventually written
            to the disk, but usually not until after the write operation has already returned. The performance increase comes at the
            expense of an increased risk of losing data if a problem occurs before the cache is saved and the data in the cache is lost.
            <para>
            If you do not specify this value, then committing changes to root-level storage objects is robust even if a disk cache is
            used. The two-phase commit process ensures that data is stored on the disk and not just to the disk cache.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGC.STGC_CONSOLIDATE">
            <summary>
            Windows 2000 and Windows XP: Indicates that a storage should be consolidated after it is committed, resulting in a smaller
            file on disk. This flag is valid only on the outermost storage object that has been opened in transacted mode. It is not
            valid for streams. The STGC_CONSOLIDATE flag can be combined with any other STGC flags.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.STGMOVE">
            <summary>Indicate whether a storage element is to be moved or copied. They are used in the IStorage::MoveElementTo method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGMOVE.STGMOVE_MOVE">
            <summary>Indicates that the method should move the data from the source to the destination.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGMOVE.STGMOVE_COPY">
            <summary>
            Indicates that the method should copy the data from the source to the destination. A copy is the same as a move except that
            the source element is not removed after copying the element to the destination. Copying an element on top of itself is undefined.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.STGMOVE.STGMOVE_SHALLOWCOPY">
            <summary>Not implemented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.TYSPEC">
            <summary>Specifies a mapping for a class ID.</summary>
            <remarks>
            The TYSPEC enumeration and uCLSSPEC union provide mappings to a class ID. Note that TYSPEC_CLSID is the only supported value.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_CLSID">
            <summary>A CLSID.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_FILEEXT">
            <summary>A file name extension.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_MIMETYPE">
            <summary>A MIME type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_FILENAME">
            <summary>A file name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_PROGID">
            <summary>A PROGID.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_PACKAGENAME">
            <summary>A package name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.TYSPEC.TYSPEC_OBJECTID">
            <summary>An object ID.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.VARTYPE">
            <summary>Equivalent to <see cref="T:System.Runtime.InteropServices.VarEnum"/>, but cast to <see cref="T:System.UInt16"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_EMPTY">
            <summary>Not specified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_NULL">
            <summary>Null.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_I2">
            <summary>A 2-byte integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_I4">
            <summary>A 4-byte integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_R4">
            <summary>A 4-byte real.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_R8">
            <summary>A 8-byte real.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_CY">
            <summary>Currency</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_DATE">
            <summary>A date.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_BSTR">
            <summary>A string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_DISPATCH">
            <summary>An IDispatch pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_ERROR">
            <summary>An SCODE value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_BOOL">
            <summary>A Boolean value. True is -1 and false is 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_VARIANT">
            <summary>A variant pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UNKNOWN">
            <summary>An IUnknown pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_DECIMAL">
            <summary>A 16-byte fixed-point value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_I1">
            <summary>A character.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UI1">
            <summary>An unsigned character.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UI2">
            <summary>An unsigned short.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UI4">
            <summary>An unsigned long.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_I8">
            <summary>A 64-bit integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UI8">
            <summary>A 64-bit unsigned integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_INT">
            <summary>An integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_UINT">
            <summary>An unsigned integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_VOID">
            <summary>A C-style void.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_HRESULT">
            <summary>A C-style void.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_PTR">
            <summary>A pointer type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_SAFEARRAY">
            <summary>A safe array. Use VT_ARRAY in VARIANT.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_CARRAY">
            <summary>A C-style array.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_USERDEFINED">
            <summary>A user-defined type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_LPSTR">
            <summary>A null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_LPWSTR">
            <summary>A wide null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_RECORD">
            <summary>A user-defined type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_FILETIME">
            <summary>A FILETIME value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_BLOB">
            <summary>Length-prefixed bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_STREAM">
            <summary>The name of the stream follows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_STORAGE">
            <summary>The name of the storage follows.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_STREAMED_OBJECT">
            <summary>The stream contains an object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_STORED_OBJECT">
            <summary>The storage contains an object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_BLOB_OBJECT">
            <summary>The blob contains an object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_CF">
            <summary>A clipboard format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_CLSID">
            <summary>A class ID (GUID).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_VERSIONED_STREAM">
            <summary>A stream with a GUID version.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_VECTOR">
            <summary>A simple counted array.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_ARRAY">
            <summary>A SAFEARRAY pointer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.VARTYPE.VT_BYREF">
            <summary>A void pointer for local use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.CSPLATFORM">
            <summary>Contains an operating system platform and processor architecture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CSPLATFORM.dwPlatformId">
            <summary>The operating system platform. See the <c>dwPlatformId</c> member of OSVERSIONINFO.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CSPLATFORM.dwVersionHi">
            <summary>The major version of the operating system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CSPLATFORM.dwVersionLo">
            <summary>The minor version of the operating system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.CSPLATFORM.dwProcessorArch">
            <summary>The processor architecture. See the <c>wProcessorArchitecture</c> member of SYSTEM_INFO.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.QUERYCONTEXT">
            <summary>Contains a list of attributes used to look up a class implementation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.QUERYCONTEXT.dwContext">
            <summary>The execution context.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.QUERYCONTEXT.Platform">
            <summary>The operating system platform and processor architecture. For more information, see CSPLATFORM.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.QUERYCONTEXT.Locale">
            <summary>The locale identifier. For more information, see Language Identifier Constants and Strings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.QUERYCONTEXT.dwVersionHi">
            <summary>The high version number.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.QUERYCONTEXT.dwVersionLo">
            <summary>The low version number.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.uCLSSPEC">
            <summary>Specifies a mapping for a class ID.</summary>
            <remarks>
            The TYSPEC enumeration and uCLSSPEC union provide mappings to a class ID. Note that TYSPEC_CLSID is the only supported value.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.tyspec">
            <summary>The union type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.tagged_union">
            <summary>The union.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion">
            <summary>The union.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.clsid">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.pFileExt">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.pMimeType">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.pProgId">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.pFileName">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.ByName">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.ByObjectId">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYNAME">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYNAME.pPackageName">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYNAME.PolicyId">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYOBJECTID">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYOBJECTID.ObjectId">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.uCLSSPEC.SpecUnion.BYOBJECTID.PolicyId">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY">
            <summary>Specifies the FMTID/PID identifier that programmatically identifies a property. Replaces SHCOLUMNID.</summary>
            <remarks>
            <para>As of Windows Vista, the SHCOLUMNID structure is simply an alias for PROPERTYKEY, as shown in this declaration from Shobjidl.h.</para>
            <para>SHCOLUMNID can be considered a legacy structure with PROPERTYKEY being the new, preferred form. <c>PROPERTYKEY</c> has a broader purpose than <c>SHCOLUMNID</c>, and the new name is more descriptive of its uses.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPERTYKEY.fmtid">
            <summary>
              <para>Type: <c>GUID</c></para>
              <para>A unique GUID for the property.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPERTYKEY.pid">
            <summary>
              <para>Type: <c>DWORD</c></para>
              <para>A property identifier (PID). This parameter is not used as in SHCOLUMNID. It is recommended that you set this value to PID_FIRST_USABLE. Any value greater than or equal to 2 is acceptable.</para>
              <para>
                <c>Note</c> Values of 0 and 1 are reserved and should not be used.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.#ctor(System.Guid,System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ole32.PROPERTYKEY" /> struct.
            </summary>
            <param name="key">The key.</param>
            <param name="id">The identifier.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.Key">
            <summary>
            A unique GUID for the property.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.Id">
            <summary>
            <para>A property identifier (PID). This parameter is not used as in SHCOLUMNID. It is recommended that you set this value to PID_FIRST_USABLE. Any value greater than or equal to 2 is acceptable.</para>
            <para>
              <c>Note</c> Values of 0 and 1 are reserved and should not be used.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.Equals(Vanara.PInvoke.Ole32.PROPERTYKEY)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.op_Equality(Vanara.PInvoke.Ole32.PROPERTYKEY,Vanara.PInvoke.Ole32.PROPERTYKEY)">
            <summary>Implements the equality operator.</summary>
            <param name="pk1">The first key.</param>
            <param name="pk2">The second key.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.op_Inequality(Vanara.PInvoke.Ole32.PROPERTYKEY,Vanara.PInvoke.Ole32.PROPERTYKEY)">
            <summary>Implements the inequality operator.</summary>
            <param name="pk1">The first key.</param>
            <param name="pk2">The second key.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.System#IComparable{Vanara#PInvoke#Ole32#PROPERTYKEY}#CompareTo(Vanara.PInvoke.Ole32.PROPERTYKEY)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.GetCanonicalName">
            <summary>
            Gets the canonical name of the key.
            </summary>
            <returns>The name returned from PSGetNameFromPropertyKey.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ole32.PROPERTYKEY.ReverseLookup(Vanara.PInvoke.Ole32.PROPERTYKEY)">
            <summary>Provided a key, use reflection to do a reverse lookup and find the string value.</summary>
            <param name="key">The key.</param>
            <returns>The string value of the name.</returns>
        </member>
        <member name="F:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Thumbnail">
            <summary>
            <para>Name:     System.Thumbnail -- PKEY_Thumbnail</para>
            <para>Description: A data that represents the thumbnail in VT_CF format.</para>
            <para>Type:     Clipboard -- VT_CF</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 17 (PIDSI_THUMBNAIL)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AcquisitionID">
            <summary>
            <para>Name:     System.AcquisitionID -- PKEY_AcquisitionID</para>
            <para>Description: Hash to determine acquisition session.</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {65A98875-3C80-40AB-ABBC-EFDAF77DBEE2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ApplicationName">
            <summary>
            <para>Name:     System.ApplicationName -- PKEY_ApplicationName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR) Legacy code may treat this as VT_LPSTR.</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 18 (PIDSI_APPNAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Author">
            <summary>
            <para>Name:     System.Author -- PKEY_Author</para>
            <para>Description:</para>
            <para>
            Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR) Legacy code may treat this as VT_LPSTR.
            </para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 4 (PIDSI_AUTHOR)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Capacity">
            <summary>
            <para>Name:     System.Capacity -- PKEY_Capacity</para>
            <para>Description: The amount of total space in bytes.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>
            FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 3 (PID_VOLUME_CAPACITY) (Filesystem Volume Properties)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Category">
            <summary>
            <para>Name:     System.Category -- PKEY_Category</para>
            <para>Description: Legacy code treats this as VT_LPSTR.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 2 (PIDDSI_CATEGORY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Comment">
            <summary>
            <para>Name:     System.Comment -- PKEY_Comment</para>
            <para>Description: Comments.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR) Legacy code may treat this as VT_LPSTR.</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 6 (PIDSI_COMMENTS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Company">
            <summary>
            <para>Name:     System.Company -- PKEY_Company</para>
            <para>Description: The company or publisher.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 15 (PIDDSI_COMPANY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ComputerName">
            <summary>
            <para>Name:     System.ComputerName -- PKEY_ComputerName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 5 (PID_COMPUTERNAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ContainedItems">
            <summary>
            <para>Name:     System.ContainedItems -- PKEY_ContainedItems</para>
            <para>
            Description: The list of type of items, this item contains. For example, this item contains urls, attachments etc. This
            is represented as a vector array of GUIDs where each GUID represents certain type.
            </para>
            <para>Type:     Multivalue Guid -- VT_VECTOR | VT_CLSID (For variants: VT_ARRAY | VT_CLSID)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 29</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ContentStatus">
            <summary>
            <para>Name:     System.ContentStatus -- PKEY_ContentStatus</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 27</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ContentType">
            <summary>
            <para>Name:     System.ContentType -- PKEY_ContentType</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 26</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Copyright">
            <summary>
            <para>Name:     System.Copyright -- PKEY_Copyright</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 11 (PIDMSI_COPYRIGHT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateAccessed">
            <summary>
            <para>Name:     System.DateAccessed -- PKEY_DateAccessed</para>
            <para>Description: The time of the last access to the item. The Indexing Service friendly name is 'access'.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 16 (PID_STG_ACCESSTIME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateAcquired">
            <summary>
            <para>Name:     System.DateAcquired -- PKEY_DateAcquired</para>
            <para>
            Description: The time the file entered the system via acquisition. This is not the same as System.DateImported. Examples
            are when pictures are acquired from a camera, or when music is purchased online.
            </para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {2CBAA8F5-D81F-47CA-B17A-F8D822300131}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateArchived">
            <summary>
            <para>Name:     System.DateArchived -- PKEY_DateArchived</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {43F8D7B7-A444-4F87-9383-52271C9B915C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateCompleted">
            <summary>
            <para>Name:     System.DateCompleted -- PKEY_DateCompleted</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {72FAB781-ACDA-43E5-B155-B2434F85E678}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateCreated">
            <summary>
            <para>Name:     System.DateCreated -- PKEY_DateCreated</para>
            <para>Description: The date and time the item was created. The Indexing Service friendly name is 'create'.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 15 (PID_STG_CREATETIME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateImported">
            <summary>
            <para>Name:     System.DateImported -- PKEY_DateImported</para>
            <para>
            Description: The time the file is imported into a separate database. This is not the same as System.DateAcquired. (Eg,
            2003:05:22 13:55:04)
            </para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 18258</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DateModified">
            <summary>
            <para>Name:     System.DateModified -- PKEY_DateModified</para>
            <para>Description: The date and time of the last write to the item. The Indexing Service friendly name is 'write'.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 14 (PID_STG_WRITETIME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DescriptionID">
            <summary>
            <para>Name:     System.DescriptionID -- PKEY_DescriptionID</para>
            <para>Description: The contents of a SHDESCRIPTIONID structure as a buffer of bytes.</para>
            <para>Type:     Buffer -- VT_VECTOR | VT_UI1 (For variants: VT_ARRAY | VT_UI1)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 2 (PID_DESCRIPTIONID)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DueDate">
            <summary>
            <para>Name:     System.DueDate -- PKEY_DueDate</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {3F8472B5-E0AF-4DB2-8071-C53FE76AE7CE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.EndDate">
            <summary>
            <para>Name:     System.EndDate -- PKEY_EndDate</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {C75FAA05-96FD-49E7-9CB4-9F601082D553}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileAllocationSize">
            <summary>
            <para>Name:     System.FileAllocationSize -- PKEY_FileAllocationSize</para>
            <para>Description:</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 18 (PID_STG_ALLOCSIZE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileAttributes">
            <summary>
            <para>Name:     System.FileAttributes -- PKEY_FileAttributes</para>
            <para>Description: This is the WIN32_FIND_DATA dwFileAttributes for the file-based item.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 13 (PID_STG_ATTRIBUTES)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileCount">
            <summary>
            <para>Name:     System.FileCount -- PKEY_FileCount</para>
            <para>Description:</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 12</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileDescription">
            <summary>
            <para>Name:     System.FileDescription -- PKEY_FileDescription</para>
            <para>Description: This is a user-friendly description of the file.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 3 (PIDVSI_FileDescription)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileExtension">
            <summary>
            <para>Name:     System.FileExtension -- PKEY_FileExtension</para>
            <para>
            Description: This is the file extension of the file based item, including the leading period. If System.FileName is
            VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from
            System.FileName. If System.FileName does not have a file extension, this value should be VT_EMPTY. To obtain the type of
            any item (including an item that is not a file), use System.ItemType. Example values: If the path is... The property
            value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" ".txt"
            "\\server\share\mydir\goodnews.doc" ".doc" "\\server\share\numbers.xls" ".xls" "\\server\share\folder" VT_EMPTY
            "c:\foo\MyFolder" VT_EMPTY [desktop] VT_EMPTY
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E4F10A3C-49E6-405D-8288-A23BD4EEAA6C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileFRN">
            <summary>
            <para>Name:     System.FileFRN -- PKEY_FileFRN</para>
            <para>
            Description: This is the unique file ID, also known as the File Reference Number. For a given file, this is the same
            value as is found in the structure variable FILE_ID_BOTH_DIR_INFO.FileId, via GetFileInformationByHandleEx().
            </para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 21 (PID_STG_FRN)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileName">
            <summary>
            <para>Name:     System.FileName -- PKEY_FileName</para>
            <para>
            Description: This is the file name (including extension) of the file. It is possible that the item might not exist on a
            filesystem (ie, it may not be opened using CreateFile). Nonetheless, if the item is represented as a file from the
            logical sense (and its name follows standard Win32 file-naming syntax), then the data source should emit this property.
            If an item is not a file, then the value for this property is VT_EMPTY. See System.ItemNameDisplay. This has the same
            value as System.ParsingName for items that are provided by the Shell's file folder. Example values: If the path is... The
            property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "hello.txt"
            "\\server\share\mydir\goodnews.doc" "goodnews.doc" "\\server\share\numbers.xls" "numbers.xls" "c:\foo\MyFolder"
            "MyFolder" (email message) VT_EMPTY (song on portable device) "song.wma"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {41CF5AE0-F75A-4806-BD87-59C7D9248EB9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileOwner">
            <summary>
            <para>Name:     System.FileOwner -- PKEY_FileOwner</para>
            <para>Description: This is the owner of the file, according to the file system.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Misc) {9B174B34-40FF-11D2-A27E-00C04FC30871}, 4 (PID_MISC_OWNER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FileVersion">
            <summary>
            <para>Name:     System.FileVersion -- PKEY_FileVersion</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 4 (PIDVSI_FileVersion)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FindData">
            <summary>
            <para>Name:     System.FindData -- PKEY_FindData</para>
            <para>Description: WIN32_FIND_DATAW in buffer of bytes.</para>
            <para>Type:     Buffer -- VT_VECTOR | VT_UI1 (For variants: VT_ARRAY | VT_UI1)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 0 (PID_FINDDATA)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FlagColor">
            <summary>
            <para>Name:     System.FlagColor -- PKEY_FlagColor</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {67DF94DE-0CA7-4D6F-B792-053A3E4F03CF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FlagColorText">
            <summary>
            <para>Name:     System.FlagColorText -- PKEY_FlagColorText</para>
            <para>
            Description: This is the user-friendly form of System.FlagColor. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {45EAE747-8E2A-40AE-8CBF-CA52ABA6152A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FlagStatus">
            <summary>
            <para>Name:     System.FlagStatus -- PKEY_FlagStatus</para>
            <para>Description: Status of Flag. Values: (0=none 1=white 2=Red). cdoPR_FLAG_STATUS</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 12</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FlagStatusText">
            <summary>
            <para>Name:     System.FlagStatusText -- PKEY_FlagStatusText</para>
            <para>
            Description: This is the user-friendly form of System.FlagStatus. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DC54FD2E-189D-4871-AA01-08C2F57A4ABC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FreeSpace">
            <summary>
            <para>Name:     System.FreeSpace -- PKEY_FreeSpace</para>
            <para>Description: The amount of free space in bytes.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>
            FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 2 (PID_VOLUME_FREE) (Filesystem Volume Properties)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.FullText">
            <summary>
            <para>Name:     System.FullText -- PKEY_FullText</para>
            <para>
            Description: This PKEY is used to specify search terms that should be applied as broadly as possible, across all valid
            properties for the data source(s) being searched. It should not be emitted from a data source.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {1E3EE840-BC2B-476C-8237-2ACD1A839B22}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IdentityProperty">
            <summary>
            <para>Name:     System.Identity -- PKEY_Identity</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A26F4AFC-7346-4299-BE47-EB1AE613139F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ImageParsingName">
            <summary>
            <para>Name:     System.ImageParsingName -- PKEY_ImageParsingName</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D7750EE0-C6A4-48EC-B53E-B87B52E6D073}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Importance">
            <summary>
            <para>Name:     System.Importance -- PKEY_Importance</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ImportanceText">
            <summary>
            <para>Name:     System.ImportanceText -- PKEY_ImportanceText</para>
            <para>
            Description: This is the user-friendly form of System.Importance. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A3B29791-7713-4E1D-BB40-17DB85F01831}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.InfoTipText">
            <summary>
            <para>Name:     System.InfoTipText -- PKEY_InfoTipText</para>
            <para>Description: The text (with formatted property values) to show in the infotip.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 17</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.InternalName">
            <summary>
            <para>Name:     System.InternalName -- PKEY_InternalName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 5 (PIDVSI_InternalName)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsAttachment">
            <summary>
            <para>Name:     System.IsAttachment -- PKEY_IsAttachment</para>
            <para>Description: Identifies if this item is an attachment.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {F23F425C-71A1-4FA8-922F-678EA4A60408}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsDefaultNonOwnerSaveLocation">
            <summary>
            <para>Name:     System.IsDefaultNonOwnerSaveLocation -- PKEY_IsDefaultNonOwnerSaveLocation</para>
            <para>Description: Identifies the default save location for a library for non-owners of the library</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsDefaultSaveLocation">
            <summary>
            <para>Name:     System.IsDefaultSaveLocation -- PKEY_IsDefaultSaveLocation</para>
            <para>Description: Identifies the default save location for a library for the owner of the library</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsDeleted">
            <summary>
            <para>Name:     System.IsDeleted -- PKEY_IsDeleted</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5CDA5FC8-33EE-4FF3-9094-AE7BD8868C4D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsEncrypted">
            <summary>
            <para>Name:     System.IsEncrypted -- PKEY_IsEncrypted</para>
            <para>Description: Is the item encrypted?</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {90E5E14E-648B-4826-B2AA-ACAF790E3513}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsFlagged">
            <summary>
            <para>Name:     System.IsFlagged -- PKEY_IsFlagged</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5DA84765-E3FF-4278-86B0-A27967FBDD03}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsFlaggedComplete">
            <summary>
            <para>Name:     System.IsFlaggedComplete -- PKEY_IsFlaggedComplete</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {A6F360D2-55F9-48DE-B909-620E090A647C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsIncomplete">
            <summary>
            <para>Name:     System.IsIncomplete -- PKEY_IsIncomplete</para>
            <para>Description: Identifies if the message was not completely received for some error condition.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {346C8BD1-2E6A-4C45-89A4-61B78E8E700F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsLocationSupported">
            <summary>
            <para>Name:     System.IsLocationSupported -- PKEY_IsLocationSupported</para>
            <para>Description: A bool value to know if a location is supported (locally indexable, or remotely indexed).</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsPinnedToNameSpaceTree">
            <summary>
            <para>Name:     System.IsPinnedToNameSpaceTree -- PKEY_IsPinnedToNameSpaceTree</para>
            <para>Description: A bool value to know if a shell folder is pinned to the navigation pane</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsRead">
            <summary>
            <para>Name:     System.IsRead -- PKEY_IsRead</para>
            <para>Description: Has the item been read?</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsSearchOnlyItem">
            <summary>
            <para>Name:     System.IsSearchOnlyItem -- PKEY_IsSearchOnlyItem</para>
            <para>Description: Identifies if a location or a library is search only</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsSendToTarget">
            <summary>
            <para>Name:     System.IsSendToTarget -- PKEY_IsSendToTarget</para>
            <para>Description: Provided by certain shell folders. Return TRUE if the folder is a valid Send To target.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 33</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IsShared">
            <summary>
            <para>Name:     System.IsShared -- PKEY_IsShared</para>
            <para>Description: Is this item shared? This only checks for ACLs that are not inherited.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemAuthors">
            <summary>
            <para>Name:     System.ItemAuthors -- PKEY_ItemAuthors</para>
            <para>
            Description: This is the generic list of authors associated with an item. For example, the artist name for a track is the
            item author.
            </para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D0A04F0A-462A-48A4-BB2F-3706E88DBD7D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemClassType">
            <summary>
            <para>Name:     System.ItemClassType -- PKEY_ItemClassType</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {048658AD-2DB8-41A4-BBB6-AC1EF1207EB1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemDate">
            <summary>
            <para>Name:     System.ItemDate -- PKEY_ItemDate</para>
            <para>
            Description: This is the main date for an item. The date of interest. For example, for photos this maps to System.Photo.DateTaken.
            </para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {F7DB74B4-4287-4103-AFBA-F1B13DCD75CF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemFolderNameDisplay">
            <summary>
            <para>Name:     System.ItemFolderNameDisplay -- PKEY_ItemFolderNameDisplay</para>
            <para>
            Description: This is the user-friendly display name of the parent folder of an item. If System.ItemFolderPathDisplay is
            VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from
            System.ItemFolderPathDisplay. If the folder is a file folder, the value will be localized if a localized name is
            available. Example values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "bar"
            "\\server\share\mydir\goodnews.doc" "mydir" "\\server\share\numbers.xls" "share" "c:\foo\MyFolder" "foo" "/Mailbox
            Account/Inbox/'Re: Hello!'" "Inbox"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 2 (PID_STG_DIRECTORY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemFolderPathDisplay">
            <summary>
            <para>Name:     System.ItemFolderPathDisplay -- PKEY_ItemFolderPathDisplay</para>
            <para>
            Description: This is the user-friendly display path of the parent folder of an item. If System.ItemPathDisplay is
            VT_EMPTY, then this property should be too. Otherwise, it should be derived appropriately by the data source from
            System.ItemPathDisplay. Example values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "c:\foo\bar"
            "\\server\share\mydir\goodnews.doc" "\\server\share\mydir" "\\server\share\numbers.xls" "\\server\share"
            "c:\foo\MyFolder" "c:\foo" "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox Account/Inbox"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemFolderPathDisplayNarrow">
            <summary>
            <para>Name:     System.ItemFolderPathDisplayNarrow -- PKEY_ItemFolderPathDisplayNarrow</para>
            <para>
            Description: This is the user-friendly display path of the parent folder of an item. The format of the string should be
            tailored such that the folder name comes first, to optimize for a narrow viewing column. If the folder is a file folder,
            the value includes localized names if they are present. If System.ItemFolderPathDisplay is VT_EMPTY, then this property
            should be too. Otherwise, it should be derived appropriately by the data source from System.ItemFolderPathDisplay.
            Example values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "bar (c:\foo)"
            "\\server\share\mydir\goodnews.doc" "mydir (\\server\share)" "\\server\share\numbers.xls" "share (\\server)"
            "c:\foo\MyFolder" "foo (c:\)" "/Mailbox Account/Inbox/'Re: Hello!'" "Inbox (/Mailbox Account)"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DABD30ED-0043-4789-A7F8-D013A4736622}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemName">
            <summary>
            <para>Name:     System.ItemName -- PKEY_ItemName</para>
            <para>
            Description: This is the base-name of the System.ItemNameDisplay. If the item is a file this property includes the
            extension in all cases, and will be localized if a localized name is available. If the item is a message, then the value
            of this property does not include the forwarding or reply prefixes (see System.ItemNamePrefix).
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6B8DA074-3B5C-43BC-886F-0A2CDCE00B6F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemNameDisplay">
            <summary>
            <para>Name:     System.ItemNameDisplay -- PKEY_ItemNameDisplay</para>
            <para>
            Description: This is the display name in "most complete" form. This is the best effort unique representation of the name
            of an item that makes sense for end users to read. It is the concatentation of System.ItemNamePrefix and System.ItemName.
            If the item is a file this property includes the extension in all cases, and will be localized if a localized name is
            available. There are acceptable cases when System.FileName is not VT_EMPTY, yet the value of this property is completely
            different. Email messages are a key example. If the item is an email message, the item name is likely the subject. In
            that case, the value must be the concatenation of the System.ItemNamePrefix and System.ItemName. Since the value of
            System.ItemNamePrefix excludes any trailing whitespace, the concatenation must include a whitespace when generating
            System.ItemNameDisplay. Note that this property is not guaranteed to be unique, but the idea is to promote the most
            likely candidate that can be unique and also makes sense for end users. For example, for documents, you might think about
            using System.Title as the System.ItemNameDisplay, but in practice the title of the documents may not be useful or unique
            enough to be of value as the sole System.ItemNameDisplay. Instead, providing the value of System.FileName as the value of
            System.ItemNameDisplay is a better candidate. In Windows Mail, the emails are stored in the file system as .eml files and
            the System.FileName for those files are not human-friendly as they contain GUIDs. In this example, promoting
            System.Subject as System.ItemNameDisplay makes more sense. Compatibility notes: Shell folder implementations on Vista:
            use PKEY_ItemNameDisplay for the name column when you want Explorer to call ISF::GetDisplayNameOf(SHGDN_NORMAL) to get
            the value of the name. Use another PKEY (like PKEY_ItemName) when you want Explorer to call either the folder's property
            store or ISF2::GetDetailsEx in order to get the value of the name. Shell folder implementations on XP: the first column
            needs to be the name column, and Explorer will call ISF::GetDisplayNameOf to get the value of the name. The PKEY/SCID
            does not matter. Example values:
            File:          "hello.txt"
            Message:       "Re: Let's talk about Tom's argyle socks!" Device folder: "song.wma"
            Folder:        "Documents"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 10 (PID_STG_NAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemNamePrefix">
            <summary>
            <para>Name:     System.ItemNamePrefix -- PKEY_ItemNamePrefix</para>
            <para>
            Description: This is the prefix of an item, used for email messages. where the subject begins with "Re:" which is the
            prefix. If the item is a file, then the value of this property is VT_EMPTY. If the item is a message, then the value of
            this property is the forwarding or reply prefixes (including delimiting colon, but no whitespace), or VT_EMPTY if there
            is no prefix. Example values: System.ItemNamePrefix System.ItemName System.ItemNameDisplay
            ---------------------    ------------------- ---------------------- VT_EMPTY "Great day" "Great day" "Re:" "Great day"
            "Re: Great day" "Fwd: " "Monthly budget" "Fwd: Monthly budget" VT_EMPTY "accounts.xls" "accounts.xls"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D7313FF1-A77A-401C-8C99-3DBDD68ADD36}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemParticipants">
            <summary>
            <para>Name:     System.ItemParticipants -- PKEY_ItemParticipants</para>
            <para>
            Description: This is the generic list of people associated with an item and who contributed to the item. For example,
            this is the combination of people in the To list, Cc list and sender of an email message.
            </para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D4D0AA16-9948-41A4-AA85-D97FF9646993}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemPathDisplay">
            <summary>
            <para>Name:     System.ItemPathDisplay -- PKEY_ItemPathDisplay</para>
            <para>
            Description: This is the user-friendly display path to the item. If the item is a file or folder this property includes
            the extension in all cases, and will be localized if a localized name is available. For other items,this is the
            user-friendly equivalent, assuming the item exists in hierarchical storage. Unlike System.ItemUrl, this property value
            does not include the URL scheme. To parse an item path, use System.ItemUrl or System.ParsingPath. To reference shell
            namespace items using shell APIs, use System.ParsingPath. Example values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "c:\foo\bar\hello.txt"
            "\\server\share\mydir\goodnews.doc" "\\server\share\mydir\goodnews.doc" "\\server\share\numbers.xls"
            "\\server\share\numbers.xls" "c:\foo\MyFolder" "c:\foo\MyFolder" "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox
            Account/Inbox/'Re: Hello!'"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 7</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemPathDisplayNarrow">
            <summary>
            <para>Name:     System.ItemPathDisplayNarrow -- PKEY_ItemPathDisplayNarrow</para>
            <para>
            Description: This is the user-friendly display path to the item. The format of the string should be tailored such that
            the name comes first, to optimize for a narrow viewing column. If the item is a file, the value excludes the file
            extension, and includes localized names if they are present. If the item is a message, the value includes the
            System.ItemNamePrefix. To parse an item path, use System.ItemUrl or System.ParsingPath. Example values: If the path is...
            The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "hello (c:\foo\bar)"
            "\\server\share\mydir\goodnews.doc" "goodnews (\\server\share\mydir)" "\\server\share\folder" "folder (\\server\share)"
            "c:\foo\MyFolder" "MyFolder (c:\foo)" "/Mailbox Account/Inbox/'Re: Hello!'" "Re: Hello! (/Mailbox Account/Inbox)"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemType">
            <summary>
            <para>Name:     System.ItemType -- PKEY_ItemType</para>
            <para>
            Description: This is the canonical type of the item and is intended to be programmatically parsed. If there is no
            canonical type, the value is VT_EMPTY. If the item is a file (ie, System.FileName is not VT_EMPTY), the value is the same
            as System.FileExtension. Use System.ItemTypeText when you want to display the type to end users in a view. (If the item
            is a file, passing the System.ItemType value to PSFormatForDisplay will result in the same value as System.ItemTypeText.)
            Example values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" ".txt"
            "\\server\share\mydir\goodnews.doc" ".doc" "\\server\share\folder" "Directory" "c:\foo\MyFolder" "Directory" [desktop]
            "Folder" "/Mailbox Account/Inbox/'Re: Hello!'" "MAPI/IPM.Message"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemTypeText">
            <summary>
            <para>Name:     System.ItemTypeText -- PKEY_ItemTypeText</para>
            <para>
            Description: This is the user friendly type name of the item. This is not intended to be programmatically parsed. If
            System.ItemType is VT_EMPTY, the value of this property is also VT_EMPTY. If the item is a file, the value of this
            property is the same as if you passed the file's System.ItemType value to PSFormatForDisplay. This property should not be
            confused with System.Kind, where System.Kind is a high-level user friendly kind name. For example, for a document,
            System.Kind = "Document" and System.Item.Type = ".doc" and System.Item.TypeText = "Microsoft Word Document" Example
            values: If the path is... The property value is...
            -----------------                     ------------------------ "c:\foo\bar\hello.txt" "Text File"
            "\\server\share\mydir\goodnews.doc" "Microsoft Word Document" "\\server\share\folder" "File Folder" "c:\foo\MyFolder"
            "File Folder" "/Mailbox Account/Inbox/'Re: Hello!'" "Outlook E-Mail Message"
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 4 (PID_STG_STORAGETYPE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ItemUrl">
            <summary>
            <para>Name:     System.ItemUrl -- PKEY_ItemUrl</para>
            <para>
            Description: This always represents a well formed URL that points to the item. To reference shell namespace items using
            shell APIs, use System.ParsingPath. Example values:
            Files:    "file:///c:/foo/bar/hello.txt" "csc://{GUID}/..."
            Messages: "mapi://..."
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 9 (DISPID_QUERY_VIRTUALPATH)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Keywords">
            <summary>
            <para>Name:     System.Keywords -- PKEY_Keywords</para>
            <para>Description: The keywords for the item. Also referred to as tags.</para>
            <para>
            Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR) Legacy code may treat this as VT_LPSTR.
            </para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 5 (PIDSI_KEYWORDS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Kind">
            <summary>
            <para>Name:     System.Kind -- PKEY_Kind</para>
            <para>
            Description: System.Kind is used to map extensions to various .Search folders. Extensions are mapped to Kinds at
            HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\KindMap The list of kinds is not extensible.
            </para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {1E3EE840-BC2B-476C-8237-2ACD1A839B22}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.KindText">
            <summary>
            <para>Name:     System.KindText -- PKEY_KindText</para>
            <para>
            Description: This is the user-friendly form of System.Kind. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F04BEF95-C585-4197-A2B7-DF46FDC9EE6D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Language">
            <summary>
            <para>Name:     System.Language -- PKEY_Language</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 28</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.MileageInformation">
            <summary>
            <para>Name:     System.MileageInformation -- PKEY_MileageInformation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FDF84370-031A-4ADD-9E91-0D775F1C6605}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.MIMEType">
            <summary>
            <para>Name:     System.MIMEType -- PKEY_MIMEType</para>
            <para>Description: The MIME type. Eg, for EML files: 'message/rfc822'.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0B63E350-9CCC-11D0-BCDB-00805FCCCE04}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.NamespaceCLSID">
            <summary>
            <para>Name:     System.NamespaceCLSID -- PKEY_NamespaceCLSID</para>
            <para>
            Description: The CLSID of the name space extension for an item, the object that implements IShellFolder for this item
            </para>
            <para>Type:     Guid -- VT_CLSID</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Null">
            <summary>
            <para>Name:     System.Null -- PKEY_Null</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {00000000-0000-0000-0000-000000000000}, 0</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.OfflineAvailability">
            <summary>
            <para>Name:     System.OfflineAvailability -- PKEY_OfflineAvailability</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {A94688B6-7D9F-4570-A648-E3DFC0AB2B3F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.OfflineStatus">
            <summary>
            <para>Name:     System.OfflineStatus -- PKEY_OfflineStatus</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {6D24888F-4718-4BDA-AFED-EA0FB4386CD8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.OriginalFileName">
            <summary>
            <para>Name:     System.OriginalFileName -- PKEY_OriginalFileName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.OwnerSID">
            <summary>
            <para>Name:     System.OwnerSID -- PKEY_OwnerSID</para>
            <para>Description: SID of the user that owns the library.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {5D76B67F-9B3D-44BB-B6AE-25DA4F638A67}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParentalRating">
            <summary>
            <para>Name:     System.ParentalRating -- PKEY_ParentalRating</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 21 (PIDMSI_PARENTAL_RATING)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParentalRatingReason">
            <summary>
            <para>Name:     System.ParentalRatingReason -- PKEY_ParentalRatingReason</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {10984E0A-F9F2-4321-B7EF-BAF195AF4319}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParentalRatingsOrganization">
            <summary>
            <para>Name:     System.ParentalRatingsOrganization -- PKEY_ParentalRatingsOrganization</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A7FE0840-1344-46F0-8D37-52ED712A4BF9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParsingBindContext">
            <summary>
            <para>Name:     System.ParsingBindContext -- PKEY_ParsingBindContext</para>
            <para>Description: used to get the IBindCtx for an item for parsing</para>
            <para>Type:     Any -- VT_NULL Legacy code may treat this as VT_UNKNOWN.</para>
            <para>FormatID: {DFB9A04D-362F-4CA3-B30B-0254B17B5B84}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParsingName">
            <summary>
            <para>Name:     System.ParsingName -- PKEY_ParsingName</para>
            <para>
            Description: The shell namespace name of an item relative to a parent folder. This name may be passed to
            IShellFolder::ParseDisplayName() of the parent shell folder.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 24</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ParsingPath">
            <summary>
            <para>Name:     System.ParsingPath -- PKEY_ParsingPath</para>
            <para>
            Description: This is the shell namespace path to the item. This path may be passed to SHParseDisplayName to parse the
            path to the correct shell folder. If the item is a file, the value is identical to System.ItemPathDisplay. If the item
            cannot be accessed through the shell namespace, this value is VT_EMPTY.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 30</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PerceivedType">
            <summary>
            <para>Name:     System.PerceivedType -- PKEY_PerceivedType</para>
            <para>Description: The perceived type of a shell item, based upon its canonical type.</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PercentFull">
            <summary>
            <para>Name:     System.PercentFull -- PKEY_PercentFull</para>
            <para>Description: The amount filled as a percentage, multiplied by 100 (ie, the valid range is 0 through 100).</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 5 (Filesystem Volume Properties)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Priority">
            <summary>
            <para>Name:     System.Priority -- PKEY_Priority</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PriorityText">
            <summary>
            <para>Name:     System.PriorityText -- PKEY_PriorityText</para>
            <para>
            Description: This is the user-friendly form of System.Priority. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D98BE98B-B86B-4095-BF52-9D23B2E0A752}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Project">
            <summary>
            <para>Name:     System.Project -- PKEY_Project</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {39A7F922-477C-48DE-8BC8-B28441E342E3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ProviderItemID">
            <summary>
            <para>Name:     System.ProviderItemID -- PKEY_ProviderItemID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F21D9941-81F0-471A-ADEE-4E74B49217ED}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Rating">
            <summary>
            <para>Name:     System.Rating -- PKEY_Rating</para>
            <para>
            Description: Indicates the users preference rating of an item on a scale of 1-99 (1-12 = One Star, 13-37 = Two Stars,
            38-62 = Three Stars, 63-87 = Four Stars, 88-99 = Five Stars).
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 9 (PIDMSI_RATING)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RatingText">
            <summary>
            <para>Name:     System.RatingText -- PKEY_RatingText</para>
            <para>
            Description: This is the user-friendly form of System.Rating. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {90197CA7-FD8F-4E8C-9DA3-B57E1E609295}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sensitivity">
            <summary>
            <para>Name:     System.Sensitivity -- PKEY_Sensitivity</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {F8D3F6AC-4874-42CB-BE59-AB454B30716A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SensitivityText">
            <summary>
            <para>Name:     System.SensitivityText -- PKEY_SensitivityText</para>
            <para>
            Description: This is the user-friendly form of System.Sensitivity. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D0C7F054-3F72-4725-8527-129A577CB269}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SFGAOFlags">
            <summary>
            <para>Name:     System.SFGAOFlags -- PKEY_SFGAOFlags</para>
            <para>Description: IShellFolder::GetAttributesOf flags, with SFGAO_PKEYSFGAOMASK attributes masked out.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 25</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SharedWith">
            <summary>
            <para>Name:     System.SharedWith -- PKEY_SharedWith</para>
            <para>Description: Who is the item shared with?</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 200</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ShareUserRating">
            <summary>
            <para>Name:     System.ShareUserRating -- PKEY_ShareUserRating</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 12 (PIDMSI_SHARE_USER_RATING)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SharingStatus">
            <summary>
            <para>Name:     System.SharingStatus -- PKEY_SharingStatus</para>
            <para>Description: What is the item's sharing status (not shared, shared, everyone (homegroup or everyone), or private)?</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902}, 300</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SimpleRating">
            <summary>
            <para>Name:     System.SimpleRating -- PKEY_SimpleRating</para>
            <para>
            Description: Indicates the users preference rating of an item on a scale of 0-5 (0=unrated, 1=One Star, 2=Two Stars,
            3=Three Stars, 4=Four Stars, 5=Five Stars)
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {A09F084E-AD41-489F-8076-AA5BE3082BCA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Size">
            <summary>
            <para>Name:     System.Size -- PKEY_Size</para>
            <para>Description:</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 12 (PID_STG_SIZE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SoftwareUsed">
            <summary>
            <para>Name:     System.SoftwareUsed -- PKEY_SoftwareUsed</para>
            <para>Description: PropertyTagSoftwareUsed</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 305</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SourceItem">
            <summary>
            <para>Name:     System.SourceItem -- PKEY_SourceItem</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {668CDFA5-7A1B-4323-AE4B-E527393A1D81}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.StartDate">
            <summary>
            <para>Name:     System.StartDate -- PKEY_StartDate</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {48FD6EC8-8A12-4CDF-A03E-4EC5A511EDDE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Status">
            <summary>
            <para>Name:     System.Status -- PKEY_Status</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_IntSite) {000214A1-0000-0000-C000-000000000046}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Subject">
            <summary>
            <para>Name:     System.Subject -- PKEY_Subject</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 3 (PIDSI_SUBJECT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.SyncTransferStatus">
            <summary>
            <para>Name:     System.SyncTransferStatus -- PKEY_SyncTransferStatus</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {FCEFF153-E839-4CF3-A9E7-EA22832094B8}, 103</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ThumbnailCacheId">
            <summary>
            <para>Name:     System.ThumbnailCacheId -- PKEY_ThumbnailCacheId</para>
            <para>
            Description: Unique value that can be used as a key to cache thumbnails. The value changes when the name, volume, or data
            modified of an item changes.
            </para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {446D16B1-8DAD-4870-A748-402EA43D788C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.ThumbnailStream">
            <summary>
            <para>Name:     System.ThumbnailStream -- PKEY_ThumbnailStream</para>
            <para>
            Description: Data that represents the thumbnail in VT_STREAM format that GDI+/WindowsCodecs supports (jpg, png, etc).
            </para>
            <para>Type:     Stream -- VT_STREAM</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 27</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Title">
            <summary>
            <para>Name:     System.Title -- PKEY_Title</para>
            <para>Description: Title of item.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR) Legacy code may treat this as VT_LPSTR.</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 2 (PIDSI_TITLE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.TotalFileSize">
            <summary>
            <para>Name:     System.TotalFileSize -- PKEY_TotalFileSize</para>
            <para>Description:</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_ShellDetails) {28636AA6-953D-11D2-B5D6-00C04FD918D0}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Trademarks">
            <summary>
            <para>Name:     System.Trademarks -- PKEY_Trademarks</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 9 (PIDVSI_Trademarks)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel">
            <summary>AppUserModel Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.ExcludeFromShowInNewInstall">
            <summary>
            <para>Name:     System.AppUserModel.ExcludeFromShowInNewInstall -- PKEY_AppUserModel_ExcludeFromShowInNewInstall</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.ID">
            <summary>
            <para>Name:     System.AppUserModel.ID -- PKEY_AppUserModel_ID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.IsDestListSeparator">
            <summary>
            <para>Name:     System.AppUserModel.IsDestListSeparator -- PKEY_AppUserModel_IsDestListSeparator</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.IsDualMode">
            <summary>
            <para>Name:     System.AppUserModel.IsDualMode -- PKEY_AppUserModel_IsDualMode</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.PreventPinning">
            <summary>
            <para>Name:     System.AppUserModel.PreventPinning -- PKEY_AppUserModel_PreventPinning</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.RelaunchCommand">
            <summary>
            <para>Name:     System.AppUserModel.RelaunchCommand -- PKEY_AppUserModel_RelaunchCommand</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.RelaunchDisplayNameResource">
            <summary>
            <para>Name:     System.AppUserModel.RelaunchDisplayNameResource -- PKEY_AppUserModel_RelaunchDisplayNameResource</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.RelaunchIconResource">
            <summary>
            <para>Name:     System.AppUserModel.RelaunchIconResource -- PKEY_AppUserModel_RelaunchIconResource</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.StartPinOption">
            <summary>
            <para>Name:     System.AppUserModel.StartPinOption -- PKEY_AppUserModel_StartPinOption</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 12</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.ToastActivatorCLSID">
            <summary>
            <para>Name:     System.AppUserModel.ToastActivatorCLSID -- PKEY_AppUserModel_ToastActivatorCLSID</para>
            <para>Description:</para>
            <para>Type:     Guid -- VT_CLSID</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 26</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.AppUserModel.VisualElementsManifestHintPath">
            <summary>
            <para>Name:     System.AppUserModel.VisualElementsManifestHintPath -- PKEY_AppUserModel_VisualElementsManifestHintPath</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)</para>
            <para>FormatID: {9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}, 31</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio">
            <summary>Audio Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.ChannelCount">
            <summary>
            <para>Name:     System.Audio.ChannelCount -- PKEY_Audio_ChannelCount</para>
            <para>Description: Indicates the channel count for the audio file. Values: 1 (mono), 2 (stereo).</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 7 (PIDASI_CHANNEL_COUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.Compression">
            <summary>
            <para>Name:     System.Audio.Compression -- PKEY_Audio_Compression</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 10 (PIDASI_COMPRESSION)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.EncodingBitrate">
            <summary>
            <para>Name:     System.Audio.EncodingBitrate -- PKEY_Audio_EncodingBitrate</para>
            <para>Description: Indicates the average data rate in Hz for the audio file in "bits per second".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 4 (PIDASI_AVG_DATA_RATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.Format">
            <summary>
            <para>Name:     System.Audio.Format -- PKEY_Audio_Format</para>
            <para>Description: Indicates the format of the audio file.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR) Legacy code may treat this as VT_BSTR.</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 2 (PIDASI_FORMAT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.IsVariableBitRate">
            <summary>
            <para>Name:     System.Audio.IsVariableBitRate -- PKEY_Audio_IsVariableBitRate</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {E6822FEE-8C17-4D62-823C-8E9CFCBD1D5C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.PeakValue">
            <summary>
            <para>Name:     System.Audio.PeakValue -- PKEY_Audio_PeakValue</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {2579E5D0-1116-4084-BD9A-9B4F7CB4DF5E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.SampleRate">
            <summary>
            <para>Name:     System.Audio.SampleRate -- PKEY_Audio_SampleRate</para>
            <para>Description: Indicates the audio sample rate for the audio file in "samples per second".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 5 (PIDASI_SAMPLE_RATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.SampleSize">
            <summary>
            <para>Name:     System.Audio.SampleSize -- PKEY_Audio_SampleSize</para>
            <para>Description: Indicates the audio sample size for the audio file in "bits per sample".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 6 (PIDASI_SAMPLE_SIZE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.StreamName">
            <summary>
            <para>Name:     System.Audio.StreamName -- PKEY_Audio_StreamName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 9 (PIDASI_STREAM_NAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Audio.StreamNumber">
            <summary>
            <para>Name:     System.Audio.StreamNumber -- PKEY_Audio_StreamNumber</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 8 (PIDASI_STREAM_NUMBER)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar">
            <summary>Calendar Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.Duration">
            <summary>
            <para>Name:     System.Calendar.Duration -- PKEY_Calendar_Duration</para>
            <para>Description: The duration as specified in a string.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {293CA35A-09AA-4DD2-B180-1FE245728A52}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.IsOnline">
            <summary>
            <para>Name:     System.Calendar.IsOnline -- PKEY_Calendar_IsOnline</para>
            <para>Description: Identifies if the event is an online event.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {BFEE9149-E3E2-49A7-A862-C05988145CEC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.IsRecurring">
            <summary>
            <para>Name:     System.Calendar.IsRecurring -- PKEY_Calendar_IsRecurring</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {315B9C8D-80A9-4EF9-AE16-8E746DA51D70}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.Location">
            <summary>
            <para>Name:     System.Calendar.Location -- PKEY_Calendar_Location</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F6272D18-CECC-40B1-B26A-3911717AA7BD}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.OptionalAttendeeAddresses">
            <summary>
            <para>Name:     System.Calendar.OptionalAttendeeAddresses -- PKEY_Calendar_OptionalAttendeeAddresses</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D55BAE5A-3892-417A-A649-C6AC5AAAEAB3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.OptionalAttendeeNames">
            <summary>
            <para>Name:     System.Calendar.OptionalAttendeeNames -- PKEY_Calendar_OptionalAttendeeNames</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {09429607-582D-437F-84C3-DE93A2B24C3C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.OrganizerAddress">
            <summary>
            <para>Name:     System.Calendar.OrganizerAddress -- PKEY_Calendar_OrganizerAddress</para>
            <para>Description: Address of the organizer organizing the event.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {744C8242-4DF5-456C-AB9E-014EFB9021E3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.OrganizerName">
            <summary>
            <para>Name:     System.Calendar.OrganizerName -- PKEY_Calendar_OrganizerName</para>
            <para>Description: Name of the organizer organizing the event.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {AAA660F9-9865-458E-B484-01BC7FE3973E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.ReminderTime">
            <summary>
            <para>Name:     System.Calendar.ReminderTime -- PKEY_Calendar_ReminderTime</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {72FC5BA4-24F9-4011-9F3F-ADD27AFAD818}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.RequiredAttendeeAddresses">
            <summary>
            <para>Name:     System.Calendar.RequiredAttendeeAddresses -- PKEY_Calendar_RequiredAttendeeAddresses</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {0BA7D6C3-568D-4159-AB91-781A91FB71E5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.RequiredAttendeeNames">
            <summary>
            <para>Name:     System.Calendar.RequiredAttendeeNames -- PKEY_Calendar_RequiredAttendeeNames</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {B33AF30B-F552-4584-936C-CB93E5CDA29F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.Resources">
            <summary>
            <para>Name:     System.Calendar.Resources -- PKEY_Calendar_Resources</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {00F58A38-C54B-4C40-8696-97235980EAE1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.ResponseStatus">
            <summary>
            <para>Name:     System.Calendar.ResponseStatus -- PKEY_Calendar_ResponseStatus</para>
            <para>Description: This property stores the status of the user responses to meetings in her calendar.</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {188C1F91-3C40-4132-9EC5-D8B03B72A8A2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.ShowTimeAs">
            <summary>
            <para>Name:     System.Calendar.ShowTimeAs -- PKEY_Calendar_ShowTimeAs</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {5BF396D4-5EB2-466F-BDE9-2FB3F2361D6E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Calendar.ShowTimeAsText">
            <summary>
            <para>Name:     System.Calendar.ShowTimeAsText -- PKEY_Calendar_ShowTimeAsText</para>
            <para>
            Description: This is the user-friendly form of System.Calendar.ShowTimeAs. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {53DA57CF-62C0-45C4-81DE-7610BCEFD7F5}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication">
            <summary>Communication Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.AccountName">
            <summary>
            <para>Name:     System.Communication.AccountName -- PKEY_Communication_AccountName</para>
            <para>Description: Account Name</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.DateItemExpires">
            <summary>
            <para>Name:     System.Communication.DateItemExpires -- PKEY_Communication_DateItemExpires</para>
            <para>Description: Date the item expires due to the retention policy.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {428040AC-A177-4C8A-9760-F6F761227F9A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.FollowupIconIndex">
            <summary>
            <para>Name:     System.Communication.FollowupIconIndex -- PKEY_Communication_FollowupIconIndex</para>
            <para>Description: This is the icon index used on messages marked for followup.</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {83A6347E-6FE4-4F40-BA9C-C4865240D1F4}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.HeaderItem">
            <summary>
            <para>Name:     System.Communication.HeaderItem -- PKEY_Communication_HeaderItem</para>
            <para>
            Description: This property will be true if the item is a header item which means the item hasn't been fully downloaded.
            </para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {C9C34F84-2241-4401-B607-BD20ED75AE7F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.PolicyTag">
            <summary>
            <para>Name:     System.Communication.PolicyTag -- PKEY_Communication_PolicyTag</para>
            <para>Description: This a string used to identify the retention policy applied to the item.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {EC0B4191-AB0B-4C66-90B6-C6637CDEBBAB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.SecurityFlags">
            <summary>
            <para>Name:     System.Communication.SecurityFlags -- PKEY_Communication_SecurityFlags</para>
            <para>Description: Security flags associated with the item to know if the item is encrypted, signed or DRM enabled.</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {8619A4B6-9F4D-4429-8C0F-B996CA59E335}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.Suffix">
            <summary>
            <para>Name:     System.Communication.Suffix -- PKEY_Communication_Suffix</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {807B653A-9E91-43EF-8F97-11CE04EE20C5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.TaskStatus">
            <summary>
            <para>Name:     System.Communication.TaskStatus -- PKEY_Communication_TaskStatus</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {BE1A72C6-9A1D-46B7-AFE7-AFAF8CEF4999}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Communication.TaskStatusText">
            <summary>
            <para>Name:     System.Communication.TaskStatusText -- PKEY_Communication_TaskStatusText</para>
            <para>
            Description: This is the user-friendly form of System.Communication.TaskStatus. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A6744477-C237-475B-A075-54F34498292A}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Computer">
            <summary>Computer Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Computer.DecoratedFreeSpace">
            <summary>
            <para>Name:     System.Computer.DecoratedFreeSpace -- PKEY_Computer_DecoratedFreeSpace</para>
            <para>Description: Free space and total space: "%s free of %s"</para>
            <para>Type:     Multivalue UInt64 -- VT_VECTOR | VT_UI8 (For variants: VT_ARRAY | VT_UI8)</para>
            <para>FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 7 (Filesystem Volume Properties)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact">
            <summary>Contact Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Anniversary">
            <summary>
            <para>Name:     System.Contact.Anniversary -- PKEY_Contact_Anniversary</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {9AD5BADB-CEA7-4470-A03D-B84E51B9949E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.AssistantName">
            <summary>
            <para>Name:     System.Contact.AssistantName -- PKEY_Contact_AssistantName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CD102C9C-5540-4A88-A6F6-64E4981C8CD1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.AssistantTelephone">
            <summary>
            <para>Name:     System.Contact.AssistantTelephone -- PKEY_Contact_AssistantTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9A93244D-A7AD-4FF8-9B99-45EE4CC09AF6}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Birthday">
            <summary>
            <para>Name:     System.Contact.Birthday -- PKEY_Contact_Birthday</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 47</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddress">
            <summary>
            <para>Name:     System.Contact.BusinessAddress -- PKEY_Contact_BusinessAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {730FB6DD-CF7C-426B-A03F-BD166CC9EE24}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressCity">
            <summary>
            <para>Name:     System.Contact.BusinessAddressCity -- PKEY_Contact_BusinessAddressCity</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {402B5934-EC5A-48C3-93E6-85E86A2D934E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressCountry">
            <summary>
            <para>Name:     System.Contact.BusinessAddressCountry -- PKEY_Contact_BusinessAddressCountry</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {B0B87314-FCF6-4FEB-8DFF-A50DA6AF561C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressPostalCode">
            <summary>
            <para>Name:     System.Contact.BusinessAddressPostalCode -- PKEY_Contact_BusinessAddressPostalCode</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E1D4A09E-D758-4CD1-B6EC-34A8B5A73F80}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressPostOfficeBox">
            <summary>
            <para>Name:     System.Contact.BusinessAddressPostOfficeBox -- PKEY_Contact_BusinessAddressPostOfficeBox</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {BC4E71CE-17F9-48D5-BEE9-021DF0EA5409}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressState">
            <summary>
            <para>Name:     System.Contact.BusinessAddressState -- PKEY_Contact_BusinessAddressState</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {446F787F-10C4-41CB-A6C4-4D0343551597}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessAddressStreet">
            <summary>
            <para>Name:     System.Contact.BusinessAddressStreet -- PKEY_Contact_BusinessAddressStreet</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DDD1460F-C0BF-4553-8CE4-10433C908FB0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessFaxNumber">
            <summary>
            <para>Name:     System.Contact.BusinessFaxNumber -- PKEY_Contact_BusinessFaxNumber</para>
            <para>Description: Business fax number of the contact.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {91EFF6F3-2E27-42CA-933E-7C999FBE310B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessHomePage">
            <summary>
            <para>Name:     System.Contact.BusinessHomePage -- PKEY_Contact_BusinessHomePage</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {56310920-2491-4919-99CE-EADB06FAFDB2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.BusinessTelephone">
            <summary>
            <para>Name:     System.Contact.BusinessTelephone -- PKEY_Contact_BusinessTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6A15E5A0-0A1E-4CD7-BB8C-D2F1B0C929BC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.CallbackTelephone">
            <summary>
            <para>Name:     System.Contact.CallbackTelephone -- PKEY_Contact_CallbackTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {BF53D1C3-49E0-4F7F-8567-5A821D8AC542}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.CarTelephone">
            <summary>
            <para>Name:     System.Contact.CarTelephone -- PKEY_Contact_CarTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8FDC6DEA-B929-412B-BA90-397A257465FE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Children">
            <summary>
            <para>Name:     System.Contact.Children -- PKEY_Contact_Children</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D4729704-8EF1-43EF-9024-2BD381187FD5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.CompanyMainTelephone">
            <summary>
            <para>Name:     System.Contact.CompanyMainTelephone -- PKEY_Contact_CompanyMainTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8589E481-6040-473D-B171-7FA89C2708ED}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Department">
            <summary>
            <para>Name:     System.Contact.Department -- PKEY_Contact_Department</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FC9F7306-FF8F-4D49-9FB6-3FFE5C0951EC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.EmailAddress">
            <summary>
            <para>Name:     System.Contact.EmailAddress -- PKEY_Contact_EmailAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F8FA7FA3-D12B-4785-8A4E-691A94F7A3E7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.EmailAddress2">
            <summary>
            <para>Name:     System.Contact.EmailAddress2 -- PKEY_Contact_EmailAddress2</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {38965063-EDC8-4268-8491-B7723172CF29}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.EmailAddress3">
            <summary>
            <para>Name:     System.Contact.EmailAddress3 -- PKEY_Contact_EmailAddress3</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {644D37B4-E1B3-4BAD-B099-7E7C04966ACA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.EmailAddresses">
            <summary>
            <para>Name:     System.Contact.EmailAddresses -- PKEY_Contact_EmailAddresses</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {84D8F337-981D-44B3-9615-C7596DBA17E3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.EmailName">
            <summary>
            <para>Name:     System.Contact.EmailName -- PKEY_Contact_EmailName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CC6F4F24-6083-4BD4-8754-674D0DE87AB8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.FileAsName">
            <summary>
            <para>Name:     System.Contact.FileAsName -- PKEY_Contact_FileAsName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F1A24AA7-9CA7-40F6-89EC-97DEF9FFE8DB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.FirstName">
            <summary>
            <para>Name:     System.Contact.FirstName -- PKEY_Contact_FirstName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {14977844-6B49-4AAD-A714-A4513BF60460}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.FullName">
            <summary>
            <para>Name:     System.Contact.FullName -- PKEY_Contact_FullName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {635E9051-50A5-4BA2-B9DB-4ED056C77296}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Gender">
            <summary>
            <para>Name:     System.Contact.Gender -- PKEY_Contact_Gender</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.GenderValue">
            <summary>
            <para>Name:     System.Contact.GenderValue -- PKEY_Contact_GenderValue</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD}, 101</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Hobbies">
            <summary>
            <para>Name:     System.Contact.Hobbies -- PKEY_Contact_Hobbies</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {5DC2253F-5E11-4ADF-9CFE-910DD01E3E70}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddress">
            <summary>
            <para>Name:     System.Contact.HomeAddress -- PKEY_Contact_HomeAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {98F98354-617A-46B8-8560-5B1B64BF1F89}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressCity">
            <summary>
            <para>Name:     System.Contact.HomeAddressCity -- PKEY_Contact_HomeAddressCity</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 65</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressCountry">
            <summary>
            <para>Name:     System.Contact.HomeAddressCountry -- PKEY_Contact_HomeAddressCountry</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {08A65AA1-F4C9-43DD-9DDF-A33D8E7EAD85}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressPostalCode">
            <summary>
            <para>Name:     System.Contact.HomeAddressPostalCode -- PKEY_Contact_HomeAddressPostalCode</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8AFCC170-8A46-4B53-9EEE-90BAE7151E62}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressPostOfficeBox">
            <summary>
            <para>Name:     System.Contact.HomeAddressPostOfficeBox -- PKEY_Contact_HomeAddressPostOfficeBox</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7B9F6399-0A3F-4B12-89BD-4ADC51C918AF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressState">
            <summary>
            <para>Name:     System.Contact.HomeAddressState -- PKEY_Contact_HomeAddressState</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C89A23D0-7D6D-4EB8-87D4-776A82D493E5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeAddressStreet">
            <summary>
            <para>Name:     System.Contact.HomeAddressStreet -- PKEY_Contact_HomeAddressStreet</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0ADEF160-DB3F-4308-9A21-06237B16FA2A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeFaxNumber">
            <summary>
            <para>Name:     System.Contact.HomeFaxNumber -- PKEY_Contact_HomeFaxNumber</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {660E04D6-81AB-4977-A09F-82313113AB26}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.HomeTelephone">
            <summary>
            <para>Name:     System.Contact.HomeTelephone -- PKEY_Contact_HomeTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 20</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.IMAddress">
            <summary>
            <para>Name:     System.Contact.IMAddress -- PKEY_Contact_IMAddress</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D68DBD8A-3374-4B81-9972-3EC30682DB3D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Initials">
            <summary>
            <para>Name:     System.Contact.Initials -- PKEY_Contact_Initials</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F3D8F40D-50CB-44A2-9718-40CB9119495D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.JobTitle">
            <summary>
            <para>Name:     System.Contact.JobTitle -- PKEY_Contact_JobTitle</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Label">
            <summary>
            <para>Name:     System.Contact.Label -- PKEY_Contact_Label</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {97B0AD89-DF49-49CC-834E-660974FD755B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.LastName">
            <summary>
            <para>Name:     System.Contact.LastName -- PKEY_Contact_LastName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8F367200-C270-457C-B1D4-E07C5BCD90C7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.MailingAddress">
            <summary>
            <para>Name:     System.Contact.MailingAddress -- PKEY_Contact_MailingAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C0AC206A-827E-4650-95AE-77E2BB74FCC9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.MiddleName">
            <summary>
            <para>Name:     System.Contact.MiddleName -- PKEY_Contact_MiddleName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 71</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.MobileTelephone">
            <summary>
            <para>Name:     System.Contact.MobileTelephone -- PKEY_Contact_MobileTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 35</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.NickName">
            <summary>
            <para>Name:     System.Contact.NickName -- PKEY_Contact_NickName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 74</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OfficeLocation">
            <summary>
            <para>Name:     System.Contact.OfficeLocation -- PKEY_Contact_OfficeLocation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 7</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddress">
            <summary>
            <para>Name:     System.Contact.OtherAddress -- PKEY_Contact_OtherAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {508161FA-313B-43D5-83A1-C1ACCF68622C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressCity">
            <summary>
            <para>Name:     System.Contact.OtherAddressCity -- PKEY_Contact_OtherAddressCity</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6E682923-7F7B-4F0C-A337-CFCA296687BF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressCountry">
            <summary>
            <para>Name:     System.Contact.OtherAddressCountry -- PKEY_Contact_OtherAddressCountry</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8F167568-0AAE-4322-8ED9-6055B7B0E398}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressPostalCode">
            <summary>
            <para>Name:     System.Contact.OtherAddressPostalCode -- PKEY_Contact_OtherAddressPostalCode</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {95C656C1-2ABF-4148-9ED3-9EC602E3B7CD}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressPostOfficeBox">
            <summary>
            <para>Name:     System.Contact.OtherAddressPostOfficeBox -- PKEY_Contact_OtherAddressPostOfficeBox</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {8B26EA41-058F-43F6-AECC-4035681CE977}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressState">
            <summary>
            <para>Name:     System.Contact.OtherAddressState -- PKEY_Contact_OtherAddressState</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {71B377D6-E570-425F-A170-809FAE73E54E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.OtherAddressStreet">
            <summary>
            <para>Name:     System.Contact.OtherAddressStreet -- PKEY_Contact_OtherAddressStreet</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FF962609-B7D6-4999-862D-95180D529AEA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PagerTelephone">
            <summary>
            <para>Name:     System.Contact.PagerTelephone -- PKEY_Contact_PagerTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D6304E01-F8F5-4F45-8B15-D024A6296789}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PersonalTitle">
            <summary>
            <para>Name:     System.Contact.PersonalTitle -- PKEY_Contact_PersonalTitle</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 69</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressCity">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressCity -- PKEY_Contact_PrimaryAddressCity</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C8EA94F0-A9E3-4969-A94B-9C62A95324E0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressCountry">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressCountry -- PKEY_Contact_PrimaryAddressCountry</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E53D799D-0F3F-466E-B2FF-74634A3CB7A4}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressPostalCode">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressPostalCode -- PKEY_Contact_PrimaryAddressPostalCode</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {18BBD425-ECFD-46EF-B612-7B4A6034EDA0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressPostOfficeBox">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressPostOfficeBox -- PKEY_Contact_PrimaryAddressPostOfficeBox</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DE5EF3C7-46E1-484E-9999-62C5308394C1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressState">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressState -- PKEY_Contact_PrimaryAddressState</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F1176DFE-7138-4640-8B4C-AE375DC70A6D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryAddressStreet">
            <summary>
            <para>Name:     System.Contact.PrimaryAddressStreet -- PKEY_Contact_PrimaryAddressStreet</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {63C25B20-96BE-488F-8788-C09C407AD812}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryEmailAddress">
            <summary>
            <para>Name:     System.Contact.PrimaryEmailAddress -- PKEY_Contact_PrimaryEmailAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 48</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.PrimaryTelephone">
            <summary>
            <para>Name:     System.Contact.PrimaryTelephone -- PKEY_Contact_PrimaryTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 25</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Profession">
            <summary>
            <para>Name:     System.Contact.Profession -- PKEY_Contact_Profession</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7268AF55-1CE4-4F6E-A41F-B6E4EF10E4A9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.SpouseName">
            <summary>
            <para>Name:     System.Contact.SpouseName -- PKEY_Contact_SpouseName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9D2408B6-3167-422B-82B0-F583B7A7CFE3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.Suffix">
            <summary>
            <para>Name:     System.Contact.Suffix -- PKEY_Contact_Suffix</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {176DC63C-2688-4E89-8143-A347800F25E9}, 73</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.TelexNumber">
            <summary>
            <para>Name:     System.Contact.TelexNumber -- PKEY_Contact_TelexNumber</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C554493C-C1F7-40C1-A76C-EF8C0614003E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.TTYTDDTelephone">
            <summary>
            <para>Name:     System.Contact.TTYTDDTelephone -- PKEY_Contact_TTYTDDTelephone</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {AAF16BAC-2B55-45E6-9F6D-415EB94910DF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.WebPage">
            <summary>
            <para>Name:     System.Contact.WebPage -- PKEY_Contact_WebPage</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 18</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.JA">
            <summary>JA Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.JA.CompanyNamePhonetic">
            <summary>
            <para>Name:     System.Contact.JA.CompanyNamePhonetic -- PKEY_Contact_JA_CompanyNamePhonetic</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.JA.FirstNamePhonetic">
            <summary>
            <para>Name:     System.Contact.JA.FirstNamePhonetic -- PKEY_Contact_JA_FirstNamePhonetic</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Contact.JA.LastNamePhonetic">
            <summary>
            <para>Name:     System.Contact.JA.LastNamePhonetic -- PKEY_Contact_JA_LastNamePhonetic</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {897B3694-FE9E-43E6-8066-260F590C0100}, 4</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Device">
            <summary>Device Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Device.PrinterURL">
            <summary>
            <para>Name:     System.Device.PrinterURL -- PKEY_Device_PrinterURL</para>
            <para>Description: Printer information Printer URL.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0B48F35A-BE6E-4F17-B108-3C4073D1669A}, 15</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DeviceInterface">
            <summary>DeviceInterface Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DeviceInterface.PrinterDriverDirectory">
            <summary>
            <para>Name:     System.DeviceInterface.PrinterDriverDirectory -- PKEY_DeviceInterface_PrinterDriverDirectory</para>
            <para>Description: Printer information Printer Driver Directory.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {847C66DE-B8D6-4AF9-ABC3-6F4F926BC039}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DeviceInterface.PrinterDriverName">
            <summary>
            <para>Name:     System.DeviceInterface.PrinterDriverName -- PKEY_DeviceInterface_PrinterDriverName</para>
            <para>Description: Printer information Driver Name.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {AFC47170-14F5-498C-8F30-B0D19BE449C6}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DeviceInterface.PrinterName">
            <summary>
            <para>Name:     System.DeviceInterface.PrinterName -- PKEY_DeviceInterface_PrinterName</para>
            <para>Description: Printer information Printer Name.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0A7B84EF-0C27-463F-84EF-06C5070001BE}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DeviceInterface.PrinterPortName">
            <summary>
            <para>Name:     System.DeviceInterface.PrinterPortName -- PKEY_DeviceInterface_PrinterPortName</para>
            <para>Description: Printer information Port Name.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {EEC7B761-6F94-41B1-949F-C729720DD13C}, 12</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices">
            <summary>Devices Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.BatteryLife">
            <summary>
            <para>Name:     System.Devices.BatteryLife -- PKEY_Devices_BatteryLife</para>
            <para>Description: Remaining battery life of the device as an integer between 0 and 100 percent.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.BatteryPlusCharging">
            <summary>
            <para>Name:     System.Devices.BatteryPlusCharging -- PKEY_Devices_BatteryPlusCharging</para>
            <para>
            Description: Remaining battery life of the device as an integer between 0 and 100 percent and the device's charging state.
            </para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 22</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.BatteryPlusChargingText">
            <summary>
            <para>Name:     System.Devices.BatteryPlusChargingText -- PKEY_Devices_BatteryPlusChargingText</para>
            <para>Description: Remaining battery life of the device and the device's charging state as a string.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 23</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Category">
            <summary>
            <para>Name:     System.Devices.Category -- PKEY_Devices_Category_Desc_Singular</para>
            <para>Description: Singular form of device category.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 91</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.CategoryGroup">
            <summary>
            <para>Name:     System.Devices.CategoryGroup -- PKEY_Devices_CategoryGroup_Desc</para>
            <para>Description: Plural form of device category.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 94</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.CategoryPlural">
            <summary>
            <para>Name:     System.Devices.CategoryPlural -- PKEY_Devices_Category_Desc_Plural</para>
            <para>Description: Plural form of device category.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 92</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.ChargingState">
            <summary>
            <para>Name:     System.Devices.ChargingState -- PKEY_Devices_ChargingState</para>
            <para>Description: Boolean value representing if the device is currently charging.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Connected">
            <summary>
            <para>Name:     System.Devices.Connected -- PKEY_Devices_IsConnected</para>
            <para>
            Description: Device connection state. If VARIANT_TRUE, indicates the device is currently connected to the computer.
            </para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 55</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.ContainerId">
            <summary>
            <para>Name:     System.Devices.ContainerId -- PKEY_Devices_ContainerId</para>
            <para>Description: Device container ID.</para>
            <para>Type:     Guid -- VT_CLSID</para>
            <para>FormatID: {8C7ED206-3F8A-4827-B3AB-AE9E1FAEFC6C}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.DefaultTooltip">
            <summary>
            <para>Name:     System.Devices.DefaultTooltip -- PKEY_Devices_DefaultTooltip</para>
            <para>Description: Tooltip for default state</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 153</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.DeviceDescription1">
            <summary>
            <para>Name:     System.Devices.DeviceDescription1 -- PKEY_Devices_DeviceDescription1</para>
            <para>Description: First line of descriptive text about the device.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 81</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.DeviceDescription2">
            <summary>
            <para>Name:     System.Devices.DeviceDescription2 -- PKEY_Devices_DeviceDescription2</para>
            <para>Description: Second line of descriptive text about the device.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 82</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.DiscoveryMethod">
            <summary>
            <para>Name:     System.Devices.DiscoveryMethod -- PKEY_Devices_DiscoveryMethod</para>
            <para>
            Description: Device discovery method. This indicates on what transport or physical connection the device is discovered.
            </para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 52</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.FriendlyName">
            <summary>
            <para>Name:     System.Devices.FriendlyName -- PKEY_Devices_FriendlyName</para>
            <para>Description: Device friendly name.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 12288</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.FunctionPaths">
            <summary>
            <para>Name:     System.Devices.FunctionPaths -- PKEY_Devices_FunctionPaths</para>
            <para>Description: Available functions for this device.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.InterfacePaths">
            <summary>
            <para>Name:     System.Devices.InterfacePaths -- PKEY_Devices_InterfacePaths</para>
            <para>Description: Available interfaces for this device.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.IsDefault">
            <summary>
            <para>Name:     System.Devices.IsDefault -- PKEY_Devices_IsDefaultDevice</para>
            <para>Description: If VARIANT_TRUE, the device is not working properly.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 86</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.IsNetworkConnected">
            <summary>
            <para>Name:     System.Devices.IsNetworkConnected -- PKEY_Devices_IsNetworkDevice</para>
            <para>Description: If VARIANT_TRUE, the device is not working properly.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 85</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.IsShared">
            <summary>
            <para>Name:     System.Devices.IsShared -- PKEY_Devices_IsSharedDevice</para>
            <para>Description: If VARIANT_TRUE, the device is not working properly.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 84</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.IsSoftwareInstalling">
            <summary>
            <para>Name:     System.Devices.IsSoftwareInstalling -- PKEY_Devices_IsSoftwareInstalling</para>
            <para>Description: If VARIANT_TRUE, the device installer is currently installing software.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {83DA6326-97A6-4088-9453-A1923F573B29}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.LaunchDeviceStageFromExplorer">
            <summary>
            <para>Name:     System.Devices.LaunchDeviceStageFromExplorer -- PKEY_Devices_LaunchDeviceStageFromExplorer</para>
            <para>Description: Indicates whether to launch Device Stage or not</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 77</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.LocalMachine">
            <summary>
            <para>Name:     System.Devices.LocalMachine -- PKEY_Devices_IsLocalMachine</para>
            <para>Description: If VARIANT_TRUE, the device in question is actually the computer.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 70</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Manufacturer">
            <summary>
            <para>Name:     System.Devices.Manufacturer -- PKEY_Devices_Manufacturer</para>
            <para>Description: Device manufacturer.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8192</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.MissedCalls">
            <summary>
            <para>Name:     System.Devices.MissedCalls -- PKEY_Devices_MissedCalls</para>
            <para>Description: Number of missed calls on the device.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.ModelName">
            <summary>
            <para>Name:     System.Devices.ModelName -- PKEY_Devices_ModelName</para>
            <para>Description: Model name of the device.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8194</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.ModelNumber">
            <summary>
            <para>Name:     System.Devices.ModelNumber -- PKEY_Devices_ModelNumber</para>
            <para>Description: Model number of the device.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {656A3BB3-ECC0-43FD-8477-4AE0404A96CD}, 8195</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NetworkedTooltip">
            <summary>
            <para>Name:     System.Devices.NetworkedTooltip -- PKEY_Devices_NetworkedTooltip</para>
            <para>Description: Tooltip for connection state</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 152</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NetworkName">
            <summary>
            <para>Name:     System.Devices.NetworkName -- PKEY_Devices_NetworkName</para>
            <para>Description: Name of the device's network.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 7</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NetworkType">
            <summary>
            <para>Name:     System.Devices.NetworkType -- PKEY_Devices_NetworkType</para>
            <para>Description: String representing the type of the device's network.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NewPictures">
            <summary>
            <para>Name:     System.Devices.NewPictures -- PKEY_Devices_NewPictures</para>
            <para>Description: Number of new pictures on the device.</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notification">
            <summary>
            <para>Name:     System.Devices.Notification -- PKEY_Devices_Notification</para>
            <para>Description: Device Notification Property.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {06704B0C-E830-4C81-9178-91E4E95A80A0}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NotificationStore">
            <summary>
            <para>Name:     System.Devices.NotificationStore -- PKEY_Devices_NotificationStore</para>
            <para>Description: Device Notification Store.</para>
            <para>Type:     Object -- VT_UNKNOWN</para>
            <para>FormatID: {06704B0C-E830-4C81-9178-91E4E95A80A0}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.NotWorkingProperly">
            <summary>
            <para>Name:     System.Devices.NotWorkingProperly -- PKEY_Devices_IsNotWorkingProperly</para>
            <para>Description: If VARIANT_TRUE, the device is not working properly.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 83</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Paired">
            <summary>
            <para>Name:     System.Devices.Paired -- PKEY_Devices_IsPaired</para>
            <para>Description: Device paired state. If VARIANT_TRUE, indicates the device is not paired with the computer.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {78C34FC8-104A-4ACA-9EA4-524D52996E57}, 56</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.PrimaryCategory">
            <summary>
            <para>Name:     System.Devices.PrimaryCategory -- PKEY_Devices_PrimaryCategory</para>
            <para>Description: Primary category group for this device.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Roaming">
            <summary>
            <para>Name:     System.Devices.Roaming -- PKEY_Devices_Roaming</para>
            <para>Description: Status indicator used to indicate if the device is roaming.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.SafeRemovalRequired">
            <summary>
            <para>Name:     System.Devices.SafeRemovalRequired -- PKEY_Devices_SafeRemovalRequired</para>
            <para>Description: Indicates if a device requires safe removal or not</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {AFD97640-86A3-4210-B67C-289C41AABE55}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.SharedTooltip">
            <summary>
            <para>Name:     System.Devices.SharedTooltip -- PKEY_Devices_SharedTooltip</para>
            <para>Description: Tooltip for sharing state</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {880F70A2-6082-47AC-8AAB-A739D1A300C3}, 151</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.SignalStrength">
            <summary>
            <para>Name:     System.Devices.SignalStrength -- PKEY_Devices_SignalStrength</para>
            <para>Description: Device signal strength.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Status1">
            <summary>
            <para>Name:     System.Devices.Status1 -- PKEY_Devices_Status1</para>
            <para>Description: 1st line of device status.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 257</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Status2">
            <summary>
            <para>Name:     System.Devices.Status2 -- PKEY_Devices_Status2</para>
            <para>Description: 2nd line of device status.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D08DD4C0-3A9E-462E-8290-7B636B2576B9}, 258</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.StorageCapacity">
            <summary>
            <para>Name:     System.Devices.StorageCapacity -- PKEY_Devices_StorageCapacity</para>
            <para>Description: Total storage capacity of the device.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 12</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.StorageFreeSpace">
            <summary>
            <para>Name:     System.Devices.StorageFreeSpace -- PKEY_Devices_StorageFreeSpace</para>
            <para>Description: Total free space of the storage of the device.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 13</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.StorageFreeSpacePercent">
            <summary>
            <para>Name:     System.Devices.StorageFreeSpacePercent -- PKEY_Devices_StorageFreeSpacePercent</para>
            <para>Description: Total free space of the storage of the device as a percentage.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.TextMessages">
            <summary>
            <para>Name:     System.Devices.TextMessages -- PKEY_Devices_TextMessages</para>
            <para>Description: Number of unread text messages on the device.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Voicemail">
            <summary>
            <para>Name:     System.Devices.Voicemail -- PKEY_Devices_Voicemail</para>
            <para>Description: Status indicator used to indicate if the device has voicemail.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {49CD1F76-5626-4B17-A4E8-18B4AA1A2213}, 6</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications">
            <summary>Notifications Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.LowBattery">
            <summary>
            <para>Name:     System.Devices.Notifications.LowBattery -- PKEY_Devices_Notification_LowBattery</para>
            <para>Description: Device Low Battery Notification.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {C4C07F2B-8524-4E66-AE3A-A6235F103BEB}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.MissedCall">
            <summary>
            <para>Name:     System.Devices.Notifications.MissedCall -- PKEY_Devices_Notification_MissedCall</para>
            <para>Description: Device Missed Call Notification.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {6614EF48-4EFE-4424-9EDA-C79F404EDF3E}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.NewMessage">
            <summary>
            <para>Name:     System.Devices.Notifications.NewMessage -- PKEY_Devices_Notification_NewMessage</para>
            <para>Description: Device New Message Notification.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {2BE9260A-2012-4742-A555-F41B638B7DCB}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.NewVoicemail">
            <summary>
            <para>Name:     System.Devices.Notifications.NewVoicemail -- PKEY_Devices_Notification_NewVoicemail</para>
            <para>Description: Device Voicemail Notification.</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {59569556-0A08-4212-95B9-FAE2AD6413DB}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.StorageFull">
            <summary>
            <para>Name:     System.Devices.Notifications.StorageFull -- PKEY_Devices_Notification_StorageFull</para>
            <para>Description: Device Storage Full Notification.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {A0E00EE1-F0C7-4D41-B8E7-26A7BD8D38B0}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Devices.Notifications.StorageFullLinkText">
            <summary>
            <para>Name:     System.Devices.Notifications.StorageFullLinkText -- PKEY_Devices_Notification_StorageFullLinkText</para>
            <para>Description: Link Text for the Device Storage Full Notification.</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {A0E00EE1-F0C7-4D41-B8E7-26A7BD8D38B0}, 3</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document">
            <summary>Document Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.ByteCount">
            <summary>
            <para>Name:     System.Document.ByteCount -- PKEY_Document_ByteCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 4 (PIDDSI_BYTECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.CharacterCount">
            <summary>
            <para>Name:     System.Document.CharacterCount -- PKEY_Document_CharacterCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 16 (PIDSI_CHARCOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.ClientID">
            <summary>
            <para>Name:     System.Document.ClientID -- PKEY_Document_ClientID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {276D7BB0-5B34-4FB0-AA4B-158ED12A1809}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Contributor">
            <summary>
            <para>Name:     System.Document.Contributor -- PKEY_Document_Contributor</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {F334115E-DA1B-4509-9B3D-119504DC7ABB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.DateCreated">
            <summary>
            <para>Name:     System.Document.DateCreated -- PKEY_Document_DateCreated</para>
            <para>Description: This property is stored in the document, not obtained from the file system.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 12 (PIDSI_CREATE_DTM)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.DatePrinted">
            <summary>
            <para>Name:     System.Document.DatePrinted -- PKEY_Document_DatePrinted</para>
            <para>Description: Legacy name: "DocLastPrinted".</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 11 (PIDSI_LASTPRINTED)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.DateSaved">
            <summary>
            <para>Name:     System.Document.DateSaved -- PKEY_Document_DateSaved</para>
            <para>Description: Legacy name: "DocLastSavedTm".</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 13 (PIDSI_LASTSAVE_DTM)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Division">
            <summary>
            <para>Name:     System.Document.Division -- PKEY_Document_Division</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {1E005EE6-BF27-428B-B01C-79676ACD2870}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.DocumentID">
            <summary>
            <para>Name:     System.Document.DocumentID -- PKEY_Document_DocumentID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E08805C8-E395-40DF-80D2-54F0D6C43154}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.HiddenSlideCount">
            <summary>
            <para>Name:     System.Document.HiddenSlideCount -- PKEY_Document_HiddenSlideCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 9 (PIDDSI_HIDDENCOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.LastAuthor">
            <summary>
            <para>Name:     System.Document.LastAuthor -- PKEY_Document_LastAuthor</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 8 (PIDSI_LASTAUTHOR)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.LineCount">
            <summary>
            <para>Name:     System.Document.LineCount -- PKEY_Document_LineCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 5 (PIDDSI_LINECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Manager">
            <summary>
            <para>Name:     System.Document.Manager -- PKEY_Document_Manager</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 14 (PIDDSI_MANAGER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.MultimediaClipCount">
            <summary>
            <para>Name:     System.Document.MultimediaClipCount -- PKEY_Document_MultimediaClipCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 10 (PIDDSI_MMCLIPCOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.NoteCount">
            <summary>
            <para>Name:     System.Document.NoteCount -- PKEY_Document_NoteCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 8 (PIDDSI_NOTECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.PageCount">
            <summary>
            <para>Name:     System.Document.PageCount -- PKEY_Document_PageCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 14 (PIDSI_PAGECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.ParagraphCount">
            <summary>
            <para>Name:     System.Document.ParagraphCount -- PKEY_Document_ParagraphCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 6 (PIDDSI_PARCOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.PresentationFormat">
            <summary>
            <para>Name:     System.Document.PresentationFormat -- PKEY_Document_PresentationFormat</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 3 (PIDDSI_PRESFORMAT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.RevisionNumber">
            <summary>
            <para>Name:     System.Document.RevisionNumber -- PKEY_Document_RevisionNumber</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 9 (PIDSI_REVNUMBER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Security">
            <summary>
            <para>Name:     System.Document.Security -- PKEY_Document_Security</para>
            <para>Description: Access control information, from SummaryInfo propset</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 19</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.SlideCount">
            <summary>
            <para>Name:     System.Document.SlideCount -- PKEY_Document_SlideCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 7 (PIDDSI_SLIDECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Template">
            <summary>
            <para>Name:     System.Document.Template -- PKEY_Document_Template</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 7 (PIDSI_TEMPLATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.TotalEditingTime">
            <summary>
            <para>Name:     System.Document.TotalEditingTime -- PKEY_Document_TotalEditingTime</para>
            <para>Description: 100ns units, not milliseconds. VT_FILETIME for IPropertySetStorage handlers (legacy)</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 10 (PIDSI_EDITTIME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.Version">
            <summary>
            <para>Name:     System.Document.Version -- PKEY_Document_Version</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DocumentSummaryInformation) {D5CDD502-2E9C-101B-9397-08002B2CF9AE}, 29</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Document.WordCount">
            <summary>
            <para>Name:     System.Document.WordCount -- PKEY_Document_WordCount</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_SummaryInformation) {F29F85E0-4FF9-1068-AB91-08002B27B3D9}, 15 (PIDSI_WORDCOUNT)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM">
            <summary>DRM Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM.DatePlayExpires">
            <summary>
            <para>Name:     System.DRM.DatePlayExpires -- PKEY_DRM_DatePlayExpires</para>
            <para>Description: Indicates when play expires for digital rights management.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 6 (PIDDRSI_PLAYEXPIRES)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM.DatePlayStarts">
            <summary>
            <para>Name:     System.DRM.DatePlayStarts -- PKEY_DRM_DatePlayStarts</para>
            <para>Description: Indicates when play starts for digital rights management.</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 5 (PIDDRSI_PLAYSTARTS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM.Description">
            <summary>
            <para>Name:     System.DRM.Description -- PKEY_DRM_Description</para>
            <para>Description: Displays the description for digital rights management.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 3 (PIDDRSI_DESCRIPTION)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM.IsProtected">
            <summary>
            <para>Name:     System.DRM.IsProtected -- PKEY_DRM_IsProtected</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 2 (PIDDRSI_PROTECTED)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.DRM.PlayCount">
            <summary>
            <para>Name:     System.DRM.PlayCount -- PKEY_DRM_PlayCount</para>
            <para>Description: Indicates the play count for digital rights management.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_DRM) {AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED}, 4 (PIDDRSI_PLAYCOUNT)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS">
            <summary>GPS Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Altitude">
            <summary>
            <para>Name:     System.GPS.Altitude -- PKEY_GPS_Altitude</para>
            <para>
            Description: Indicates the altitude based on the reference in PKEY_GPS_AltitudeRef. Calculated from
            PKEY_GPS_AltitudeNumerator and PKEY_GPS_AltitudeDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {827EDB4F-5B73-44A7-891D-FDFFABEA35CA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.AltitudeDenominator">
            <summary>
            <para>Name:     System.GPS.AltitudeDenominator -- PKEY_GPS_AltitudeDenominator</para>
            <para>Description: Denominator of PKEY_GPS_Altitude</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {78342DCB-E358-4145-AE9A-6BFE4E0F9F51}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.AltitudeNumerator">
            <summary>
            <para>Name:     System.GPS.AltitudeNumerator -- PKEY_GPS_AltitudeNumerator</para>
            <para>Description: Numerator of PKEY_GPS_Altitude</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {2DAD1EB7-816D-40D3-9EC3-C9773BE2AADE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.AltitudeRef">
            <summary>
            <para>Name:     System.GPS.AltitudeRef -- PKEY_GPS_AltitudeRef</para>
            <para>
            Description: Indicates the reference for the altitude property. (eg: above sea level, below sea level, absolute value)
            </para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: {46AC629D-75EA-4515-867F-6DC4321C5844}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.AreaInformation">
            <summary>
            <para>Name:     System.GPS.AreaInformation -- PKEY_GPS_AreaInformation</para>
            <para>Description: Represents the name of the GPS area</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {972E333E-AC7E-49F1-8ADF-A70D07A9BCAB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Date">
            <summary>
            <para>Name:     System.GPS.Date -- PKEY_GPS_Date</para>
            <para>Description: Date and time of the GPS record</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {3602C812-0F3B-45F0-85AD-603468D69423}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestBearing">
            <summary>
            <para>Name:     System.GPS.DestBearing -- PKEY_GPS_DestBearing</para>
            <para>
            Description: Indicates the bearing to the destination point. Calculated from PKEY_GPS_DestBearingNumerator and PKEY_GPS_DestBearingDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {C66D4B3C-E888-47CC-B99F-9DCA3EE34DEA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestBearingDenominator">
            <summary>
            <para>Name:     System.GPS.DestBearingDenominator -- PKEY_GPS_DestBearingDenominator</para>
            <para>Description: Denominator of PKEY_GPS_DestBearing</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {7ABCF4F8-7C3F-4988-AC91-8D2C2E97ECA5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestBearingNumerator">
            <summary>
            <para>Name:     System.GPS.DestBearingNumerator -- PKEY_GPS_DestBearingNumerator</para>
            <para>Description: Numerator of PKEY_GPS_DestBearing</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {BA3B1DA9-86EE-4B5D-A2A4-A271A429F0CF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestBearingRef">
            <summary>
            <para>Name:     System.GPS.DestBearingRef -- PKEY_GPS_DestBearingRef</para>
            <para>
            Description: Indicates the reference used for the giving the bearing to the destination point. (eg: true direction,
            magnetic direction)
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9AB84393-2A0F-4B75-BB22-7279786977CB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestDistance">
            <summary>
            <para>Name:     System.GPS.DestDistance -- PKEY_GPS_DestDistance</para>
            <para>
            Description: Indicates the distance to the destination point. Calculated from PKEY_GPS_DestDistanceNumerator and PKEY_GPS_DestDistanceDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {A93EAE04-6804-4F24-AC81-09B266452118}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestDistanceDenominator">
            <summary>
            <para>Name:     System.GPS.DestDistanceDenominator -- PKEY_GPS_DestDistanceDenominator</para>
            <para>Description: Denominator of PKEY_GPS_DestDistance</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {9BC2C99B-AC71-4127-9D1C-2596D0D7DCB7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestDistanceNumerator">
            <summary>
            <para>Name:     System.GPS.DestDistanceNumerator -- PKEY_GPS_DestDistanceNumerator</para>
            <para>Description: Numerator of PKEY_GPS_DestDistance</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {2BDA47DA-08C6-4FE1-80BC-A72FC517C5D0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestDistanceRef">
            <summary>
            <para>Name:     System.GPS.DestDistanceRef -- PKEY_GPS_DestDistanceRef</para>
            <para>
            Description: Indicates the unit used to express the distance to the destination. (eg: kilometers, miles, knots)
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {ED4DF2D3-8695-450B-856F-F5C1C53ACB66}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLatitude">
            <summary>
            <para>Name:     System.GPS.DestLatitude -- PKEY_GPS_DestLatitude</para>
            <para>
            Description: Indicates the latitude of the destination point. This is an array of three values. Index 0 is the
            degrees, index 1 is the minutes, index 2 is the seconds. Each is calculated from the values in
            PKEY_GPS_DestLatitudeNumerator and PKEY_GPS_DestLatitudeDenominator.
            </para>
            <para>Type:     Multivalue Double -- VT_VECTOR | VT_R8 (For variants: VT_ARRAY | VT_R8)</para>
            <para>FormatID: {9D1D7CC5-5C39-451C-86B3-928E2D18CC47}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLatitudeDenominator">
            <summary>
            <para>Name:     System.GPS.DestLatitudeDenominator -- PKEY_GPS_DestLatitudeDenominator</para>
            <para>Description: Denominator of PKEY_GPS_DestLatitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {3A372292-7FCA-49A7-99D5-E47BB2D4E7AB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLatitudeNumerator">
            <summary>
            <para>Name:     System.GPS.DestLatitudeNumerator -- PKEY_GPS_DestLatitudeNumerator</para>
            <para>Description: Numerator of PKEY_GPS_DestLatitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {ECF4B6F6-D5A6-433C-BB92-4076650FC890}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLatitudeRef">
            <summary>
            <para>Name:     System.GPS.DestLatitudeRef -- PKEY_GPS_DestLatitudeRef</para>
            <para>Description: Indicates whether the latitude destination point is north or south latitude</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CEA820B9-CE61-4885-A128-005D9087C192}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLongitude">
            <summary>
            <para>Name:     System.GPS.DestLongitude -- PKEY_GPS_DestLongitude</para>
            <para>
            Description: Indicates the latitude of the destination point. This is an array of three values. Index 0 is the
            degrees, index 1 is the minutes, index 2 is the seconds. Each is calculated from the values in
            PKEY_GPS_DestLongitudeNumerator and PKEY_GPS_DestLongitudeDenominator.
            </para>
            <para>Type:     Multivalue Double -- VT_VECTOR | VT_R8 (For variants: VT_ARRAY | VT_R8)</para>
            <para>FormatID: {47A96261-CB4C-4807-8AD3-40B9D9DBC6BC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLongitudeDenominator">
            <summary>
            <para>Name:     System.GPS.DestLongitudeDenominator -- PKEY_GPS_DestLongitudeDenominator</para>
            <para>Description: Denominator of PKEY_GPS_DestLongitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {425D69E5-48AD-4900-8D80-6EB6B8D0AC86}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLongitudeNumerator">
            <summary>
            <para>Name:     System.GPS.DestLongitudeNumerator -- PKEY_GPS_DestLongitudeNumerator</para>
            <para>Description: Numerator of PKEY_GPS_DestLongitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {A3250282-FB6D-48D5-9A89-DBCACE75CCCF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DestLongitudeRef">
            <summary>
            <para>Name:     System.GPS.DestLongitudeRef -- PKEY_GPS_DestLongitudeRef</para>
            <para>Description: Indicates whether the longitude destination point is east or west longitude</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {182C1EA6-7C1C-4083-AB4B-AC6C9F4ED128}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Differential">
            <summary>
            <para>Name:     System.GPS.Differential -- PKEY_GPS_Differential</para>
            <para>Description: Indicates whether differential correction was applied to the GPS receiver</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {AAF4EE25-BD3B-4DD7-BFC4-47F77BB00F6D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DOP">
            <summary>
            <para>Name:     System.GPS.DOP -- PKEY_GPS_DOP</para>
            <para>
            Description: Indicates the GPS DOP (data degree of precision). Calculated from PKEY_GPS_DOPNumerator and PKEY_GPS_DOPDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {0CF8FB02-1837-42F1-A697-A7017AA289B9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DOPDenominator">
            <summary>
            <para>Name:     System.GPS.DOPDenominator -- PKEY_GPS_DOPDenominator</para>
            <para>Description: Denominator of PKEY_GPS_DOP</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {A0BE94C5-50BA-487B-BD35-0654BE8881ED}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.DOPNumerator">
            <summary>
            <para>Name:     System.GPS.DOPNumerator -- PKEY_GPS_DOPNumerator</para>
            <para>Description: Numerator of PKEY_GPS_DOP</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {47166B16-364F-4AA0-9F31-E2AB3DF449C3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.ImgDirection">
            <summary>
            <para>Name:     System.GPS.ImgDirection -- PKEY_GPS_ImgDirection</para>
            <para>
            Description: Indicates direction of the image when it was captured. Calculated from PKEY_GPS_ImgDirectionNumerator
            and PKEY_GPS_ImgDirectionDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {16473C91-D017-4ED9-BA4D-B6BAA55DBCF8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.ImgDirectionDenominator">
            <summary>
            <para>Name:     System.GPS.ImgDirectionDenominator -- PKEY_GPS_ImgDirectionDenominator</para>
            <para>Description: Denominator of PKEY_GPS_ImgDirection</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {10B24595-41A2-4E20-93C2-5761C1395F32}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.ImgDirectionNumerator">
            <summary>
            <para>Name:     System.GPS.ImgDirectionNumerator -- PKEY_GPS_ImgDirectionNumerator</para>
            <para>Description: Numerator of PKEY_GPS_ImgDirection</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {DC5877C7-225F-45F7-BAC7-E81334B6130A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.ImgDirectionRef">
            <summary>
            <para>Name:     System.GPS.ImgDirectionRef -- PKEY_GPS_ImgDirectionRef</para>
            <para>
            Description: Indicates reference for giving the direction of the image when it was captured. (eg: true direction,
            magnetic direction)
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A4AAA5B7-1AD0-445F-811A-0F8F6E67F6B5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Latitude">
            <summary>
            <para>Name:     System.GPS.Latitude -- PKEY_GPS_Latitude</para>
            <para>
            Description: Indicates the latitude. This is an array of three values. Index 0 is the degrees, index 1 is the
            minutes, index 2 is the seconds. Each is calculated from the values in PKEY_GPS_LatitudeNumerator and PKEY_GPS_LatitudeDenominator.
            </para>
            <para>Type:     Multivalue Double -- VT_VECTOR | VT_R8 (For variants: VT_ARRAY | VT_R8)</para>
            <para>FormatID: {8727CFFF-4868-4EC6-AD5B-81B98521D1AB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LatitudeDenominator">
            <summary>
            <para>Name:     System.GPS.LatitudeDenominator -- PKEY_GPS_LatitudeDenominator</para>
            <para>Description: Denominator of PKEY_GPS_Latitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {16E634EE-2BFF-497B-BD8A-4341AD39EEB9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LatitudeNumerator">
            <summary>
            <para>Name:     System.GPS.LatitudeNumerator -- PKEY_GPS_LatitudeNumerator</para>
            <para>Description: Numerator of PKEY_GPS_Latitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {7DDAAAD1-CCC8-41AE-B750-B2CB8031AEA2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LatitudeRef">
            <summary>
            <para>Name:     System.GPS.LatitudeRef -- PKEY_GPS_LatitudeRef</para>
            <para>Description: Indicates whether latitude is north or south latitude</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {029C0252-5B86-46C7-ACA0-2769FFC8E3D4}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Longitude">
            <summary>
            <para>Name:     System.GPS.Longitude -- PKEY_GPS_Longitude</para>
            <para>
            Description: Indicates the longitude. This is an array of three values. Index 0 is the degrees, index 1 is the
            minutes, index 2 is the seconds. Each is calculated from the values in PKEY_GPS_LongitudeNumerator and PKEY_GPS_LongitudeDenominator.
            </para>
            <para>Type:     Multivalue Double -- VT_VECTOR | VT_R8 (For variants: VT_ARRAY | VT_R8)</para>
            <para>FormatID: {C4C4DBB2-B593-466B-BBDA-D03D27D5E43A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LongitudeDenominator">
            <summary>
            <para>Name:     System.GPS.LongitudeDenominator -- PKEY_GPS_LongitudeDenominator</para>
            <para>Description: Denominator of PKEY_GPS_Longitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {BE6E176C-4534-4D2C-ACE5-31DEDAC1606B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LongitudeNumerator">
            <summary>
            <para>Name:     System.GPS.LongitudeNumerator -- PKEY_GPS_LongitudeNumerator</para>
            <para>Description: Numerator of PKEY_GPS_Longitude</para>
            <para>Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4 (For variants: VT_ARRAY | VT_UI4)</para>
            <para>FormatID: {02B0F689-A914-4E45-821D-1DDA452ED2C4}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.LongitudeRef">
            <summary>
            <para>Name:     System.GPS.LongitudeRef -- PKEY_GPS_LongitudeRef</para>
            <para>Description: Indicates whether longitude is east or west longitude</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {33DCF22B-28D5-464C-8035-1EE9EFD25278}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.MapDatum">
            <summary>
            <para>Name:     System.GPS.MapDatum -- PKEY_GPS_MapDatum</para>
            <para>Description: Indicates the geodetic survey data used by the GPS receiver</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {2CA2DAE6-EDDC-407D-BEF1-773942ABFA95}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.MeasureMode">
            <summary>
            <para>Name:     System.GPS.MeasureMode -- PKEY_GPS_MeasureMode</para>
            <para>Description: Indicates the GPS measurement mode. (eg: 2-dimensional, 3-dimensional)</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A015ED5D-AAEA-4D58-8A86-3C586920EA0B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.ProcessingMethod">
            <summary>
            <para>Name:     System.GPS.ProcessingMethod -- PKEY_GPS_ProcessingMethod</para>
            <para>Description: Indicates the name of the method used for location finding</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {59D49E61-840F-4AA9-A939-E2099B7F6399}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Satellites">
            <summary>
            <para>Name:     System.GPS.Satellites -- PKEY_GPS_Satellites</para>
            <para>Description: Indicates the GPS satellites used for measurements</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {467EE575-1F25-4557-AD4E-B8B58B0D9C15}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Speed">
            <summary>
            <para>Name:     System.GPS.Speed -- PKEY_GPS_Speed</para>
            <para>
            Description: Indicates the speed of the GPS receiver movement. Calculated from PKEY_GPS_SpeedNumerator and PKEY_GPS_SpeedDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {DA5D0862-6E76-4E1B-BABD-70021BD25494}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.SpeedDenominator">
            <summary>
            <para>Name:     System.GPS.SpeedDenominator -- PKEY_GPS_SpeedDenominator</para>
            <para>Description: Denominator of PKEY_GPS_Speed</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {7D122D5A-AE5E-4335-8841-D71E7CE72F53}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.SpeedNumerator">
            <summary>
            <para>Name:     System.GPS.SpeedNumerator -- PKEY_GPS_SpeedNumerator</para>
            <para>Description: Numerator of PKEY_GPS_Speed</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {ACC9CE3D-C213-4942-8B48-6D0820F21C6D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.SpeedRef">
            <summary>
            <para>Name:     System.GPS.SpeedRef -- PKEY_GPS_SpeedRef</para>
            <para>
            Description: Indicates the unit used to express the speed of the GPS receiver movement. (eg: kilometers per hour,
            miles per hour, knots).
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {ECF7F4C9-544F-4D6D-9D98-8AD79ADAF453}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Status">
            <summary>
            <para>Name:     System.GPS.Status -- PKEY_GPS_Status</para>
            <para>
            Description: Indicates the status of the GPS receiver when the image was recorded. (eg: measurement in progress,
            measurement interoperability).
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {125491F4-818F-46B2-91B5-D537753617B2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.Track">
            <summary>
            <para>Name:     System.GPS.Track -- PKEY_GPS_Track</para>
            <para>
            Description: Indicates the direction of the GPS receiver movement. Calculated from PKEY_GPS_TrackNumerator and PKEY_GPS_TrackDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {76C09943-7C33-49E3-9E7E-CDBA872CFADA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.TrackDenominator">
            <summary>
            <para>Name:     System.GPS.TrackDenominator -- PKEY_GPS_TrackDenominator</para>
            <para>Description: Denominator of PKEY_GPS_Track</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {C8D1920C-01F6-40C0-AC86-2F3A4AD00770}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.TrackNumerator">
            <summary>
            <para>Name:     System.GPS.TrackNumerator -- PKEY_GPS_TrackNumerator</para>
            <para>Description: Numerator of PKEY_GPS_Track</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {702926F4-44A6-43E1-AE71-45627116893B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.TrackRef">
            <summary>
            <para>Name:     System.GPS.TrackRef -- PKEY_GPS_TrackRef</para>
            <para>
            Description: Indicates reference for the direction of the GPS receiver movement. (eg: true direction, magnetic direction)
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {35DBE6FE-44C3-4400-AAAE-D2C799C407E8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.GPS.VersionID">
            <summary>
            <para>Name:     System.GPS.VersionID -- PKEY_GPS_VersionID</para>
            <para>Description: Indicates the version of the GPS information</para>
            <para>Type:     Buffer -- VT_VECTOR | VT_UI1 (For variants: VT_ARRAY | VT_UI1)</para>
            <para>FormatID: {22704DA4-C6B2-4A99-8E56-F16DF8C92599}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity">
            <summary>Identity Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.Blob">
            <summary>
            <para>Name:     System.Identity.Blob -- PKEY_Identity_Blob</para>
            <para>Description: Blob used to import/export identities</para>
            <para>Type:     Blob -- VT_BLOB</para>
            <para>FormatID: {8C3B93A4-BAED-1A83-9A32-102EE313F6EB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.DisplayName">
            <summary>
            <para>Name:     System.Identity.DisplayName -- PKEY_Identity_DisplayName</para>
            <para>Description: Display Name</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7D683FC9-D155-45A8-BB1F-89D19BCB792F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.IsMeIdentity">
            <summary>
            <para>Name:     System.Identity.IsMeIdentity -- PKEY_Identity_IsMeIdentity</para>
            <para>Description: Is it Me Identity</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {A4108708-09DF-4377-9DFC-6D99986D5A67}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.PrimaryEmailAddress">
            <summary>
            <para>Name:     System.Identity.PrimaryEmailAddress -- PKEY_Identity_PrimaryEmailAddress</para>
            <para>Description: Primary Email Address</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FCC16823-BAED-4F24-9B32-A0982117F7FA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.ProviderID">
            <summary>
            <para>Name:     System.Identity.ProviderID -- PKEY_Identity_ProviderID</para>
            <para>Description: Provider ID</para>
            <para>Type:     Guid -- VT_CLSID</para>
            <para>FormatID: {74A7DE49-FA11-4D3D-A006-DB7E08675916}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.UniqueID">
            <summary>
            <para>Name:     System.Identity.UniqueID -- PKEY_Identity_UniqueID</para>
            <para>Description: Unique ID</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E55FC3B0-2B60-4220-918E-B21E8BF16016}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Identity.UserName">
            <summary>
            <para>Name:     System.Identity.UserName -- PKEY_Identity_UserName</para>
            <para>Description: Identity User Name</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C4322503-78CA-49C6-9ACC-A68E2AFD7B6B}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IdentityProvider">
            <summary>IdentityProvider Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IdentityProvider.Name">
            <summary>
            <para>Name:     System.IdentityProvider.Name -- PKEY_IdentityProvider_Name</para>
            <para>Description: Identity Provider Name</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {B96EFF7B-35CA-4A35-8607-29E3A54C46EA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.IdentityProvider.Picture">
            <summary>
            <para>Name:     System.IdentityProvider.Picture -- PKEY_IdentityProvider_Picture</para>
            <para>Description: Picture for the Identity Provider</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {2425166F-5642-4864-992F-98FD98F294C3}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image">
            <summary>Image Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.BitDepth">
            <summary>
            <para>Name:     System.Image.BitDepth -- PKEY_Image_BitDepth</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 7 (PIDISI_BITDEPTH)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.ColorSpace">
            <summary>
            <para>Name:     System.Image.ColorSpace -- PKEY_Image_ColorSpace</para>
            <para>Description: PropertyTagExifColorSpace</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 40961</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.CompressedBitsPerPixel">
            <summary>
            <para>Name:     System.Image.CompressedBitsPerPixel -- PKEY_Image_CompressedBitsPerPixel</para>
            <para>
            Description: Calculated from PKEY_Image_CompressedBitsPerPixelNumerator and PKEY_Image_CompressedBitsPerPixelDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {364B6FA9-37AB-482A-BE2B-AE02F60D4318}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.CompressedBitsPerPixelDenominator">
            <summary>
            <para>Name:     System.Image.CompressedBitsPerPixelDenominator -- PKEY_Image_CompressedBitsPerPixelDenominator</para>
            <para>Description: Denominator of PKEY_Image_CompressedBitsPerPixel.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {1F8844E1-24AD-4508-9DFD-5326A415CE02}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.CompressedBitsPerPixelNumerator">
            <summary>
            <para>Name:     System.Image.CompressedBitsPerPixelNumerator -- PKEY_Image_CompressedBitsPerPixelNumerator</para>
            <para>Description: Numerator of PKEY_Image_CompressedBitsPerPixel.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {D21A7148-D32C-4624-8900-277210F79C0F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.Compression">
            <summary>
            <para>Name:     System.Image.Compression -- PKEY_Image_Compression</para>
            <para>Description: Indicates the image compression level. PropertyTagCompression.</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 259</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.CompressionText">
            <summary>
            <para>Name:     System.Image.CompressionText -- PKEY_Image_CompressionText</para>
            <para>
            Description: This is the user-friendly form of System.Image.Compression. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {3F08E66F-2F44-4BB9-A682-AC35D2562322}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.Dimensions">
            <summary>
            <para>Name:     System.Image.Dimensions -- PKEY_Image_Dimensions</para>
            <para>Description: Indicates the dimensions of the image.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 13 (PIDISI_DIMENSIONS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.HorizontalResolution">
            <summary>
            <para>Name:     System.Image.HorizontalResolution -- PKEY_Image_HorizontalResolution</para>
            <para>Description:</para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 5 (PIDISI_RESOLUTIONX)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.HorizontalSize">
            <summary>
            <para>Name:     System.Image.HorizontalSize -- PKEY_Image_HorizontalSize</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 3 (PIDISI_CX)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.ImageID">
            <summary>
            <para>Name:     System.Image.ImageID -- PKEY_Image_ImageID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {10DABE05-32AA-4C29-BF1A-63E2D220587F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.ResolutionUnit">
            <summary>
            <para>Name:     System.Image.ResolutionUnit -- PKEY_Image_ResolutionUnit</para>
            <para>Description:</para>
            <para>Type:     Int16 -- VT_I2</para>
            <para>FormatID: {19B51FA6-1F92-4A5C-AB48-7DF0ABD67444}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.VerticalResolution">
            <summary>
            <para>Name:     System.Image.VerticalResolution -- PKEY_Image_VerticalResolution</para>
            <para>Description:</para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 6 (PIDISI_RESOLUTIONY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Image.VerticalSize">
            <summary>
            <para>Name:     System.Image.VerticalSize -- PKEY_Image_VerticalSize</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 4 (PIDISI_CY)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Journal">
            <summary>Journal Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Journal.Contacts">
            <summary>
            <para>Name:     System.Journal.Contacts -- PKEY_Journal_Contacts</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {DEA7C82C-1D89-4A66-9427-A4E3DEBABCB1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Journal.EntryType">
            <summary>
            <para>Name:     System.Journal.EntryType -- PKEY_Journal_EntryType</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {95BEB1FC-326D-4644-B396-CD3ED90E6DDF}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.LayoutPattern">
            <summary>LayoutPattern Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.LayoutPattern.ContentViewModeForBrowse">
            <summary>
            <para>Name:     System.LayoutPattern.ContentViewModeForBrowse -- PKEY_LayoutPattern_ContentViewModeForBrowse</para>
            <para>
            Description: Specifies the layout pattern that the content view mode should apply for this item in the context of
            browsing. Register the regvalue under the name of "ContentViewModeLayoutPatternForBrowse".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 500</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.LayoutPattern.ContentViewModeForSearch">
            <summary>
            <para>Name:     System.LayoutPattern.ContentViewModeForSearch -- PKEY_LayoutPattern_ContentViewModeForSearch</para>
            <para>
            Description: Specifies the layout pattern that the content view mode should apply for this item in the context of
            searching. Register the regvalue under the name of "ContentViewModeLayoutPatternForSearch".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 501</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link">
            <summary>Link Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.Arguments">
            <summary>
            <para>Name:     System.Link.Arguments -- PKEY_Link_Arguments</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {436F2667-14E2-4FEB-B30A-146C53B5B674}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.Comment">
            <summary>
            <para>Name:     System.Link.Comment -- PKEY_Link_Comment</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.DateVisited">
            <summary>
            <para>Name:     System.Link.DateVisited -- PKEY_Link_DateVisited</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 23 (PKEYs relating to URLs. Used by IE History.)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.Description">
            <summary>
            <para>Name:     System.Link.Description -- PKEY_Link_Description</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 21 (PKEYs relating to URLs. Used by IE History.)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.Status">
            <summary>
            <para>Name:     System.Link.Status -- PKEY_Link_Status</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 3 (PID_LINK_TARGET_TYPE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.TargetExtension">
            <summary>
            <para>Name:     System.Link.TargetExtension -- PKEY_Link_TargetExtension</para>
            <para>Description: The file extension of the link target. See System.File.Extension</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {7A7D76F4-B630-4BD7-95FF-37CC51A975C9}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.TargetParsingPath">
            <summary>
            <para>Name:     System.Link.TargetParsingPath -- PKEY_Link_TargetParsingPath</para>
            <para>
            Description: This is the shell namespace path to the target of the link item. This path may be passed to
            SHParseDisplayName to parse the path to the correct shell folder. If the target item is a file, the value is
            identical to System.ItemPathDisplay. If the target item cannot be accessed through the shell namespace, this value is VT_EMPTY.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 2 (PID_LINK_TARGET)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.TargetSFGAOFlags">
            <summary>
            <para>Name:     System.Link.TargetSFGAOFlags -- PKEY_Link_TargetSFGAOFlags</para>
            <para>
            Description: IShellFolder::GetAttributesOf flags for the target of a link, with SFGAO_PKEYSFGAOMASK attributes masked out.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_LINK) {B9B4B3FC-2B51-4A42-B5D8-324146AFCF25}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.TargetSFGAOFlagsStrings">
            <summary>
            <para>Name:     System.Link.TargetSFGAOFlagsStrings -- PKEY_Link_TargetSFGAOFlagsStrings</para>
            <para>
            Description: Expresses the SFGAO flags of a link as string values and is used as a query optimization. See
            PKEY_Shell_SFGAOFlagsStrings for possible values of this.
            </para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D6942081-D53B-443D-AD47-5E059D9CD27A}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Link.TargetUrl">
            <summary>
            <para>Name:     System.Link.TargetUrl -- PKEY_Link_TargetUrl</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {5CBF2787-48CF-4208-B90E-EE5E5D420294}, 2 (PKEYs relating to URLs. Used by IE History.)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media">
            <summary>Media Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.AuthorUrl">
            <summary>
            <para>Name:     System.Media.AuthorUrl -- PKEY_Media_AuthorUrl</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 32 (PIDMSI_AUTHOR_URL)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.AverageLevel">
            <summary>
            <para>Name:     System.Media.AverageLevel -- PKEY_Media_AverageLevel</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {09EDD5B6-B301-43C5-9990-D00302EFFD46}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ClassPrimaryID">
            <summary>
            <para>Name:     System.Media.ClassPrimaryID -- PKEY_Media_ClassPrimaryID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 13 (PIDMSI_CLASS_PRIMARY_ID)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ClassSecondaryID">
            <summary>
            <para>Name:     System.Media.ClassSecondaryID -- PKEY_Media_ClassSecondaryID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 14 (PIDMSI_CLASS_SECONDARY_ID)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.CollectionGroupID">
            <summary>
            <para>Name:     System.Media.CollectionGroupID -- PKEY_Media_CollectionGroupID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 24 (PIDMSI_COLLECTION_GROUP_ID)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.CollectionID">
            <summary>
            <para>Name:     System.Media.CollectionID -- PKEY_Media_CollectionID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 25 (PIDMSI_COLLECTION_ID)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ContentDistributor">
            <summary>
            <para>Name:     System.Media.ContentDistributor -- PKEY_Media_ContentDistributor</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 18 (PIDMSI_CONTENTDISTRIBUTOR)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ContentID">
            <summary>
            <para>Name:     System.Media.ContentID -- PKEY_Media_ContentID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 26 (PIDMSI_CONTENT_ID)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.CreatorApplication">
            <summary>
            <para>Name:     System.Media.CreatorApplication -- PKEY_Media_CreatorApplication</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 27 (PIDMSI_TOOL_NAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.CreatorApplicationVersion">
            <summary>
            <para>Name:     System.Media.CreatorApplicationVersion -- PKEY_Media_CreatorApplicationVersion</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 28 (PIDMSI_TOOL_VERSION)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.DateEncoded">
            <summary>
            <para>Name:     System.Media.DateEncoded -- PKEY_Media_DateEncoded</para>
            <para>Description: DateTime is in UTC (in the doc, not file system).</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {2E4B640D-5019-46D8-8881-55414CC5CAA0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.DateReleased">
            <summary>
            <para>Name:     System.Media.DateReleased -- PKEY_Media_DateReleased</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DE41CC29-6971-4290-B472-F59F2E2F31E2}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.Duration">
            <summary>
            <para>Name:     System.Media.Duration -- PKEY_Media_Duration</para>
            <para>Description: 100ns units, not milliseconds</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: (FMTID_AudioSummaryInformation) {64440490-4C8B-11D1-8B70-080036B11A03}, 3 (PIDASI_TIMELENGTH)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.DVDID">
            <summary>
            <para>Name:     System.Media.DVDID -- PKEY_Media_DVDID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 15 (PIDMSI_DVDID)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.EncodedBy">
            <summary>
            <para>Name:     System.Media.EncodedBy -- PKEY_Media_EncodedBy</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 36 (PIDMSI_ENCODED_BY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.EncodingSettings">
            <summary>
            <para>Name:     System.Media.EncodingSettings -- PKEY_Media_EncodingSettings</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 37 (PIDMSI_ENCODING_SETTINGS)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.FrameCount">
            <summary>
            <para>Name:     System.Media.FrameCount -- PKEY_Media_FrameCount</para>
            <para>Description: Indicates the frame count for the image.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (PSGUID_IMAGESUMMARYINFORMATION) {6444048F-4C8B-11D1-8B70-080036B11A03}, 12 (PIDISI_FRAMECOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.MCDI">
            <summary>
            <para>Name:     System.Media.MCDI -- PKEY_Media_MCDI</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 16 (PIDMSI_MCDI)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.MetadataContentProvider">
            <summary>
            <para>Name:     System.Media.MetadataContentProvider -- PKEY_Media_MetadataContentProvider</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 17 (PIDMSI_PROVIDER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.Producer">
            <summary>
            <para>Name:     System.Media.Producer -- PKEY_Media_Producer</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 22 (PIDMSI_PRODUCER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.PromotionUrl">
            <summary>
            <para>Name:     System.Media.PromotionUrl -- PKEY_Media_PromotionUrl</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 33 (PIDMSI_PROMOTION_URL)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ProtectionType">
            <summary>
            <para>Name:     System.Media.ProtectionType -- PKEY_Media_ProtectionType</para>
            <para>Description: If media is protected, how is it protected?</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 38</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ProviderRating">
            <summary>
            <para>Name:     System.Media.ProviderRating -- PKEY_Media_ProviderRating</para>
            <para>Description: Rating (0 - 99) supplied by metadata provider</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 39</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.ProviderStyle">
            <summary>
            <para>Name:     System.Media.ProviderStyle -- PKEY_Media_ProviderStyle</para>
            <para>Description: Style of music or video, supplied by metadata provider</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 40</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.Publisher">
            <summary>
            <para>Name:     System.Media.Publisher -- PKEY_Media_Publisher</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 30 (PIDMSI_PUBLISHER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.SubscriptionContentId">
            <summary>
            <para>Name:     System.Media.SubscriptionContentId -- PKEY_Media_SubscriptionContentId</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {9AEBAE7A-9644-487D-A92C-657585ED751A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.SubTitle">
            <summary>
            <para>Name:     System.Media.SubTitle -- PKEY_Media_SubTitle</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 38 (PIDSI_MUSIC_SUB_TITLE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.UniqueFileIdentifier">
            <summary>
            <para>Name:     System.Media.UniqueFileIdentifier -- PKEY_Media_UniqueFileIdentifier</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 35 (PIDMSI_UNIQUE_FILE_IDENTIFIER)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.UserNoAutoInfo">
            <summary>
            <para>Name:     System.Media.UserNoAutoInfo -- PKEY_Media_UserNoAutoInfo</para>
            <para>Description: If true, do NOT alter this file's metadata. Set by user.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 41</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.UserWebUrl">
            <summary>
            <para>Name:     System.Media.UserWebUrl -- PKEY_Media_UserWebUrl</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 34 (PIDMSI_USER_WEB_URL)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.Writer">
            <summary>
            <para>Name:     System.Media.Writer -- PKEY_Media_Writer</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 23 (PIDMSI_WRITER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Media.Year">
            <summary>
            <para>Name:     System.Media.Year -- PKEY_Media_Year</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 5 (PIDSI_MUSIC_YEAR)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message">
            <summary>Message Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.AttachmentContents">
            <summary>
            <para>Name:     System.Message.AttachmentContents -- PKEY_Message_AttachmentContents</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {3143BF7C-80A8-4854-8880-E2E40189BDD0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.AttachmentNames">
            <summary>
            <para>Name:     System.Message.AttachmentNames -- PKEY_Message_AttachmentNames</para>
            <para>Description: The names of the attachments in a message</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 21</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.BccAddress">
            <summary>
            <para>Name:     System.Message.BccAddress -- PKEY_Message_BccAddress</para>
            <para>Description: Addresses in Bcc: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.BccName">
            <summary>
            <para>Name:     System.Message.BccName -- PKEY_Message_BccName</para>
            <para>Description: person names in Bcc: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.CcAddress">
            <summary>
            <para>Name:     System.Message.CcAddress -- PKEY_Message_CcAddress</para>
            <para>Description: Addresses in Cc: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.CcName">
            <summary>
            <para>Name:     System.Message.CcName -- PKEY_Message_CcName</para>
            <para>Description: person names in Cc: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ConversationID">
            <summary>
            <para>Name:     System.Message.ConversationID -- PKEY_Message_ConversationID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DC8F80BD-AF1E-4289-85B6-3DFC1B493992}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ConversationIndex">
            <summary>
            <para>Name:     System.Message.ConversationIndex -- PKEY_Message_ConversationIndex</para>
            <para>Description:</para>
            <para>Type:     Buffer -- VT_VECTOR | VT_UI1 (For variants: VT_ARRAY | VT_UI1)</para>
            <para>FormatID: {DC8F80BD-AF1E-4289-85B6-3DFC1B493992}, 101</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.DateReceived">
            <summary>
            <para>Name:     System.Message.DateReceived -- PKEY_Message_DateReceived</para>
            <para>Description: Date and Time communication was received</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 20</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.DateSent">
            <summary>
            <para>Name:     System.Message.DateSent -- PKEY_Message_DateSent</para>
            <para>Description: Date and Time communication was sent</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 19</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.Flags">
            <summary>
            <para>Name:     System.Message.Flags -- PKEY_Message_Flags</para>
            <para>
            Description: These are flags associated with email messages to know if a read receipt is pending, etc. The values
            stored here by Outlook are defined for PR_MESSAGE_FLAGS on MSDN.
            </para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {A82D9EE7-CA67-4312-965E-226BCEA85023}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.FromAddress">
            <summary>
            <para>Name:     System.Message.FromAddress -- PKEY_Message_FromAddress</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 13</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.FromName">
            <summary>
            <para>Name:     System.Message.FromName -- PKEY_Message_FromName</para>
            <para>Description: Address in from field as person name</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.HasAttachments">
            <summary>
            <para>Name:     System.Message.HasAttachments -- PKEY_Message_HasAttachments</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.IsFwdOrReply">
            <summary>
            <para>Name:     System.Message.IsFwdOrReply -- PKEY_Message_IsFwdOrReply</para>
            <para>Description:</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {9A9BC088-4F6D-469E-9919-E705412040F9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.MessageClass">
            <summary>
            <para>Name:     System.Message.MessageClass -- PKEY_Message_MessageClass</para>
            <para>Description: What type of outlook msg this is (meeting, task, mail, etc.)</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CD9ED458-08CE-418F-A70E-F912C7BB9C5C}, 103</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ProofInProgress">
            <summary>
            <para>Name:     System.Message.ProofInProgress -- PKEY_Message_ProofInProgress</para>
            <para>Description: This property will be true if the message junk email proofing is still in progress.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9098F33C-9A7D-48A8-8DE5-2E1227A64E91}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.SenderAddress">
            <summary>
            <para>Name:     System.Message.SenderAddress -- PKEY_Message_SenderAddress</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0BE1C8E7-1981-4676-AE14-FDD78F05A6E7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.SenderName">
            <summary>
            <para>Name:     System.Message.SenderName -- PKEY_Message_SenderName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0DA41CFA-D224-4A18-AE2F-596158DB4B3A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.Store">
            <summary>
            <para>Name:     System.Message.Store -- PKEY_Message_Store</para>
            <para>Description: The store (aka protocol handler) FILE, MAIL, OUTLOOKEXPRESS</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 15</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ToAddress">
            <summary>
            <para>Name:     System.Message.ToAddress -- PKEY_Message_ToAddress</para>
            <para>Description: Addresses in To: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 16</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ToDoFlags">
            <summary>
            <para>Name:     System.Message.ToDoFlags -- PKEY_Message_ToDoFlags</para>
            <para>
            Description: Flags associated with a message flagged to know if it's still active, if it was custom flagged, etc.
            </para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {1F856A9F-6900-4ABA-9505-2D5F1B4D66CB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ToDoTitle">
            <summary>
            <para>Name:     System.Message.ToDoTitle -- PKEY_Message_ToDoTitle</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {BCCC8A3C-8CEF-42E5-9B1C-C69079398BC7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Message.ToName">
            <summary>
            <para>Name:     System.Message.ToName -- PKEY_Message_ToName</para>
            <para>Description: Person names in To: field</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD}, 17</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music">
            <summary>Music Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.AlbumArtist">
            <summary>
            <para>Name:     System.Music.AlbumArtist -- PKEY_Music_AlbumArtist</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 13 (PIDSI_MUSIC_ALBUM_ARTIST)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.AlbumID">
            <summary>
            <para>Name:     System.Music.AlbumID -- PKEY_Music_AlbumID</para>
            <para>
            Description: Concatenation of System.Music.AlbumArtist and System.Music.AlbumTitle, suitable for indexing and
            display. Used to differentiate albums with the same title from different artists.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.AlbumTitle">
            <summary>
            <para>Name:     System.Music.AlbumTitle -- PKEY_Music_AlbumTitle</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 4 (PIDSI_MUSIC_ALBUM)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Artist">
            <summary>
            <para>Name:     System.Music.Artist -- PKEY_Music_Artist</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 2 (PIDSI_MUSIC_ARTIST)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.BeatsPerMinute">
            <summary>
            <para>Name:     System.Music.BeatsPerMinute -- PKEY_Music_BeatsPerMinute</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 35 (PIDSI_MUSIC_BEATS_PER_MINUTE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Composer">
            <summary>
            <para>Name:     System.Music.Composer -- PKEY_Music_Composer</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 19 (PIDMSI_COMPOSER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Conductor">
            <summary>
            <para>Name:     System.Music.Conductor -- PKEY_Music_Conductor</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 36 (PIDSI_MUSIC_CONDUCTOR)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.ContentGroupDescription">
            <summary>
            <para>Name:     System.Music.ContentGroupDescription -- PKEY_Music_ContentGroupDescription</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 33 (PIDSI_MUSIC_CONTENT_GROUP_DESCRIPTION)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.DisplayArtist">
            <summary>
            <para>Name:     System.Music.DisplayArtist -- PKEY_Music_DisplayArtist</para>
            <para>
            Description: This property returns the best representation of Album Artist for a given music file based upon
            AlbumArtist, ContributingArtist and compilation info.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FD122953-FA93-4EF7-92C3-04C946B2F7C8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Genre">
            <summary>
            <para>Name:     System.Music.Genre -- PKEY_Music_Genre</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 11 (PIDSI_MUSIC_GENRE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.InitialKey">
            <summary>
            <para>Name:     System.Music.InitialKey -- PKEY_Music_InitialKey</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 34 (PIDSI_MUSIC_INITIAL_KEY)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.IsCompilation">
            <summary>
            <para>Name:     System.Music.IsCompilation -- PKEY_Music_IsCompilation</para>
            <para>Description: Indicates whether the file is part of a compilation.</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {C449D5CB-9EA4-4809-82E8-AF9D59DED6D1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Lyrics">
            <summary>
            <para>Name:     System.Music.Lyrics -- PKEY_Music_Lyrics</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 12 (PIDSI_MUSIC_LYRICS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Mood">
            <summary>
            <para>Name:     System.Music.Mood -- PKEY_Music_Mood</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 39 (PIDSI_MUSIC_MOOD)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.PartOfSet">
            <summary>
            <para>Name:     System.Music.PartOfSet -- PKEY_Music_PartOfSet</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 37 (PIDSI_MUSIC_PART_OF_SET)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.Period">
            <summary>
            <para>Name:     System.Music.Period -- PKEY_Music_Period</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 31 (PIDMSI_PERIOD)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.SynchronizedLyrics">
            <summary>
            <para>Name:     System.Music.SynchronizedLyrics -- PKEY_Music_SynchronizedLyrics</para>
            <para>Description:</para>
            <para>Type:     Blob -- VT_BLOB</para>
            <para>FormatID: {6B223B6A-162E-4AA9-B39F-05D678FC6D77}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Music.TrackNumber">
            <summary>
            <para>Name:     System.Music.TrackNumber -- PKEY_Music_TrackNumber</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_MUSIC) {56A3372E-CE9C-11D2-9F0E-006097C686F6}, 7 (PIDSI_MUSIC_TRACK)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Note">
            <summary>Note Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Note.Color">
            <summary>
            <para>Name:     System.Note.Color -- PKEY_Note_Color</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {4776CAFA-BCE4-4CB1-A23E-265E76D8EB11}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Note.ColorText">
            <summary>
            <para>Name:     System.Note.ColorText -- PKEY_Note_ColorText</para>
            <para>
            Description: This is the user-friendly form of System.Note.Color. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {46B4E8DE-CDB2-440D-885C-1658EB65B914}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo">
            <summary>Photo Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Aperture">
            <summary>
            <para>Name:     System.Photo.Aperture -- PKEY_Photo_Aperture</para>
            <para>
            Description: PropertyTagExifAperture. Calculated from PKEY_Photo_ApertureNumerator and PKEY_Photo_ApertureDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37378</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ApertureDenominator">
            <summary>
            <para>Name:     System.Photo.ApertureDenominator -- PKEY_Photo_ApertureDenominator</para>
            <para>Description: Denominator of PKEY_Photo_Aperture</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {E1A9A38B-6685-46BD-875E-570DC7AD7320}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ApertureNumerator">
            <summary>
            <para>Name:     System.Photo.ApertureNumerator -- PKEY_Photo_ApertureNumerator</para>
            <para>Description: Numerator of PKEY_Photo_Aperture</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {0337ECEC-39FB-4581-A0BD-4C4CC51E9914}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Brightness">
            <summary>
            <para>Name:     System.Photo.Brightness -- PKEY_Photo_Brightness</para>
            <para>
            Description: This is the brightness of the photo. Calculated from PKEY_Photo_BrightnessNumerator and
            PKEY_Photo_BrightnessDenominator. The units are "APEX", normally in the range of -99.99 to 99.99. If the numerator of
            the recorded value is FFFFFFFF.H, "Unknown" should be indicated.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {1A701BF6-478C-4361-83AB-3701BB053C58}, 100 (PropertyTagExifBrightness)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.BrightnessDenominator">
            <summary>
            <para>Name:     System.Photo.BrightnessDenominator -- PKEY_Photo_BrightnessDenominator</para>
            <para>Description: Denominator of PKEY_Photo_Brightness</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {6EBE6946-2321-440A-90F0-C043EFD32476}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.BrightnessNumerator">
            <summary>
            <para>Name:     System.Photo.BrightnessNumerator -- PKEY_Photo_BrightnessNumerator</para>
            <para>Description: Numerator of PKEY_Photo_Brightness</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {9E7D118F-B314-45A0-8CFB-D654B917C9E9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.CameraManufacturer">
            <summary>
            <para>Name:     System.Photo.CameraManufacturer -- PKEY_Photo_CameraManufacturer</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 271 (PropertyTagEquipMake)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.CameraModel">
            <summary>
            <para>Name:     System.Photo.CameraModel -- PKEY_Photo_CameraModel</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 272 (PropertyTagEquipModel)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.CameraSerialNumber">
            <summary>
            <para>Name:     System.Photo.CameraSerialNumber -- PKEY_Photo_CameraSerialNumber</para>
            <para>Description: Serial number of camera that produced this photo</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 273</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Contrast">
            <summary>
            <para>Name:     System.Photo.Contrast -- PKEY_Photo_Contrast</para>
            <para>
            Description: This indicates the direction of contrast processing applied by the camera when the image was shot.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {2A785BA9-8D23-4DED-82E6-60A350C86A10}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ContrastText">
            <summary>
            <para>Name:     System.Photo.ContrastText -- PKEY_Photo_ContrastText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.Contrast. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {59DDE9F2-5253-40EA-9A8B-479E96C6249A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.DateTaken">
            <summary>
            <para>Name:     System.Photo.DateTaken -- PKEY_Photo_DateTaken</para>
            <para>Description: PropertyTagExifDTOrig</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 36867</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.DigitalZoom">
            <summary>
            <para>Name:     System.Photo.DigitalZoom -- PKEY_Photo_DigitalZoom</para>
            <para>
            Description: PropertyTagExifDigitalZoom. Calculated from PKEY_Photo_DigitalZoomNumerator and PKEY_Photo_DigitalZoomDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {F85BF840-A925-4BC2-B0C4-8E36B598679E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.DigitalZoomDenominator">
            <summary>
            <para>Name:     System.Photo.DigitalZoomDenominator -- PKEY_Photo_DigitalZoomDenominator</para>
            <para>Description: Denominator of PKEY_Photo_DigitalZoom</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {745BAF0E-E5C1-4CFB-8A1B-D031A0A52393}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.DigitalZoomNumerator">
            <summary>
            <para>Name:     System.Photo.DigitalZoomNumerator -- PKEY_Photo_DigitalZoomNumerator</para>
            <para>Description: Numerator of PKEY_Photo_DigitalZoom</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {16CBB924-6500-473B-A5BE-F1599BCBE413}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Event">
            <summary>
            <para>Name:     System.Photo.Event -- PKEY_Photo_Event</para>
            <para>Description: The event at which the photo was taken</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 18248</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.EXIFVersion">
            <summary>
            <para>Name:     System.Photo.EXIFVersion -- PKEY_Photo_EXIFVersion</para>
            <para>Description: The EXIF version.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D35F743A-EB2E-47F2-A286-844132CB1427}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureBias">
            <summary>
            <para>Name:     System.Photo.ExposureBias -- PKEY_Photo_ExposureBias</para>
            <para>
            Description: PropertyTagExifExposureBias. Calculated from PKEY_Photo_ExposureBiasNumerator and PKEY_Photo_ExposureBiasDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37380</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureBiasDenominator">
            <summary>
            <para>Name:     System.Photo.ExposureBiasDenominator -- PKEY_Photo_ExposureBiasDenominator</para>
            <para>Description: Denominator of PKEY_Photo_ExposureBias</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {AB205E50-04B7-461C-A18C-2F233836E627}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureBiasNumerator">
            <summary>
            <para>Name:     System.Photo.ExposureBiasNumerator -- PKEY_Photo_ExposureBiasNumerator</para>
            <para>Description: Numerator of PKEY_Photo_ExposureBias</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {738BF284-1D87-420B-92CF-5834BF6EF9ED}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureIndex">
            <summary>
            <para>Name:     System.Photo.ExposureIndex -- PKEY_Photo_ExposureIndex</para>
            <para>
            Description: PropertyTagExifExposureIndex. Calculated from PKEY_Photo_ExposureIndexNumerator and PKEY_Photo_ExposureIndexDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {967B5AF8-995A-46ED-9E11-35B3C5B9782D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureIndexDenominator">
            <summary>
            <para>Name:     System.Photo.ExposureIndexDenominator -- PKEY_Photo_ExposureIndexDenominator</para>
            <para>Description: Denominator of PKEY_Photo_ExposureIndex</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {93112F89-C28B-492F-8A9D-4BE2062CEE8A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureIndexNumerator">
            <summary>
            <para>Name:     System.Photo.ExposureIndexNumerator -- PKEY_Photo_ExposureIndexNumerator</para>
            <para>Description: Numerator of PKEY_Photo_ExposureIndex</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {CDEDCF30-8919-44DF-8F4C-4EB2FFDB8D89}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureProgram">
            <summary>
            <para>Name:     System.Photo.ExposureProgram -- PKEY_Photo_ExposureProgram</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 34850 (PropertyTagExifExposureProg)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureProgramText">
            <summary>
            <para>Name:     System.Photo.ExposureProgramText -- PKEY_Photo_ExposureProgramText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.ExposureProgram. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FEC690B7-5F30-4646-AE47-4CAAFBA884A3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureTime">
            <summary>
            <para>Name:     System.Photo.ExposureTime -- PKEY_Photo_ExposureTime</para>
            <para>
            Description: PropertyTagExifExposureTime. Calculated from PKEY_Photo_ExposureTimeNumerator and PKEY_Photo_ExposureTimeDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 33434</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureTimeDenominator">
            <summary>
            <para>Name:     System.Photo.ExposureTimeDenominator -- PKEY_Photo_ExposureTimeDenominator</para>
            <para>Description: Denominator of PKEY_Photo_ExposureTime</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {55E98597-AD16-42E0-B624-21599A199838}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ExposureTimeNumerator">
            <summary>
            <para>Name:     System.Photo.ExposureTimeNumerator -- PKEY_Photo_ExposureTimeNumerator</para>
            <para>Description: Numerator of PKEY_Photo_ExposureTime</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {257E44E2-9031-4323-AC38-85C552871B2E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Flash">
            <summary>
            <para>Name:     System.Photo.Flash -- PKEY_Photo_Flash</para>
            <para>Description: PropertyTagExifFlash</para>
            <para>Type:     Byte -- VT_UI1</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37385</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashEnergy">
            <summary>
            <para>Name:     System.Photo.FlashEnergy -- PKEY_Photo_FlashEnergy</para>
            <para>
            Description: PropertyTagExifFlashEnergy. Calculated from PKEY_Photo_FlashEnergyNumerator and PKEY_Photo_FlashEnergyDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 41483</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashEnergyDenominator">
            <summary>
            <para>Name:     System.Photo.FlashEnergyDenominator -- PKEY_Photo_FlashEnergyDenominator</para>
            <para>Description: Denominator of PKEY_Photo_FlashEnergy</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {D7B61C70-6323-49CD-A5FC-C84277162C97}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashEnergyNumerator">
            <summary>
            <para>Name:     System.Photo.FlashEnergyNumerator -- PKEY_Photo_FlashEnergyNumerator</para>
            <para>Description: Numerator of PKEY_Photo_FlashEnergy</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {FCAD3D3D-0858-400F-AAA3-2F66CCE2A6BC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashManufacturer">
            <summary>
            <para>Name:     System.Photo.FlashManufacturer -- PKEY_Photo_FlashManufacturer</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {AABAF6C9-E0C5-4719-8585-57B103E584FE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashModel">
            <summary>
            <para>Name:     System.Photo.FlashModel -- PKEY_Photo_FlashModel</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {FE83BB35-4D1A-42E2-916B-06F3E1AF719E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FlashText">
            <summary>
            <para>Name:     System.Photo.FlashText -- PKEY_Photo_FlashText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.Flash. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6B8B68F6-200B-47EA-8D25-D8050F57339F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FNumber">
            <summary>
            <para>Name:     System.Photo.FNumber -- PKEY_Photo_FNumber</para>
            <para>Description: PropertyTagExifFNumber. Calculated from PKEY_Photo_FNumberNumerator and PKEY_Photo_FNumberDenominator</para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 33437</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FNumberDenominator">
            <summary>
            <para>Name:     System.Photo.FNumberDenominator -- PKEY_Photo_FNumberDenominator</para>
            <para>Description: Denominator of PKEY_Photo_FNumber</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {E92A2496-223B-4463-A4E3-30EABBA79D80}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FNumberNumerator">
            <summary>
            <para>Name:     System.Photo.FNumberNumerator -- PKEY_Photo_FNumberNumerator</para>
            <para>Description: Numerator of PKEY_Photo_FNumber</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {1B97738A-FDFC-462F-9D93-1957E08BE90C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalLength">
            <summary>
            <para>Name:     System.Photo.FocalLength -- PKEY_Photo_FocalLength</para>
            <para>
            Description: PropertyTagExifFocalLength. Calculated from PKEY_Photo_FocalLengthNumerator and PKEY_Photo_FocalLengthDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37386</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalLengthDenominator">
            <summary>
            <para>Name:     System.Photo.FocalLengthDenominator -- PKEY_Photo_FocalLengthDenominator</para>
            <para>Description: Denominator of PKEY_Photo_FocalLength</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {305BC615-DCA1-44A5-9FD4-10C0BA79412E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalLengthInFilm">
            <summary>
            <para>Name:     System.Photo.FocalLengthInFilm -- PKEY_Photo_FocalLengthInFilm</para>
            <para>Description:</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {A0E74609-B84D-4F49-B860-462BD9971F98}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalLengthNumerator">
            <summary>
            <para>Name:     System.Photo.FocalLengthNumerator -- PKEY_Photo_FocalLengthNumerator</para>
            <para>Description: Numerator of PKEY_Photo_FocalLength</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {776B6B3B-1E3D-4B0C-9A0E-8FBAF2A8492A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneXResolution">
            <summary>
            <para>Name:     System.Photo.FocalPlaneXResolution -- PKEY_Photo_FocalPlaneXResolution</para>
            <para>
            Description: PropertyTagExifFocalXRes. Calculated from PKEY_Photo_FocalPlaneXResolutionNumerator and PKEY_Photo_FocalPlaneXResolutionDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {CFC08D97-C6F7-4484-89DD-EBEF4356FE76}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneXResolutionDenominator">
            <summary>
            <para>Name:     System.Photo.FocalPlaneXResolutionDenominator -- PKEY_Photo_FocalPlaneXResolutionDenominator</para>
            <para>Description: Denominator of PKEY_Photo_FocalPlaneXResolution</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {0933F3F5-4786-4F46-A8E8-D64DD37FA521}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneXResolutionNumerator">
            <summary>
            <para>Name:     System.Photo.FocalPlaneXResolutionNumerator -- PKEY_Photo_FocalPlaneXResolutionNumerator</para>
            <para>Description: Numerator of PKEY_Photo_FocalPlaneXResolution</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {DCCB10AF-B4E2-4B88-95F9-031B4D5AB490}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneYResolution">
            <summary>
            <para>Name:     System.Photo.FocalPlaneYResolution -- PKEY_Photo_FocalPlaneYResolution</para>
            <para>
            Description: PropertyTagExifFocalYRes. Calculated from PKEY_Photo_FocalPlaneYResolutionNumerator and PKEY_Photo_FocalPlaneYResolutionDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {4FFFE4D0-914F-4AC4-8D6F-C9C61DE169B1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneYResolutionDenominator">
            <summary>
            <para>Name:     System.Photo.FocalPlaneYResolutionDenominator -- PKEY_Photo_FocalPlaneYResolutionDenominator</para>
            <para>Description: Denominator of PKEY_Photo_FocalPlaneYResolution</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {1D6179A6-A876-4031-B013-3347B2B64DC8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.FocalPlaneYResolutionNumerator">
            <summary>
            <para>Name:     System.Photo.FocalPlaneYResolutionNumerator -- PKEY_Photo_FocalPlaneYResolutionNumerator</para>
            <para>Description: Numerator of PKEY_Photo_FocalPlaneYResolution</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {A2E541C5-4440-4BA8-867E-75CFC06828CD}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.GainControl">
            <summary>
            <para>Name:     System.Photo.GainControl -- PKEY_Photo_GainControl</para>
            <para>
            Description: This indicates the degree of overall image gain adjustment. Calculated from
            PKEY_Photo_GainControlNumerator and PKEY_Photo_GainControlDenominator.
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {FA304789-00C7-4D80-904A-1E4DCC7265AA}, 100 (PropertyTagExifGainControl)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.GainControlDenominator">
            <summary>
            <para>Name:     System.Photo.GainControlDenominator -- PKEY_Photo_GainControlDenominator</para>
            <para>Description: Denominator of PKEY_Photo_GainControl</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {42864DFD-9DA4-4F77-BDED-4AAD7B256735}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.GainControlNumerator">
            <summary>
            <para>Name:     System.Photo.GainControlNumerator -- PKEY_Photo_GainControlNumerator</para>
            <para>Description: Numerator of PKEY_Photo_GainControl</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {8E8ECF7C-B7B8-4EB8-A63F-0EE715C96F9E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.GainControlText">
            <summary>
            <para>Name:     System.Photo.GainControlText -- PKEY_Photo_GainControlText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.GainControl. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C06238B2-0BF9-4279-A723-25856715CB9D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ISOSpeed">
            <summary>
            <para>Name:     System.Photo.ISOSpeed -- PKEY_Photo_ISOSpeed</para>
            <para>Description: PropertyTagExifISOSpeed</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 34855</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.LensManufacturer">
            <summary>
            <para>Name:     System.Photo.LensManufacturer -- PKEY_Photo_LensManufacturer</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E6DDCAF7-29C5-4F0A-9A68-D19412EC7090}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.LensModel">
            <summary>
            <para>Name:     System.Photo.LensModel -- PKEY_Photo_LensModel</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {E1277516-2B5F-4869-89B1-2E585BD38B7A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.LightSource">
            <summary>
            <para>Name:     System.Photo.LightSource -- PKEY_Photo_LightSource</para>
            <para>Description: PropertyTagExifLightSource</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37384</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MakerNote">
            <summary>
            <para>Name:     System.Photo.MakerNote -- PKEY_Photo_MakerNote</para>
            <para>Description:</para>
            <para>Type:     Buffer -- VT_VECTOR | VT_UI1 (For variants: VT_ARRAY | VT_UI1)</para>
            <para>FormatID: {FA303353-B659-4052-85E9-BCAC79549B84}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MakerNoteOffset">
            <summary>
            <para>Name:     System.Photo.MakerNoteOffset -- PKEY_Photo_MakerNoteOffset</para>
            <para>Description:</para>
            <para>Type:     UInt64 -- VT_UI8</para>
            <para>FormatID: {813F4124-34E6-4D17-AB3E-6B1F3C2247A1}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MaxAperture">
            <summary>
            <para>Name:     System.Photo.MaxAperture -- PKEY_Photo_MaxAperture</para>
            <para>Description: Calculated from PKEY_Photo_MaxApertureNumerator and PKEY_Photo_MaxApertureDenominator</para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: {08F6D7C2-E3F2-44FC-AF1E-5AA5C81A2D3E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MaxApertureDenominator">
            <summary>
            <para>Name:     System.Photo.MaxApertureDenominator -- PKEY_Photo_MaxApertureDenominator</para>
            <para>Description: Denominator of PKEY_Photo_MaxAperture</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {C77724D4-601F-46C5-9B89-C53F93BCEB77}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MaxApertureNumerator">
            <summary>
            <para>Name:     System.Photo.MaxApertureNumerator -- PKEY_Photo_MaxApertureNumerator</para>
            <para>Description: Numerator of PKEY_Photo_MaxAperture</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {C107E191-A459-44C5-9AE6-B952AD4B906D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MeteringMode">
            <summary>
            <para>Name:     System.Photo.MeteringMode -- PKEY_Photo_MeteringMode</para>
            <para>Description: PropertyTagExifMeteringMode</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37383</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.MeteringModeText">
            <summary>
            <para>Name:     System.Photo.MeteringModeText -- PKEY_Photo_MeteringModeText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.MeteringMode. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {F628FD8C-7BA8-465A-A65B-C5AA79263A9E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Orientation">
            <summary>
            <para>Name:     System.Photo.Orientation -- PKEY_Photo_Orientation</para>
            <para>Description: This is the image orientation viewed in terms of rows and columns.</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 274 (PropertyTagOrientation)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.OrientationText">
            <summary>
            <para>Name:     System.Photo.OrientationText -- PKEY_Photo_OrientationText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.Orientation. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A9EA193C-C511-498A-A06B-58E2776DCC28}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.PeopleNames">
            <summary>
            <para>Name:     System.Photo.PeopleNames -- PKEY_Photo_PeopleNames</para>
            <para>Description: The people tags on an image.</para>
            <para>
            Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR) Legacy code may treat this as VT_LPSTR.
            </para>
            <para>FormatID: {E8309B6E-084C-49B4-B1FC-90A80331B638}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.PhotometricInterpretation">
            <summary>
            <para>Name:     System.Photo.PhotometricInterpretation -- PKEY_Photo_PhotometricInterpretation</para>
            <para>
            Description: This is the pixel composition. In JPEG compressed data, a JPEG marker is used instead of this property.
            </para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: {341796F1-1DF9-4B1C-A564-91BDEFA43877}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.PhotometricInterpretationText">
            <summary>
            <para>Name:     System.Photo.PhotometricInterpretationText -- PKEY_Photo_PhotometricInterpretationText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.PhotometricInterpretation. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {821437D6-9EAB-4765-A589-3B1CBBD22A61}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ProgramMode">
            <summary>
            <para>Name:     System.Photo.ProgramMode -- PKEY_Photo_ProgramMode</para>
            <para>
            Description: This is the class of the program used by the camera to set exposure when the picture is taken.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {6D217F6D-3F6A-4825-B470-5F03CA2FBE9B}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ProgramModeText">
            <summary>
            <para>Name:     System.Photo.ProgramModeText -- PKEY_Photo_ProgramModeText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.ProgramMode. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7FE3AA27-2648-42F3-89B0-454E5CB150C3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.RelatedSoundFile">
            <summary>
            <para>Name:     System.Photo.RelatedSoundFile -- PKEY_Photo_RelatedSoundFile</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {318A6B45-087F-4DC2-B8CC-05359551FC9E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Saturation">
            <summary>
            <para>Name:     System.Photo.Saturation -- PKEY_Photo_Saturation</para>
            <para>
            Description: This indicates the direction of saturation processing applied by the camera when the image was shot.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {49237325-A95A-4F67-B211-816B2D45D2E0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.SaturationText">
            <summary>
            <para>Name:     System.Photo.SaturationText -- PKEY_Photo_SaturationText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.Saturation. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {61478C08-B600-4A84-BBE4-E99C45F0A072}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.Sharpness">
            <summary>
            <para>Name:     System.Photo.Sharpness -- PKEY_Photo_Sharpness</para>
            <para>
            Description: This indicates the direction of sharpness processing applied by the camera when the image was shot.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {FC6976DB-8349-4970-AE97-B3C5316A08F0}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.SharpnessText">
            <summary>
            <para>Name:     System.Photo.SharpnessText -- PKEY_Photo_SharpnessText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.Sharpness. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {51EC3F47-DD50-421D-8769-334F50424B1E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ShutterSpeed">
            <summary>
            <para>Name:     System.Photo.ShutterSpeed -- PKEY_Photo_ShutterSpeed</para>
            <para>
            Description: PropertyTagExifShutterSpeed. Calculated from PKEY_Photo_ShutterSpeedNumerator and PKEY_Photo_ShutterSpeedDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37377</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ShutterSpeedDenominator">
            <summary>
            <para>Name:     System.Photo.ShutterSpeedDenominator -- PKEY_Photo_ShutterSpeedDenominator</para>
            <para>Description: Denominator of PKEY_Photo_ShutterSpeed</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {E13D8975-81C7-4948-AE3F-37CAE11E8FF7}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.ShutterSpeedNumerator">
            <summary>
            <para>Name:     System.Photo.ShutterSpeedNumerator -- PKEY_Photo_ShutterSpeedNumerator</para>
            <para>Description: Numerator of PKEY_Photo_ShutterSpeed</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: {16EA4042-D6F4-4BCA-8349-7C78D30FB333}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.SubjectDistance">
            <summary>
            <para>Name:     System.Photo.SubjectDistance -- PKEY_Photo_SubjectDistance</para>
            <para>
            Description: PropertyTagExifSubjectDist. Calculated from PKEY_Photo_SubjectDistanceNumerator and PKEY_Photo_SubjectDistanceDenominator
            </para>
            <para>Type:     Double -- VT_R8</para>
            <para>FormatID: (FMTID_ImageProperties) {14B81DA1-0135-4D31-96D9-6CBFC9671A99}, 37382</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.SubjectDistanceDenominator">
            <summary>
            <para>Name:     System.Photo.SubjectDistanceDenominator -- PKEY_Photo_SubjectDistanceDenominator</para>
            <para>Description: Denominator of PKEY_Photo_SubjectDistance</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {0C840A88-B043-466D-9766-D4B26DA3FA77}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.SubjectDistanceNumerator">
            <summary>
            <para>Name:     System.Photo.SubjectDistanceNumerator -- PKEY_Photo_SubjectDistanceNumerator</para>
            <para>Description: Numerator of PKEY_Photo_SubjectDistance</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {8AF4961C-F526-43E5-AA81-DB768219178D}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.TagViewAggregate">
            <summary>
            <para>Name:     System.Photo.TagViewAggregate -- PKEY_Photo_TagViewAggregate</para>
            <para>Description: A read-only aggregation of tag-like properties for use in building views.</para>
            <para>
            Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR) Legacy code may treat this as VT_LPSTR.
            </para>
            <para>FormatID: {B812F15D-C2D8-4BBF-BACD-79744346113F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.TranscodedForSync">
            <summary>
            <para>Name:     System.Photo.TranscodedForSync -- PKEY_Photo_TranscodedForSync</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {9A8EBB75-6458-4E82-BACB-35C0095B03BB}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.WhiteBalance">
            <summary>
            <para>Name:     System.Photo.WhiteBalance -- PKEY_Photo_WhiteBalance</para>
            <para>Description: This indicates the white balance mode set when the image was shot.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {EE3D3D8A-5381-4CFA-B13B-AAF66B5F4EC9}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Photo.WhiteBalanceText">
            <summary>
            <para>Name:     System.Photo.WhiteBalanceText -- PKEY_Photo_WhiteBalanceText</para>
            <para>
            Description: This is the user-friendly form of System.Photo.WhiteBalance. Not intended to be parsed programmatically.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6336B95E-C7A7-426D-86FD-7AE3D39C84B4}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup">
            <summary>PropGroup Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Advanced">
            <summary>
            <para>Name:     System.PropGroup.Advanced -- PKEY_PropGroup_Advanced</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {900A403B-097B-4B95-8AE2-071FDAEEB118}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Audio">
            <summary>
            <para>Name:     System.PropGroup.Audio -- PKEY_PropGroup_Audio</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {2804D469-788F-48AA-8570-71B9C187E138}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Calendar">
            <summary>
            <para>Name:     System.PropGroup.Calendar -- PKEY_PropGroup_Calendar</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {9973D2B5-BFD8-438A-BA94-5349B293181A}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Camera">
            <summary>
            <para>Name:     System.PropGroup.Camera -- PKEY_PropGroup_Camera</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {DE00DE32-547E-4981-AD4B-542F2E9007D8}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Contact">
            <summary>
            <para>Name:     System.PropGroup.Contact -- PKEY_PropGroup_Contact</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {DF975FD3-250A-4004-858F-34E29A3E37AA}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Content">
            <summary>
            <para>Name:     System.PropGroup.Content -- PKEY_PropGroup_Content</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {D0DAB0BA-368A-4050-A882-6C010FD19A4F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Description">
            <summary>
            <para>Name:     System.PropGroup.Description -- PKEY_PropGroup_Description</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {8969B275-9475-4E00-A887-FF93B8B41E44}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.FileSystem">
            <summary>
            <para>Name:     System.PropGroup.FileSystem -- PKEY_PropGroup_FileSystem</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {E3A7D2C1-80FC-4B40-8F34-30EA111BDC2E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.General">
            <summary>
            <para>Name:     System.PropGroup.General -- PKEY_PropGroup_General</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {CC301630-B192-4C22-B372-9F4C6D338E07}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.GPS">
            <summary>
            <para>Name:     System.PropGroup.GPS -- PKEY_PropGroup_GPS</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {F3713ADA-90E3-4E11-AAE5-FDC17685B9BE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Image">
            <summary>
            <para>Name:     System.PropGroup.Image -- PKEY_PropGroup_Image</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {E3690A87-0FA8-4A2A-9A9F-FCE8827055AC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Media">
            <summary>
            <para>Name:     System.PropGroup.Media -- PKEY_PropGroup_Media</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {61872CF7-6B5E-4B4B-AC2D-59DA84459248}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.MediaAdvanced">
            <summary>
            <para>Name:     System.PropGroup.MediaAdvanced -- PKEY_PropGroup_MediaAdvanced</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {8859A284-DE7E-4642-99BA-D431D044B1EC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Message">
            <summary>
            <para>Name:     System.PropGroup.Message -- PKEY_PropGroup_Message</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {7FD7259D-16B4-4135-9F97-7C96ECD2FA9E}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Music">
            <summary>
            <para>Name:     System.PropGroup.Music -- PKEY_PropGroup_Music</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {68DD6094-7216-40F1-A029-43FE7127043F}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Origin">
            <summary>
            <para>Name:     System.PropGroup.Origin -- PKEY_PropGroup_Origin</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {2598D2FB-5569-4367-95DF-5CD3A177E1A5}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.PhotoAdvanced">
            <summary>
            <para>Name:     System.PropGroup.PhotoAdvanced -- PKEY_PropGroup_PhotoAdvanced</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {0CB2BF5A-9EE7-4A86-8222-F01E07FDADAF}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.RecordedTV">
            <summary>
            <para>Name:     System.PropGroup.RecordedTV -- PKEY_PropGroup_RecordedTV</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {E7B33238-6584-4170-A5C0-AC25EFD9DA56}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropGroup.Video">
            <summary>
            <para>Name:     System.PropGroup.Video -- PKEY_PropGroup_Video</para>
            <para>Description:</para>
            <para>Type:     Null -- VT_NULL</para>
            <para>FormatID: {BEBE0920-7671-4C54-A3EB-49FDDFC191EE}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList">
            <summary>PropList Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.ConflictPrompt">
            <summary>
            <para>Name:     System.PropList.ConflictPrompt -- PKEY_PropList_ConflictPrompt</para>
            <para>
            Description: The list of properties to show in the file operation conflict resolution dialog. Properties with empty
            values will not be displayed. Register under the regvalue of "ConflictPrompt".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 11</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.ContentViewModeForBrowse">
            <summary>
            <para>Name:     System.PropList.ContentViewModeForBrowse -- PKEY_PropList_ContentViewModeForBrowse</para>
            <para>
            Description: The list of properties to show in the content view mode of an item in the context of browsing. Register
            the regvalue under the name of "ContentViewModeForBrowse".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 13</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.ContentViewModeForSearch">
            <summary>
            <para>Name:     System.PropList.ContentViewModeForSearch -- PKEY_PropList_ContentViewModeForSearch</para>
            <para>
            Description: The list of properties to show in the content view mode of an item in the context of searching. Register
            the regvalue under the name of "ContentViewModeForSearch".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.ExtendedTileInfo">
            <summary>
            <para>Name:     System.PropList.ExtendedTileInfo -- PKEY_PropList_ExtendedTileInfo</para>
            <para>
            Description: The list of properties to show in the listview on extended tiles. Register under the regvalue of "ExtendedTileInfo".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.FileOperationPrompt">
            <summary>
            <para>Name:     System.PropList.FileOperationPrompt -- PKEY_PropList_FileOperationPrompt</para>
            <para>
            Description: The list of properties to show in the file operation confirmation dialog. Properties with empty values
            will not be displayed. If this list is not specified, then the InfoTip property list is used instead. Register under
            the regvalue of "FileOperationPrompt".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 10</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.FullDetails">
            <summary>
            <para>Name:     System.PropList.FullDetails -- PKEY_PropList_FullDetails</para>
            <para>
            Description: The list of all the properties to show in the details page. Property groups can be included in this list
            in order to more easily organize the UI. Register under the regvalue of "FullDetails".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.InfoTip">
            <summary>
            <para>Name:     System.PropList.InfoTip -- PKEY_PropList_InfoTip</para>
            <para>
            Description: The list of properties to show in the infotip. Properties with empty values will not be displayed.
            Register under the regvalue of "InfoTip".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 4 (PID_PROPLIST_INFOTIP)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.NonPersonal">
            <summary>
            <para>Name:     System.PropList.NonPersonal -- PKEY_PropList_NonPersonal</para>
            <para>
            Description: The list of properties that are considered 'non-personal'. When told to remove all non-personal
            properties from a given file, the system will leave these particular properties untouched. Register under the
            regvalue of "NonPersonal".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {49D1091F-082E-493F-B23F-D2308AA9668C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.PreviewDetails">
            <summary>
            <para>Name:     System.PropList.PreviewDetails -- PKEY_PropList_PreviewDetails</para>
            <para>
            Description: The list of properties to display in the preview pane. Register under the regvalue of "PreviewDetails".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.PreviewTitle">
            <summary>
            <para>Name:     System.PropList.PreviewTitle -- PKEY_PropList_PreviewTitle</para>
            <para>
            Description: The one or two properties to display in the preview pane title section. The optional second property is
            displayed as a subtitle. Register under the regvalue of "PreviewTitle".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.QuickTip">
            <summary>
            <para>Name:     System.PropList.QuickTip -- PKEY_PropList_QuickTip</para>
            <para>
            Description: The list of properties to show in the infotip when the item is on a slow network. Properties with empty
            values will not be displayed. Register under the regvalue of "QuickTip".
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 5 (PID_PROPLIST_QUICKTIP)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.TileInfo">
            <summary>
            <para>Name:     System.PropList.TileInfo -- PKEY_PropList_TileInfo</para>
            <para>Description: The list of properties to show in the listview on tiles. Register under the regvalue of "TileInfo".</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {C9944A21-A406-48FE-8225-AEC7E24C211B}, 3 (PID_PROPLIST_TILEINFO)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.PropList.XPDetailsPanel">
            <summary>
            <para>Name:     System.PropList.XPDetailsPanel -- PKEY_PropList_XPDetailsPanel</para>
            <para>Description: The list of properties to display in the XP webview details panel. Obsolete.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_WebView) {F2275480-F782-4291-BD94-F13693513AEC}, 0 (PID_DISPLAY_PROPERTIES)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV">
            <summary>RecordedTV Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.ChannelNumber">
            <summary>
            <para>Name:     System.RecordedTV.ChannelNumber -- PKEY_RecordedTV_ChannelNumber</para>
            <para>Description: Example: 42</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 7</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.Credits">
            <summary>
            <para>Name:     System.RecordedTV.Credits -- PKEY_RecordedTV_Credits</para>
            <para>Description: Example: "Don Messick/Frank Welker/Casey Kasem/Heather North/Nicole Jaffe;;;"</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.DateContentExpires">
            <summary>
            <para>Name:     System.RecordedTV.DateContentExpires -- PKEY_RecordedTV_DateContentExpires</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 15</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.EpisodeName">
            <summary>
            <para>Name:     System.RecordedTV.EpisodeName -- PKEY_RecordedTV_EpisodeName</para>
            <para>Description: Example: "Nowhere to Hyde"</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsATSCContent">
            <summary>
            <para>Name:     System.RecordedTV.IsATSCContent -- PKEY_RecordedTV_IsATSCContent</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 16</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsClosedCaptioningAvailable">
            <summary>
            <para>Name:     System.RecordedTV.IsClosedCaptioningAvailable -- PKEY_RecordedTV_IsClosedCaptioningAvailable</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 12</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsDTVContent">
            <summary>
            <para>Name:     System.RecordedTV.IsDTVContent -- PKEY_RecordedTV_IsDTVContent</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 17</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsHDContent">
            <summary>
            <para>Name:     System.RecordedTV.IsHDContent -- PKEY_RecordedTV_IsHDContent</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 18</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsRepeatBroadcast">
            <summary>
            <para>Name:     System.RecordedTV.IsRepeatBroadcast -- PKEY_RecordedTV_IsRepeatBroadcast</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 13</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.IsSAP">
            <summary>
            <para>Name:     System.RecordedTV.IsSAP -- PKEY_RecordedTV_IsSAP</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 14</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.NetworkAffiliation">
            <summary>
            <para>Name:     System.RecordedTV.NetworkAffiliation -- PKEY_RecordedTV_NetworkAffiliation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {2C53C813-FB63-4E22-A1AB-0B331CA1E273}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.OriginalBroadcastDate">
            <summary>
            <para>Name:     System.RecordedTV.OriginalBroadcastDate -- PKEY_RecordedTV_OriginalBroadcastDate</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {4684FE97-8765-4842-9C13-F006447B178C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.ProgramDescription">
            <summary>
            <para>Name:     System.RecordedTV.ProgramDescription -- PKEY_RecordedTV_ProgramDescription</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.RecordingTime">
            <summary>
            <para>Name:     System.RecordedTV.RecordingTime -- PKEY_RecordedTV_RecordingTime</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {A5477F61-7A82-4ECA-9DDE-98B69B2479B3}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.StationCallSign">
            <summary>
            <para>Name:     System.RecordedTV.StationCallSign -- PKEY_RecordedTV_StationCallSign</para>
            <para>Description: Example: "TOONP"</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {6D748DE2-8D38-4CC3-AC60-F009B057C557}, 5</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.RecordedTV.StationName">
            <summary>
            <para>Name:     System.RecordedTV.StationName -- PKEY_RecordedTV_StationName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {1B5439E7-EBA1-4AF8-BDD7-7AF1D4549493}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search">
            <summary>Search Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.AutoSummary">
            <summary>
            <para>Name:     System.Search.AutoSummary -- PKEY_Search_AutoSummary</para>
            <para>Description: General Summary of the document.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.ContainerHash">
            <summary>
            <para>Name:     System.Search.ContainerHash -- PKEY_Search_ContainerHash</para>
            <para>Description: Hash code used to identify attachments to be deleted based on a common container url</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {BCEEE283-35DF-4D53-826A-F36A3EEFC6BE}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.Contents">
            <summary>
            <para>Name:     System.Search.Contents -- PKEY_Search_Contents</para>
            <para>
            Description: The contents of the item. This property is for query restrictions only; it cannot be retrieved in a
            query result. The Indexing Service friendly name is 'contents'.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_Storage) {B725F130-47EF-101A-A5F1-02608C9EEBAC}, 19 (PID_STG_CONTENTS)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.EntryID">
            <summary>
            <para>Name:     System.Search.EntryID -- PKEY_Search_EntryID</para>
            <para>
            Description: The entry ID for an item within a given catalog in the Windows Search Index. This value may be recycled,
            and therefore is not considered unique over time.
            </para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 5 (PROPID_QUERY_WORKID)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.ExtendedProperties">
            <summary>
            <para>Name:     System.Search.ExtendedProperties -- PKEY_Search_ExtendedProperties</para>
            <para>Description:</para>
            <para>Type:     Blob -- VT_BLOB</para>
            <para>FormatID: {7B03B546-FA4F-4A52-A2FE-03D5311E5865}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.GatherTime">
            <summary>
            <para>Name:     System.Search.GatherTime -- PKEY_Search_GatherTime</para>
            <para>
            Description: The Datetime that the Windows Search Gatherer process last pushed properties of this document to the
            Windows Search Gatherer Plugins.
            </para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {0B63E350-9CCC-11D0-BCDB-00805FCCCE04}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.HitCount">
            <summary>
            <para>Name:     System.Search.HitCount -- PKEY_Search_HitCount</para>
            <para>
            Description: When using CONTAINS over the Windows Search Index, this is the number of matches of the term. If there
            are multiple CONTAINS, an AND computes the min number of hits and an OR the max number of hits.
            </para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 4 (PROPID_QUERY_HITCOUNT)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.IsClosedDirectory">
            <summary>
            <para>Name:     System.Search.IsClosedDirectory -- PKEY_Search_IsClosedDirectory</para>
            <para>
            Description: If this property is emitted with a value of TRUE, then it indicates that this URL's last modified time
            applies to all of it's children, and if this URL is deleted then all of it's children are deleted as well. For
            example, this would be emitted as TRUE when emitting the URL of an email so that all attachments are tied to the last
            modified time of that email.
            </para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 23</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.IsFullyContained">
            <summary>
            <para>Name:     System.Search.IsFullyContained -- PKEY_Search_IsFullyContained</para>
            <para>
            Description: Any child URL of a URL which has System.Search.IsClosedDirectory=TRUE must emit
            System.Search.IsFullyContained=TRUE. This ensures that the URL is not deleted at the end of a crawl because it hasn't
            been visited (which is the normal mechanism for detecting deletes). For example an email attachment would emit this property
            </para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 24</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.QueryFocusedSummary">
            <summary>
            <para>Name:     System.Search.QueryFocusedSummary -- PKEY_Search_QueryFocusedSummary</para>
            <para>Description: Query Focused Summary of the document.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.QueryFocusedSummaryWithFallback">
            <summary>
            <para>Name:     System.Search.QueryFocusedSummaryWithFallback -- PKEY_Search_QueryFocusedSummaryWithFallback</para>
            <para>Description: Query Focused Summary of the document, if none is available it returns the AutoSummary.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {560C36C0-503A-11CF-BAA1-00004C752A9A}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.Rank">
            <summary>
            <para>Name:     System.Search.Rank -- PKEY_Search_Rank</para>
            <para>Description: Relevance rank of row. Ranges from 0-1000. Larger numbers = better matches. Query-time only.</para>
            <para>Type:     Int32 -- VT_I4</para>
            <para>FormatID: (FMTID_Query) {49691C90-7E17-101A-A91C-08002B2ECDA9}, 3 (PROPID_QUERY_RANK)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.Store">
            <summary>
            <para>Name:     System.Search.Store -- PKEY_Search_Store</para>
            <para>Description: The identifier for the protocol handler that produced this item. (E.g. MAPI, CSC, FILE etc.)</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {A06992B3-8CAF-4ED7-A547-B259E32AC9FC}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.UrlToIndex">
            <summary>
            <para>Name:     System.Search.UrlToIndex -- PKEY_Search_UrlToIndex</para>
            <para>
            Description: This property should be emitted by a container IFilter for each child URL within the container. The
            children will eventually be crawled by the indexer if they are within scope.
            </para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Search.UrlToIndexWithModificationTime">
            <summary>
            <para>Name:     System.Search.UrlToIndexWithModificationTime -- PKEY_Search_UrlToIndexWithModificationTime</para>
            <para>
            Description: This property is the same as System.Search.UrlToIndex except that it includes the time the URL was last
            modified. This is an optimization for the indexer as it doesn't have to call back into the protocol handler to ask
            for this information to determine if the content needs to be indexed again. The property is a vector with two
            elements, a VT_LPWSTR with the URL and a VT_FILETIME for the last modified time.
            </para>
            <para>Type:     Multivalue Any -- VT_VECTOR | VT_NULL (For variants: VT_ARRAY | VT_NULL)</para>
            <para>FormatID: {0B63E343-9CCC-11D0-BCDB-00805FCCCE04}, 12</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Shell">
            <summary>Shell Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Shell.OmitFromView">
            <summary>
            <para>Name:     System.Shell.OmitFromView -- PKEY_Shell_OmitFromView</para>
            <para>Description: Set this to a string value of 'True' to omit this item from shell views</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {DE35258C-C695-4CBC-B982-38B0AD24CED0}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Shell.SFGAOFlagsStrings">
            <summary>
            <para>Name:     System.Shell.SFGAOFlagsStrings -- PKEY_Shell_SFGAOFlagsStrings</para>
            <para>Description: Expresses the SFGAO flags as string values and is used as a query optimization.</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: {D6942081-D53B-443D-AD47-5E059D9CD27A}, 2</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Software">
            <summary>Software Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Software.DateLastUsed">
            <summary>
            <para>Name:     System.Software.DateLastUsed -- PKEY_Software_DateLastUsed</para>
            <para>Description:</para>
            <para>Type:     DateTime -- VT_FILETIME (For variants: VT_DATE)</para>
            <para>FormatID: {841E4F90-FF59-4D16-8947-E81BBFFAB36D}, 16</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Software.ProductName">
            <summary>
            <para>Name:     System.Software.ProductName -- PKEY_Software_ProductName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (PSFMTID_VERSION) {0CEF7D53-FA64-11D1-A203-0000F81FEDEE}, 7</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync">
            <summary>Sync Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.Comments">
            <summary>
            <para>Name:     System.Sync.Comments -- PKEY_Sync_Comments</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 13</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ConflictDescription">
            <summary>
            <para>Name:     System.Sync.ConflictDescription -- PKEY_Sync_ConflictDescription</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ConflictFirstLocation">
            <summary>
            <para>Name:     System.Sync.ConflictFirstLocation -- PKEY_Sync_ConflictFirstLocation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ConflictSecondLocation">
            <summary>
            <para>Name:     System.Sync.ConflictSecondLocation -- PKEY_Sync_ConflictSecondLocation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 7</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.HandlerCollectionID">
            <summary>
            <para>Name:     System.Sync.HandlerCollectionID -- PKEY_Sync_HandlerCollectionID</para>
            <para>Description:</para>
            <para>Type:     Guid -- VT_CLSID</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.HandlerID">
            <summary>
            <para>Name:     System.Sync.HandlerID -- PKEY_Sync_HandlerID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.HandlerName">
            <summary>
            <para>Name:     System.Sync.HandlerName -- PKEY_Sync_HandlerName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.HandlerType">
            <summary>
            <para>Name:     System.Sync.HandlerType -- PKEY_Sync_HandlerType</para>
            <para>Description:</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 8</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.HandlerTypeLabel">
            <summary>
            <para>Name:     System.Sync.HandlerTypeLabel -- PKEY_Sync_HandlerTypeLabel</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 9</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ItemID">
            <summary>
            <para>Name:     System.Sync.ItemID -- PKEY_Sync_ItemID</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 6</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ItemName">
            <summary>
            <para>Name:     System.Sync.ItemName -- PKEY_Sync_ItemName</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {CE50C159-2FB8-41FD-BE68-D3E042E274BC}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.ProgressPercentage">
            <summary>
            <para>Name:     System.Sync.ProgressPercentage -- PKEY_Sync_ProgressPercentage</para>
            <para>Description: An integer value between 0 and 100 representing the percentage completed.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 23</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.State">
            <summary>
            <para>Name:     System.Sync.State -- PKEY_Sync_State</para>
            <para>Description: Sync state.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 24</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Sync.Status">
            <summary>
            <para>Name:     System.Sync.Status -- PKEY_Sync_Status</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {7BD5533E-AF15-44DB-B8C8-BD6624E1D032}, 10</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Task">
            <summary>Task Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Task.BillingInformation">
            <summary>
            <para>Name:     System.Task.BillingInformation -- PKEY_Task_BillingInformation</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {D37D52C6-261C-4303-82B3-08B926AC6F12}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Task.CompletionStatus">
            <summary>
            <para>Name:     System.Task.CompletionStatus -- PKEY_Task_CompletionStatus</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {084D8A0A-E6D5-40DE-BF1F-C8820E7C877C}, 100</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Task.Owner">
            <summary>
            <para>Name:     System.Task.Owner -- PKEY_Task_Owner</para>
            <para>Description:</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: {08C7CC5F-60F2-4494-AD75-55E3E0B5ADD0}, 100</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video">
            <summary>Video Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.Compression">
            <summary>
            <para>Name:     System.Video.Compression -- PKEY_Video_Compression</para>
            <para>Description: Indicates the level of compression for the video stream. "Compression".</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 10 (PIDVSI_COMPRESSION)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.Director">
            <summary>
            <para>Name:     System.Video.Director -- PKEY_Video_Director</para>
            <para>Description:</para>
            <para>Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR (For variants: VT_ARRAY | VT_BSTR)</para>
            <para>FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) {64440492-4C8B-11D1-8B70-080036B11A03}, 20 (PIDMSI_DIRECTOR)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.EncodingBitrate">
            <summary>
            <para>Name:     System.Video.EncodingBitrate -- PKEY_Video_EncodingBitrate</para>
            <para>Description: Indicates the data rate in "bits per second" for the video stream. "DataRate".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 8 (PIDVSI_DATA_RATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.FourCC">
            <summary>
            <para>Name:     System.Video.FourCC -- PKEY_Video_FourCC</para>
            <para>Description: Indicates the 4CC for the video stream.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 44</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.FrameHeight">
            <summary>
            <para>Name:     System.Video.FrameHeight -- PKEY_Video_FrameHeight</para>
            <para>Description: Indicates the frame height for the video stream.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 4</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.FrameRate">
            <summary>
            <para>Name:     System.Video.FrameRate -- PKEY_Video_FrameRate</para>
            <para>Description: Indicates the frame rate in "frames per millisecond" for the video stream. "FrameRate".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 6 (PIDVSI_FRAME_RATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.FrameWidth">
            <summary>
            <para>Name:     System.Video.FrameWidth -- PKEY_Video_FrameWidth</para>
            <para>Description: Indicates the frame width for the video stream.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 3</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.HorizontalAspectRatio">
            <summary>
            <para>Name:     System.Video.HorizontalAspectRatio -- PKEY_Video_HorizontalAspectRatio</para>
            <para>
            Description: Indicates the horizontal portion of the aspect ratio. The X portion of XX:YY, like 16:9.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 42</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.SampleSize">
            <summary>
            <para>Name:     System.Video.SampleSize -- PKEY_Video_SampleSize</para>
            <para>Description: Indicates the sample size in bits for the video stream. "SampleSize".</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 9 (PIDVSI_SAMPLE_SIZE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.StreamName">
            <summary>
            <para>Name:     System.Video.StreamName -- PKEY_Video_StreamName</para>
            <para>Description: Indicates the name for the video stream. "StreamName".</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 2 (PIDVSI_STREAM_NAME)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.StreamNumber">
            <summary>
            <para>Name:     System.Video.StreamNumber -- PKEY_Video_StreamNumber</para>
            <para>Description: "Stream Number".</para>
            <para>Type:     UInt16 -- VT_UI2</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 11 (PIDVSI_STREAM_NUMBER)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.TotalBitrate">
            <summary>
            <para>Name:     System.Video.TotalBitrate -- PKEY_Video_TotalBitrate</para>
            <para>Description: Indicates the total data rate in "bits per second" for all video and audio streams.</para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 43 (PIDVSI_TOTAL_BITRATE)</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.TranscodedForSync">
            <summary>
            <para>Name:     System.Video.TranscodedForSync -- PKEY_Video_TranscodedForSync</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 46</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Video.VerticalAspectRatio">
            <summary>
            <para>Name:     System.Video.VerticalAspectRatio -- PKEY_Video_VerticalAspectRatio</para>
            <para>
            Description: Indicates the vertical portion of the aspect ratio. The Y portion of XX:YY, like 16:9.
            </para>
            <para>Type:     UInt32 -- VT_UI4</para>
            <para>FormatID: (FMTID_VideoSummaryInformation) {64440491-4C8B-11D1-8B70-080036B11A03}, 45</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Volume">
            <summary>Volume Properties</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Volume.FileSystem">
            <summary>
            <para>Name:     System.Volume.FileSystem -- PKEY_Volume_FileSystem</para>
            <para>Description: Indicates the filesystem of the volume.</para>
            <para>Type:     String -- VT_LPWSTR (For variants: VT_BSTR)</para>
            <para>
            FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 4 (PID_VOLUME_FILESYSTEM) (Filesystem Volume Properties)
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Volume.IsMappedDrive">
            <summary>
            <para>Name:     System.Volume.IsMappedDrive -- PKEY_Volume_IsMappedDrive</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: {149C0B69-2C2D-48FC-808F-D318D78C4636}, 2</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ole32.PROPERTYKEY.System.Volume.IsRoot">
            <summary>
            <para>Name:     System.Volume.IsRoot -- PKEY_Volume_IsRoot</para>
            <para>Description:</para>
            <para>Type:     Boolean -- VT_BOOL</para>
            <para>FormatID: (FMTID_Volume) {9B174B35-40FF-11D2-A27E-00C04FC30871}, 10 (Filesystem Volume Properties)</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32">
            <summary>Platform invokable enumerated types, constants and functions from oleaut.h</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.CALLCONV">
            <summary>Identifies the calling convention used by a member function described in the METHODDATA structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_CDECL">
            <summary>Indicates that the Cdecl calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_FASTCALL">
            <summary>Indicates that the Fastcall calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_FPFASTCALL">
            <summary>Indicates that the FPFastcall calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_MACPASCAL">
            <summary>Indicates that the Macpascal calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_MAX">
            <summary>Indicates the end of the CALLCONV enumeration.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_MPWCDECL">
            <summary>Indicates that the Mpwcdecl calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_MPWPASCAL">
            <summary>Indicates that the Mpwpascal calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_MSCPASCAL">
            <summary>Indicates that the Mscpascal calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_PASCAL">
            <summary>Indicates that the Pascal calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_STDCALL">
            <summary>Indicates that the Stdcall calling convention is used for a method.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CALLCONV.CC_SYSCALL">
            <summary>Indicates that the Syscall calling convention is used for a method.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.CHANGEKIND">
            <summary>Used by <see cref="T:Vanara.PInvoke.OleAut32.ITypeChangeEvents"/> functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_ADDMEMBER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_DELETEMEMBER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_SETNAMES">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_SETDOCUMENTATION">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_GENERAL">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_INVALIDATE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_CHANGEFAILED">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CHANGEKIND.CHANGEKIND_MAX">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE">
            <summary>Identifies the type of data contained in a <c>PROPBAG2</c> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_UNDEFINED">
            <summary>Value type is unknown or undefined.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_DATA">
            <summary>Value type is simple data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_URL">
            <summary>Value type is a URL reference.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_OBJECT">
            <summary>Value type is an object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_STREAM">
            <summary>Value type is a stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_STORAGE">
            <summary>Value type is storage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2_TYPE.PROPBAG2_TYPE_MONIKER">
            <summary>Value type is a moniker.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserFree(System.UInt32*,System.Byte*)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The object.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserFree64(System.UInt32*,System.Byte*)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The object.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserMarshal(System.UInt32*,System.Byte*,System.Byte*)">
            <summary>Marshals a BSTR object into the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserMarshal64(System.UInt32*,System.Byte*,System.Byte*)">
            <summary>Marshals a BSTR object into the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserSize(System.UInt32*,System.UInt32,System.Byte*)">
            <summary>Calculates the wire size of the BSTR object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer offset where the object will be marshaled. The method has to account for any padding needed for the BSTR
            object to be properly aligned when it will be marshaled to the buffer.
            </param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserSize64(System.UInt32*,System.UInt32,System.Byte*)">
            <summary>Calculates the wire size of the BSTR object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer offset where the object will be marshaled. The method has to account for any padding needed for the BSTR
            object to be properly aligned when it will be marshaled to the buffer.
            </param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserUnmarshal(System.UInt32*,System.Byte*,System.Byte*)">
            <summary>Unmarshals a BSTR object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BSTR_UserUnmarshal64(System.UInt32*,System.Byte*,System.Byte*)">
            <summary>Unmarshals a BSTR object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserFree(System.UInt32*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The object.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserFree64(System.UInt32*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The object.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserMarshal(System.UInt32*,System.Byte*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Marshals a VARIANT object into the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pVariant parameter is not valid.</term>
            </item>
            <item>
            <term>RPC_X_NULL_REF_POINTER</term>
            <term>The pVariant parameter is null.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserMarshal64(System.UInt32*,System.Byte*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Marshals a VARIANT object into the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pVariant parameter is not valid.</term>
            </item>
            <item>
            <term>RPC_X_NULL_REF_POINTER</term>
            <term>The pVariant parameter is null.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserSize(System.UInt32*,System.UInt32,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Calculates the wire size of the VARIANT object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer offset where the object will be marshaled. The method has to account for any padding needed for the object to
            be properly aligned when it will be marshaled to the buffer.
            </param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserSize64(System.UInt32*,System.UInt32,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Calculates the wire size of the VARIANT object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer offset where the object will be marshaled. The method has to account for any padding needed for the object to
            be properly aligned when it will be marshaled to the buffer.
            </param>
            <param name="arg3">The object.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserUnmarshal(System.UInt32*,System.Byte*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Unmarshals a VARIANT object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pVariant parameter is not valid.</term>
            </item>
            <item>
            <term>RPC_X_BAD_STUB_DATA</term>
            <term>The stub data for the buffer size is incorrect.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VARIANT_UserUnmarshal64(System.UInt32*,System.Byte*,Vanara.PInvoke.OleAut32.VARIANT*)">
            <summary>Unmarshals a VARIANT object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The current buffer. This pointer may or may not be aligned on entry.</param>
            <param name="arg3">The object.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pVariant parameter is not valid.</term>
            </item>
            <item>
            <term>RPC_X_BAD_STUB_DATA</term>
            <term>The stub data for the buffer size is incorrect.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.CUSTDATA">
            <summary>Represents custom data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CUSTDATA.cCustData">
            <summary>The number of custom data items in the <c>prgCustData</c> array.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CUSTDATA.prgCustData">
            <summary>The array of custom data items.</summary>
        </member>
        <member name="P:Vanara.PInvoke.OleAut32.CUSTDATA.Items">
            <summary>Gets the array of <see cref="T:Vanara.PInvoke.OleAut32.CUSTDATAITEM"/> structures.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.CUSTDATAITEM">
            <summary>Represents a custom data item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CUSTDATAITEM.guid">
            <summary>The unique identifier of the data item.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.CUSTDATAITEM.varValue">
            <summary>The value of the data item.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PROPBAG2">
            <summary>Contains or receives property information.</summary>
            <remarks>
            The <c>PROPBAG2</c> structure is used with the <c>IPropertyBag2::GetPropertyInfo</c>, <c>IPropertyBag2::Read</c>, and
            <c>IPropertyBag2::Write</c> methods.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.dwType">
            <summary>Type of property. This will be one of the PROPBAG2_TYPE values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.vt">
            <summary>VARIANT type of the property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.cfType">
            <summary>Clipboard format or MIME type of the property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.dwHint">
            <summary>
            Property name integer. If possible, this member will be filled by IPropertyBag2::GetPropertyInfo and can be used with
            IPropertyBag2::Read and IPropertyBag2::Write to accelerate the read or write operation. These values are not valid outside
            the property bag that created them.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.pstrName">
            <summary>Pointer to a string that specifies the property name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PROPBAG2.clsid">
            <summary>CLSID of the object. This member is valid only if dwType is PROPBAG2_TYPE_OBJECT.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ICreateErrorInfo">
            <summary>Returns error information.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateErrorInfo.SetGUID(System.Guid@)">
            <summary>Sets the globally unique identifier (GUID) of the interface that defined the error.</summary>
            <param name="rguid">
            The GUID of the interface that defined the error, or GUID_NULL if the error was defined by the operating system.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method sets the GUID of the interface that defined the error. If the error was defined by the system, set
            <c>ICreateErrorInfo::SetGUID</c> to GUID_NULL.
            </para>
            <para>
            This GUID does not necessarily represent the source of the error; however, the source is the class or application that
            raised the error. Using the GUID, applications can handle errors in an interface, independent of the class that implements
            the interface.
            </para>
            <para>Use of this function is demonstrated in the file Main.cpp of the COM Fundamentals Hello sample.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateErrorInfo.SetSource(System.String)">
            <summary>Sets the language-dependent programmatic identifier (ProgID) for the class or application that raised the error.</summary>
            <param name="szSource">A ProgID in the form progname.objectname.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method should be used to identify the class or application that is the source of the error. The language for the
            returned ProgID depends on the locale identifier (LCID) that was passed to the method at the time of invocation.
            </para>
            <para>Use of this function is demonstrated in the file Main.cpp of the COM Fundamentals Hello sample.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateErrorInfo.SetDescription(System.String)">
            <summary>Sets the textual description of the error.</summary>
            <param name="szDescription">A brief description of the error.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The text should be supplied in the language specified by the locale ID (LCID) that was passed to the method raising the
            error. For more information, see LCID Attribute in Type Libraries and the Object Description Language.
            </para>
            <para>Use of this function is demonstrated in the file Main.cpp of the COM Fundamentals Hello sample.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateErrorInfo.SetHelpFile(System.String)">
            <summary>Sets the path of the Help file that describes the error.</summary>
            <param name="szHelpFile">The fully qualified path of the Help file that describes the error.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This method sets the fully qualified path of the Help file that describes the current error. Use
            ICreateErrorInfo::SetHelpContext to set the Help context ID for the error in the Help file.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateErrorInfo.SetHelpContext(System.UInt32)">
            <summary>Sets the Help context identifier (ID) for the error.</summary>
            <param name="dwHelpContext">The Help context ID for the error.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>This method sets the Help context ID for the error. To establish the Help file to which it applies, use ICreateErrorInfo::SetHelpFile.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ICreateTypeInfo">
            <summary>Provides the tools for creating and administering the type information defined through the type description.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetGuid(System.Guid@)">
            <summary>Sets the globally unique identifier (GUID) associated with the type description.</summary>
            <param name="guid">The globally unique ID to be associated with the type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For an interface, this is an interface ID (IID); for a coclass, it is a class ID (CLSID). For information on GUIDs, see Type
            Libraries and the Object Description Language.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetTypeFlags(System.UInt32)">
            <summary>Sets type flags of the type description being created.</summary>
            <param name="uTypeFlags">The settings for the type flags. For details, see TYPEFLAGS.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetDocString(System.String)">
            <summary>Sets the documentation string displayed by type browsers.</summary>
            <param name="pStrDoc">A brief description of the type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetHelpContext(System.UInt32)">
            <summary>Sets the Help context ID of the type information.</summary>
            <param name="dwHelpContext">A handle to the Help context.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetVersion(System.UInt16,System.UInt16)">
            <summary>Sets the major and minor version number of the type information.</summary>
            <param name="wMajorVerNum">The major version number.</param>
            <param name="wMinorVerNum">The minor version number.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.AddRefTypeInfo(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.UInt32@)">
            <summary>Adds a type description to those referenced by the type description being created.</summary>
            <param name="pTInfo">The type description to be referenced.</param>
            <param name="phRefType">The handle that this type description associates with the referenced type information.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The second parameter returns a pointer to the handle of the added type information. If <c>AddRefTypeInfo</c> has been called
            previously for the same type information, the index that was returned by the previous call is returned in phRefType. If the
            referenced type description is in the type library being created, its type information can be obtained by calling
            IUnknown::QueryInterface(IID_ITypeInfo, ...) on the ICreateTypeInfo interface of that type description.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.AddFuncDesc(System.UInt32,System.Runtime.InteropServices.ComTypes.FUNCDESC@)">
            <summary>Adds a function description to the type description.</summary>
            <param name="index">The index of the new FUNCDESC in the type information.</param>
            <param name="pFuncDesc">
            A FUNCDESC structure that describes the function. The <c>bstrIDLInfo</c> field in the FUNCDESC should be null.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The index specifies the order of the functions within the type information. The first function has an index of zero. If an
            index is specified that exceeds one less than the number of functions in the type information, an error is returned. Calling
            this function does not pass ownership of the FUNCDESC structure to ICreateTypeInfo. Therefore, the caller must still
            de-allocate the FUNCDESC structure.
            </para>
            <para>
            The passed-in virtual function table (VTBL) field (oVft) of the FUNCDESC is ignored if the TYPEKIND is TKIND_MODULE or if
            oVft is -1 or 0. This attribute is set when ICreateTypeInfo::LayOut is called. The oVft value is used if the TYPEKIND is
            TKIND_DISPATCH and a dual interface or if the TYPEKIND is TKIND_INTERFACE. If the oVft is used, it must be a multiple of the
            sizeof(VOID *) on the machine, otherwise the function fails and E_INVALIDARG is returned as the HRESULT.
            </para>
            <para>
            The function <c>AddFuncDesc</c> uses the passed-in member identifier (memid) fields within each FUNCDESC for classes with
            TYPEKIND = TKIND_DISPATCH or TKIND_INTERFACE. If the member IDs are set to MEMBERID_NIL, <c>AddFuncDesc</c> assigns member
            IDs to the functions. Otherwise, the member ID fields within each FUNCDESC are ignored.
            </para>
            <para>
            Any HREFTYPE fields in the FUNCDESC structure must have been produced by the same instance of ITypeInfo for which
            <c>AddFuncDesc</c> is called.
            </para>
            <para>The get and put accessor functions for the same property must have the same dispatch identifier (DISPID).</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.AddImplType(System.UInt32,System.UInt32)">
            <summary>Specifies an inherited interface, or an interface implemented by a component object class (coclass).</summary>
            <param name="index">
            The index of the implementation class to be added. Specifies the order of the type relative to the other type.
            </param>
            <param name="hRefType">A handle to the referenced type description obtained from the AddRefType description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            To specify an inherited interface, use index = 0. For a dispinterface with Syntax 2, call
            <c>ICreateTypeInfo::AddImplType</c> twice, once with index = 0 for the inherited IDispatch and once with index = 1 for the
            interface that is being wrapped. For a dual interface, call <c>ICreateTypeInfo::AddImplType</c> with index = -1 for the
            TKIND_INTERFACE type information component of the dual interface.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetImplTypeFlags(System.UInt32,System.Int32)">
            <summary>Sets the attributes for an implemented or inherited interface of a type.</summary>
            <param name="index">The index of the interface for which to set type flags.</param>
            <param name="implTypeFlags">IMPLTYPE flags to be set.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetAlignment(System.UInt16)">
            <summary>Specifies the data alignment for an item of TYPEKIND=TKIND_RECORD.</summary>
            <param name="cbAlignment">
            Alignment method for the type. A value of 0 indicates alignment on the 64K boundary; 1 indicates no special alignment. For
            other values, n indicates alignment on byte n.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The alignment is the minimum of the natural alignment (for example, byte data on byte boundaries, word data on word
            boundaries, and so on), and the alignment denoted by cbAlignment.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetSchema(System.String)">
            <summary>Reserved for future use.</summary>
            <param name="pStrSchema">The schema.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.AddVarDesc(System.UInt32,System.Runtime.InteropServices.ComTypes.VARDESC@)">
            <summary>Adds a variable or data member description to the type description.</summary>
            <param name="index">The index of the variable or data member to be added to the type description.</param>
            <param name="pVarDesc">A pointer to the variable or data member description to be added.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The index specifies the order of the variables. The first variable has an index of zero. <c>ICreateTypeInfo::AddVarDesc</c>
            returns an error if the specified index is greater than the number of variables currently in the type information. Calling
            this function does not pass ownership of the VARDESC structure to ICreateTypeInfo. The instance field (oInst) of the VARDESC
            structure is ignored. This attribute is set only when ICreateTypeInfo::LayOut is called. Also, the member ID fields within
            the VARDESCs are ignored unless the TYPEKIND of the class is TKIND_DISPATCH.
            </para>
            <para>
            Any HREFTYPE fields in the VARDESC structure must have been produced by the same instance of ITypeInfo for which
            <c>AddVarDesc</c> is called.
            </para>
            <para><c>AddVarDesc</c> ignores the contents of the idldesc field of the ELEMDESC.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetFuncAndParamNames(System.UInt32,System.String[],System.UInt32)">
            <summary>Sets the name of a function and the names of its parameters to the specified names.</summary>
            <param name="index">The index of the function whose function name and parameter names are to be set.</param>
            <param name="rgszNames">
            An array of pointers to names. The first element is the function name. Subsequent elements are names of parameters.
            </param>
            <param name="cNames">The number of elements in the rgszNames array.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This method must be used once for each property. The last parameter for put and putref accessor functions is unnamed.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetVarName(System.UInt32,System.String)">
            <summary>Sets the name of a variable.</summary>
            <param name="index">The index of the variable.</param>
            <param name="szName">The name.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetTypeDescAlias(System.Runtime.InteropServices.ComTypes.TYPEDESC@)">
            <summary>Sets the type description for which this type description is an alias, if TYPEKIND=TKIND_ALIAS.</summary>
            <param name="pTDescAlias">The type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>To set the type for an alias, call <c>SetTypeDescAlias</c> for a type description whose TYPEKIND is TKIND_ALIAS.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.DefineFuncAsDllEntry(System.UInt32,System.String,System.String)">
            <summary>Associates a DLL entry point with the function that has the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="szDllName">The name of the DLL that contains the entry point.</param>
            <param name="szProcName">The name of the entry point or an ordinal (if the high word is zero).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the high word of szProcName is zero, then the low word must contain the ordinal of the entry point; otherwise, szProcName
            points to the zero-terminated name of the entry point.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetFuncDocString(System.UInt32,System.String)">
            <summary>Sets the documentation string for the function with the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="szDocString">The documentation string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The documentation string is a brief description of the function intended for use by tools such as type browsers.
            <c>SetFuncDocString</c> only needs to be used once for each property, because all property accessor functions are identified
            by one name.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetVarDocString(System.UInt32,System.String)">
            <summary>Sets the documentation string for the variable with the specified index.</summary>
            <param name="index">The index of the variable.</param>
            <param name="szDocString">The documentation string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetFuncHelpContext(System.UInt32,System.UInt32)">
            <summary>Sets the Help context ID for the function with the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="dwHelpContext">The Help context ID for the Help topic.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>SetFuncHelpContext</c> only needs to be set once for each property, because all property accessor functions are
            identified by one name.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetVarHelpContext(System.UInt32,System.UInt32)">
            <summary>Sets the Help context ID for the variable with the specified index.</summary>
            <param name="index">The index of the variable.</param>
            <param name="dwHelpContext">The handle to the Help context ID for the Help topic on the variable.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetMops(System.UInt32,System.String)">
            <summary>Sets the marshaling opcode string associated with the type description or the function.</summary>
            <param name="index">
            The index of the member for which to set the opcode string. If index is –1, sets the opcode string for the type description.
            </param>
            <param name="bstrMops">The marshaling opcode string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.SetTypeIdldesc(System.Runtime.InteropServices.ComTypes.IDLDESC@)">
            <summary>Reserved for future use.</summary>
            <param name="pIdlDesc">The IDLDESC.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo.LayOut">
            <summary>
            Assigns VTBL offsets for virtual functions and instance offsets for per-instance data members, and creates the two type
            descriptions for dual interfaces.
            </summary>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_UNDEFINEDTYPE</term>
            <term>Bound to unrecognized type.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            <item>
            <term>TYPE_E_AMBIGUOUSNAME</term>
            <term>More than one item exists with this name.</term>
            </item>
            <item>
            <term>TYPE_E_SIZETOOBIG</term>
            <term>The type information is too long.</term>
            </item>
            <item>
            <term>TYPE_E_TYPEMISMATCH</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>LayOut</c> also assigns member ID numbers to the functions and variables, unless the TYPEKIND of the class is
            TKIND_DISPATCH. Call <c>LayOut</c> after all members of the type information are defined, and before the type library is saved.
            </para>
            <para>
            Use ICreateTypeLib::SaveAllChanges to save the type information after calling <c>LayOut</c>. Other members of the
            ICreateTypeInfo interface should not be called after calling <c>LayOut</c>.
            </para>
            <para>
            <c>Note</c> Different implementations of ICreateTypeLib::SaveAllChanges or other interfaces that create type information are
            free to assign any member ID numbers, provided that all members (including inherited members), have unique IDs. For
            examples, see ICreateTypeInfo2.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ICreateTypeInfo2">
            <summary>
            <para>
            Provides the tools for creating and administering the type information defined through the type description. Derives from
            ICreateTypeInfo, and adds methods for deleting items that have been added through ICreateTypeInfo.
            </para>
            <para>
            The ICreateTypeInfo::LayOut method provides a way for the creator of the type information to check for any errors. A call to
            QueryInterface can be made to the ICreateTypeInfo instance at any time for its ITypeInfo interface. Calling any of the methods
            in the ITypeInfointerface that require layout information lays out the type information automatically.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetGuid(System.Guid@)">
            <summary>Sets the globally unique identifier (GUID) associated with the type description.</summary>
            <param name="guid">The globally unique ID to be associated with the type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For an interface, this is an interface ID (IID); for a coclass, it is a class ID (CLSID). For information on GUIDs, see Type
            Libraries and the Object Description Language.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetTypeFlags(System.UInt32)">
            <summary>Sets type flags of the type description being created.</summary>
            <param name="uTypeFlags">The settings for the type flags. For details, see TYPEFLAGS.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetDocString(System.String)">
            <summary>Sets the documentation string displayed by type browsers.</summary>
            <param name="pStrDoc">A brief description of the type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetHelpContext(System.UInt32)">
            <summary>Sets the Help context ID of the type information.</summary>
            <param name="dwHelpContext">A handle to the Help context.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVersion(System.UInt16,System.UInt16)">
            <summary>Sets the major and minor version number of the type information.</summary>
            <param name="wMajorVerNum">The major version number.</param>
            <param name="wMinorVerNum">The minor version number.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.AddRefTypeInfo(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.UInt32@)">
            <summary>Adds a type description to those referenced by the type description being created.</summary>
            <param name="pTInfo">The type description to be referenced.</param>
            <param name="phRefType">The handle that this type description associates with the referenced type information.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The second parameter returns a pointer to the handle of the added type information. If <c>AddRefTypeInfo</c> has been called
            previously for the same type information, the index that was returned by the previous call is returned in phRefType. If the
            referenced type description is in the type library being created, its type information can be obtained by calling
            IUnknown::QueryInterface(IID_ITypeInfo, ...) on the ICreateTypeInfo interface of that type description.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.AddFuncDesc(System.UInt32,System.Runtime.InteropServices.ComTypes.FUNCDESC@)">
            <summary>Adds a function description to the type description.</summary>
            <param name="index">The index of the new FUNCDESC in the type information.</param>
            <param name="pFuncDesc">
            A FUNCDESC structure that describes the function. The <c>bstrIDLInfo</c> field in the FUNCDESC should be null.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The index specifies the order of the functions within the type information. The first function has an index of zero. If an
            index is specified that exceeds one less than the number of functions in the type information, an error is returned. Calling
            this function does not pass ownership of the FUNCDESC structure to ICreateTypeInfo. Therefore, the caller must still
            de-allocate the FUNCDESC structure.
            </para>
            <para>
            The passed-in virtual function table (VTBL) field (oVft) of the FUNCDESC is ignored if the TYPEKIND is TKIND_MODULE or if
            oVft is -1 or 0. This attribute is set when ICreateTypeInfo::LayOut is called. The oVft value is used if the TYPEKIND is
            TKIND_DISPATCH and a dual interface or if the TYPEKIND is TKIND_INTERFACE. If the oVft is used, it must be a multiple of the
            sizeof(VOID *) on the machine, otherwise the function fails and E_INVALIDARG is returned as the HRESULT.
            </para>
            <para>
            The function <c>AddFuncDesc</c> uses the passed-in member identifier (memid) fields within each FUNCDESC for classes with
            TYPEKIND = TKIND_DISPATCH or TKIND_INTERFACE. If the member IDs are set to MEMBERID_NIL, <c>AddFuncDesc</c> assigns member
            IDs to the functions. Otherwise, the member ID fields within each FUNCDESC are ignored.
            </para>
            <para>
            Any HREFTYPE fields in the FUNCDESC structure must have been produced by the same instance of ITypeInfo for which
            <c>AddFuncDesc</c> is called.
            </para>
            <para>The get and put accessor functions for the same property must have the same dispatch identifier (DISPID).</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.AddImplType(System.UInt32,System.UInt32)">
            <summary>Specifies an inherited interface, or an interface implemented by a component object class (coclass).</summary>
            <param name="index">
            The index of the implementation class to be added. Specifies the order of the type relative to the other type.
            </param>
            <param name="hRefType">A handle to the referenced type description obtained from the AddRefType description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            To specify an inherited interface, use index = 0. For a dispinterface with Syntax 2, call
            <c>ICreateTypeInfo::AddImplType</c> twice, once with index = 0 for the inherited IDispatch and once with index = 1 for the
            interface that is being wrapped. For a dual interface, call <c>ICreateTypeInfo::AddImplType</c> with index = -1 for the
            TKIND_INTERFACE type information component of the dual interface.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetImplTypeFlags(System.UInt32,System.Int32)">
            <summary>Sets the attributes for an implemented or inherited interface of a type.</summary>
            <param name="index">The index of the interface for which to set type flags.</param>
            <param name="implTypeFlags">IMPLTYPE flags to be set.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetAlignment(System.UInt16)">
            <summary>Specifies the data alignment for an item of TYPEKIND=TKIND_RECORD.</summary>
            <param name="cbAlignment">
            Alignment method for the type. A value of 0 indicates alignment on the 64K boundary; 1 indicates no special alignment. For
            other values, n indicates alignment on byte n.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The alignment is the minimum of the natural alignment (for example, byte data on byte boundaries, word data on word
            boundaries, and so on), and the alignment denoted by cbAlignment.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetSchema(System.String)">
            <summary>Reserved for future use.</summary>
            <param name="pStrSchema">The schema.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.AddVarDesc(System.UInt32,System.Runtime.InteropServices.ComTypes.VARDESC@)">
            <summary>Adds a variable or data member description to the type description.</summary>
            <param name="index">The index of the variable or data member to be added to the type description.</param>
            <param name="pVarDesc">A pointer to the variable or data member description to be added.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The index specifies the order of the variables. The first variable has an index of zero. <c>ICreateTypeInfo::AddVarDesc</c>
            returns an error if the specified index is greater than the number of variables currently in the type information. Calling
            this function does not pass ownership of the VARDESC structure to ICreateTypeInfo. The instance field (oInst) of the VARDESC
            structure is ignored. This attribute is set only when ICreateTypeInfo::LayOut is called. Also, the member ID fields within
            the VARDESCs are ignored unless the TYPEKIND of the class is TKIND_DISPATCH.
            </para>
            <para>
            Any HREFTYPE fields in the VARDESC structure must have been produced by the same instance of ITypeInfo for which
            <c>AddVarDesc</c> is called.
            </para>
            <para><c>AddVarDesc</c> ignores the contents of the idldesc field of the ELEMDESC.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetFuncAndParamNames(System.UInt32,System.String[],System.UInt32)">
            <summary>Sets the name of a function and the names of its parameters to the specified names.</summary>
            <param name="index">The index of the function whose function name and parameter names are to be set.</param>
            <param name="rgszNames">
            An array of pointers to names. The first element is the function name. Subsequent elements are names of parameters.
            </param>
            <param name="cNames">The number of elements in the rgszNames array.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This method must be used once for each property. The last parameter for put and putref accessor functions is unnamed.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVarName(System.UInt32,System.String)">
            <summary>Sets the name of a variable.</summary>
            <param name="index">The index of the variable.</param>
            <param name="szName">The name.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetTypeDescAlias(System.Runtime.InteropServices.ComTypes.TYPEDESC@)">
            <summary>Sets the type description for which this type description is an alias, if TYPEKIND=TKIND_ALIAS.</summary>
            <param name="pTDescAlias">The type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>To set the type for an alias, call <c>SetTypeDescAlias</c> for a type description whose TYPEKIND is TKIND_ALIAS.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DefineFuncAsDllEntry(System.UInt32,System.String,System.String)">
            <summary>Associates a DLL entry point with the function that has the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="szDllName">The name of the DLL that contains the entry point.</param>
            <param name="szProcName">The name of the entry point or an ordinal (if the high word is zero).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the high word of szProcName is zero, then the low word must contain the ordinal of the entry point; otherwise, szProcName
            points to the zero-terminated name of the entry point.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetFuncDocString(System.UInt32,System.String)">
            <summary>Sets the documentation string for the function with the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="szDocString">The documentation string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The documentation string is a brief description of the function intended for use by tools such as type browsers.
            <c>SetFuncDocString</c> only needs to be used once for each property, because all property accessor functions are identified
            by one name.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVarDocString(System.UInt32,System.String)">
            <summary>Sets the documentation string for the variable with the specified index.</summary>
            <param name="index">The index of the variable.</param>
            <param name="szDocString">The documentation string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetFuncHelpContext(System.UInt32,System.UInt32)">
            <summary>Sets the Help context ID for the function with the specified index.</summary>
            <param name="index">The index of the function.</param>
            <param name="dwHelpContext">The Help context ID for the Help topic.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>SetFuncHelpContext</c> only needs to be set once for each property, because all property accessor functions are
            identified by one name.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVarHelpContext(System.UInt32,System.UInt32)">
            <summary>Sets the Help context ID for the variable with the specified index.</summary>
            <param name="index">The index of the variable.</param>
            <param name="dwHelpContext">The handle to the Help context ID for the Help topic on the variable.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetMops(System.UInt32,System.String)">
            <summary>Sets the marshaling opcode string associated with the type description or the function.</summary>
            <param name="index">
            The index of the member for which to set the opcode string. If index is –1, sets the opcode string for the type description.
            </param>
            <param name="bstrMops">The marshaling opcode string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetTypeIdldesc(System.Runtime.InteropServices.ComTypes.IDLDESC@)">
            <summary>Reserved for future use.</summary>
            <param name="pIdlDesc">The IDLDESC.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.LayOut">
            <summary>
            Assigns VTBL offsets for virtual functions and instance offsets for per-instance data members, and creates the two type
            descriptions for dual interfaces.
            </summary>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>Cannot write to the destination.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_UNDEFINEDTYPE</term>
            <term>Bound to unrecognized type.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The element cannot be found.</term>
            </item>
            <item>
            <term>TYPE_E_AMBIGUOUSNAME</term>
            <term>More than one item exists with this name.</term>
            </item>
            <item>
            <term>TYPE_E_SIZETOOBIG</term>
            <term>The type information is too long.</term>
            </item>
            <item>
            <term>TYPE_E_TYPEMISMATCH</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>LayOut</c> also assigns member ID numbers to the functions and variables, unless the TYPEKIND of the class is
            TKIND_DISPATCH. Call <c>LayOut</c> after all members of the type information are defined, and before the type library is saved.
            </para>
            <para>
            Use ICreateTypeLib::SaveAllChanges to save the type information after calling <c>LayOut</c>. Other members of the
            ICreateTypeInfo interface should not be called after calling <c>LayOut</c>.
            </para>
            <para>
            <c>Note</c> Different implementations of ICreateTypeLib::SaveAllChanges or other interfaces that create type information are
            free to assign any member ID numbers, provided that all members (including inherited members), have unique IDs. For
            examples, see ICreateTypeInfo2.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DeleteFuncDesc(System.UInt32)">
            <summary>Deletes a function description specified by the index number.</summary>
            <param name="index">
            The index of the function whose description is to be deleted. The index should be in the range of 0 to 1 less than the
            number of functions in this type.
            </param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DeleteFuncDescByMemId(System.Int32,System.Runtime.InteropServices.ComTypes.INVOKEKIND)">
            <summary>Deletes the specified function description (FUNCDESC).</summary>
            <param name="memid">The member identifier of the FUNCDESC to delete.</param>
            <param name="invKind">The type of the invocation.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DeleteVarDesc(System.UInt32)">
            <summary>Deletes the specified VARDESC structure.</summary>
            <param name="index">The index number of the VARDESC structure.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function cannot read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVDATAREAD</term>
            <term>The function cannot read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_UNSUPFORMAT</term>
            <term>The type library has an old format.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library cannot be opened.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DeleteVarDescByMemId(System.Int32)">
            <summary>Deletes the specified VARDESC structure.</summary>
            <param name="memid">The member identifier of the VARDESC to be deleted.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function cannot read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVDATAREAD</term>
            <term>The function cannot read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_UNSUPFORMAT</term>
            <term>The type library has an old format.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library cannot be opened.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.DeleteImplType(System.UInt32)">
            <summary>Deletes the IMPLTYPE flags for the indexed interface.</summary>
            <param name="index">The index of the interface for which to delete the type flags.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetCustData(System.Guid@,System.Object)">
            <summary>Sets a value for custom data.</summary>
            <param name="guid">The unique identifier that can be used to identify the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetFuncCustData(System.UInt32,System.Guid@,System.Object)">
            <summary>Sets a value for custom data for the specified function.</summary>
            <param name="index">The index of the function for which to set the custom data.</param>
            <param name="guid">The unique identifier used to identify the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetParamCustData(System.UInt32,System.UInt32,System.Guid@,System.Object)">
            <summary>Sets a value for the custom data for the specified parameter.</summary>
            <param name="indexFunc">The index of the function for which to set the custom data.</param>
            <param name="indexParam">The index of the parameter of the function for which to set the custom data.</param>
            <param name="guid">The globally unique identifier (GUID) used to identify the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVarCustData(System.UInt32,System.Guid@,System.Object)">
            <summary>Sets a value for custom data for the specified variable.</summary>
            <param name="index">The index of the variable for which to set the custom data.</param>
            <param name="guid">The globally unique ID (GUID) used to identify the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetImplTypeCustData(System.UInt32,System.Guid@,System.Object)">
            <summary>Sets a value for custom data for the specified implementation type.</summary>
            <param name="index">The index of the variable for which to set the custom data.</param>
            <param name="guid">The unique identifier used to identify the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetHelpStringContext(System.UInt32)">
            <summary>Sets the context number for the specified Help string.</summary>
            <param name="dwHelpStringContext">The Help string context number.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetFuncHelpStringContext(System.UInt32,System.UInt32)">
            <summary>Sets a Help context value for a specified function.</summary>
            <param name="index">The index of the function for which to set the help string context.</param>
            <param name="dwHelpStringContext">The Help string context for a localized string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetVarHelpStringContext(System.UInt32,System.UInt32)">
            <summary>Sets a Help context value for a specified variable.</summary>
            <param name="index">The index of the variable.</param>
            <param name="dwHelpStringContext">The Help string context for a localized string.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.Invalidate">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeInfo2.SetName(System.String)">
            <summary>Sets the name of the typeinfo.</summary>
            <param name="szName">The name to be assigned.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ICreateTypeLib">
            <summary>
            Provides the methods for creating and managing the component or file that contains type information. Type libraries are created
            from type descriptions using the MIDL compiler. These type libraries are accessed through the ITypeLib interface.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.CreateTypeInfo(System.String,System.Runtime.InteropServices.ComTypes.TYPEKIND,Vanara.PInvoke.OleAut32.ICreateTypeInfo@)">
            <summary>Creates a new type description instance within the type library.</summary>
            <param name="szName">The name of the new type.</param>
            <param name="tkind">TYPEKIND of the type description to be created.</param>
            <param name="ppCTInfo">The type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            <item>
            <term>TYPE_E_NAMECONFLICT</term>
            <term>The provided name is not unique.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Use ICreateTypeLib to create a new type description instance within the library. An error is returned if the specified name
            already appears in the library. Valid tkind values are described in TYPEKIND. To get the type information of the type
            description that is being created, call on the returned <c>ICreateTypeLib</c>. This type information can be used by other
            type descriptions that reference it by using ICreateTypeInfo::AddRefTypeInfo.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetName(System.String)">
            <summary>Sets the name of the type library.</summary>
            <param name="szName">The name to be assigned to the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetVersion(System.UInt16,System.UInt16)">
            <summary>Sets the major and minor version numbers of the type library.</summary>
            <param name="wMajorVerNum">The major version number for the library.</param>
            <param name="wMinorVerNum">The minor version number for the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetGuid(System.Guid@)">
            <summary>
            Sets the universal unique identifier (UUID) associated with the type library (Also known as the globally unique identifier (GUID)).
            </summary>
            <param name="guid">The globally unique identifier to be assigned to the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetDocString(System.String)">
            <summary>Sets the documentation string associated with the library.</summary>
            <param name="szDoc">A brief description of the type library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The documentation string is a brief description of the library intended for use by type information browsing tools.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetHelpFileName(System.String)">
            <summary>Sets the name of the Help file.</summary>
            <param name="szHelpFileName">The name of the Help file for the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Each type library can reference a single Help file.</para>
            <para>
            The GetDocumentation method of the created ITypeLib returns a fully qualified path for the Help file, which is formed by
            appending the name passed into szHelpFileName to the registered Help directory for the type library. The Help directory is
            registered under:
            </para>
            <para>\TYPELIB&amp;lt;guid of library&gt;&amp;lt;Major.Minor version &gt;\HELPDIR</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetHelpContext(System.UInt32)">
            <summary>Sets the Help context ID for retrieving general Help information for the type library.</summary>
            <param name="dwHelpContext">The Help context ID.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Calling <c>SetHelpContext</c> with a Help context of zero is equivalent to not calling it at all, because zero indicates a
            null Help context.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetLcid(Vanara.PInvoke.LCID)">
            <summary>Sets the binary Microsoft national language ID associated with the library.</summary>
            <param name="lcid">The locale ID for the type library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For more information on national language IDs, see Supporting Multiple National Languages and the National Language Support
            (NLS) API.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SetLibFlags(System.UInt32)">
            <summary>Sets library flags.</summary>
            <param name="uLibFlags">The flags to set.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>Valid uLibFlags values are listed in LIBFLAGS.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib.SaveAllChanges">
            <summary>Saves the ICreateTypeLib instance following the layout of type information.</summary>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function cannot write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>You should not call any other ICreateTypeLib methods after calling <c>SaveAllChanges</c>.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ICreateTypeLib2">
            <summary>
            Provides the methods for creating and managing the component or file that contains type information. Derives from
            ICreateTypeLib. The ICreateTypeInfo instance returned from <c>ICreateTypeLib</c> can be accessed through a <c>QueryInterface</c>
            call to ICreateTypeInfo2.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.CreateTypeInfo(System.String,System.Runtime.InteropServices.ComTypes.TYPEKIND,Vanara.PInvoke.OleAut32.ICreateTypeInfo@)">
            <summary>Creates a new type description instance within the type library.</summary>
            <param name="szName">The name of the new type.</param>
            <param name="tkind">TYPEKIND of the type description to be created.</param>
            <param name="ppCTInfo">The type description.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            <item>
            <term>TYPE_E_NAMECONFLICT</term>
            <term>The provided name is not unique.</term>
            </item>
            <item>
            <term>TYPE_E_WRONGTYPEKIND</term>
            <term>Type mismatch.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Use ICreateTypeLib to create a new type description instance within the library. An error is returned if the specified name
            already appears in the library. Valid tkind values are described in TYPEKIND. To get the type information of the type
            description that is being created, call on the returned <c>ICreateTypeLib</c>. This type information can be used by other
            type descriptions that reference it by using ICreateTypeInfo::AddRefTypeInfo.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetName(System.String)">
            <summary>Sets the name of the type library.</summary>
            <param name="szName">The name to be assigned to the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetVersion(System.UInt16,System.UInt16)">
            <summary>Sets the major and minor version numbers of the type library.</summary>
            <param name="wMajorVerNum">The major version number for the library.</param>
            <param name="wMinorVerNum">The minor version number for the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetGuid(System.Guid@)">
            <summary>
            Sets the universal unique identifier (UUID) associated with the type library (Also known as the globally unique identifier (GUID)).
            </summary>
            <param name="guid">The globally unique identifier to be assigned to the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetDocString(System.String)">
            <summary>Sets the documentation string associated with the library.</summary>
            <param name="szDoc">A brief description of the type library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The documentation string is a brief description of the library intended for use by type information browsing tools.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetHelpFileName(System.String)">
            <summary>Sets the name of the Help file.</summary>
            <param name="szHelpFileName">The name of the Help file for the library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Each type library can reference a single Help file.</para>
            <para>
            The GetDocumentation method of the created ITypeLib returns a fully qualified path for the Help file, which is formed by
            appending the name passed into szHelpFileName to the registered Help directory for the type library. The Help directory is
            registered under:
            </para>
            <para>\TYPELIB&amp;lt;guid of library&gt;&amp;lt;Major.Minor version &gt;\HELPDIR</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetHelpContext(System.UInt32)">
            <summary>Sets the Help context ID for retrieving general Help information for the type library.</summary>
            <param name="dwHelpContext">The Help context ID.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Calling <c>SetHelpContext</c> with a Help context of zero is equivalent to not calling it at all, because zero indicates a
            null Help context.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetLcid(Vanara.PInvoke.LCID)">
            <summary>Sets the binary Microsoft national language ID associated with the library.</summary>
            <param name="lcid">The locale ID for the type library.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For more information on national language IDs, see Supporting Multiple National Languages and the National Language Support
            (NLS) API.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetLibFlags(System.UInt32)">
            <summary>Sets library flags.</summary>
            <param name="uLibFlags">The flags to set.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>Valid uLibFlags values are listed in LIBFLAGS.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SaveAllChanges">
            <summary>Saves the ICreateTypeLib instance following the layout of type information.</summary>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function cannot write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The state of the type library is not valid for this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>You should not call any other ICreateTypeLib methods after calling <c>SaveAllChanges</c>.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.DeleteTypeInfo(System.String)">
            <summary>Deletes a specified type information from the type library.</summary>
            <param name="szName">The name of the type information to remove.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetCustData(System.Guid@,System.Object)">
            <summary>Sets a value to custom data.</summary>
            <param name="guid">The unique identifier for the data.</param>
            <param name="pVarVal">The data to store (any variant except an object).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetHelpStringContext(System.UInt32)">
            <summary>Sets the Help string context number.</summary>
            <param name="dwHelpStringContext">The Help string context number.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ICreateTypeLib2.SetHelpStringDll(System.String)">
            <summary>Sets the DLL name to be used for Help string lookup (for localization purposes).</summary>
            <param name="szFileName">The DLL file name.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IDispatch">
            <summary>
            Exposes objects, methods and properties to programming tools and other applications that support Automation. COM components
            implement the <c>IDispatch</c> interface to enable access by Automation clients, such as Visual Basic.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IDispatch.GetTypeInfoCount(System.UInt32@)">
            <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
            <param name="pctinfo">
            The number of type information interfaces provided by the object. If the object provides type information, this number is 1;
            otherwise the number is 0.
            </param>
            <remarks>
            The method may return zero, which indicates that the object does not provide any type information. In this case, the object
            may still be programmable through <c>IDispatch</c> or a VTBL, but does not provide run-time type information for browsers,
            compilers, or other programming tools that access type information. This can be useful for hiding an object from browsers.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IDispatch.GetTypeInfo(System.UInt32,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.ITypeInfo@)">
            <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
            <param name="iTInfo">The type information to return. Pass 0 to retrieve type information for the IDispatch implementation.</param>
            <param name="lcid">
            The locale identifier for the type information. An object may be able to return different type information for different
            languages. This is important for classes that support localized member names. For classes that do not support localized
            member names, this parameter can be ignored.
            </param>
            <param name="ppTInfo">The requested type information object.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IDispatch.GetIDsOfNames(System.Guid@,System.String[],System.UInt32,Vanara.PInvoke.LCID,System.Int32[])">
            <summary>
            Maps a single member and an optional set of argument names to a corresponding set of integer DISPIDs, which can be used on
            subsequent calls to Invoke. The dispatch function DispGetIDsOfNames provides a standard implementation of <c>GetIDsOfNames</c>.
            </summary>
            <param name="riid">Reserved for future use. Must be IID_NULL.</param>
            <param name="rgszNames">The array of names to be mapped.</param>
            <param name="cNames">The count of the names to be mapped.</param>
            <param name="lcid">The locale context in which to interpret the names.</param>
            <param name="rgDispId">
            Caller-allocated array, each element of which contains an identifier (ID) corresponding to one of the names passed in the
            rgszNames array. The first element represents the member name. The subsequent elements represent each of the member's parameters.
            </param>
            <remarks>
            <para>
            An IDispatch implementation can associate any positive integer ID value with a given name. Zero is reserved for the default,
            or <c>Value</c> property; –1 is reserved to indicate an unknown name; and other negative values are defined for other
            purposes. For example, if <c>GetIDsOfNames</c> is called, and the implementation does not recognize one or more of the
            names, it returns DISP_E_UNKNOWNNAME, and the rgDispId array contains DISPID_UNKNOWN for the entries that correspond to the
            unknown names.
            </para>
            <para>
            The member and parameter DISPIDs must remain constant for the lifetime of the object. This allows a client to obtain the
            DISPIDs once, and cache them for later use.
            </para>
            <para>
            When <c>GetIDsOfNames</c> is called with more than one name, the first name (rgszNames[0]) corresponds to the member name,
            and subsequent names correspond to the names of the member's parameters.
            </para>
            <para>
            The same name may map to different DISPIDs, depending on context. For example, a name may have a DISPID when it is used as a
            member name with a particular interface, a different ID as a member of a different interface, and different mapping for each
            time it appears as a parameter.
            </para>
            <para>
            <c>GetIDsOfNames</c> is used when an IDispatch client binds to names at run time. To bind at compile time instead, an
            <c>IDispatch</c> client can map names to DISPIDs by using the type information interfaces described in Type Description
            Interfaces. This allows a client to bind to members at compile time and avoid calling <c>GetIDsOfNames</c> at run time. For
            a description of binding at compile time, see Type Description Interfaces.
            </para>
            <para>
            The implementation of <c>GetIDsOfNames</c> is case insensitive. Users that need case-sensitive name mapping should use type
            information interfaces to map names to DISPIDs, rather than call <c>GetIDsOfNames</c>.
            </para>
            <para>
            <c>Caution</c> You cannot use this method to access values that have been added dynamically, such as values added through
            JavaScript. Instead, use the GetDispID of the IDispatchEx interface. For more information, see the IDispatchEx interface.
            </para>
            <para>Examples</para>
            <para>
            The following code from the Lines sample file Lines.cpp implements the <c>GetIDsOfNames</c> member function for the CLine
            class. The ActiveX or OLE object uses the standard implementation, DispGetIDsOfNames. This implementation relies on
            <c>DispGetIdsOfNames</c> to validate input arguments. To help minimize security risks, include code that performs more
            robust validation of the input arguments.
            </para>
            <para>
            The following code might appear in an ActiveX client that calls <c>GetIDsOfNames</c> to get the DISPID of the
            <c>CLine</c><c>Color</c> property.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IDispatch.Invoke(System.Int32,System.Guid@,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.INVOKEKIND,System.Runtime.InteropServices.ComTypes.DISPPARAMS@,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Provides access to properties and methods exposed by an object. The dispatch function DispInvoke provides a standard
            implementation of <c>Invoke</c>.
            </summary>
            <param name="dispIdMember">
            Identifies the member. Use GetIDsOfNames or the object's documentation to obtain the dispatch identifier.
            </param>
            <param name="riid">Reserved for future use. Must be IID_NULL.</param>
            <param name="lcid">
            <para>
            The locale context in which to interpret arguments. The <paramref name="lcid"/> is used by the GetIDsOfNames function, and
            is also passed to <c>Invoke</c> to allow the object to interpret its arguments specific to a locale.
            </para>
            <para>
            Applications that do not support multiple national languages can ignore this parameter. For more information, refer to
            Supporting Multiple National Languages and Exposing ActiveX Objects.
            </para>
            </param>
            <param name="wFlags">
            <para>Flags describing the context of the <c>Invoke</c> call.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DISPATCH_METHOD</term>
            <term>
            The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag can be set.
            </term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYGET</term>
            <term>The member is retrieved as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUT</term>
            <term>The member is changed as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUTREF</term>
            <term>
            The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property
            accepts a reference to an object.
            </term>
            </item>
            </list>
            </param>
            <param name="pDispParams">
            Pointer to a DISPPARAMS structure containing an array of arguments, an array of argument DISPIDs for named arguments, and
            counts for the number of elements in the arrays.
            </param>
            <param name="pVarResult">
            Pointer to the location where the result is to be stored, or NULL if the caller expects no result. This argument is ignored
            if DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.
            </param>
            <param name="pExcepInfo">
            Pointer to a structure that contains exception information. This structure should be filled in if DISP_E_EXCEPTION is
            returned. Can be NULL.
            </param>
            <param name="puArgErr">
            The index within rgvarg of the first argument that has an error. Arguments are stored in pDispParams-&gt;rgvarg in reverse
            order, so the first argument is the one with the highest index in the array. This parameter is returned only when the
            resulting return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND. This argument can be set to null. For details, see
            Returning Errors.
            </param>
            <remarks>
            <para>
            Generally, you should not implement <c>Invoke</c> directly. Instead, use the dispatch interface to create functions
            CreateStdDispatch and DispInvoke. For details, refer to <c>CreateStdDispatch</c>, <c>DispInvoke</c>, Creating the IDispatch
            Interface and Exposing ActiveX Objects.
            </para>
            <para>
            If some application-specific processing needs to be performed before calling a member, the code should perform the necessary
            actions, and then call ITypeInfo::Invoke to invoke the member. <c>ITypeInfo::Invoke</c> acts exactly like <c>Invoke</c>. The
            standard implementations of <c>Invoke</c> created by <c>CreateStdDispatch</c> and <c>DispInvoke</c> defer to <c>ITypeInfo::Invoke</c>.
            </para>
            <para>
            In an ActiveX client, <c>Invoke</c> should be used to get and set the values of properties, or to call a method of an
            ActiveX object. The dispIdMember argument identifies the member to invoke. The DISPIDs that identify members are defined by
            the implementor of the object and can be determined by using the object's documentation, the IDispatch::GetIDsOfNames
            function, or the ITypeInfo interface.
            </para>
            <para>
            When you use <c>IDispatch::Invoke()</c> with DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF, you have to specially
            initialize the <c>cNamedArgs</c> and <c>rgdispidNamedArgs</c> elements of your DISPPARAMS structure with the following:
            </para>
            <para>
            The information that follows addresses developers of ActiveX clients and others who use code to expose ActiveX objects. It
            describes the behavior that users of exposed objects should expect.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IErrorInfo">
            <summary>Provides detailed contextual error information.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorInfo.GetGUID(System.Guid@)">
            <summary>Returns the globally unique identifier (GUID) of the interface that defined the error.</summary>
            <param name="pGUID">A pointer to a GUID, or GUID_NULL, if the error was defined by the operating system.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            <c>IErrorInfo::GetGUID</c> returns the GUID of the interface that defined the error. If the error was defined by the system,
            <c>IErrorInfo::GetGUID</c> returns GUID_NULL.
            </para>
            <para>
            This GUID does not necessarily represent the source of the error. The source is the class or application that raised the
            error. Using the GUID, an application can handle errors in an interface, independent of the class that implements the interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorInfo.GetSource(System.String@)">
            <summary>Returns the language-dependent programmatic ID (ProgID) for the class or application that raised the error.</summary>
            <param name="pBstrSource">A ProgID, in the form progname.objectname.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            Use <c>IErrorInfo::GetSource</c> to determine the class or application that is the source of the error. The language for the
            returned ProgID depends on the locale ID (LCID) that was passed into the method at the time of invocation.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorInfo.GetDescription(System.String@)">
            <summary>Returns a textual description of the error.</summary>
            <param name="pBstrDescription">A brief description of the error.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            The text is returned in the language specified by the locale identifier (LCID) that was passed to IDispatch::Invoke for the
            method that encountered the error.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorInfo.GetHelpFile(System.String@)">
            <summary>Returns the path of the Help file that describes the error.</summary>
            <param name="pBstrHelpFile">The fully qualified path of the Help file.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            This method returns the fully qualified path of the Help file that describes the current error. IErrorInfo::GetHelpContext
            should be used to find the Help context ID for the error in the Help file.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorInfo.GetHelpContext(System.UInt32@)">
            <summary>Returns the Help context identifier (ID) for the error.</summary>
            <param name="pdwHelpContext">The Help context ID for the error.</param>
            <returns>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>This method returns the Help context ID for the error. To find the Help file to which it applies, use IErrorInfo::GetHelpFile.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IErrorLog">
            <summary>Communicates detailed error information between a client and an object.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IErrorLog.AddError(System.String,System.Runtime.InteropServices.ComTypes.EXCEPINFO@)">
            <summary>Logs an error (using an EXCEPINFO structure) in the error log for a named property.</summary>
            <param name="pszPropName">
            A pointer to a string containing the name of the property involved with the error. This cannot be NULL.
            </param>
            <param name="pExcepInfo">
            A pointer to the caller-initialized EXCEPINFO structure that describes the error to log. This cannot be NULL.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IPropertyBag">
            <summary>Provides an object with a property bag in which the object can save its properties persistently.</summary>
            <remarks>
            To read a property in IPersistPropertyBag::Load, the object calls IPropertyBag::Read. When the object saves properties in
            IPersistPropertyBag::Save, it calls IPropertyBag::Write. Each property is described with a name, whose value is stored in a
            VARIANT. This information allows a client to save the property values as text, for example; which is the primary reason why a
            client might choose to support IPersistPropertyBag.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag.Read(System.String,System.Object@,Vanara.PInvoke.OleAut32.IErrorLog)">
            <summary>Tells the property bag to read the named property into a caller-initialized VARIANT.</summary>
            <param name="pszPropName">The address of the name of the property to read. This cannot be NULL.</param>
            <param name="pVar">
            The address of the caller-initialized VARIANT that receives the property value on output. The function must set the type
            field and the value field in the VARIANT before it returns. If the caller initialized the pVar-&gt;vt field on entry, the
            property bag attempts to change its corresponding value to this type. If the caller sets pVar-&gt;vt to VT_EMPTY, the
            property bag can use whatever type is convenient.
            </param>
            <param name="pErrorLog">
            The address of the caller's error log in which the property bag stores any errors that occur during reads. This can be NULL;
            in which case, the caller does not receive errors.
            </param>
            <remarks>
            The Read method tells the property bag to read the property named in pszPropName to the caller-initialized VARIANT in pVar.
            Errors are logged in the error log that is pointed to by pErrorLog. When pVar-&gt;vt specifies another object pointer
            (VT_UNKNOWN), the property bag is responsible for creating and initializing the object described by pszPropName.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag.Write(System.String,System.Object@)">
            <summary>Tells the property bag to save the named property in a caller-initialized VARIANT.</summary>
            <param name="pszPropName">The address of a string containing the name of the property to write. This cannot be NULL.</param>
            <param name="pVar">
            The address of the caller-initialized VARIANT that holds the property value to save. The caller owns this VARIANT, and is
            responsible for all of its allocations. That is, the property bag does not attempt to free data in the VARIANT.
            </param>
            <remarks>
            The Write method tells the property bag to save the property named with pszPropName by using the type and value in the
            caller-initialized VARIANT in pVar. In some cases, the caller might be telling the property bag to save another object, for
            example, when pVar-&gt;vt is VT_UNKNOWN. In such cases, the property bag queries this object pointer for a persistence
            interface, such as IPersistStream or IPersistPropertyBag, and has that object save its data as well. Usually this results in
            the property bag having some byte array for this object, which can be saved as encoded text, such as hexadecimal string,
            MIME, and so on. When the property bag is later used to reinitialize a control, the client that owns the property bag must
            re-create the object when the caller asks for it, initializing that object with the previously saved bits.
            <para>
            This allows efficient persistence operations for Binary Large Object (BLOB) properties, such as a picture, where the owner
            of the property bag tells the picture object (which is managed as a property in the control that is saved) to save to a
            specific location. This avoids potential extra copy operations that might be involved with other property-based persistence mechanisms.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IPropertyBag2">
            <summary>Provides an object with a property bag in which the object can save its properties persistently.</summary>
            <remarks>
            <para>
            When a client wants to control how the individually named properties of an object are saved, it uses an object's
            <c>IPersistPropertyBag2</c> interface as a persistence mechanism. The client supplies a property bag to the object in the form
            of an <c>IPropertyBag2</c> interface.
            </para>
            <para>
            <c>IPropertyBag2</c> is an enhancement of the <c>IPropertyBag</c> interface. <c>IPropertyBag2</c> allows the object to obtain
            type information for each property by using the <c>CountProperties</c> method and the <c>GetPropertyInfo</c> method. A property
            bag that implements <c>IPropertyBag2</c> must also support <c>IPropertyBag</c>, so that objects that only support
            <c>IPropertyBag</c> can access their properties. Also, an object that supports <c>IPropertyBag2</c> must also support
            <c>IPropertyBag</c> so that the object can communicate with property bags that only support <c>IPropertyBag</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag2.Read(System.UInt32,Vanara.PInvoke.OleAut32.PROPBAG2[],Vanara.PInvoke.OleAut32.IErrorLog,System.Object[],Vanara.PInvoke.HRESULT[])">
            <summary>Causes one or more properties to be read from the property bag.</summary>
            <param name="cProperties">
            <para>[in]Type: <c>unsigned long</c></para>
            <para>
            The number of properties to read. This argument specifies the number of elements in the arrays at pPropBag, pvarValue, and phrError.
            </para>
            </param>
            <param name="pPropBag">
            <para>[in]Type: <c>[</c> PROPBAG2 <c>]</c></para>
            <para>
            The address of an array of <c>PROPBAG2</c> structures that specify the properties that are requested. The <c>vt</c> member
            and the <c>pstrName</c> member of these structures must be filled in before this method can be called. The <c>dwHint</c>
            member of these structures is optional. There must be at least cProperties elements in this array. This argument cannot be NULL.
            </para>
            </param>
            <param name="pErrLog">
            <para>[in]Type: <c>IErrorLog</c></para>
            <para>
            The address of an <c>IErrorlog</c> interface in which the property bag stores any errors that occur during the reads. This
            argument can be NULL; in which case, the caller receives no logging errors.
            </para>
            </param>
            <param name="pvarValue">
            <para>[out]Type: <c>VARIANT</c></para>
            <para>
            The address of an array of <c>VARIANT</c> structures that receive the property values. The caller does not have to
            initialize these structures before calling <c>IPropertyBag2::Read</c>. The <c>IPropertyBag2::Read</c> method fills the type
            field and the value field in these structures before it returns. There must be at least cProperties elements in this array.
            The calling application is responsible for freeing any allocations that are contained in these structures. This argument
            cannot be NULL.
            </para>
            </param>
            <param name="phrError">
            <para>[out]Type: <c>HRESULT</c></para>
            <para>
            The address of an array of <c>HRESULT</c> values that receives the result of each property read. There must be at least
            cProperties elements in this array. This argument cannot be NULL.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag2.Write(System.UInt32,Vanara.PInvoke.OleAut32.PROPBAG2[],Vanara.PInvoke.OleAut32.VARIANT[])">
            <summary>Causes one or more properties to be saved into the property bag.</summary>
            <param name="cProperties">
            <para>[in]Type: <c>unsigned long</c></para>
            <para>The number of properties to save. This argument specifies the number of elements in the arrays at pPropBag and pvarValue.</para>
            </param>
            <param name="pPropBag">
            <para>[in]Type: <c>[</c> PROPBAG2 <c>](aa768188(v=vs.85).md)</c></para>
            <para>
            The address of an array of <c>PROPBAG2</c> structures that specify the properties saved. The <c>pstrName</c> member of these
            structures must be filled in before this method is called. The <c>dwHint</c> member of these structures is optional. There
            must be at least cProperties elements in this array. This argument cannot be NULL.
            </para>
            </param>
            <param name="pvarValue">
            <para>[in]Type: <c>VARIANT</c></para>
            <para>
            The address of an array of <c>VARIANT</c> structures that contain the property values to save. There must be at least
            cProperties elements in this array. This argument cannot be NULL.
            </para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag2.CountProperties">
            <summary>Gets the number of properties in the property bag.</summary>
            <returns>
            <para>[out]Type: <c>unsigned long</c></para>
            <para>The address of a <c>unsigned long</c> that receives the number of properties in the property bag.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag2.GetPropertyInfo(System.UInt32,System.UInt32,Vanara.PInvoke.OleAut32.PROPBAG2[],System.UInt32@)">
            <summary>Gets information for properties in a property bag without actually getting those properties.</summary>
            <param name="iProperty">
            <para>[in]Type: <c>unsigned long</c></para>
            <para>
            The zero-based index of the first property for which information is requested. This argument must be less than the number of
            properties retrieved by <c>IPropertyBag2::CountProperties</c>.
            </para>
            </param>
            <param name="cProperties">
            <para>[in]Type: <c>unsigned long</c></para>
            <para>The number of properties to get information for. This argument specifies the number of array elements in pPropBag.</para>
            </param>
            <param name="pPropBag">
            <para>[out]Type: <c>[</c> PROPBAG2 <c>](aa768188(v=vs.85).md)</c></para>
            <para>
            The address of an array of <c>PROPBAG2</c> structures that receive the information for the properties. There must be at
            least cProperties elements in this array. This argument cannot be NULL.
            </para>
            </param>
            <param name="pcProperties">
            <para>[out]Type: <c>unsigned long</c></para>
            <para>
            The address of a <c>unsigned long</c> that receives the number of properties for which information was retrieved. This
            argument cannot be NULL.
            </para>
            </param>
            <remarks>
            <para>When you implement this method, use CoTaskMemAlloc to allocate memory for the <c>pstrName</c> member of pPropBag.</para>
            <para>When you call this method, use CoTaskMemFree to free the <c>pstrName</c> member of pPropBag.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IPropertyBag2.LoadObject(System.String,System.UInt32,System.Object,Vanara.PInvoke.OleAut32.IErrorLog)">
            <summary>
            Causes the property bag to instruct a property object that was previously created and initialized to read its persistent properties.
            </summary>
            <param name="pstrName">
            <para>[in]Type: <c>LPCOLESTR</c></para>
            <para>The address of the name of the property object.</para>
            </param>
            <param name="dwHint">
            <para>[in]Type: <c>DWORD</c></para>
            <para>
            An integer value that was retrieved by using <c>IPropertyBag2::GetPropertyInfo</c>. This argument is optional and must be
            zero, if the value is not known or used.
            </para>
            </param>
            <param name="pUnkObject">
            <para>[in]Type: <c>IUnknown</c></para>
            <para>The address of the object's IUnknown interface. This argument cannot be NULL.</para>
            </param>
            <param name="pErrLog">
            <para>[in]Type: <c>IErrorLog</c></para>
            <para>
            The address of an <c>IErrorlog</c> interface in which the property bag stores any errors that occur during the load. This
            argument can be NULL; in which case, the caller does not receive logging errors.
            </para>
            </param>
            <remarks>
            <para>
            The <c>IPropertyBag2::LoadObject</c> method enables the calling application to participate in the creation and
            initialization of a property object. When the <c>IPropertyBag</c> interface is used, a property object can be loaded by
            using the <c>IPropertyBag::Read</c> method with <c>VT_UNKNOWN</c>. The <c>IPropertyBag</c> interface does not allow the
            property object to be initialized by the calling application before the property object reads its own persistent data.
            <c>IPropertyBag2::LoadObject</c> allows the property object to be created and initialized by the calling application,
            instead of using the property bag to create and initialize the property object.
            </para>
            <para>
            To use <c>IPropertyBag2::LoadObject</c>, get the property object's name and CLSID by using
            <c>IPropertyBag2::GetPropertyInfo</c>. The property object is created and initialized. <c>IPropertyBag2::LoadObject</c> is
            used instead of <c>IPropertyBag2::Read</c> to cause the property object to read its persistent data.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IRecordInfo">
            <summary>
            Describes the structure of a particular UDT. You can use IRecordInfo any time you need to access the description of UDTs
            contained in type libraries. IRecordInfo can be reused as needed; there can be many instances of the UDT for a single
            IRecordInfo pointer.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordInit(System.IntPtr)">
            <summary>
            <para>Initializes a new instance of a record.</para>
            </summary>
            <param name="pvNew">
            <para>An instance of a record.</para>
            </param>
            <remarks>
            <para>The caller must allocate the memory of the record by its appropriate size using the GetSize method.</para>
            <para><c>RecordInit</c> sets all contents of the record to 0 and the record should hold no resources.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordClear(System.IntPtr)">
            <summary>
            <para>Releases object references and other values of a record without deallocating the record.</para>
            </summary>
            <param name="pvExisting">
            <para>The record to be cleared.</para>
            </param>
            <remarks>
            <c>RecordClear</c> releases memory blocks held by VT_PTR or VT_SAFEARRAY instance fields. The caller needs to free the
            instance fields memory, <c>RecordClear</c> will do nothing if there are no resources held.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordCopy(System.IntPtr,System.IntPtr)">
            <summary>
            <para>Copies an existing record into the passed in buffer.</para>
            </summary>
            <param name="pvExisting">
            <para>The current record instance.</para>
            </param>
            <param name="pvNew">
            <para>The destination where the record will be copied.</para>
            </param>
            <remarks>
            <c>RecordCopy</c> will release the resources in the destination first. The caller is responsible for allocating sufficient
            memory in the destination by calling GetSize or RecordCreate. If <c>RecordCopy</c> fails to copy any of the fields then all
            fields will be cleared, as though RecordClear had been called.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetGuid">
            <summary>
            <para>Gets the GUID of the record type.</para>
            </summary>
            <returns>
            <para>The class GUID of the TypeInfo that describes the UDT.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetName">
            <summary>
            <para>
            Gets the name of the record type. This is useful if you want to print out the type of the record, because each UDT has it's
            own IRecordInfo.
            </para>
            </summary>
            <returns>
            <para>The name.</para>
            </returns>
            <remarks>
            <para>The caller must free the BSTR by calling SysFreeString.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetSize">
            <summary>
            <para>
            Gets the number of bytes of memory necessary to hold the record instance. This allows you to allocate memory for a record
            instance rather than calling RecordCreate.
            </para>
            </summary>
            <returns>
            <para>The size of a record instance, in bytes.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetTypeInfo(System.Type@)">
            <summary>Retrieves the type information that describes a UDT or safearray of UDTs.</summary>
            <param name="ppTypeInfo">The type information.</param>
            <remarks><c>AddRef</c> is called on the pointer ppTypeInfo.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetField(System.IntPtr,System.String)">
            <summary>
            <para>Returns a pointer to the VARIANT containing the value of a given field name.</para>
            </summary>
            <param name="pvData">
            <para>The instance of a record.</para>
            </param>
            <param name="szFieldName">
            <para>The field name.</para>
            </param>
            <returns>
            The VARIANT that you want to hold the value of the field name, szFieldName. On return, places a copy of the field's value in
            the variant.
            </returns>
            <remarks>
            <para>
            The VARIANT that you pass in contains a copy of the field's value upon return. If you modify the VARIANT then the underlying
            record field does not change.
            </para>
            <para>The caller allocates memory of the VARIANT.</para>
            <para>The method VariantClear is called for pvarField before copying.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetFieldNoCopy(System.IntPtr,System.String,System.Object@)">
            <summary>
            <para>Returns a pointer to the value of a given field name without copying the value and allocating resources.</para>
            </summary>
            <param name="pvData">
            <para>The instance of a record.</para>
            </param>
            <param name="szFieldName">
            <para>The name of the field.</para>
            </param>
            <param name="pvarField">
            <para>The VARIANT that will contain the UDT upon return.</para>
            </param>
            <returns>
            <para>Receives the value of the field upon return.</para>
            </returns>
            <remarks>
            <para>
            Upon return, the VARIANT you pass contains a direct pointer to the record's field, ppvDataCArray. If you modify the VARIANT,
            then the underlying record field will change.
            </para>
            <para>
            The caller allocates memory of the VARIANT, but does not own the memory so cannot free pvarField. This method calls
            VariantClear for pvarField before filling in the requested field.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.PutField(System.UInt32,System.IntPtr,System.String,System.Object@)">
            <summary>
            <para>Puts a variant into a field.</para>
            </summary>
            <param name="wFlags">
            <para>The only legal values for the wFlags parameter is INVOKE_PROPERTYPUT or INVOKE_PROPERTYPUTREF.</para>
            <para>
            If INVOKE_PROPERTYPUTREF is passed in then <c>PutField</c> just assigns the value of the variant that is passed in to the
            field using normal coercion rules.
            </para>
            <para>
            If INVOKE_PROPERTYPUT is passed in then specific rules apply. If the field is declared as a class that derives from
            IDispatch and the field's value is NULL then an error will be returned. If the field's value is not NULL then the variant
            will be passed to the default property supported by the object referenced by the field. If the field is not declared as a
            class derived from <c>IDispatch</c> then an error will be returned. If the field is declared as a variant of type
            VT_Dispatch then the default value of the object is assigned to the field. Otherwise, the variant's value is assigned to the field.
            </para>
            </param>
            <param name="pvData">
            <para>The pointer to an instance of the record.</para>
            </param>
            <param name="szFieldName">
            <para>The name of the field of the record.</para>
            </param>
            <param name="pvarField">
            <para>The pointer to the variant.</para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.PutFieldNoCopy(System.UInt32,System.IntPtr,System.String,System.Object@)">
            <summary>
            <para>
            Passes ownership of the data to the assigned field by placing the actual data into the field. <c>PutFieldNoCopy</c> is
            useful for saving resources because it allows you to place your data directly into a record field. <c>PutFieldNoCopy</c>
            differs from PutField because it does not copy the data referenced by the variant.
            </para>
            </summary>
            <param name="wFlags">
            <para>The only legal values for the wFlags parameter is INVOKE_PROPERTYPUT or INVOKE_PROPERTYPUTREF.</para>
            </param>
            <param name="pvData">
            <para>An instance of the record described by IRecordInfo.</para>
            </param>
            <param name="szFieldName">
            <para>The name of the field of the record.</para>
            </param>
            <param name="pvarField">
            <para>The variant to be put into the field.</para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.GetFieldNames(System.UInt32@,System.String[])">
            <summary>
            <para>Gets the names of the fields of the record.</para>
            </summary>
            <param name="pcNames">
            <para>The number of names to return.</para>
            </param>
            <param name="rgBstrNames">
            <para>The name of the array of type BSTR.</para>
            <para>If the rgBstrNames parameter is NULL, then pcNames is returned with the number of field names.</para>
            <para>
            It the rgBstrNames parameter is not NULL, then the string names contained in rgBstrNames are returned. If the number of
            names in pcNames and rgBstrNames are not equal then the lesser number of the two is the number of returned field names. The
            caller needs to free the BSTRs inside the array returned in rgBstrNames.
            </para>
            </param>
            <remarks>
            <para>
            The caller should allocate memory for the array of BSTRs. If the array is larger than needed, set the unused portion to 0.
            </para>
            <para>On return, the caller will need to free each contained BSTR using SysFreeString.</para>
            <para>In case of out of memory, pcNames points to error code.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.IsMatchingType(Vanara.PInvoke.OleAut32.IRecordInfo)">
            <summary>
            <para>Determines whether the record that is passed in matches that of the current record information.</para>
            </summary>
            <param name="pRecordInfo">
            <para>The information of the record.</para>
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>The record that is passed in matches the current record information.</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>The record that is passed in does not match the current record information.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordCreate">
            <summary>
            <para>Allocates memory for a new record, initializes the instance and returns a pointer to the record.</para>
            </summary>
            <returns>
            <para>This method returns a pointer to the created record.</para>
            </returns>
            <remarks>
            <para>The memory is set to zeros before it is returned.</para>
            <para>The records created must be freed by calling RecordDestroy.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordCreateCopy(System.IntPtr,System.IntPtr@)">
            <summary>
            <para>Creates a copy of an instance of a record to the specified location.</para>
            </summary>
            <param name="pvSource">
            <para>An instance of the record to be copied.</para>
            </param>
            <param name="ppvDest">
            <para>The new record with data copied from pvSource.</para>
            </param>
            <remarks>
            <para>The records created must be freed by calling RecordDestroy.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IRecordInfo.RecordDestroy(System.IntPtr)">
            <summary>
            <para>Releases the resources and deallocates the memory of the record.</para>
            </summary>
            <param name="pvRecord">
            <para>An instance of the record to be destroyed.</para>
            </param>
            <remarks>
            <para>RecordClear is called to release the resources held by the instance of a record without deallocating memory.</para>
            <para>
            <c>Note</c> This method can only be called on records allocated through RecordCreate and RecordCreateCopy. If you allocate
            the record yourself, you cannot call this method.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ISupportErrorInfo">
            <summary>
            Ensures that error information can be propagated up the call chain correctly. Automation objects that use the error handling
            interfaces must implement <c>ISupportErrorInfo</c>.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ISupportErrorInfo.InterfaceSupportsErrorInfo(System.Guid@)">
            <summary>Indicates whether an interface supports the IErrorInfo interface.</summary>
            <param name="riid">An interface identifier (IID).</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface supports IErrorInfo.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The interface does not support IErrorInfo.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Objects that support the IErrorInfo interface must also implement this interface.</para>
            <para>
            Programs that receive an error return value should call <c>QueryInterface</c> to get a pointer to the
            ISupportErrorInfointerface, and then call <c>InterfaceSupportsErrorInfo</c> with the riid of the interface that returned the
            return value. If <c>InterfaceSupportsErrorInfo</c> returns S_FALSE, then the error object does not represent an error
            returned from the caller, but from somewhere else. In this case, the error object can be considered incorrect and should be discarded.
            </para>
            <para>If ISupportErrorInfo returns S_OK, use the GetErrorInfo function to get a pointer to the error object.</para>
            <para>
            For an example that demonstrates implementing <c>InterfaceSupportsErrorInfo</c>, see the ErrorInfo.cpp file in the COM
            Fundamentals Lines sample.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ITypeChangeEvents">
            <summary>
            Enables clients to subscribe to type change notifications on objects that implement the ITypeInfo, ITypeInfo2, ICreateTypeInfo,
            and ICreateTypeInfo2 interfaces. When ITypeChangeEvents is implemented on an object, it acts as an incoming interface that
            enables the object to receive calls from external clients and engage in bidirectional communication with those clients. For more
            information, see Events in COM and Connectable Objects.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ITypeChangeEvents.RequestTypeChange(Vanara.PInvoke.OleAut32.CHANGEKIND,System.Runtime.InteropServices.ComTypes.ITypeInfo,System.String,System.Int32@)">
            <summary>Raised when a request has been made to change a type. The change can be disallowed.</summary>
            <param name="changeKind">
            <para>The type of change.</para>
            <para>CHANGEKIND_ADDMEMBER</para>
            <para>CHANGEKIND_DELETEMEMBER</para>
            <para>CHANGEKIND_SETNAMES</para>
            <para>CHANGEKIND_SETDOCUMENTATION</para>
            <para>CHANGEKIND_GENERAL</para>
            <para>CHANGEKIND_INVALIDATE</para>
            <para>CHANGEKIND_CHANGEFAILED</para>
            </param>
            <param name="pTInfoBefore">
            An object that implements the ITypeInfo, ITypeInfo2, ICreateTypeInfo, or ICreateTypeInfo2 interface and that contains the
            type information before the change was made. The client subscribes to this object to receive notifications about any changes.
            </param>
            <param name="pStrName">The name of the change. This value may be null.</param>
            <param name="pfCancel">False to disallow the change; otherwise, true.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ITypeChangeEvents.AfterTypeChange(Vanara.PInvoke.OleAut32.CHANGEKIND,System.Runtime.InteropServices.ComTypes.ITypeInfo,System.String)">
            <summary>Raised after a type has been changed.</summary>
            <param name="changeKind">
            <para>The type of change.</para>
            <para>CHANGEKIND_ADDMEMBER</para>
            <para>CHANGEKIND_DELETEMEMBER</para>
            <para>CHANGEKIND_SETNAMES</para>
            <para>CHANGEKIND_SETDOCUMENTATION</para>
            <para>CHANGEKIND_GENERAL</para>
            <para>CHANGEKIND_INVALIDATE</para>
            <para>CHANGEKIND_CHANGEFAILED</para>
            </param>
            <param name="pTInfoAfter">
            An object that implements the ITypeInfo, ITypeInfo2, ICreateTypeInfo, or ICreateTypeInfo2 interface and that contains the
            type information before the change was made. The client subscribes to this object to receive notifications about any changes.
            </param>
            <param name="pStrName">The name of the change. This value may be null.</param>
            <returns>
            <para>This method can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.VarChangeFlag">
            <summary>Flags used by <see cref="M:Vanara.PInvoke.OleAut32.VariantChangeType(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VarChangeFlag,Vanara.PInvoke.Ole32.VARTYPE)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VarChangeFlag.VARIANT_NOVALUEPROP">
            <summary>
            Prevents the function from attempting to coerce an object to a fundamental type by getting the Value property. Applications
            should set this flag only if necessary, because it makes their behavior inconsistent with other applications.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VarChangeFlag.VARIANT_ALPHABOOL">
            <summary>Converts a VT_BOOL value to a string containing either "True" or "False".</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VarChangeFlag.VARIANT_NOUSEROVERRIDE">
            <summary>For conversions to or from VT_BSTR, passes LOCALE_NOUSEROVERRIDE to the core coercion routines.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VarChangeFlag.VARIANT_LOCALBOOL">
            <summary>
            For conversions from VT_BOOL to VT_BSTR and back, uses the language specified by the locale in use on the local computer.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.VtBits">
            <summary>Bits for numeric VARTYPE values.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarAbs(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the absolute value of a variant.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarAdd(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the sum of two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings</term>
            <term>Concatenated</term>
            </item>
            <item>
            <term>One expression is a string and the other a character</term>
            <term>Addition</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Addition</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Addition</term>
            </item>
            <item>
            <term>Either expression is null</term>
            <term>Null</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>Integer</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarAnd(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs a bitwise And operation between two variants of any integral type.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>pvarLeft</term>
            <term>pvarRight</term>
            <term>pvarResult</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>FALSE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>TRUE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>FALSE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>NULL</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>TRUE</term>
            <term>NULL</term>
            </item>
            <item>
            <term>NULL</term>
            <term>FALSE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarBoolFromCy(System.Int64,System.Boolean@)">
            <summary>Converts a currency value to a Boolean value.</summary>
            <param name="cyIn">The value to convert.</param>
            <param name="pboolOut">The resulting value.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by the output parameter does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarBoolFromDate(System.Double,System.Boolean@)">
            <summary>Converts a date value to a Boolean value.</summary>
            <param name="dateIn">The value to convert.</param>
            <param name="pboolOut">The resulting value.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by the output parameter does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarBoolFromDec(System.Decimal@,System.Boolean@)">
            <summary>Converts a decimal value to a Boolean value.</summary>
            <param name="pdecIn">The value to convert.</param>
            <param name="pboolOut">The resulting value.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by the output parameter does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarBoolFromDisp(Vanara.PInvoke.OleAut32.IDispatch,Vanara.PInvoke.LCID,System.Boolean@)">
            <summary>Converts the default property of an IDispatch instance to a Boolean value.</summary>
            <param name="pdispIn">The value to convert.</param>
            <param name="lcid">The locale identifier.</param>
            <param name="pboolOut">The resulting value.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The input parameter is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by the output parameter does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarCat(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Concatenates two variants and returns the result.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings</term>
            <term>Concatenated</term>
            </item>
            <item>
            <term>Both expressions are null</term>
            <term>Null</term>
            </item>
            <item>
            <term>One expression is null and the other is not null</term>
            <term>The non-null type</term>
            </item>
            <item>
            <term>Either expression is a Boolean</term>
            <term>FALSE equal to 1 or TRUE equal to -1</term>
            </item>
            <item>
            <term>Either expression is VT_ERROR</term>
            <term>Null</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Concatenated and returned as a string</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Concatenated</term>
            </item>
            <item>
            <term>Either expression is a date</term>
            <term>Date</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>Empty string</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarCmp(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.LCID,System.UInt32)">
            <summary>Compares two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="lcid">The locale identifier.</param>
            <param name="dwFlags">
            <para>The compare results option.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NORM_IGNORECASE 0x00000001</term>
            <term>Ignore case.</term>
            </item>
            <item>
            <term>NORM_IGNORENONSPACE 0x00000002</term>
            <term>Ignore nonspace characters.</term>
            </item>
            <item>
            <term>NORM_IGNORESYMBOLS 0x00000004</term>
            <term>Ignore symbols.</term>
            </item>
            <item>
            <term>NORM_IGNOREWIDTH 0x00000008</term>
            <term>Ignore string width.</term>
            </item>
            <item>
            <term>NORM_IGNOREKANATYPE 0x00000040</term>
            <term>Ignore Kana type.</term>
            </item>
            <item>
            <term>NORM_IGNOREKASHIDA 0x00040000</term>
            <term>Ignore Arabic kashida characters.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code/value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>VARCMP_LT 0</term>
            <term>pvarLeft is less than pvarRight.</term>
            </item>
            <item>
            <term>VARCMP_EQ 1</term>
            <term>The parameters are equal.</term>
            </item>
            <item>
            <term>VARCMP_GT 2</term>
            <term>pvarLeft is greater than pvarRight.</term>
            </item>
            <item>
            <term>VARCMP_NULL 3</term>
            <term>Either expression is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The function only compares the value of the variant types. It compares strings, integers, and floating points, but not arrays or records.
            </para>
            <para>
            NORM_IGNOREWIDTH causes <c>VarCmp</c> to ignore the difference between half-width and full-width characters, as the following
            example demonstrates:
            </para>
            <para>"Ｃａｔ"== "cat"</para>
            <para>The full-width form is a formatting distinction used in Chinese and Japanese scripts.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarDiv(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the result from dividing two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings, dates, characters, or boolean values</term>
            <term>Double</term>
            </item>
            <item>
            <term>One expression is a string and the other a character</term>
            <term>Division and a double is returned</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Division and a double is returned</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Division and a double is returned</term>
            </item>
            <item>
            <term>Either expression is null</term>
            <term>Null</term>
            </item>
            <item>
            <term>pvarRight is empty and pvarLeft is not empty</term>
            <term>DISP_E_DIVBYZERO</term>
            </item>
            <item>
            <term>pvarLeft is empty and pvarRight is not empty</term>
            <term>0 as type double</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>DISP_E_OVERFLOW</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarEqv(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs a bitwise equivalence on two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            If each bit in pvarLeft is equal to the corresponding bit in pvarRight then TRUE is returned. Otherwise FALSE is returned.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarFix(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the integer portion of a variant.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>If the variant is negative, then the first negative integer greater than or equal to the variant is returned.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarFormat(Vanara.PInvoke.OleAut32.VARIANT@,System.String,System.Int32,System.Int32,Vanara.PInvoke.OleAut32.VarFlags,System.String@)">
            <summary>Formats a variant into string form by parsing a format string.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pstrFormat">The format string. For example "mm-dd-yy".</param>
            <param name="iFirstDay">
            <para>First day of the week.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The system default</term>
            </item>
            <item>
            <term>1</term>
            <term>Monday</term>
            </item>
            <item>
            <term>2</term>
            <term>Tuesday</term>
            </item>
            <item>
            <term>3</term>
            <term>Wednesday</term>
            </item>
            <item>
            <term>4</term>
            <term>Thursday</term>
            </item>
            <item>
            <term>5</term>
            <term>Friday</term>
            </item>
            <item>
            <term>6</term>
            <term>Saturday</term>
            </item>
            <item>
            <term>7</term>
            <term>Sunday</term>
            </item>
            </list>
            </param>
            <param name="iFirstWeek">
            <para>First week of the year.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The system default.</term>
            </item>
            <item>
            <term>1</term>
            <term>The first week contains January 1st.</term>
            </item>
            <item>
            <term>2</term>
            <term>The larger half (four days) of the first week is in the current year.</term>
            </item>
            <item>
            <term>3</term>
            <term>The first week has seven days.</term>
            </item>
            </list>
            </param>
            <param name="dwFlags">Flags that control the formatting process. The only flags that can be set are VAR_CALENDAR_HIJRI or VAR_FORMAT_NOSUBSTITUTE.</param>
            <param name="pbstrOut">The formatted string that represents the variant.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>This function uses the user's default locale while calling VarTokenizeFormatString and VarFormatFromTokens.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantChangeType(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VarChangeFlag,Vanara.PInvoke.Ole32.VARTYPE)">
            <summary>Converts a variant from one type to another.</summary>
            <param name="pvargDest">The destination variant. If this is the same as pvarSrc, the variant will be converted in place.</param>
            <param name="pvarSrc">The variant to convert.</param>
            <param name="wFlags">
            <para>Flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>VARIANT_NOVALUEPROP</term>
            <term>
            Prevents the function from attempting to coerce an object to a fundamental type by getting the Value property. Applications
            should set this flag only if necessary, because it makes their behavior inconsistent with other applications.
            </term>
            </item>
            <item>
            <term>VARIANT_ALPHABOOL</term>
            <term>Converts a VT_BOOL value to a string containing either "True" or "False".</term>
            </item>
            <item>
            <term>VARIANT_NOUSEROVERRIDE</term>
            <term>For conversions to or from VT_BSTR, passes LOCALE_NOUSEROVERRIDE to the core coercion routines.</term>
            </item>
            <item>
            <term>VARIANT_LOCALBOOL</term>
            <term>For conversions from VT_BOOL to VT_BSTR and back, uses the language specified by the locale in use on the local computer.</term>
            </item>
            </list>
            </param>
            <param name="vt">
            The type to convert to. If the return code is S_OK, the <c>vt</c> field of the *pvargDest is guaranteed to be equal to this value.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The variant type is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by pvarSrc does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>VariantChangeType</c> function handles coercions between the fundamental types (including numeric-to-string and
            string-to-numeric coercions). The pvarSrc argument is changed during the conversion process. For example, if the source variant
            is of type VT_BOOL and the destination is of type VT_UINT, the pvarSrc argument is first converted to VT_I2 and then the
            conversion proceeds. A variant that has VT_BYREF set is coerced to a value by obtaining the referenced value. An object is
            coerced to a value by invoking the object's <c>Value</c> property (DISPID_VALUE).
            </para>
            <para>
            Typically, the implementor of IDispatch::Invoke determines which member is being accessed, and then calls
            <c>VariantChangeType</c> to get the value of one or more arguments. For example, if the IDispatch call specifies a
            <c>SetTitle</c> member that takes one string argument, the implementor would call <c>VariantChangeType</c> to attempt to coerce
            the argument to VT_BSTR. If <c>VariantChangeType</c> does not return an error, the argument could then be obtained directly from
            the <c>bstrVal</c> field of the VARIANTARG. If <c>VariantChangeType</c> returns DISP_E_TYPEMISMATCH, the implementor would set
            *puArgErr to 0 (indicating the argument in error) and return DISP_E_TYPEMISMATCH from Invoke.
            </para>
            <para>Arrays of one type cannot be converted to arrays of another type with this function.</para>
            <para><c>Note</c> The type of a VARIANTARG should not be changed in the rgvarg array in place.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantChangeTypeEx(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.LCID,Vanara.PInvoke.OleAut32.VarChangeFlag,Vanara.PInvoke.Ole32.VARTYPE)">
            <summary>Converts a variant from one type to another, using an LCID.</summary>
            <param name="pvargDest">The destination variant. If this is the same as pvarSrc, the variant will be converted in place.</param>
            <param name="pvarSrc">The variant to convert.</param>
            <param name="lcid">
            The locale identifier. The LCID is useful when the type of the source or destination VARIANTARG is VT_BSTR, VT_DISPATCH, or VT_DATE.
            </param>
            <param name="wFlags">
            <para>Flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>VARIANT_NOVALUEPROP</term>
            <term>
            Prevents the function from attempting to coerce an object to a fundamental type by getting the Value property. Applications
            should set this flag only if necessary, because it makes their behavior inconsistent with other applications.
            </term>
            </item>
            <item>
            <term>VARIANT_ALPHABOOL</term>
            <term>Converts a VT_BOOL value to a string containing either "True" or "False".</term>
            </item>
            <item>
            <term>VARIANT_NOUSEROVERRIDE</term>
            <term>For conversions to or from VT_BSTR, passes LOCALE_NOUSEROVERRIDE to the core coercion routines.</term>
            </item>
            <item>
            <term>VARIANT_LOCALBOOL</term>
            <term>For conversions from VT_BOOL to VT_BSTR and back, uses the language specified by the locale in use on the local computer.</term>
            </item>
            </list>
            </param>
            <param name="vt">
            The type to convert to. If the return code is S_OK, the <c>vt</c> field of the *pvargDest is guaranteed to be equal to this value.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The variant type is not a valid type of variant.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The data pointed to by pvarSrc does not fit in the destination type.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>VariantChangeTypeEx</c> function handles coercions between the fundamental types (including numeric-to-string and
            string-to-numeric coercions). A variant that has VT_BYREF set is coerced to a value by obtaining the referenced value. An object
            is coerced to a value by invoking the object's <c>Value</c> property (DISPID_VALUE).
            </para>
            <para>
            Typically, the implementor of IDispatch::Invoke determines which member is being accessed, and then calls VariantChangeType to
            get the value of one or more arguments. For example, if the IDispatch call specifies a SetTitle member that takes one string
            argument, the implementor would call <c>VariantChangeTypeEx</c> to attempt to coerce the argument to VT_BSTR.
            </para>
            <para>
            If <c>VariantChangeTypeEx</c> does not return an error, the argument could then be obtained directly from the <c>bstrVal</c>
            field of the VARIANTARG. If <c>VariantChangeTypeEx</c> returns DISP_E_TYPEMISMATCH, the implementor would set *puArgErr to 0
            (indicating the argument in error) and return DISP_E_TYPEMISMATCH from IDispatch::Invoke.
            </para>
            <para>Arrays of one type cannot be converted to arrays of another type with this function.</para>
            <para><c>Note</c> The type of a VARIANTARG should not be changed in the rgvarg array in place.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantCopy(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Frees the destination variant and makes a copy of the source variant.</summary>
            <param name="pvargDest">The destination variant.</param>
            <param name="pvargSrc">The source variant.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The variant contains an array that is locked.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The variant type is not a valid type of variant.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            First, free any memory that is owned by pvargDest, such as VariantClear (pvargDest must point to a valid initialized variant,
            and not simply to an uninitialized memory location). Then pvargDest receives an exact copy of the contents of pvargSrc.
            </para>
            <para>
            If pvargSrc is a VT_BSTR, a copy of the string is made. If pvargSrcis a VT_ARRAY, the entire array is copied. If pvargSrc is a
            VT_DISPATCH or VT_UNKNOWN, <c>AddRef</c> is called to increment the object's reference count.
            </para>
            <para>
            If the variant to be copied is a COM object that is passed by reference, the vtfield of the pvargSrcparameter is VT_DISPATCH |
            VT_BYREF or VT_UNKNOWN | VT_BYREF. In this case, <c>VariantCopy</c> does not increment the reference count on the referenced
            object. Because the variant being copied is a pointer to a reference to an object, <c>VariantCopy</c> has no way to determine if
            it is necessary to increment the reference count of the object. It is therefore the responsibility of the caller to call
            <c>IUnknown::AddRef</c> on the object or not, as appropriate.
            </para>
            <para><c>Note</c> The <c>VariantCopy</c> method is not threadsafe.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantCopyInd(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>
            Frees the destination variant and makes a copy of the source variant, performing the necessary indirection if the source is
            specified to be VT_BYREF.
            </summary>
            <param name="pvarDest">The destination variant.</param>
            <param name="pvargSrc">The source variant.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The variant contains an array that is locked.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The variant type is not a valid type of variant.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is useful when a copy of a variant is needed, and to guarantee that it is not VT_BYREF, such as when handling
            arguments in an implementation of IDispatch::Invoke.
            </para>
            <para>
            For example, if the source is a (VT_BYREF | VT_I2), the destination will be a BYVAL | VT_I2. The same is true for all legal
            VT_BYREF combinations, including VT_VARIANT.
            </para>
            <para>If pvargSrc is (VT_BYREF | VT_VARIANT), and the contained variant is VT_BYREF, the contained variant is also dereferenced.</para>
            <para>This function frees any existing contents of pvarDest.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantInit(Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a variant.</summary>
            <param name="pvarg">The variant to initialize.</param>
            <returns>This function does not return a value.</returns>
            <remarks>
            <para>
            The <c>VariantInit</c> function initializes the VARIANTARG by setting the <c>vt</c> field to VT_EMPTY. Unlike VariantClear, this
            function does not interpret the current contents of the VARIANTARG. Use <c>VariantInit</c> to initialize new local variables of
            type VARIANTARG (or VARIANT).
            </para>
            <para>Examples</para>
            <para>The following example shows how to initialize an array of variants, where is the number of elements in the array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarIdiv(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Converts two variants of any type to integers then returns the result from dividing them.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings, dates, characters, or boolean values</term>
            <term>Division and an integer is returned</term>
            </item>
            <item>
            <term>One expression is a string and the other a character</term>
            <term>Division</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Division</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Division</term>
            </item>
            <item>
            <term>Either expression is null</term>
            <term>Null</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>DISP_E_DIVBYZERO</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarImp(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs a bitwise implication on two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>pvarLeft</term>
            <term>pvarRight</term>
            <term>pvarResult</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>FALSE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>NULL</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>FALSE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>NULL</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>FALSE</term>
            <term>NULL</term>
            </item>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            </list>
            <para>
            Because <c>VarImp</c> performs bitwise operations on pvarLeft and pvarRight instead of logical operations a pvarResult of TRUE
            is returned by this function call.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarInt(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the integer portion of a variant.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>If the variant is negative, then the first negative integer less than or equal to the variant is returned.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarMod(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Divides two variants and returns only the remainder.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarMonthName(System.Int32,System.Boolean,Vanara.PInvoke.OleAut32.VarFlags,System.String@)">
            <summary>Returns a string containing the localized month name.</summary>
            <param name="iMonth">Represents the month, as a number from 1 to 12.</param>
            <param name="fAbbrev">
            If zero then the full (non-abbreviated) month name is used. If non-zero, then the abbreviation for the month name is used.
            </param>
            <param name="dwFlags">VAR_CALENDAR_HIJRI is the only flag that can be set.</param>
            <param name="pbstrOut">Receives the formatted string that represents the variant.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarMul(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the result from multiplying two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings, dates, characters, or boolean values</term>
            <term>Multiplication</term>
            </item>
            <item>
            <term>One expression is a string and the other a character</term>
            <term>Multiplication</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Multiplication</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Multiplication</term>
            </item>
            <item>
            <term>Either expression is null</term>
            <term>Null</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>Empty string</term>
            </item>
            </list>
            <para>Boolean values are converted to -1 for FALSE and 0 for TRUE.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarNeg(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs logical negation on a variant.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarNot(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs the bitwise not negation operation on a variant.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>pvarIn</term>
            <term>pvarResult</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarNumFromParseNum(Vanara.PInvoke.OleAut32.NUMPARSE@,System.Byte[],Vanara.PInvoke.OleAut32.VtBits,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Converts parsed results to a variant.</summary>
            <param name="pnumprs">
            The parsed results. The <c>cDig</c> member of this argument specifies the number of digits present in rgbDig.
            </param>
            <param name="rgbDig">The values of the digits. The <c>cDig</c> field of pnumprs contains the number of digits.</param>
            <param name="dwVtBits">
            <para>One bit set for each type that is acceptable as a return value (in many cases, just one bit).</para>
            <para>VTBIT_I1</para>
            <para>VTBIT_UI1</para>
            <para>VTBIT_I2</para>
            <para>VTBIT_UI2</para>
            <para>VTBIT_I4</para>
            <para>VTBIT_UI4</para>
            <para>VTBIT_R4</para>
            <para>VTBIT_R8</para>
            <para>VTBIT_CY</para>
            <para>VTBIT_DECIMAL</para>
            </param>
            <param name="pvar">The variant result.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Out of memory.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The number is too large to be represented in an allowed type. There is no error if precision is lost in the conversion.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For rounding decimal numbers, the digit array must be at least one digit longer than the maximum required for data types. The
            maximum number of digits required for the DECIMAL data type is 29, so the digit array must have room for 30 digits. There must
            also be enough digits to accept the number in octal, if that parsing options is selected. (Hexadecimal and octal numbers are
            limited by <c>VarNumFromParseNum</c> to the magnitude of an unsigned long [32 bits], so they need 11 octal digits.)
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarOr(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs a logical disjunction on two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>pvarLeft</term>
            <term>pvarRight</term>
            <term>pvarResult</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>FALSE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>NULL</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>FALSE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            <item>
            <term>NULL</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>FALSE</term>
            <term>NULL</term>
            </item>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarParseNumFromStr(System.String,Vanara.PInvoke.LCID,Vanara.PInvoke.OleAut32.VarFlags,Vanara.PInvoke.OleAut32.NUMPARSE@,System.Byte[])">
            <summary>Parses a string, and creates a type-independent description of the number it represents.</summary>
            <param name="strIn">The input string to convert.</param>
            <param name="lcid">The locale identifier.</param>
            <param name="dwFlags">
            Enables the caller to control parsing, therefore defining the acceptable syntax of a number. If this field is set to zero, the
            input string must contain nothing but decimal digits. Setting each defined flag bit enables parsing of that syntactic feature.
            Standard Automation parsing (for example, as used by VarI2FromStr) has all flags set (NUMPRS_STD).
            </param>
            <param name="pnumprs">The parsed results.</param>
            <param name="rgbDig">
            The values for the digits in the range 0–7, 0–9, or 0–15, depending on whether the number is octal, decimal, or hexadecimal. All
            leading zeros have been stripped off. For decimal numbers, trailing zeros are also stripped off, unless the number is zero, in
            which case a single zero digit will be present.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Internal memory allocation failed. (Used for DBCS only to create a copy with all wide characters mapped narrow.)</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>
            There is no valid number in the string, or there is no closing parenthesis to match an opening one. In the former case, cDig and
            cchUsed in the NUMPARSE structure will be zero. In the latter, the NUMPARSE structure and digit array are fully updated, as if
            the closing parenthesis was present.
            </term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>
            For hexadecimal and octal digits, there are more digits than will fit into the array. For decimal, the exponent exceeds the
            maximum possible. In both cases, the NUMPARSE structure and digit array are fully updated (for decimal, the cchUsed field
            excludes the entire exponent).
            </term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarPow(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Returns the result of performing the power function with two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>Returns the result of pvarLeft to the power of pvarRight.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarRound(Vanara.PInvoke.OleAut32.VARIANT@,System.Int32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Rounds a variant to the specified number of decimal places.</summary>
            <param name="pvarIn">The variant.</param>
            <param name="cDecimals">The number of decimal places.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarSub(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Subtracts two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>Condition</term>
            <term>Result</term>
            </listheader>
            <item>
            <term>Both expressions are strings</term>
            <term>Subtraction</term>
            </item>
            <item>
            <term>One expression is a string and the other a character</term>
            <term>Subtraction</term>
            </item>
            <item>
            <term>One expression is numeric and the other a string</term>
            <term>Subtraction</term>
            </item>
            <item>
            <term>Both expressions are numeric</term>
            <term>Subtraction</term>
            </item>
            <item>
            <term>Either expression is null</term>
            <term>Null</term>
            </item>
            <item>
            <term>Both expressions are empty</term>
            <term>Empty string</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarTokenizeFormatString(System.String,System.Byte[],System.Int32,System.Int32,System.Int32,Vanara.PInvoke.LCID,System.IntPtr)">
            <summary>Parses the actual format string into a series of tokens which can be used to format variants using VarFormatFromTokens.</summary>
            <param name="pstrFormat">The format string. For example "mm-dd-yy".</param>
            <param name="rgbTok">The destination token buffer.</param>
            <param name="cbTok">The size of the destination token buffer.</param>
            <param name="iFirstDay">
            <para>First day of the week.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The system default</term>
            </item>
            <item>
            <term>1</term>
            <term>Monday</term>
            </item>
            <item>
            <term>2</term>
            <term>Tuesday</term>
            </item>
            <item>
            <term>3</term>
            <term>Wednesday</term>
            </item>
            <item>
            <term>4</term>
            <term>Thursday</term>
            </item>
            <item>
            <term>5</term>
            <term>Friday</term>
            </item>
            <item>
            <term>6</term>
            <term>Saturday</term>
            </item>
            <item>
            <term>7</term>
            <term>Sunday</term>
            </item>
            </list>
            </param>
            <param name="iFirstWeek">
            <para>First week of the year.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The system default.</term>
            </item>
            <item>
            <term>1</term>
            <term>The first week contains January 1st.</term>
            </item>
            <item>
            <term>2</term>
            <term>The larger half (four days) of the first week is in the current year.</term>
            </item>
            <item>
            <term>3</term>
            <term>The first week has seven days.</term>
            </item>
            </list>
            </param>
            <param name="lcid">The locale to interpret format string in.</param>
            <param name="pcbActual">Points to the integer which is set to the first generated token. This parameter can be NULL.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>DISP_E_BUFFERTOOSMALL</term>
            <term>The destination token buffer is too small.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Parsing the format string once and then using it repeatedly is usually faster than calling VarFormat repeatedly, because the
            latter routine calls <c>VarTokenizeFormatString</c> for each call.
            </para>
            <para>
            The locale you pass in controls how the format string is interpreted, not how the actual output of VarFormatFromTokens looks.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VarXor(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Performs a logical exclusion on two variants.</summary>
            <param name="pvarLeft">The first variant.</param>
            <param name="pvarRight">The second variant.</param>
            <param name="pvarResult">The result variant.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>The function operates as follows.</para>
            <list type="table">
            <listheader>
            <term>pvarLeft</term>
            <term>pvarRight</term>
            <term>pvarResult</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>TRUE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>TRUE</term>
            <term>FALSE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>TRUE</term>
            <term>TRUE</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>FALSE</term>
            <term>FALSE</term>
            </item>
            <item>
            <term>NULL</term>
            <term>NULL</term>
            <term>NULL</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.VARIANT">
            <summary>
            VARIANTARG describes arguments passed within DISPPARAMS, and VARIANT to specify variant data that cannot be passed by reference.
            <para>
            When a variant refers to another variant by using the VT_VARIANT | VT_BYREF vartype, the variant being referred to cannot also
            be of type VT_VARIANT | VT_BYREF.VARIANTs can be passed by value, even if VARIANTARGs cannot.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.vt">
            <summary>The type of data in the union.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.wReserved1">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.wReserved2">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.wReserved3">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.byref">
            <summary>A generic value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.VARIANT.decVal">
            <summary>A decimal value.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.DispInvokeFlags">
            <summary>Flags describing the context of the call.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.DispInvokeFlags.DISPATCH_METHOD">
            <summary>
            The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag can be set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.DispInvokeFlags.DISPATCH_PROPERTYGET">
            <summary>The member is retrieved as a property or data member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.DispInvokeFlags.DISPATCH_PROPERTYPUT">
            <summary>The member is changed as a property or data member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.DispInvokeFlags.DISPATCH_PROPERTYPUTREF">
            <summary>
            The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property
            accepts a reference to an object.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.REGKIND">
            <summary>Controls how a type library is registered.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.REGKIND.REGKIND_DEFAULT">
            <summary>Use default register behavior.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.REGKIND.REGKIND_REGISTER">
            <summary>Register this type library.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.REGKIND.REGKIND_NONE">
            <summary>Do not register this type library.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.BstrFromVector(Vanara.PInvoke.OleAut32.SAFEARRAY@,System.String@)">
            <summary>Returns a BSTR, assigning each element of the vector to a character in the BSTR.</summary>
            <param name="psa">The vector to be converted to a BSTR.</param>
            <param name="pbstr">A BSTR, each character of which is assigned to an element from the vector.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Out of memory.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The psa parameter is null.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument psa is not a vector (not an array of bytes).</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.ClearCustData(Vanara.PInvoke.OleAut32.CUSTDATA@)">
            <summary>Releases memory used to hold the custom data item.</summary>
            <param name="pCustData">The custom data item to be released.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.CreateDispTypeInfo(Vanara.PInvoke.OleAut32.INTERFACEDATA@,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.ITypeInfo@)">
            <summary>Creates simplified type information for use in an implementation of IDispatch.</summary>
            <param name="pidata">The interface description that this type information describes.</param>
            <param name="lcid">The locale identifier for the names used in the type information.</param>
            <param name="pptinfo">On return, pointer to a type information implementation for use in DispGetIDsOfNames and DispInvoke.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface is supported.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>Either the interface description or the LCID is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You can construct type information at run time by using <c>CreateDispTypeInfo</c> and an INTERFACEDATA structure that describes
            the object being exposed.
            </para>
            <para>
            The type information returned by this function is primarily designed to automate the implementation of IDispatch.
            <c>CreateDispTypeInfo</c> does not return all of the type information described in Type Description Interfaces. The argument
            pidata is not a complete description of an interface. It does not include Help information, comments, optional parameters, and
            other type information that is useful in different contexts.
            </para>
            <para>
            Accordingly, the recommended method for providing type information about an object is to describe the object using the Object
            Description Language (ODL), and to compile the object description into a type library using the Microsoft Interface Definition
            Language (MIDL) compiler.
            </para>
            <para>
            To use type information from a type library, use the LoadTypeLib and GetTypeInfoOfGuid functions instead of
            <c>CreateDispTypeInfo</c>. For more information Type Description Interfaces.
            </para>
            <para>Examples</para>
            <para>The code that follows creates type information from INTERFACEDATA to expose the CCalc object.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.CreateErrorInfo(Vanara.PInvoke.OleAut32.ICreateErrorInfo@)">
            <summary>Creates an instance of a generic error object.</summary>
            <param name="pperrinfo">A system-implemented generic error object.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Could not create the error object.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This function returns a pointer to a generic error object, which you can use with <c>QueryInterface</c> on ICreateErrorInfo to
            set its contents. You can then pass the resulting object to SetErrorInfo. The generic error object implements both
            <c>ICreateErrorInfo</c> and IErrorInfo.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.CreateStdDispatch(System.Object,System.IntPtr,System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Object@)">
            <summary>
            Creates a standard implementation of the IDispatch interface through a single function call. This simplifies exposing objects
            through Automation.
            </summary>
            <param name="punkOuter">The object's <c>IUnknown</c> implementation.</param>
            <param name="pvThis">The object to expose.</param>
            <param name="ptinfo">The type information that describes the exposed object.</param>
            <param name="ppunkStdDisp">
            The private unknown for the object that implements the IDispatch interface QueryInterface call. This pointer is null if the
            function fails.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the first three arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>There was insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You can use <c>CreateStdDispatch</c> when creating an object instead of implementing the IDispatch member functions for the
            object. However, the implementation that <c>CreateStdDispatch</c> creates has these limitations:
            </para>
            <list type="bullet">
            <item>
            <term>Supports only one national language.</term>
            </item>
            <item>
            <term>Supports only dispatch-defined exception codes returned from Invoke.</term>
            </item>
            </list>
            <para>
            LoadTypeLib, GetTypeInfoOfGuid, and <c>CreateStdDispatch</c> comprise the minimum set of functions that you need to call to
            expose an object using a type library. For more information on <c>LoadTypeLib</c> and <c>GetTypeInfoOfGuid</c>, see Type
            Description Interfaces.
            </para>
            <para>
            CreateDispTypeInfo and <c>CreateStdDispatch</c> comprise the minimum set of dispatch components you need to call to expose an
            object using type information provided by the INTERFACEDATA structure.
            </para>
            <para>Examples</para>
            <para>The following code implements the <c>IDispatch</c> interface for the <c>CCalc</c> class using <c>CreateStdDispatch</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.CreateTypeLib(System.Runtime.InteropServices.ComTypes.SYSKIND,System.String,Vanara.PInvoke.OleAut32.ICreateTypeLib@)">
            <summary>Provides access to a new object instance that supports the ICreateTypeLib interface.</summary>
            <param name="syskind">The target operating system for which to create a type library.</param>
            <param name="szFile">The name of the file to create.</param>
            <param name="ppctlib">The ICreateTypeLib interface.</param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not create the file.</term>
            </item>
            </list>
            <para>This method can also return the FACILITY_STORAGE errors.</para>
            </returns>
            <remarks>
            <c>CreateTypeLib</c> sets its output parameter (ppctlib) to point to a newly created object that supports the ICreateTypeLib interface.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.CreateTypeLib2(System.Runtime.InteropServices.ComTypes.SYSKIND,System.String,Vanara.PInvoke.OleAut32.ICreateTypeLib2@)">
            <summary>
            <para>Creates a type library in the current file format.</para>
            <para>
            The file and in-memory format for the current version of Automation makes use of memory-mapped files. The CreateTypeLib function
            is still available for creating a type library in the older format.
            </para>
            </summary>
            <param name="syskind">The target operating system for which to create a type library.</param>
            <param name="szFile">The name of the file to create.</param>
            <param name="ppctlib">The ICreateTypeLib2 interface.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DispCallFunc(System.IntPtr,System.UIntPtr,Vanara.PInvoke.OleAut32.CALLCONV,Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.Ole32.VARTYPE[],System.IntPtr[],System.Object@)">
            <summary>Low-level helper for Invoke that provides machine independence for customized <c>Invoke</c>.</summary>
            <param name="pvInstance">An instance of the interface described by this type description.</param>
            <param name="oVft">For FUNC_VIRTUAL functions, specifies the offset in the VTBL.</param>
            <param name="cc">The calling convention. One of the CALLCONV values, such as CC_STDCALL.</param>
            <param name="vtReturn">The variant type of the function return value. Use VT_EMPTY to represent void.</param>
            <param name="cActuals">The number of function parameters.</param>
            <param name="prgvt">An array of variant types of the function parameters.</param>
            <param name="prgpvarg">The function parameters.</param>
            <param name="pvargResult">The function result.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DispGetIDsOfNames(System.Runtime.InteropServices.ComTypes.ITypeInfo,System.String[],System.UInt32,System.Int32[])">
            <summary>Low-level helper for Invoke that provides machine independence for customized <c>Invoke</c>.</summary>
            <param name="ptinfo">
            The type information for an interface. This type information is specific to one interface and language code, so it is not
            necessary to pass an interface identifier (IID) or LCID to this function.
            </param>
            <param name="rgszNames">
            An array of name strings that can be the same array passed to DispInvoke in the DISPPARAMS structure. If cNames is greater than
            1, the first name is interpreted as a method name, and subsequent names are interpreted as parameters to that method.
            </param>
            <param name="cNames">The number of elements in rgszNames.</param>
            <param name="rgdispid">
            An array of DISPIDs to be filled in by this function. The first ID corresponds to the method name. Subsequent IDs are
            interpreted as parameters to the method.
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface is supported.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is not valid.</term>
            </item>
            <item>
            <term>DISP_E_UNKNOWNNAME</term>
            <term>
            One or more of the specified names were not known. The returned array of DISPIDs contains DISPID_UNKNOWN for each entry that
            corresponds to an unknown name.
            </term>
            </item>
            </list>
            <para>Any of the <c>ITypeInfo::Invoke</c> errors can also be returned.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DispGetParam(System.Runtime.InteropServices.ComTypes.DISPPARAMS@,System.UInt32,Vanara.PInvoke.Ole32.VARTYPE,System.Object@,System.UInt32@)">
            <summary>
            Retrieves a parameter from the DISPPARAMS structure, checking both named parameters and positional parameters, and coerces the
            parameter to the specified type.
            </summary>
            <param name="pdispparams">The parameters passed to Invoke.</param>
            <param name="position">
            The position of the parameter in the parameter list. <c>DispGetParam</c> starts at the end of the array, so if position is 0,
            the last parameter in the array is returned.
            </param>
            <param name="vtTarg">The type the argument should be coerced to.</param>
            <param name="pvarResult">the variant to pass the parameter into.</param>
            <param name="puArgErr">
            On return, the index of the argument that caused a DISP_E_TYPEMISMATCH error. This pointer is returned to Invoke to indicate the
            position of the argument in DISPPARAMS that caused the error.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>The variant type vtTarg is not supported.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>The retrieved parameter could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTFOUND</term>
            <term>The parameter indicated by position could not be found.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>The argument could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The output parameter pvarResult must be a valid variant. Any existing contents are released in the standard way. The contents of
            the variant are freed with <c>VariantFree</c>.
            </para>
            <para>
            If you have used <c>DispGetParam</c> to get the right side of a property put operation, the second parameter should be
            DISPID_PROPERTYPUT. For example:
            </para>
            <para>Named parameters cannot be accessed positionally, and vice versa.</para>
            <para>Examples</para>
            <para>The following example uses <c>DispGetParam</c> to set X and Y properties.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DispInvoke(System.IntPtr,System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Int32,Vanara.PInvoke.OleAut32.DispInvokeFlags,System.Runtime.InteropServices.ComTypes.DISPPARAMS@,System.Object@,System.IntPtr,System.UInt32@)">
            <summary>
            Automatically calls member functions on an interface, given the type information for the interface. You can describe an
            interface with type information and implement Invoke for the interface using this single call.
            </summary>
            <param name="_this">An implementation of the IDispatch interface described by ptinfo.</param>
            <param name="ptinfo">The type information that describes the interface.</param>
            <param name="dispidMember">The member to be invoked. Use GetIDsOfNames or the object's documentation to obtain the DISPID.</param>
            <param name="wFlags">
            <para>Flags describing the context of the Invoke call.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DISPATCH_METHOD</term>
            <term>
            The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag can be set.
            </term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYGET</term>
            <term>The member is retrieved as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUT</term>
            <term>The member is changed as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUTREF</term>
            <term>
            The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property
            accepts a reference to an object.
            </term>
            </item>
            </list>
            </param>
            <param name="pparams">
            Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for number
            of elements in the arrays.
            </param>
            <param name="pvarResult">
            Pointer to where the result is to be stored, or Null if the caller expects no result. This argument is ignored if
            DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.
            </param>
            <param name="pexcepinfo">
            Pointer to a structure containing exception information. This structure should be filled in if DISP_E_EXCEPTION is returned.
            </param>
            <param name="puArgErr">
            The index within rgvarg of the first argument that has an error. Arguments are stored in pdispparams-&gt;rgvarg in reverse
            order, so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting
            return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND.
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADPARAMCOUNT</term>
            <term>The number of elements provided to DISPPARAMS is different from the number of arguments accepted by the method or property.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>One of the arguments in DISPPARAMS is not a valid variant type.</term>
            </item>
            <item>
            <term>DISP_E_EXCEPTION</term>
            <term>The application needs to raise an exception. In this case, the structure passed in pexcepinfo should be filled in.</term>
            </item>
            <item>
            <term>DISP_E_MEMBERNOTFOUND</term>
            <term>The requested member does not exist.</term>
            </item>
            <item>
            <term>DISP_E_NONAMEDARGS</term>
            <term>This implementation of IDispatch does not support named arguments.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>One of the arguments in DISPPARAMS could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTFOUND</term>
            <term>
            One of the parameter IDs does not correspond to a parameter on the method. In this case, puArgErr is set to the first argument
            that contains the error.
            </term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTOPTIONAL</term>
            <term>A required parameter was omitted.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>
            One or more of the arguments could not be coerced. The index of the first parameter with the incorrect type within rgvarg is
            returned in puArgErr.
            </term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            <para>Any of the <c>ITypeInfo::Invoke</c> errors can also be returned.</para>
            </returns>
            <remarks>
            <para>
            The parameter _this is a pointer to an implementation of the interface that is being deferred to. <c>DispInvoke</c> builds a
            stack frame, coerces parameters using standard coercion rules, pushes them on the stack, and then calls the correct member
            function in the VTBL.
            </para>
            <para>Examples</para>
            <para>
            The following code from the Lines sample file Lines.cpp implements Invoke using <c>DispInvoke</c>. This implementation relies on
            <c>DispInvoke</c> to validate input arguments. To help minimize security risks, include code that performs more robust
            validation of the input arguments.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DispInvoke(System.IntPtr,System.Runtime.InteropServices.ComTypes.ITypeInfo,System.Int32,Vanara.PInvoke.OleAut32.DispInvokeFlags,System.Runtime.InteropServices.ComTypes.DISPPARAMS@,System.IntPtr,System.IntPtr,System.UInt32@)">
            <summary>
            Automatically calls member functions on an interface, given the type information for the interface. You can describe an
            interface with type information and implement Invoke for the interface using this single call.
            </summary>
            <param name="_this">An implementation of the IDispatch interface described by ptinfo.</param>
            <param name="ptinfo">The type information that describes the interface.</param>
            <param name="dispidMember">The member to be invoked. Use GetIDsOfNames or the object's documentation to obtain the DISPID.</param>
            <param name="wFlags">
            <para>Flags describing the context of the Invoke call.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DISPATCH_METHOD</term>
            <term>
            The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag can be set.
            </term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYGET</term>
            <term>The member is retrieved as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUT</term>
            <term>The member is changed as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUTREF</term>
            <term>
            The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property
            accepts a reference to an object.
            </term>
            </item>
            </list>
            </param>
            <param name="pparams">
            Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for number
            of elements in the arrays.
            </param>
            <param name="pvarResult">
            Pointer to where the result is to be stored, or Null if the caller expects no result. This argument is ignored if
            DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYPUTREF is specified.
            </param>
            <param name="pexcepinfo">
            Pointer to a structure containing exception information. This structure should be filled in if DISP_E_EXCEPTION is returned.
            </param>
            <param name="puArgErr">
            The index within rgvarg of the first argument that has an error. Arguments are stored in pdispparams-&gt;rgvarg in reverse
            order, so the first argument is the one with the highest index in the array. This parameter is returned only when the resulting
            return value is DISP_E_TYPEMISMATCH or DISP_E_PARAMNOTFOUND.
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADPARAMCOUNT</term>
            <term>The number of elements provided to DISPPARAMS is different from the number of arguments accepted by the method or property.</term>
            </item>
            <item>
            <term>DISP_E_BADVARTYPE</term>
            <term>One of the arguments in DISPPARAMS is not a valid variant type.</term>
            </item>
            <item>
            <term>DISP_E_EXCEPTION</term>
            <term>The application needs to raise an exception. In this case, the structure passed in pexcepinfo should be filled in.</term>
            </item>
            <item>
            <term>DISP_E_MEMBERNOTFOUND</term>
            <term>The requested member does not exist.</term>
            </item>
            <item>
            <term>DISP_E_NONAMEDARGS</term>
            <term>This implementation of IDispatch does not support named arguments.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>One of the arguments in DISPPARAMS could not be coerced to the specified type.</term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTFOUND</term>
            <term>
            One of the parameter IDs does not correspond to a parameter on the method. In this case, puArgErr is set to the first argument
            that contains the error.
            </term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTOPTIONAL</term>
            <term>A required parameter was omitted.</term>
            </item>
            <item>
            <term>DISP_E_TYPEMISMATCH</term>
            <term>
            One or more of the arguments could not be coerced. The index of the first parameter with the incorrect type within rgvarg is
            returned in puArgErr.
            </term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the parameters is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            <para>Any of the <c>ITypeInfo::Invoke</c> errors can also be returned.</para>
            </returns>
            <remarks>
            <para>
            The parameter _this is a pointer to an implementation of the interface that is being deferred to. <c>DispInvoke</c> builds a
            stack frame, coerces parameters using standard coercion rules, pushes them on the stack, and then calls the correct member
            function in the VTBL.
            </para>
            <para>Examples</para>
            <para>
            The following code from the Lines sample file Lines.cpp implements Invoke using <c>DispInvoke</c>. This implementation relies on
            <c>DispInvoke</c> to validate input arguments. To help minimize security risks, include code that performs more robust
            validation of the input arguments.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.DosDateTimeToVariantTime(System.UInt16,System.UInt16,System.Double@)">
            <summary>Converts the MS-DOS representation of time to the date and time representation stored in a variant.</summary>
            <param name="wDosDate">
            The MS-DOS date to convert. The valid range of MS-DOS dates is January 1, 1980, to December 31, 2099, inclusive.
            </param>
            <param name="wDosTime">The MS-DOS time to convert.</param>
            <param name="pvtime">The converted time.</param>
            <returns>The function returns TRUE on success and FALSE otherwise.</returns>
            <remarks>
            <para>MS-DOS records file dates and times as packed 16-bit values. An MS-DOS date has the following format.</para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Contents</term>
            </listheader>
            <item>
            <term>0–4</term>
            <term>Day of the month (1–31).</term>
            </item>
            <item>
            <term>5–8</term>
            <term>Month (1 = January, 2 = February, and so on).</term>
            </item>
            <item>
            <term>9–15</term>
            <term>Year offset from 1980 (add 1980 to get the actual year).</term>
            </item>
            </list>
            <para>An MS-DOS time has the following format.</para>
            <list type="table">
            <listheader>
            <term>Bits</term>
            <term>Contents</term>
            </listheader>
            <item>
            <term>0–4</term>
            <term>Second divided by 2.</term>
            </item>
            <item>
            <term>5–10</term>
            <term>Minute (0–59).</term>
            </item>
            <item>
            <term>11–15</term>
            <term>Hour (0– 23 on a 24-hour clock).</term>
            </item>
            </list>
            <para>
            The <c>DosDateTimeToVariantTime</c> function will accept invalid dates and try to fix them when resolving to a VARIANT time. For
            example, an invalid date such as 2/29/2001 will resolve to 3/1/2001. Only days are fixed, so invalid month values result in an
            error being returned. Days are checked to be between 1 and 31. Negative days and days greater than 31 results in an error. A day
            less than 31 but greater than the maximum day in that month has the day promoted to the appropriate day of the next month. A day
            equal to zero resolves as the last day of the previous month. For example, an invalid dates such as 2/0/2001 will resolve to 1/31/2001.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.GetActiveObject(System.Guid@,System.IntPtr,System.Object@)">
            <summary>Retrieves a pointer to a running object that has been registered with OLE.</summary>
            <param name="rclsid">The class identifier (CLSID) of the active object from the OLE registration database.</param>
            <param name="pvReserved">Reserved for future use. Must be null.</param>
            <param name="ppunk">The requested active object.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.GetAltMonthNames(Vanara.PInvoke.LCID,System.String[]@)">
            <summary>Retrieves the secondary (alternate) month names.</summary>
            <param name="lcid">The locale identifier to be used in retrieving the alternate month names.</param>
            <param name="prgp">An array of pointers to strings containing the alternate month names.</param>
            <returns>The function returns TRUE on success and FALSE otherwise.</returns>
            <remarks>Useful for Hijri, Polish and Russian alternate month names.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.GetErrorInfo(System.UInt32,Vanara.PInvoke.OleAut32.IErrorInfo@)">
            <summary>Obtains the error information pointer set by the previous call to SetErrorInfo in the current logical thread.</summary>
            <param name="dwReserved">Reserved for future use. Must be zero.</param>
            <param name="pperrinfo">An error object.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>There was no error object to return.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function returns a pointer to the most recently set IErrorInfo pointer in the current logical thread. It transfers
            ownership of the error object to the caller, and clears the error state for the thread.
            </para>
            <para>
            Making a COM call that goes through a proxy-stub will clear any existing error object for the calling thread. A called object
            should not make any such calls after calling SetErrorInfo and before returning. The caller should not make any such calls after
            the call returns and before calling <c>GetErrorInfo</c>. As a rule of thumb, an interface method should return as soon as
            possible after calling <c>SetErrorInfo</c>, and the caller should call <c>GetErrorInfo</c> as soon as possible after the call returns.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.GetRecordInfoFromGuids(System.Guid@,System.UInt32,System.UInt32,Vanara.PInvoke.LCID,System.Guid@,Vanara.PInvoke.OleAut32.IRecordInfo@)">
            <summary>
            Returns a pointer to the IRecordInfo interface for a UDT by passing the GUID of the type information without having to load the
            type library.
            </summary>
            <param name="rGuidTypeLib">The GUID of the type library containing the UDT.</param>
            <param name="uVerMajor">The major version number of the type library of the UDT.</param>
            <param name="uVerMinor">The minor version number of the type library of the UDT.</param>
            <param name="lcid">The locale ID of the caller.</param>
            <param name="rGuidTypeInfo">The GUID of the typeinfo that describes the UDT.</param>
            <param name="ppRecInfo">The IRecordInfo interface.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            A pointer to IRecordInfo can be serialized by writing out the GUIDs and version numbers and deserialized by loading the
            information and passing it to <c>GetRecordInfoFromGuids</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.GetRecordInfoFromTypeInfo(System.Runtime.InteropServices.ComTypes.ITypeInfo,Vanara.PInvoke.OleAut32.IRecordInfo@)">
            <summary>
            Returns a pointer to the IRecordInfo interface of the UDT by passing its type information. The given ITypeInfo interface is used
            to create a RecordInfo object.
            </summary>
            <param name="pTypeInfo">The type information of a record.</param>
            <param name="ppRecInfo">The IRecordInfo interface.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Out of memory.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>TYPE_E_UNSUPFORMAT</term>
            <term>The type is not an interface.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LHashValOfName(Vanara.PInvoke.LCID,System.String)">
            <summary>Computes a hash value for a name.</summary>
            <param name="lcid">The LCID for the string.</param>
            <param name="szName">The string whose hash value is to be computed.</param>
            <returns>A hash value that represents the passed-in name.</returns>
            <remarks>
            <para>
            This function is equivalent to LHashValOfNameSys. The header file OleAuto.h contains macros that define <c>LHashValOfName</c> as
            <c>LHashValOfNameSys</c>, with the target operating system (syskind) based on the build preprocessor flags.
            </para>
            <para>
            <c>LHashValOfName</c> computes a 32-bit hash value for a name that can be passed to ITypeComp::Bind, ITypeComp::BindType,
            ITypeLib::FindName, or ITypeLib::IsName. The returned hash value is independent of the case of the characters in szName, as long
            as the language of the name is one of the languages supported by the OLE National Language Specification API. Any two strings
            that match when a case-insensitive comparison is done using any language produce the same hash value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LHashValOfNameSys(System.Runtime.InteropServices.ComTypes.SYSKIND,Vanara.PInvoke.LCID,System.String)">
            <summary>Computes a hash value for a name.</summary>
            <param name="syskind">The SYSKIND of the target operating system.</param>
            <param name="lcid">The LCID for the string.</param>
            <param name="szName">The string whose hash value is to be computed.</param>
            <returns>A hash value that represents the passed-in name.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LHashValOfNameSysA(System.Runtime.InteropServices.ComTypes.SYSKIND,Vanara.PInvoke.LCID,System.String)">
            <summary>Computes a hash value for the specified name.</summary>
            <param name="syskind">The SYSKIND of the target operating system.</param>
            <param name="lcid">The LCID for the string.</param>
            <param name="szName">The string whose hash value is to be computed.</param>
            <returns>A hash value that represents the specified name.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LoadRegTypeLib(System.Guid@,System.UInt16,System.UInt16,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.ITypeLib@)">
            <summary>Uses registry information to load a type library.</summary>
            <param name="rguid">The GUID of the library.</param>
            <param name="wVerMajor">The major version of the library.</param>
            <param name="wVerMinor">The minor version of the library.</param>
            <param name="lcid">The national language code of the library.</param>
            <param name="pptlib">The loaded type library.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVDATAREAD</term>
            <term>The function could not read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_UNSUPFORMAT</term>
            <term>The type library has an older format.</term>
            </item>
            <item>
            <term>TYPE_E_UNKNOWNLCID</term>
            <term>The LCID could not be found in the OLE-supported DLLs.</term>
            </item>
            <item>
            <term>TYPE_E_CANTLOADLIBRARY</term>
            <term>The type library or DLL could not be loaded.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The function <c>LoadRegTypeLib</c> defers to LoadTypeLib to load the file.</para>
            <para>
            <c>LoadRegTypeLib</c> compares the requested version numbers against those found in the system registry, and takes one of the
            following actions:
            </para>
            <list type="bullet">
            <item>
            <term>
            If one of the registered libraries exactly matches both the requested major and minor version numbers, then that type library is loaded.
            </term>
            </item>
            <item>
            <term>
            If one or more registered type libraries exactly match the requested major version number, and has a greater minor version
            number than that requested, the one with the greatest minor version number is loaded.
            </term>
            </item>
            <item>
            <term>
            If none of the registered type libraries exactly match the requested major version number (or if none of those that do exactly
            match the major version number also have a minor version number greater than or equal to the requested minor version number),
            then <c>LoadRegTypeLib</c> returns an error.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LoadTypeLib(System.String,System.Runtime.InteropServices.ComTypes.ITypeLib@)">
            <summary>Loads and registers a type library.</summary>
            <param name="szFile">The name of the file from which the method should attempt to load a type library.</param>
            <param name="pptlib">The loaded type library.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVDATAREAD</term>
            <term>The function could not read from the file.</term>
            </item>
            <item>
            <term>TYPE_E_UNSUPFORMAT</term>
            <term>The type library has an older format.</term>
            </item>
            <item>
            <term>TYPE_E_UNKNOWNLCID</term>
            <term>The LCID could not be found in the OLE-supported DLLs.</term>
            </item>
            <item>
            <term>TYPE_E_CANTLOADLIBRARY</term>
            <term>The type library or DLL could not be loaded.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The function <c>LoadTypeLib</c> loads a type library (usually created with MkTypLib) that is stored in the specified file. If
            szFile specifies only a file name without any path, <c>LoadTypeLib</c> searches for the file and proceeds as follows:
            </para>
            <list type="bullet">
            <item>
            <term>If the file is a stand-alone type library implemented by Typelib.dll, the library is loaded directly.</term>
            </item>
            <item>
            <term>
            If the file is a DLL or an executable file, it is loaded. By default, the type library is extracted from the first resource of
            type ITypeLib. To load a different type of library resource, append an integer index to szFile. For example:
            </term>
            </item>
            <item>
            <term>
            If the file is none of the above, the file name is parsed into a moniker (an object that represents a file-based link source),
            and then bound to the moniker. This approach allows <c>LoadTypeLib</c> to be used on foreign type libraries, including in-memory
            type libraries. Foreign type libraries cannot reside in a DLL or an executable file. For more information on monikers, see the
            COM Programmer's Reference.
            </term>
            </item>
            </list>
            <para>
            If the type library is already loaded, <c>LoadTypeLib</c> increments the type library's reference count and returns a pointer to
            the type library.
            </para>
            <para>
            For backward compatibility, <c>LoadTypeLib</c> will register the type library if the path is not specified in the szFile
            parameter. <c>LoadTypeLib</c> will not register the type library if the path of the type library is specified. It is recommended
            that RegisterTypeLib be used to register a type library.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LoadTypeLibEx(System.String,Vanara.PInvoke.OleAut32.REGKIND,System.Runtime.InteropServices.ComTypes.ITypeLib@)">
            <summary>Loads a type library and (optionally) registers it in the system registry.</summary>
            <param name="szFile">The type library file.</param>
            <param name="regkind">
            Identifies the kind of registration to perform for the type library based on the following flags: DEFAULT, REGISTER and NONE.
            REGKIND_DEFAULT simply calls LoadTypeLib and registration occurs based on the LoadTypeLib registration rules. REGKIND_NONE calls
            <c>LoadTypeLib</c> without the registration process enabled. REGKIND_REGISTER calls <c>LoadTypeLib</c> followed by
            RegisterTypeLib, which registers the type library. To unregister the type library, use UnRegisterTypeLib.
            </param>
            <param name="pptlib">The type library.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_REGISTRYACCESS</term>
            <term>The system registration database could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_CANTLOADLIBRARY</term>
            <term>The type library or DLL could not be loaded.</term>
            </item>
            </list>
            </returns>
            <remarks>Enables programmers to specify whether or not the type library should be loaded.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OaBuildVersion">
            <summary>Retrieves the build version of OLE Automation.</summary>
            <returns>The build number.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OaEnablePerUserTLibRegistration">
            <summary>
            Enables the RegisterTypeLib function to override default registry mappings under Windows Vista Service Pack 1 (SP1), Windows
            Server 2008, and later operating system versions.
            </summary>
            <returns>This function does not return a value.</returns>
            <remarks>
            <para>
            Consider the following scenario: You are running an application on a computer that is running Windows Vista SP1 or later. In
            your application, you have overridden the HKEY_CLASSES_ROOT registry subtree and mapped it to another registry subtree. (For
            example, perhaps you mapped HKEY_CLASSES_ROOT to HKEY_CURRENT_USER.) You then attempt to register a type library by calling
            RegisterTypeLib, and you receive an "access denied" error message. Additionally, <c>RegisterTypeLib</c> returns the
            TYPE_E_REGISTRYACCESS (0x8002801c) value.
            </para>
            <para>This problem occurs if User Account Control (UAC) is enabled, and the application is running under a limited user account.</para>
            <para>You can resolve this problem in one of two ways:</para>
            <list type="bullet">
            <item>
            <term>
            Use the <c>OaEnablePerUserTLibRegistration</c> function. Before your application calls RegisterTypeLib, it should call
            <c>OaEnablePerUserTLibRegistration</c>. This enables <c>RegisterTypeLib</c> to accept the registry override mapping. The
            <c>OaEnablePerUserTLibRegistration</c> function is exported from the Oleaut32.dll file. You must reference this file by using
            run-time dynamic linking and the GetProcAddress function.
            </term>
            </item>
            <item>
            <term>
            Set the OAPERUSERTLIBREG environment variable. RegisterTypeLib will check the value of this variable. If the value of
            OAPERUSERTLIBREG is 1, <c>RegisterTypeLib</c> will use the appropriate override mapping. Because this environment variable is
            read during the initialization of the <c>DLLMain</c> function, you must set the variable before you run your application. To do
            this, run one of the following commands at a command prompt: <c>start cmd.exe /c "set OAPERUSERTLIBREG=1 &amp;&amp;</c>
            MyApp.exe <c>"</c>
            </term>
            </item>
            </list>
            <para>
            When using run-time dynamic linking it should be noted that the setting to enable per-user type library registration is a global
            setting in oleaut32.dll, so if oleaut32.dll is unloaded then this setting is lost.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.QueryPathOfRegTypeLib(System.Guid@,System.UInt16,System.UInt16,Vanara.PInvoke.LCID,System.String@)">
            <summary>Retrieves the path of a registered type library.</summary>
            <param name="guid">The GUID of the library.</param>
            <param name="wMaj">The major version number of the library.</param>
            <param name="wMin">The minor version number of the library.</param>
            <param name="lcid">The national language code for the library.</param>
            <param name="lpbstrPathName">The type library name.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            Returns the fully qualified file name that is specified for the type library in the registry. The caller allocates the BSTR that
            is passed in, and must free it after use.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.RegisterActiveObject(System.Object,System.Guid@,System.UInt32,System.UInt32@)">
            <summary>Registers an object as the active object for its class.</summary>
            <param name="punk">The active object.</param>
            <param name="rclsid">The CLSID of the active object.</param>
            <param name="dwFlags">Flags controlling registration of the object. Possible values are ACTIVEOBJECT_STRONG and ACTIVEOBJECT_WEAK.</param>
            <param name="pdwRegister">Receives a handle. This handle must be passed to RevokeActiveObject to end the object's active status.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            The <c>RegisterActiveObject</c> function registers the object to which punk points as the active object for the class denoted by
            rclsid. Registration causes the object to be listed in the running object table (ROT) of OLE, a globally accessible lookup table
            that keeps track of objects that are currently running on the computer. (For more information about the running object table,
            see the COM Programmer's Reference.) The dwFlags parameter specifies the strength or weakness of the registration, which affects
            the way the object is shut down.
            </para>
            <para>In general, ActiveX objects should behave in the following manner:</para>
            <list type="bullet">
            <item>
            <term>
            If the object is visible, it should shut down only in response to an explicit user command (such as the <c>Exit</c> command on
            the <c>File</c> menu), or to the equivalent command from an ActiveX client (invoking the <c>Quit</c> or <c>Exit</c> method on
            the Application object).
            </term>
            </item>
            <item>
            <term>If the object is not visible, it should shut down only when the last external connection to it is gone.</term>
            </item>
            </list>
            <para>
            Strong registration performs an <c>AddRef</c> on the object, incrementing the reference count of the object (and its associated
            stub) in the running object table. A strongly registered object must be explicitly revoked from the table with
            RevokeActiveObject. The default is strong registration (ACTIVEOBJECT_STRONG).
            </para>
            <para>
            Weak registration keeps a pointer to the object in the running object table, but does not increment the reference count.
            Consequently, when the last external connection to a weakly registered object disappears, OLE releases the object's stub, and
            the object itself is no longer available.
            </para>
            <para>To ensure the desired behavior, consider not only the default actions of OLE, but also the following:</para>
            <list type="bullet">
            <item>
            <term>
            Even though code can create an invisible object, the object may become visible at some later time. Once the object is visible,
            it should remain visible and active until it receives an explicit command to shut down. This can occur after references from the
            code disappear.
            </term>
            </item>
            <item>
            <term>Other ActiveX clients may be using the object. If so, the code should not force the object to shut down.</term>
            </item>
            </list>
            <para>
            To avoid possible conflicts, you should always register ActiveX objects with ACTIVEOBJECT_WEAK, and call
            <c>CoLockObjectExternal</c>, when necessary, to guarantee the object remains active. <c>CoLockObjectExternal</c> adds a strong
            lock, thereby preventing the object's reference count from reaching zero. For detailed information about this function, refer to
            the COM Programmer's Reference.
            </para>
            <para>
            Most commonly, objects need to call <c>CoLockObjectExternal</c> when they become visible, so they remain active until the user
            requests the object to shut down. The following procedure lists the steps your code should follow to shut down an object correctly.
            </para>
            <para><c>To shut down an active object:</c></para>
            <list type="number">
            <item>
            <term>When the object becomes visible, make the following call to add a lock for user:</term>
            </item>
            <item>
            <term>When the user requests the object to be shut down, call <c>CoLockObjectExternal</c> again to free the lock, as follows:</term>
            </item>
            <item>
            <term>Call <c>RevokeActiveObject</c> to make the object inactive.</term>
            </item>
            <item>
            <term>To end all connections from remote processes, call <c>CoDisconnectObject</c> as follows:</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.RegisterTypeLib(System.Runtime.InteropServices.ComTypes.ITypeLib,System.String,System.String)">
            <summary>Adds information about a type library to the system registry.</summary>
            <param name="ptlib">The type library.</param>
            <param name="szFullPath">The fully qualified path specification for the type library.</param>
            <param name="szHelpDir">
            The directory in which the Help file for the library being registered can be found. This parameter can be null.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_REGISTRYACCESS</term>
            <term>The system registration database could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function can be used during application initialization to register the application's type library correctly. When
            <c>RegisterTypeLib</c> is called to register a type library, both the minor and major version numbers are registered in hexadecimal.
            </para>
            <para>
            In addition to filling in a complete registry entry under the type library key, <c>RegisterTypeLib</c> adds entries for each of
            the dispinterfaces and Automation-compatible interfaces, including dual interfaces. This information is required to create
            instances of these interfaces. Coclasses are not registered (that is, <c>RegisterTypeLib</c> does not write any values to the
            CLSID key of the coclass).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.RegisterTypeLibForUser(System.Runtime.InteropServices.ComTypes.ITypeLib,System.String,System.String)">
            <summary>Registers a type library for use by the calling user.</summary>
            <param name="ptlib">The type library.</param>
            <param name="szFullPath">The fully qualified path specification for the type library.</param>
            <param name="szHelpDir">
            The directory in which the Help file for the library being registered can be found. This parameter can be null.
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_REGISTRYACCESS</term>
            <term>The system registration database could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <c>RegisterTypeLibForUser</c> has functionality identical to RegisterTypeLib except that type library is registered for use only
            by the calling user identity.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.RevokeActiveObject(System.UInt32,System.IntPtr)">
            <summary>Ends an object's status as active.</summary>
            <param name="dwRegister">A handle previously returned by RegisterActiveObject.</param>
            <param name="pvReserved">Reserved for future use. Must be null.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SetErrorInfo(System.UInt32,Vanara.PInvoke.OleAut32.IErrorInfo)">
            <summary>Sets the error information object for the current logical thread of execution.</summary>
            <param name="dwReserved">Reserved for future use. Must be zero.</param>
            <param name="perrinfo">An error object.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            <para>
            This function releases the existing error information object, if one exists, and sets the pointer to perrinfo. Use this function
            after creating an error object that associates the object with the current logical thread of execution.
            </para>
            <para>
            If the property or method that calls <c>SetErrorInfo</c> is called by DispInvoke, then <c>DispInvoke</c> will fill the EXCEPINFO
            parameter with the values specified in the error information object. <c>DispInvoke</c> will return DISP_E_EXCEPTION when the
            property or method returns a failure return value for <c>DispInvoke</c>
            </para>
            <para>
            Virtual function table (VTBL) binding controllers that do not use IDispatch::Invoke can get the error information object by
            using GetErrorInfo. This allows an object that supports a dual interface to use <c>SetErrorInfo</c>, regardless of whether the
            client uses VTBL binding or IDispatch.
            </para>
            <para>When a cross apartment call is made COM clears out any error object.</para>
            <para>
            Making a COM call that goes through a proxy-stub will clear any existing error object for the calling thread. A called object
            should not make any such calls after calling <c>SetErrorInfo</c> and before returning. The caller should not make any such calls
            after the call returns and before calling GetErrorInfo. As a rule of thumb, an interface method should return as soon as
            possible after calling <c>SetErrorInfo</c>, and the caller should call <c>GetErrorInfo</c> as soon as possible after the call returns.
            </para>
            <para>
            Entering the COM modal message loop will clear any existing error object. A called object should not enter a message loop after
            calling <c>SetErrorInfo</c>.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysAddRefString(Vanara.PInvoke.OleAut32.SafeBSTR)">
            <summary>
            The string for which the pinning reference count should increase. While that count remains greater than 0, the memory for the
            string is prevented from being freed by calls to the SysFreeString function.
            </summary>
            <param name="bstrString">
            The string for which the pinning reference count should increase. While that count remains greater than 0, the memory for the
            string is prevented from being freed by calls to the SysFreeString function.
            </param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
            <remarks>
            Strings with the <c>BSTR</c> data type have not traditionally had a reference count. All existing usage of these strings will
            continue to work with no changes. The <c>SysAddRefString</c> and SysReleaseString functions add the ability to use reference
            counting to pin the string into memory before calling from an untrusted script into an IDispatch method that may not expect the
            script to free that memory before the method returns, so that the script cannot force the code for that method into accessing
            memory that has been freed. After such a method safely returns, the pinning references should be released by calling <c>SysReleaseString</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysAllocString(System.String)">
            <summary>Allocates a new string and copies the passed string into it.</summary>
            <param name="psz">The string to copy.</param>
            <returns>
            If successful, returns the string. If psz is a zero-length string, returns a zero-length <c>BSTR</c>. If psz is NULL or
            insufficient memory exists, returns NULL.
            </returns>
            <remarks>You can free strings created with <c>SysAllocString</c> using SysFreeString.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysAllocStringByteLen(System.Byte[],System.UInt32)">
            <summary>
            Takes an ANSI string as input, and returns a BSTR that contains an ANSI string. Does not perform any ANSI-to-Unicode translation.
            </summary>
            <param name="psz">The string to copy, or NULL to keep the string uninitialized.</param>
            <param name="len">
            The number of bytes to copy. A null character is placed afterwards, allocating a total of len plus the size of <c>OLECHAR</c> bytes.
            </param>
            <returns>A copy of the string, or NULL if there is insufficient memory to complete the operation.</returns>
            <remarks>
            <para>
            This function is provided to create BSTRs that contain binary data. You can use this type of BSTR only in situations where it
            will not be translated from ANSI to Unicode, or vice versa.
            </para>
            <para>
            For example, do not use these BSTRs between a 16-bit and a 32-bit application running on a 32-bit Windows system. The OLE 16-bit
            to 32-bit (and 32-bit to 16-bit) interoperability layer will translate the BSTR and corrupt the binary data. The preferred
            method of passing binary data is to use a SAFEARRAY of VT_UI1, which will not be translated by OLE.
            </para>
            <para>
            If psz is Null, a string of the requested length is allocated, but not initialized. The string psz can contain embedded null
            characters, and does not need to end with a Null. Free the returned string later with SysFreeString.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysAllocStringLen(System.String,System.UInt32)">
            <summary>
            Allocates a new string, copies the specified number of characters from the passed string, and appends a null-terminating character.
            </summary>
            <param name="strIn">The input string.</param>
            <param name="ui">
            The number of characters to copy. A null character is placed afterwards, allocating a total of ui plus one characters.
            </param>
            <returns>A copy of the string, or <c>NULL</c> if there is insufficient memory to complete the operation.</returns>
            <remarks>
            <para>
            The string can contain embedded null characters and does not need to end with a <c>NULL</c>. Free the returned string later with
            SysFreeString. If strIn is not <c>NULL</c>, then the memory allocated to strIn must be at least ui characters long.
            </para>
            <para><c>Note</c> This function does not convert a <c>char *</c> string into a Unicode <c>BSTR</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysFreeString(System.IntPtr)">
            <summary>
            Deallocates a string allocated previously by SysAllocString, SysAllocStringByteLen, SysReAllocString, SysAllocStringLen, or SysReAllocStringLen.
            </summary>
            <param name="bstrString">The previously allocated string. If this parameter is <c>NULL</c>, the function simply returns.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysReAllocString(System.IntPtr,System.String)">
            <summary>
            Reallocates a previously allocated string to be the size of a second string and copies the second string into the reallocated memory.
            </summary>
            <param name="pbstr">The previously allocated string.</param>
            <param name="psz">The string to copy.</param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>The string is reallocated successfully.</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>Insufficient memory exists.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The address passed in psz cannot be part of the string passed in pbstr, or unexpected results may occur.</para>
            <para>
            If pbstr is NULL, there will be an access violation and the program will crash. It is your responsibility to protect this
            function against NULL pointers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysReAllocStringLen(System.IntPtr,System.String,System.UInt32)">
            <summary>Creates a new BSTR containing a specified number of characters from an old BSTR, and frees the old BSTR.</summary>
            <param name="pbstr">The previously allocated string.</param>
            <param name="psz">The string from which to copy len characters, or NULL to keep the string uninitialized.</param>
            <param name="len">
            The number of characters to copy. A null character is placed afterward, allocating a total of len plus one characters.
            </param>
            <returns>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TRUE</term>
            <term>The string is reallocated successfully.</term>
            </item>
            <item>
            <term>FALSE</term>
            <term>Insufficient memory exists.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Allocates a new string, copies len characters from the passed string into it, and then appends a null character. Frees the BSTR
            referenced currently by pbstr, and resets pbstr to point to the new BSTR. If psz is null, a string of length len is allocated
            but not initialized.
            </para>
            <para>The psz string can contain embedded null characters and does not need to end with a null.</para>
            <para>
            If this function is passed a NULL pointer, there will be an access violation and the program will crash. It is your
            responsibility to protect this function against NULL pointers.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysReleaseString(Vanara.PInvoke.OleAut32.SafeBSTR)">
            <summary>The string for which the pinning reference count should decrease.</summary>
            <param name="bstrString">The string for which the pinning reference count should decrease.</param>
            <returns>This function does not return a value.</returns>
            <remarks>A call to the <c>SysReleaseString</c> function should match every previous call to the SysAddRefString function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysStringByteLen(Vanara.PInvoke.OleAut32.SafeBSTR)">
            <summary>Returns the length (in bytes) of a BSTR.</summary>
            <param name="bstr">A previously allocated string.</param>
            <returns>The number of bytes in bstr, not including the terminating null character. If bstr is null the return value is zero.</returns>
            <remarks>
            The returned value may be different from <c>strlen</c>(bstr) if the BSTR contains embedded null characters. This function always
            returns the number of bytes specified in the len parameter of the SysAllocStringByteLen function used to allocate the BSTR.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SysStringLen(Vanara.PInvoke.OleAut32.SafeBSTR)">
            <summary>Returns the length of a BSTR.</summary>
            <param name="pbstr">A previously allocated string.</param>
            <returns>
            The number of characters in bstr, not including the terminating null character. If bstr is null the return value is zero.
            </returns>
            <remarks>
            The returned value may be different from <c>strlen</c>(bstr) if the BSTR contains embedded Null characters. This function always
            returns the number of characters specified in the cch parameter of the SysAllocStringLen function used to allocate the BSTR.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SystemTimeToVariantTime(Vanara.PInvoke.SYSTEMTIME@,System.Double@)">
            <summary>Converts a system time to a variant representation.</summary>
            <param name="lpSystemTime">The system time.</param>
            <param name="pvtime">The variant time.</param>
            <returns>The function returns TRUE on success and FALSE otherwise.</returns>
            <remarks>
            <para>
            A variant time is stored as an 8-byte real value ( <c>double</c>), representing a date between January 1, 100 and December 31,
            9999, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value
            increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on
            January 1, 1900; 3.25 represents 6:00 A.M. on January 2, 1900, and so on. Negative numbers represent dates prior to December 30, 1899.
            </para>
            <para>The variant time resolves to one second. Any milliseconds in the input date are ignored.</para>
            <para>The SYSTEMTIME structure is useful for the following reasons:</para>
            <list type="bullet">
            <item>
            <term>It spans all time/date periods. MS-DOS date/time is limited to representing only those dates between 1/1/1980 and 12/31/2107.</term>
            </item>
            <item>
            <term>The date/time elements are all easily accessible without needing to do any bit decoding.</term>
            </item>
            <item>
            <term>
            The National Data Support data and time formatting functions GetDateFormat and GetTimeFormat take an LPSYSTEMTIME value as input.
            </term>
            </item>
            <item>
            <term>It is the default time/date data format supported by Windows.</term>
            </item>
            </list>
            <para>
            The <c>SystemTimeToVariantTime</c> function will accept invalid dates and try to fix them when resolving to a VARIANT time. For
            example, an invalid date such as 2/29/2001 will resolve to 3/1/2001. Only days are fixed, so invalid month values result in an
            error being returned. Days are checked to be between 1 and 31. Negative days and days greater than 31 results in an error. A day
            less than 31 but greater than the maximum day in that month has the day promoted to the appropriate day of the next month. A day
            equal to zero resolves as the last day of the previous month. For example, an invalid dates such as 2/0/2001 will resolve to 1/31/2001.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.UnRegisterTypeLib(System.Guid@,System.UInt16,System.UInt16,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.SYSKIND)">
            <summary>
            Removes type library information from the system registry. Use this API to allow applications to properly uninstall themselves.
            </summary>
            <param name="libID">The GUID of the type library.</param>
            <param name="wVerMajor">The major version of the type library.</param>
            <param name="wVerMinor">The minor version of the type library.</param>
            <param name="lcid">The locale identifier.</param>
            <param name="syskind">The target operating system.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_REGISTRYACCESS</term>
            <term>The system registration database could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            </list>
            </returns>
            <remarks>In-process objects typically call this API from <c>DllUnregisterServer</c>.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.UnRegisterTypeLibForUser(System.Guid@,System.UInt16,System.UInt16,Vanara.PInvoke.LCID,System.Runtime.InteropServices.ComTypes.SYSKIND)">
            <summary>Removes type library information that was registered by using RegisterTypeLibForUser.</summary>
            <param name="libID">The GUID of the library.</param>
            <param name="wMajorVerNum">The major version of the type library.</param>
            <param name="wMinorVerNum">The minor version of the type library.</param>
            <param name="lcid">The locale identifier.</param>
            <param name="syskind">The target operating system.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            <item>
            <term>TYPE_E_IOERROR</term>
            <term>The function could not write to the file.</term>
            </item>
            <item>
            <term>TYPE_E_REGISTRYACCESS</term>
            <term>The system registration database could not be opened.</term>
            </item>
            <item>
            <term>TYPE_E_INVALIDSTATE</term>
            <term>The type library could not be opened.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Use <c>UnRegisterTypeLibForUser</c> to remove type library information for type libraries that were registered using the
            RegisterTypeLibForUser function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantClear(System.IntPtr)">
            <summary>Clears a variant.</summary>
            <param name="pvarg">The variant to clear.</param>
            <returns>S_OK on success.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantTimeToDosDateTime(System.Double,System.UInt16@,System.UInt16@)">
            <summary>Converts the variant representation of a date and time to MS-DOS date and time values.</summary>
            <param name="vtime">The variant time to convert.</param>
            <param name="pwDosDate">Receives the converted MS-DOS date.</param>
            <param name="pwDosTime">Receives the converted MS-DOS time</param>
            <returns>The function returns TRUE on success and FALSE otherwise.</returns>
            <remarks>
            <para>
            A variant time is stored as an 8-byte real value ( <c>double</c>), representing a date between January 1, 100 and December 31,
            9999, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value
            increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on
            January 1, 1900; 3.25 represents 6:00 A.M. on January 2, 1900, and so on. Negative numbers represent the dates prior to December
            30, 1899.
            </para>
            <para>For a description of the MS-DOS date and time formats, see DosDateTimeToVariantTime.</para>
            <para>
            The <c>VariantTimeToDosDateTime</c> function will accept invalid dates and try to fix them when resolving to a VARIANT time. For
            example, an invalid date such as 2/29/2001 will resolve to 3/1/2001. Only days are fixed, so invalid month values result in an
            error being returned. Days are checked to be between 1 and 31. Negative days and days greater than 31 results in an error. A day
            less than 31 but greater than the maximum day in that month has the day promoted to the appropriate day of the next month. A day
            equal to zero resolves as the last day of the previous month. For example, an invalid dates such as 2/0/2001 will resolve to 1/31/2001.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VariantTimeToSystemTime(System.Double,Vanara.PInvoke.SYSTEMTIME@)">
            <summary>Converts the variant representation of time to system time values.</summary>
            <param name="vtime">The variant time to convert.</param>
            <param name="lpSystemTime">Receives the system time.</param>
            <returns>The function returns TRUE on success and FALSE otherwise.</returns>
            <remarks>
            <para>
            A variant time is stored as an 8-byte real value ( <c>double</c>), representing a date between January 1, 100 and December 31,
            9999, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value
            increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on
            January 1, 1900; 3.25 represents 6:00 A.M. on January 2, 1900, and so on. Negative numbers represent the dates prior to December
            30, 1899.
            </para>
            <para>Using the SYSTEMTIME structure is useful because:</para>
            <list type="bullet">
            <item>
            <term>It spans all time/date periods. MS-DOS date/time is limited to representing only those dates between 1/1/1980 and 12/31/2107.</term>
            </item>
            <item>
            <term>The date/time elements are all easily accessible without needing to do any bit decoding.</term>
            </item>
            <item>
            <term>
            The National Language Support data and time formatting functions <c>GetDateFormat</c> and <c>GetTimeFormat</c> take a SYSTEMTIME
            value as input.
            </term>
            </item>
            <item>
            <term>It is the default Win32 time and date data format supported by Windows NT and Windows 95.</term>
            </item>
            </list>
            <para>
            The <c>VariantTimeToSystemTime</c> function will accept invalid dates and try to fix them when resolving to a VARIANT time. For
            example, an invalid date such as 2/29/2001 will resolve to 3/1/2001. Only days are fixed, so invalid month values result in an
            error being returned. Days are checked to be between 1 and 31. Negative days and days greater than 31 results in an error. A day
            less than 31 but greater than the maximum day in that month has the day promoted to the appropriate day of the next month. A day
            equal to zero resolves as the last day of the previous month. For example, an invalid dates such as 2/0/2001 will resolve to 1/31/2001.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.VectorFromBstr(Vanara.PInvoke.OleAut32.SafeBSTR,Vanara.PInvoke.OleAut32.SafeSAFEARRAY@)">
            <summary>Returns a vector, assigning each character in the BSTR to an element of the vector.</summary>
            <param name="bstr">The BSTR to be converted to a vector.</param>
            <param name="ppsa">A one-dimensional safearray containing the characters in the BSTR.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Out of memory.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The bstr parameter is null.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.INTERFACEDATA">
            <summary>Describes the object's properties and methods.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.INTERFACEDATA.pmethdata">
            <summary>An array of METHODDATA structures.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.INTERFACEDATA.cMembers">
            <summary>The count of members.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.METHODDATA">
            <summary>Describes a method or property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.szName">
            <summary>The method name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.ppdata">
            <summary>An array of method parameters.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.dispid">
            <summary>The ID of the method, as used in IDispatch.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.iMeth">
            <summary>The index of the method in the VTBL of the interface, starting with 0.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.cc">
            <summary>
            The calling convention. The CDECL and Pascal calling conventions are supported by the dispatch interface creation functions,
            such as CreateStdDispatch.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.cArgs">
            <summary>The number of arguments.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.wFlags">
            <summary>
            <para>Invoke flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DISPATCH_METHOD</term>
            <term>
            The member is invoked as a method. If a property has the same name, both this and the DISPATCH_PROPERTYGET flag can be set.
            </term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYGET</term>
            <term>The member is retrieved as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUT</term>
            <term>The member is set as a property or data member.</term>
            </item>
            <item>
            <term>DISPATCH_PROPERTYPUTREF</term>
            <term>
            The member is changed by a reference assignment, rather than a value assignment. This flag is valid only when the property
            accepts a reference to an object.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.METHODDATA.vtReturn">
            <summary>The return type for the method.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.NUMPARSE">
            <summary>Specifies numeric parsing information.</summary>
            <remarks>
            <para>The following apply only to decimal numbers:</para>
            <list type="bullet">
            <item>
            <term><c>nPwr10</c> sets the decimal point position by giving the power of 10 of the least significant digit.</term>
            </item>
            <item>
            <term>If the number is negative, <c>NUMPRS_NEG</c> will be set in <c>dwOutFlags</c>.</term>
            </item>
            <item>
            <term>If there are more non-zero decimal digits than will fit into the digit array, the NUMPRS_INEXACT flag will be set.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.cDig">
            <summary>On input, the size of the array. On output, the number of items written to the rgbDig array.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.dwInFlags">
            <summary>
            <para>Input flags.</para>
            <para>NUMPRS_CURRENCY (0x0400)</para>
            <para>NUMPRS_DECIMAL (0x0100)</para>
            <para>NUMPRS_EXPONENT (0x0800)</para>
            <para>NUMPRS_HEX_OCT (0x0040)</para>
            <para>NUMPRS_LEADING_MINUS (0x0100)</para>
            <para>NUMPRS_LEADING_PLUS (0x0004)</para>
            <para>NUMPRS_LEADING_WHITE (0x0001)</para>
            <para>NUMPRS_PARENS (0x0080)</para>
            <para>NUMPRS_STD (0x1FFF)</para>
            <para>NUMPRS_THOUSANDS (0x0200)</para>
            <para>NUMPRS_TRAILING_MINUS (0x0020)</para>
            <para>NUMPRS_TRAILING_PLUS (0x0008)</para>
            <para>NUMPRS_TRAILING_WHITE (0x0002)</para>
            <para>NUMPRS_USE_ALL (0x1000)</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.dwOutFlags">
            <summary>
            <para>Output flags. Includes all the values for <c>dwInFlags</c>, plus the following values.</para>
            <para>NUMPRS_INEXACT (0x20000)</para>
            <para>NUMPRS_NEG (0x10000)</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.cchUsed">
            <summary>Receives the number of characters (from the beginning of the string) that were successfully parsed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.nBaseShift">
            <summary>The number of bits per digit (3 or 4 for octal and hexadecimal numbers, and zero for decimal).</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.NUMPARSE.nPwr10">
            <summary>The decimal point position.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PARAMDATA">
            <summary>Describes a parameter accepted by a method or property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PARAMDATA.szName">
            <summary>
            The parameter name. Names should follow standard conventions for programming language access; that is, no embedded spaces or
            control characters, and 32 or fewer characters. The name should be localized because each type description provides names
            for a particular locale.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PARAMDATA.vt">
            <summary>The parameter type. If more than one parameter type is accepted, VT_VARIANT should be specified.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SafeBSTR">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for a BSTR that is disposed using <see cref="M:Vanara.PInvoke.OleAut32.SysFreeString(System.IntPtr)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeBSTR"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeBSTR"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.OleAut32.SafeBSTR.Length">
            <summary>Gets the length of the string.</summary>
            <value>The length in characters.</value>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.op_Implicit(System.String)~Vanara.PInvoke.OleAut32.SafeBSTR">
            <summary>Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Vanara.PInvoke.OleAut32.SafeBSTR"/>.</summary>
            <param name="s">The string value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.op_Implicit(Vanara.PInvoke.OleAut32.SafeBSTR)~System.String">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.OleAut32.SafeBSTR"/> to <see cref="T:System.String"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.ReAlloc(System.String)">
            <summary>
            Reallocates a previously allocated string to be the size of a second string and copies the second string into the
            reallocated memory.
            </summary>
            <param name="value">The string to copy.</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeBSTR.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS">
            <summary>SafeArray advanced features.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_AUTO">
            <summary>An array that is allocated on the stack.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_STATIC">
            <summary>An array that is statically allocated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_EMBEDDED">
            <summary>An array that is embedded in a structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_FIXEDSIZE">
            <summary>An array that may not be resized or reallocated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_RECORD">
            <summary>
            An array that contains records. When set, there will be a pointer to the IRecordInfo interface at negative offset 4 in the
            array descriptor.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_HAVEIID">
            <summary>
            An array that has an IID identifying interface. When set, there will be a GUID at negative offset 16 in the safe array
            descriptor. Flag is set only when FADF_DISPATCH or FADF_UNKNOWN is also set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_HAVEVARTYPE">
            <summary>An array that has a variant type. The variant type can be retrieved with SafeArrayGetVartype.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_BSTR">
            <summary>An array of BSTRs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_UNKNOWN">
            <summary>An array of IUnknown*.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_DISPATCH">
            <summary>An array of IDispatch*.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.ADVFEATUREFLAGS.FADF_VARIANT">
            <summary>An array of VARIANTs.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayAccessData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.IntPtr@)">
            <summary>
            <para>Increments the lock count of an array, and retrieves a pointer to the array data.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="ppvData">
            <para>The array data.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>After calling <c>SafeArrayAccessData</c>, you must call the SafeArrayUnaccessData function to unlock the array.</para>
            <para>Examples</para>
            <para>
            The following example sorts a safe array of one dimension that contains BSTRs by accessing the array elements directly. This
            approach is faster than using SafeArrayGetElement and SafeArrayPutElement.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayAddRef(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.IntPtr@)">
            <summary>
            <para>
            The safe array for which the pinning reference count of the descriptor should increase. While that count remains greater than 0,
            the memory for the descriptor is prevented from being freed by calls to the SafeArrayDestroy or SafeArrayDestroyDescriptor functions.
            </para>
            <para>
            Returns the safe array data for which a pinning reference was added, if <c>SafeArrayAddRef</c> also added a pinning reference for
            the safe array data. This parameter is NULL if <c>SafeArrayAddRef</c> did not add a pinning reference for the safe array data.
            <c>SafeArrayAddRef</c> does not add a pinning reference for the safe array data if that safe array data was not dynamically allocated.
            </para>
            </summary>
            <param name="psa">
            <para>
            The safe array for which the pinning reference count of the descriptor should increase. While that count remains greater than 0,
            the memory for the descriptor is prevented from being freed by calls to the SafeArrayDestroy or SafeArrayDestroyDescriptor functions.
            </para>
            </param>
            <param name="ppDataToRelease">
            <para>
            Returns the safe array data for which a pinning reference was added, if <c>SafeArrayAddRef</c> also added a pinning reference for
            the safe array data. This parameter is NULL if <c>SafeArrayAddRef</c> did not add a pinning reference for the safe array data.
            <c>SafeArrayAddRef</c> does not add a pinning reference for the safe array data if that safe array data was not dynamically allocated.
            </para>
            </param>
            <returns>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Safe arrays have not traditionally had a reference count. All existing usage of safe arrays will continue to work with no
            changes. The <c>SafeArrayAddRef</c>, SafeArrayReleaseData, SafeArrayReleaseDescriptor functions add the ability to use reference
            counting to pin the safe array into memory before calling from an untrusted script into an IDispatch method that may not expect
            the script to free that memory before the method returns, so that the script cannot force the code for that method into accessing
            memory that has been freed. After such a method safely returns, the pinning references should be released. You can release the
            pinning references by calling the following functions:
            </para>
            <list type="bullet">
            <item>
            <term>SafeArrayReleaseData, for the data that the ppDataToRelease parameter points to, if it is not null.</term>
            </item>
            <item>
            <term>SafeArrayReleaseDescriptor, for the descriptor that the psa parameter specifies.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayAllocData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Allocates memory for a safe array, based on a descriptor created with SafeArrayAllocDescriptor.</para>
            </summary>
            <param name="psa">
            <para>A safe array descriptor created by SafeArrayAllocDescriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayAllocDescriptor(System.UInt32,Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY@)">
            <summary>
            <para>Allocates memory for a safe array descriptor.</para>
            </summary>
            <param name="cDims">
            <para>The number of dimensions of the array.</para>
            </param>
            <param name="ppsaOut">
            <para>The safe array descriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function allows the creation of safe arrays that contain elements with data types other than those provided by
            SafeArrayCreate. After creating an array descriptor using <c>SafeArrayAllocDescriptor</c>, set the element size in the array
            descriptor, an call SafeArrayAllocData to allocate memory for the array elements.
            </para>
            <para>Examples</para>
            <para>The following example creates a safe array using the <c>SafeArrayAllocDescriptor</c> and SafeArrayAllocData functions.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayAllocDescriptorEx(Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY@)">
            <summary>
            <para>
            Creates a safe array descriptor for an array of any valid variant type, including VT_RECORD, without allocating the array data.
            </para>
            </summary>
            <param name="vt">
            <para>The variant type.</para>
            </param>
            <param name="cDims">
            <para>The number of dimensions in the array.</para>
            </param>
            <param name="ppsaOut">
            <para>The safe array descriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Because SafeArrayAllocDescriptor does not take a VARTYPE, it is not possible to use it to create the safe array descriptor for an
            array of records. The <c>SafeArrayAllocDescriptorEx</c> is used to allocate a safe array descriptor for an array of records of
            the given dimensions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCopy(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.OleAut32.SafeSAFEARRAY@)">
            <summary>
            <para>Creates a copy of an existing safe array.</para>
            </summary>
            <param name="psa">
            <para>A safe array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="ppsaOut">
            <para>The safe array descriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>SafeArrayCopy</c> calls the string or variant manipulation functions if the array to copy contains either of these data types.
            If the array being copied contains object references, the reference counts for the objects are incremented.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCopyData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>
            Copies the source array to the specified target array after releasing any resources in the target array. This is similar to
            SafeArrayCopy, except that the target array has to be set up by the caller. The target is not allocated or reallocated.
            </para>
            </summary>
            <param name="psaSource">
            <para>The safe array to copy.</para>
            </param>
            <param name="psaTarget">
            <para>The target safe array.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory to complete the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreate(Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.OleAut32.SAFEARRAYBOUND@)">
            <summary>
            <para>
            Creates a new array descriptor, allocates and initializes the data for the array, and returns a pointer to the new array descriptor.
            </para>
            </summary>
            <param name="vt">
            <para>
            The base type of the array (the VARTYPE of each element of the array). The VARTYPE is restricted to a subset of the variant
            types. Neither the VT_ARRAY nor the VT_BYREF flag can be set. VT_EMPTY and VT_NULL are not valid base types for the array. All
            other types are legal.
            </para>
            </param>
            <param name="cDims">
            <para>The number of dimensions in the array. The number cannot be changed after the array is created.</para>
            </param>
            <param name="rgsabound">
            <para>A vector of bounds (one for each dimension) to allocate for the array.</para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateEx(Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.OleAut32.SAFEARRAYBOUND@,System.IntPtr)">
            <summary>
            <para>Creates and returns a safe array descriptor from the specified VARTYPE, number of dimensions and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type or the VARTYPE of each element of the array. The FADF_RECORD flag can be set for a variant type VT_RECORD, The
            FADF_HAVEIID flag can be set for VT_DISPATCH or VT_UNKNOWN, and FADF_HAVEVARTYPE can be set for all other VARTYPEs.
            </para>
            </param>
            <param name="cDims">
            <para>The number of dimensions in the array.</para>
            </param>
            <param name="rgsabound">
            <para>A vector of bounds (one for each dimension) to allocate for the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            the type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
            <remarks>
            <para>
            If the VARTYPE is VT_RECORD then SafeArraySetRecordInfo is called. If the VARTYPE is VT_DISPATCH or VT_UNKNOWN then the elements
            of the array must contain interfaces of the same type. Part of the process of marshaling this array to other processes does
            include generating the proxy/stub code of the IID pointed to by the pvExtra parameter. To actually pass heterogeneous interfaces
            one will need to specify either IID_IUnknown or IID_IDispatch in pvExtra and provide some other means for the caller to identify
            how to query for the actual interface.
            </para>
            <para>Examples</para>
            <para>The following example describes how a safe array of user-defined types is stored into a variant of type VT_RECORD.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateEx(Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.OleAut32.SAFEARRAYBOUND@,Vanara.PInvoke.OleAut32.IRecordInfo)">
            <summary>
            <para>Creates and returns a safe array descriptor from the specified VARTYPE, number of dimensions and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type or the VARTYPE of each element of the array. The FADF_RECORD flag can be set for a variant type VT_RECORD, The
            FADF_HAVEIID flag can be set for VT_DISPATCH or VT_UNKNOWN, and FADF_HAVEVARTYPE can be set for all other VARTYPEs.
            </para>
            </param>
            <param name="cDims">
            <para>The number of dimensions in the array.</para>
            </param>
            <param name="rgsabound">
            <para>A vector of bounds (one for each dimension) to allocate for the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            the type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
            <remarks>
            <para>
            If the VARTYPE is VT_RECORD then SafeArraySetRecordInfo is called. If the VARTYPE is VT_DISPATCH or VT_UNKNOWN then the elements
            of the array must contain interfaces of the same type. Part of the process of marshaling this array to other processes does
            include generating the proxy/stub code of the IID pointed to by the pvExtra parameter. To actually pass heterogeneous interfaces
            one will need to specify either IID_IUnknown or IID_IDispatch in pvExtra and provide some other means for the caller to identify
            how to query for the actual interface.
            </para>
            <para>Examples</para>
            <para>The following example describes how a safe array of user-defined types is stored into a variant of type VT_RECORD.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateEx(Vanara.PInvoke.Ole32.VARTYPE,System.UInt32,Vanara.PInvoke.OleAut32.SAFEARRAYBOUND@,System.Guid@)">
            <summary>
            <para>Creates and returns a safe array descriptor from the specified VARTYPE, number of dimensions and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type or the VARTYPE of each element of the array. The FADF_RECORD flag can be set for a variant type VT_RECORD, The
            FADF_HAVEIID flag can be set for VT_DISPATCH or VT_UNKNOWN, and FADF_HAVEVARTYPE can be set for all other VARTYPEs.
            </para>
            </param>
            <param name="cDims">
            <para>The number of dimensions in the array.</para>
            </param>
            <param name="rgsabound">
            <para>A vector of bounds (one for each dimension) to allocate for the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            the type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
            <remarks>
            <para>
            If the VARTYPE is VT_RECORD then SafeArraySetRecordInfo is called. If the VARTYPE is VT_DISPATCH or VT_UNKNOWN then the elements
            of the array must contain interfaces of the same type. Part of the process of marshaling this array to other processes does
            include generating the proxy/stub code of the IID pointed to by the pvExtra parameter. To actually pass heterogeneous interfaces
            one will need to specify either IID_IUnknown or IID_IDispatch in pvExtra and provide some other means for the caller to identify
            how to query for the actual interface.
            </para>
            <para>Examples</para>
            <para>The following example describes how a safe array of user-defined types is stored into a variant of type VT_RECORD.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateVector(Vanara.PInvoke.Ole32.VARTYPE,System.Int32,System.UInt32)">
            <summary>
            <para>
            Creates a one-dimensional array. A safe array created with <c>SafeArrayCreateVector</c> is a fixed size, so the constant
            FADF_FIXEDSIZE is always set.
            </para>
            </summary>
            <param name="vt">
            <para>
            The base type of the array (the VARTYPE of each element of the array). The VARTYPE is restricted to a subset of the variant
            types. Neither the VT_ARRAY nor the VT_BYREF flag can be set. VT_EMPTY and VT_NULL are not valid base types for the array. All
            other types are legal.
            </para>
            </param>
            <param name="lLbound">
            <para>The lower bound for the array. This parameter can be negative.</para>
            </param>
            <param name="cElements">
            <para>The number of elements in the array.</para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateVectorEx(Vanara.PInvoke.Ole32.VARTYPE,System.Int32,System.UInt32,System.IntPtr)">
            <summary>
            <para>Creates and returns a one-dimensional safe array of the specified VARTYPE and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type of the array (the VARTYPE of each element of the array). The FADF_RECORD flag can be set for VT_RECORD. The
            FADF_HAVEIID can be set for VT_DISPATCH or VT_UNKNOWN and FADF_HAVEVARTYPE can be set for all other types.
            </para>
            </param>
            <param name="lLbound">
            <para>The lower bound for the array. This parameter can be negative.</para>
            </param>
            <param name="cElements">
            <para>The number of elements in the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            The type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateVectorEx(Vanara.PInvoke.Ole32.VARTYPE,System.Int32,System.UInt32,Vanara.PInvoke.OleAut32.IRecordInfo)">
            <summary>
            <para>Creates and returns a one-dimensional safe array of the specified VARTYPE and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type of the array (the VARTYPE of each element of the array). The FADF_RECORD flag can be set for VT_RECORD. The
            FADF_HAVEIID can be set for VT_DISPATCH or VT_UNKNOWN and FADF_HAVEVARTYPE can be set for all other types.
            </para>
            </param>
            <param name="lLbound">
            <para>The lower bound for the array. This parameter can be negative.</para>
            </param>
            <param name="cElements">
            <para>The number of elements in the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            The type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayCreateVectorEx(Vanara.PInvoke.Ole32.VARTYPE,System.Int32,System.UInt32,System.Guid@)">
            <summary>
            <para>Creates and returns a one-dimensional safe array of the specified VARTYPE and bounds.</para>
            </summary>
            <param name="vt">
            <para>
            The base type of the array (the VARTYPE of each element of the array). The FADF_RECORD flag can be set for VT_RECORD. The
            FADF_HAVEIID can be set for VT_DISPATCH or VT_UNKNOWN and FADF_HAVEVARTYPE can be set for all other types.
            </para>
            </param>
            <param name="lLbound">
            <para>The lower bound for the array. This parameter can be negative.</para>
            </param>
            <param name="cElements">
            <para>The number of elements in the array.</para>
            </param>
            <param name="pvExtra">
            <para>
            The type information of the user-defined type, if you are creating a safe array of user-defined types. If the vt parameter is
            VT_RECORD, then pvExtra will be a pointer to an IRecordInfo describing the record. If the vt parameter is VT_DISPATCH or
            VT_UNKNOWN, then pvExtra will contain a pointer to a GUID representing the type of interface being passed to the array.
            </para>
            </param>
            <returns>
            <para>A safe array descriptor, or null if the array could not be created.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayDestroy(System.IntPtr)">
            <summary>
            <para>
            Destroys an existing array descriptor and all of the data in the array. If objects are stored in the array, <c>Release</c> is
            called on each object in the array.
            </para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The array is locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Safe arrays of variant will have the VariantClear function called on each member and safe arrays of BSTR will have the
            SysFreeString function called on each element. IRecordInfo::RecordClear will be called to release object references and other
            values of a record without deallocating the record.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayDestroyData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Destroys all the data in the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>A safe array descriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The array is locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is typically used when freeing safe arrays that contain elements with data types other than variants. If objects
            are stored in the array, Release is called on each object in the array. Safe arrays of variant will have the VariantClear
            function called on each member and safe arrays of BSTR will have the SysFreeString function called on each element.
            IRecordInfo::RecordClear will be called to release object references and other values of a record without deallocating the record.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayDestroyDescriptor(System.IntPtr)">
            <summary>
            <para>Destroys the descriptor of the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>A safe array descriptor.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa was not valid.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The array is locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is typically used to destroy the descriptor of a safe array that contains elements with data types other than
            variants. Destroying the array descriptor does not destroy the elements in the array. Before destroying the array descriptor,
            call SafeArrayDestroyData to free the elements.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetDim(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Gets the number of dimensions in the array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>The number of dimensions in the array.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetElement(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.Int32[],System.IntPtr)">
            <summary>
            <para>Retrieves a single element of the array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="rgIndices">
            <para>
            A vector of indexes for each dimension of the array. The right-most (least significant) dimension is rgIndices[0]. The left-most
            dimension is stored at .
            </para>
            </param>
            <param name="pv">
            <para>The element of the array.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADINDEX</term>
            <term>The specified index is not valid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Memory could not be allocated for the element.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function calls SafeArrayLock and SafeArrayUnlock automatically, before and after retrieving the element. The caller must
            provide a storage area of the correct size to receive the data. If the data element is a string, object, or variant, the function
            copies the element in the correct way.
            </para>
            <para>Examples</para>
            <para>The following example is taken from the COM Fundamentals SPoly sample (Cenumpt.cpp).</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetElemsize(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Gets the size of an element.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>The size of an element in a safe array, in bytes.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetIID(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.Guid@)">
            <summary>
            <para>Gets the GUID of the interface contained within the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="pguid">
            <para>The GUID of the interface.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is null or the array descriptor does not have the FADF_HAVEIID flag set.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetLBound(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.UInt32,System.Int32@)">
            <summary>
            <para>Gets the lower bound for any dimension of the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="nDim">
            <para>The array dimension for which to get the lower bound.</para>
            </param>
            <param name="plLbound">
            <para>The lower bound.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>DISP_E_BADINDEX</term>
            <term>The specified index is out of bounds.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetRecordInfo(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.OleAut32.IRecordInfo@)">
            <summary>
            <para>Retrieves the IRecordInfo interface of the UDT contained in the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="prinfo">
            <para>The IRecordInfo interface.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is null or the array descriptor does not have the FADF_RECORD flag set.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetUBound(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.UInt32,System.Int32@)">
            <summary>
            <para>Gets the upper bound for any dimension of the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="nDim">
            <para>The array dimension for which to get the upper bound.</para>
            </param>
            <param name="plUbound">
            <para>The upper bound.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADINDEX</term>
            <term>The specified index is out of bounds.</term>
            </item>
            <item>
            <term>DISP_E_OVERFLOW</term>
            <term>Overflow occurred while computing the upper bound.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayGetVartype(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.Ole32.VARTYPE@)">
            <summary>
            <para>Gets the VARTYPE stored in the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="pvt">
            <para>The VARTYPE.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If FADF_HAVEVARTYPE is set, <c>SafeArrayGetVartype</c> returns the VARTYPE stored in the array descriptor. If FADF_RECORD is set,
            it returns VT_RECORD; if FADF_DISPATCH is set, it returns VT_DISPATCH; and if FADF_UNKNOWN is set, it returns VT_UNKNOWN.
            </para>
            <para>
            <c>SafeArrayGetVartype</c> can fail to return VT_UNKNOWN for SAFEARRAY types that are based on <c>IUnknown</c>. Callers should
            additionally check whether the SAFEARRAY type's <c>fFeatures</c> field has the FADF_UNKNOWN flag set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayLock(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Increments the lock count of an array, and places a pointer to the array data in pvData of the array descriptor.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The pointer in the array descriptor is valid until the SafeArrayUnlock function is called. Calls to <c>SafeArrayLock</c> can be
            nested, in which case an equal number of calls to <c>SafeArrayUnlock</c> are required.
            </para>
            <para>An array cannot be deleted while it is locked.</para>
            <para>Thread Safety</para>
            <para>
            All public static (Shared in Visual Basic) members of the SAFEARRAY data type are thread safe. Instance members are not
            guaranteed to be thread safe.
            </para>
            <para>
            For example, consider an application that uses the SafeArrayLock and SafeArrayUnlock functions. If these functions are called
            concurrently from different threads on the same SAFEARRAY data type instance, an inconsistent lock count may be created. This
            will eventually cause the <c>SafeArrayUnlock</c> function to return E_UNEXPECTED. You can prevent this by providing your own
            synchronization code.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayPtrOfIndex(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.Int32[],System.IntPtr@)">
            <summary>Gets a pointer to an array element.</summary>
            <param name="psa">An array descriptor created by <c>SafeArrayCreate</c>.</param>
            <param name="rgIndices">
            An array of index values that identify an element of the array. All indexes for the element must be specified.
            </param>
            <param name="ppvData">The array element.</param>
            <returns>
            <para>This function can return one of these values.</para>
            <para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADINDEX</term>
            <term>The specified index is not valid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            </list>
            </para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayPutElement(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.Int32[],System.IntPtr)">
            <summary>
            <para>Stores the data element at the specified location in the array.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <param name="rgIndices">
            <para>
            A vector of indexes for each dimension of the array. The right-most (least significant) dimension is rgIndices[0]. The left-most
            dimension is stored at .
            </para>
            </param>
            <param name="pv">
            <para>
            The data to assign to the array. The variant types VT_DISPATCH, VT_UNKNOWN, and VT_BSTR are pointers, and do not require another
            level of indirection.
            </para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>DISP_E_BADINDEX</term>
            <term>The specified index is not valid.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One of the arguments is not valid.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Memory could not be allocated for the element.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function automatically calls SafeArrayLock and SafeArrayUnlock before and after assigning the element. If the data element
            is a string, object, or variant, the function copies it correctly when the safe array is destroyed. If the existing element is a
            string, object, or variant, it is cleared correctly. If the data element is a VT_DISPATCH or VT_UNKNOWN, <c>AddRef</c> is called
            to increment the object's reference count.
            </para>
            <para><c>Note</c> Multiple locks can be on an array. Elements can be put into an array while the array is locked by other operations.</para>
            <para>
            For an example that demonstrates calling <c>SafeArrayPutElement</c>, see the COM Fundamentals Lines sample (CLines::Add in Lines.cpp).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayRedim(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.OleAut32.SAFEARRAYBOUND@)">
            <summary>
            <para>Changes the right-most (least significant) bound of the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>A safe array descriptor.</para>
            </param>
            <param name="psaboundNew">
            <para>
            A new safe array bound structure that contains the new array boundary. You can change only the least significant dimension of an array.
            </para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>DISP_E_ARRAYISLOCKED</term>
            <term>The array is locked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If you reduce the bound of an array, <c>SafeArrayRedim</c> deallocates the array elements outside the new array boundary. If the
            bound of an array is increased, <c>SafeArrayRedim</c> allocates and initializes the new array elements. The data is preserved for
            elements that exist in both the old and new array.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayReleaseData(System.IntPtr)">
            <summary>
            <para>The safe array data for which the pinning reference count should decrease.</para>
            </summary>
            <param name="pData">
            <para>The safe array data for which the pinning reference count should decrease.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>
            A call to the <c>SafeArrayReleaseData</c> function should match every previous call to the SafeArrayAddRef function that returned
            a non-null value in the ppDataToRelease parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayReleaseDescriptor(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>The safe array for which the pinning reference count of the descriptor should decrease.</para>
            </summary>
            <param name="psa">
            <para>The safe array for which the pinning reference count of the descriptor should decrease.</para>
            </param>
            <returns>
            <para>This function does not return a value.</para>
            </returns>
            <remarks>
            <para>A call to the <c>SafeArrayReleaseDescriptor</c> function should match every previous call to the SafeArrayAddRef function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArraySetIID(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.Guid@)">
            <summary>
            <para>Sets the GUID of the interface for the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>The safe array descriptor.</para>
            </param>
            <param name="guid">
            <para>The IID.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is null or the array descriptor does not have the FADF_HAVEIID flag set.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArraySetRecordInfo(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,Vanara.PInvoke.OleAut32.IRecordInfo)">
            <summary>
            <para>Sets the record info in the specified safe array.</para>
            </summary>
            <param name="psa">
            <para>The array descriptor.</para>
            </param>
            <param name="prinfo">
            <para>The record info.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is null or the array descriptor does not have the FADF_RECORD flag set.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayUnaccessData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Decrements the lock count of an array, and invalidates the pointer retrieved by SafeArrayAccessData.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be unlocked.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayUnlock(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            <para>Decrements the lock count of an array so it can be freed or resized.</para>
            </summary>
            <param name="psa">
            <para>An array descriptor created by SafeArrayCreate.</para>
            </param>
            <returns>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The argument psa is not valid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be unlocked.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function is called after access to the data in an array is finished.</para>
            <para>Thread Safety</para>
            <para>
            All public static members of the SAFEARRAY data type are thread safe. Instance members are not guaranteed to be thread safe.
            </para>
            <para>
            For example, consider an application that uses the SafeArrayLock and SafeArrayUnlock functions. If these functions are called
            concurrently from different threads on the same SAFEARRAY data type instance, an inconsistent lock count may be created. This
            will eventually cause the SafeArrayUnlock function to return E_UNEXPECTED. You can prevent this by providing your own
            synchronization code.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SAFEARRAY">
            <summary>Represents a safe array.</summary>
            <seealso cref="T:System.IDisposable"/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.cDims">
            <summary>The number of dimensions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.fFeatures">
            <summary>Flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.cbElements">
            <summary>The size of an array element.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.cLocks">
            <summary>The number of times the array has been locked without a corresponding unlock.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.pvData">
            <summary>The data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAY.rgsabound">
            <summary>One bound for each dimension.</summary>
        </member>
        <member name="P:Vanara.PInvoke.OleAut32.SAFEARRAY.Bounds">
            <summary>Gets the bounds pointed to by <see cref="F:Vanara.PInvoke.OleAut32.SAFEARRAY.rgsabound"/>.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SAFEARRAYBOUND">
            <summary>Represents the bounds of one dimension of the array.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAYBOUND.cElements">
            <summary>The number of elements in the dimension.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.SAFEARRAYBOUND.lLbound">
            <summary>The lower bound of the dimension.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SAFEARRAYBOUND.#ctor(System.UInt32,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SAFEARRAYBOUND"/> struct.</summary>
            <param name="upperBound">The number of elements in the dimension.</param>
            <param name="lowerBound">The lower bound of the dimension.</param>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SafeSAFEARRAY">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to a safe array that releases a created SAFEARRAY instance at disposal using SafeArrayDestroy.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeSAFEARRAY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeSAFEARRAY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle"><see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeSAFEARRAY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeSAFEARRAY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeSAFEARRAY.op_Implicit(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)~Vanara.PInvoke.OleAut32.SAFEARRAY">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.OleAut32.SafeSAFEARRAY"/> to <see cref="T:Vanara.PInvoke.OleAut32.SAFEARRAY"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeSAFEARRAY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY">
            <summary>Provides a safe handle for items created with <see cref="M:Vanara.PInvoke.OleAut32.SafeArrayAllocDescriptor(System.UInt32,Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY@)"/>.</summary>
            <seealso cref="T:Vanara.PInvoke.OleAut32.SafeSAFEARRAY"/>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle"><see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).</param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeDescriptorSAFEARRAY.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.SafeArrayScopedAccessData">
            <summary>Construct for handling the paired calling of <see cref="M:Vanara.PInvoke.OleAut32.SafeArrayAccessData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.IntPtr@)"/> and <see cref="M:Vanara.PInvoke.OleAut32.SafeArrayUnaccessData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)"/>.</summary>
            <example>
            <code>
            using (var data = new SafeArrayScopedAccessData(safeArray))
            {
            // The Data property provides access to the array's data while in scope.
            FILETIME ft = (FILETIME)Marshal.PtrToStructure(data.Data, typeof(FILETIME));
            }
            </code>
            </example>
            <seealso cref="T:System.IDisposable"/>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayScopedAccessData.#ctor(Vanara.PInvoke.OleAut32.SafeSAFEARRAY)">
            <summary>
            Initializes a new instance of the <see cref="T:Vanara.PInvoke.OleAut32.SafeArrayScopedAccessData"/> class using the array descriptor that holds the data.
            </summary>
            <param name="psa">An array descriptor created by SafeArrayCreate.</param>
        </member>
        <member name="P:Vanara.PInvoke.OleAut32.SafeArrayScopedAccessData.Data">
            <summary>Gets the pointer exposed by the call to <see cref="M:Vanara.PInvoke.OleAut32.SafeArrayAccessData(Vanara.PInvoke.OleAut32.SafeSAFEARRAY,System.IntPtr@)"/>.</summary>
            <value>A pointer to the raw data within the array descriptor.</value>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.SafeArrayScopedAccessData.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.LoadPictureFlag">
            <summary>The desired color depth for the icon or cursor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.LoadPictureFlag.LP_DEFAULT">
            <summary>Selects the best color depth to use for the current display.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.LoadPictureFlag.LP_MONOCHROME">
            <summary>Creates a monochrome picture to display on a monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.LoadPictureFlag.LP_VGACOLOR">
            <summary>Creates a 16-color picture to display on a monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.LoadPictureFlag.LP_COLOR">
            <summary>Creates a 256-color picture to display on a monitor.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTYPE">
            <summary>
            Describe the type of a picture object as returned by <c>IPicture::get_Type</c>, as well as to describe the type of picture in
            the <c>picType</c> member of the <c>PICTDESC</c> structure that is passed to <c>OleCreatePictureIndirect</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_UNINITIALIZED">
            <summary>
            The picture object is currently uninitialized. This value is only valid as a return value from IPicture::get_Type and is not
            valid with the PICTDESC structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_NONE">
            <summary>
            A new picture object is to be created without an initialized state. This value is valid only in the PICTDESC structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_BITMAP">
            <summary>
            The picture type is a bitmap. When this value occurs in the PICTDESC structure, it means that the bmp field of that
            structure contains the relevant initialization parameters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_METAFILE">
            <summary>
            The picture type is a metafile. When this value occurs in the PICTDESC structure, it means that the wmf field of that
            structure contains the relevant initialization parameters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_ICON">
            <summary>
            The picture type is an icon. When this value occurs in the PICTDESC structure, it means that the icon field of that
            structure contains the relevant initialization parameters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTYPE.PICTYPE_ENHMETAFILE">
            <summary>
            The picture type is an enhanced metafile. When this value occurs in the PICTDESC structure, it means that the emf field of
            that structure contains the relevant initialization parameters.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleCreateFontIndirect(Vanara.PInvoke.OleAut32.FONTDESC@,System.Guid@,System.Object@)">
            <summary>
            Creates and initializes a standard font object using an initial description of the font's properties in a FONTDESC structure.
            The function returns an interface pointer to the new font object specified by caller in the riid parameter. A QueryInterface
            call is part of this call. The caller is responsible for calling Release through the interface pointer returned.
            </summary>
            <param name="lpFontDesc">
            Address of a caller-allocated, FONTDESC structure containing the initial state of the font. This value must not be <c>NULL</c>.
            </param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in lplpvObj.</param>
            <param name="lplpvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, this parameter
            contains the requested interface pointer on the newly created font object. If successful, the caller is responsible to call
            Release through this interface pointer when the new object is no longer needed. If unsuccessful, the value of is set to <c>NULL</c>.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The provided interface identifier is invalid.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unexpected error has occurred.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for the operation.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in pFontDesc or ppvObj is not valid. Note that if pFontDesc is set to NULL, the function returns NO_ERROR.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleCreatePictureIndirect(Vanara.PInvoke.OleAut32.PICTDESC@,System.Guid@,System.Boolean,System.Object@)">
            <summary>Creates a new picture object initialized according to a PICTDESC structure.</summary>
            <param name="lpPictDesc">
            Pointer to a caller-allocated structure containing the initial state of the picture. The specified structure can be <c>NULL</c>
            to create an uninitialized object, in the event the picture needs to initialize via IPersistStream::Load.
            </param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in lplpvObj.</param>
            <param name="fOwn">
            If <c>TRUE</c>, the picture object is to destroy its picture when the object is destroyed. If <c>FALSE</c>, the caller is
            responsible for destroying the picture.
            </param>
            <param name="lplpvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, this parameter
            contains the requested interface pointer on the newly created object. If the call is successful, the caller is responsible for
            calling Release through this interface pointer when the new object is no longer needed. If the call fails, the value is set to <c>NULL</c>.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support the interface specified in riid.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in pPictDesc or lplpvObj is not valid. For example, it may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The fOwn parameter indicates whether the picture is to own the GDI picture handle for the picture it contains, so that the
            picture object will destroy its picture when the object itself is destroyed. The function returns an interface pointer to the
            new picture object specified by the caller in the riid parameter. A QueryInterface is built into this call. The caller is
            responsible for calling Release through the interface pointer returned.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleCreatePropertyFrame(Vanara.PInvoke.HWND,System.UInt32,System.UInt32,System.String,System.UInt32,System.Object[],System.UInt32,System.Guid[],Vanara.PInvoke.LCID,System.UInt32,System.IntPtr)">
            <summary>
            Invokes a new property frame, that is, a property sheet dialog box, whose parent is hwndOwner, where the dialog is positioned at
            the point (x,y) in the parent window and has the caption lpszCaption.
            </summary>
            <param name="hwndOwner">Handle to the parent window of the resulting property sheet dialog box.</param>
            <param name="x">Reserved. Horizontal position for the dialog box relative to hwndOwner.</param>
            <param name="y">Reserved. Vertical position for the dialog box relative to hwndOwner.</param>
            <param name="lpszCaption">Pointer to the string used for the caption of the dialog box.</param>
            <param name="cObjects">Number of object pointers passed in ppUnk.</param>
            <param name="ppUnk">
            An array of IUnknown pointers on the objects for which this property sheet is being invoked. The number of elements in the array
            is specified by cObjects. These pointers are passed to each property page through IPropertyPage::SetObjects.
            </param>
            <param name="cPages">Number of property pages specified in pPageCIsID.</param>
            <param name="pPageClsID">Array of size cPages containing the CLSIDs of each property page to display in the property sheet.</param>
            <param name="lcid">Locale identifier to use for the property sheet. Property pages can retrieve this identifier through IPropertyPageSite::GetLocaleID.</param>
            <param name="dwReserved">Reserved for future use; must be zero.</param>
            <param name="pvReserved">Reserved for future use; must be <c>NULL</c>.</param>
            <returns>
            <para>This function supports the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The dialog box was invoked and operated successfully.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in lpszCaption, ppUnk, or pPageCIsID is not valid. For example, any one of them may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The property pages to be displayed are identified with pPageClsID, which is an array of cPages CLSID values. The objects that
            are affected by this property sheet are identified in ppUnk, an array of size cObjects containing IUnknown pointers.
            </para>
            <para>This function always creates a modal dialog box and does not return until the dialog box is closed.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleCreatePropertyFrameIndirect(Vanara.PInvoke.OleAut32.OCPFIPARAMS@)">
            <summary>
            Creates a property frame, that is, a property sheet dialog box, based on a structure (OCPFIPARAMS) that contains the parameters,
            rather than specifying separate parameters as when calling OleCreatePropertyFrame.
            </summary>
            <param name="lpParams">Pointer to the caller-allocated structure containing the creation parameters for the dialog box.</param>
            <returns>
            <para>This function supports the standard return values E_INVALIDARG, E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The dialog box was invoked and operated successfully.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in lpParams is not valid. For example, it may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Besides <c>cbStructSize</c> (the size of the structure) and <c>dispIDInitialProperty</c>, all of the members of the OCPFIPARAMS
            structure have the same semantics as the parameters for OleCreatePropertyFrame. When dispIDInitialProperty is DISPID_UNKNOWN,
            the behavior of the two functions is identical.
            </para>
            <para>
            Working in conjunction with IPerPropertyBrowsing and IPropertyPage2, dispIDInitialProperty allows the caller to specify which
            single property should be highlighted when the dialog box is made visible. This feature is not available when using
            OleCreatePropertyFrame. To determine the page and property to show initially, the property frame will do the following:
            </para>
            <list type="number">
            <item>
            <term>Call <c>(*ppUnk)-&gt;QueryInterface(IID_IPerPropertyBrowsing, ...)</c> to get an interface pointer to the first object.</term>
            </item>
            <item>
            <term>
            Call <c>IPerPropertyBrowsing::MapPropertyToPage(dispIDInitialProperty, ...)</c> to determine which page CLSID contains the
            property to be highlighted. All objects for which this frame is being invoked must support the set of properties displayed in
            the frame.
            </term>
            </item>
            <item>
            <term>When the dialog box is created, the property page with the CLSID retrieved in Step 2 is activated with <c>IPropertyPage::Activate</c>.</term>
            </item>
            <item>
            <term>The property frame queries the active page for IPropertyPage2.</term>
            </item>
            <item>
            <term>
            If successful, the frame calls <c>IPropertyPage2::EditProperty(dispIDInitialProperty)</c> to highlight the correct field in that
            dialog box.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleIconToCursor(Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.HICON)">
            <summary>Converts an icon to a cursor.</summary>
            <param name="hinstExe">This parameter is ignored.</param>
            <param name="hIcon">A handle to the icon to be converted.</param>
            <returns>
            The function returns a handle to the new cursor object. The caller is responsible for deleting this cursor with the
            DestroyCursor function. If the conversion could not be completed, the return value is <c>NULL</c>.
            </returns>
            <remarks>This function calls the CopyCursor function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleLoadPicture(System.Runtime.InteropServices.ComTypes.IStream,System.Int32,System.Boolean,System.Guid@,System.Object@)">
            <summary>
            Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
            OleCreatePictureIndirect with <c>NULL</c> as the first parameter, followed by a call to IPersistStream::Load.
            </summary>
            <param name="lpstream">Pointer to the stream that contains the picture's data.</param>
            <param name="lSize">The number of bytes that should be read from the stream, or zero if the entire stream should be read.</param>
            <param name="fRunmode">
            The opposite of the initial value of the KeepOriginalFormat property. If <c>TRUE</c>, KeepOriginalFormat is set to <c>FALSE</c>
            and vice-versa.
            </param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in ppvObj.</param>
            <param name="lplpvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the storage of the object identified by the moniker. If *ppvObj is non- <c>NULL</c>, this
            function calls IUnknown::AddRef on the interface; it is the caller's responsibility to call IUnknown::Release. If an error
            occurs, *ppvObj is set to <c>NULL</c>.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support the specified interface.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The stream is not valid. For example, it may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The stream must be in BMP (bitmap), WMF (metafile), or ICO (icon) format. A picture object created using <c>OleLoadPicture</c>
            always has ownership of its internal resources (fOwn== <c>TRUE</c> is implied).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleLoadPictureEx(System.Runtime.InteropServices.ComTypes.IStream,System.Int32,System.Boolean,System.Guid@,System.UInt32,System.UInt32,System.UInt32,System.Object@)">
            <summary>
            Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
            OleCreatePictureIndirect with <c>NULL</c> as the first parameter, followed by a call to IPersistStream::Load.
            </summary>
            <param name="lpstream">Pointer to the stream that contains the picture's data.</param>
            <param name="lSize">The number of bytes that should be read from the stream, or zero if the entire stream should be read.</param>
            <param name="fRunmode">
            The opposite of the initial value of the KeepOriginalFormat property. If <c>TRUE</c>, KeepOriginalFormat is set to <c>FALSE</c>
            and vice versa.
            </param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in ppvObj.</param>
            <param name="xSizeDesired">
            Desired width of icon or cursor. Valid values are 16, 32, and 48. Pass LP_DEFAULT to both size parameters to use system default size.
            </param>
            <param name="ySizeDesired">
            Desired height of icon or cursor. Valid values are 16, 32, and 48. Pass LP_DEFAULT to both size parameters to use system default size.
            </param>
            <param name="dwFlags">
            Desired color depth for icon or cursor. Values are LP_MONOCHROME (monochrome), LP_VGACOLOR (16 colors), LP_COLOR (256 colors),
            or LP_DEFAULT (selects best depth for current display).
            </param>
            <param name="lplpvObj">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvObj contains the
            requested interface pointer on the storage of the object identified by the moniker. If *ppvObj is non- <c>NULL</c>, this
            function calls IUnknown::AddRef on the interface; it is the caller's responsibility to call IUnknown::Release. If an error
            occurs, *ppvObj is set to <c>NULL</c>.
            </param>
            <returns>
            <para>This function returns S_OK on success. Other possible values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support the interface specified in riid.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in pPictDesc or ppvObj is not valid. For example, it may be NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The stream must be in BMP (bitmap), WMF (metafile), or ICO (icon) format. A picture object created using <c>OleLoadPictureEx</c>
            always has ownership of its internal resources (fOwn== <c>TRUE</c> is implied).
            </para>
            <para>In addition to allowing specification of icon or cursor size, <c>OleLoadPictureEx</c> supports loading of color cursors.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleLoadPictureFile(System.Object,System.Object@)">
            <summary>Creates an <c>IPictureDisp</c> object from a picture file on disk.</summary>
            <param name="varFileName">The path and name of the picture file to load.</param>
            <param name="lplpdispPicture">The location that receives a pointer to the <c>IPictureDisp</c> object.</param>
            <returns>
            <para>This method returns standard COM error codes in addition to the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>CTL_E_INVALIDPICTURE</term>
            <term>Invalid picture file.</term>
            </item>
            </list>
            </returns>
            <remarks>Recognized graphic formats include bitmap (.bmp), JPEG (.jpg), GIF (.gif), and PGN (.png) files.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleLoadPictureFileEx(System.Object,System.UInt32,System.UInt32,Vanara.PInvoke.OleAut32.LoadPictureFlag,System.Object@)">
            <summary>Loads a picture from a file.</summary>
            <param name="varFileName">The path and name of the picture file to load.</param>
            <param name="xSizeDesired">The desired length for the picture to be displayed.</param>
            <param name="ySizeDesired">The desired height for the picture to be displayed.</param>
            <param name="dwFlags">
            <para>
            The desired color depth for the icon or cursor. Together with the desired size it is used to select the best matching image.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LP_MONOCHROME</term>
            <term>Creates a monochrome picture to display on a monitor.</term>
            </item>
            <item>
            <term>LP_VGACOLOR</term>
            <term>Creates a 16-color picture to display on a monitor.</term>
            </item>
            <item>
            <term>LP_COLOR</term>
            <term>Creates a 256-color picture to display on a monitor.</term>
            </item>
            <item>
            <term>LP_DEFAULT</term>
            <term>Selects the best color depth to use for the current display.</term>
            </item>
            </list>
            </param>
            <param name="lplpdispPicture">The location that receives a pointer to the picture.</param>
            <returns>
            <para>This method returns standard COM error codes in addition to the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>DISP_E_PARAMNOTFOUND</term>
            <term>varFileName is not valid.</term>
            </item>
            </list>
            </returns>
            <remarks>Recognized graphic formats include bitmap (.bmp), JPEG (.jpg), GIF (.gif), and PGN (.png) files.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleLoadPicturePath(System.String,System.Object,System.UInt32,System.UInt32,System.Guid@,System.Object@)">
            <summary>
            Creates a new picture object and initializes it from the contents of a stream. This is equivalent to calling
            OleCreatePictureIndirect(NULL, ...) followed by IPersistStream::Load.
            </summary>
            <param name="szURLorPath">The path or URL to the file you want to open.</param>
            <param name="punkCaller">Points to IUnknown for COM aggregation.</param>
            <param name="dwReserved">Reserved.</param>
            <param name="clrReserved">The color you want to reserve to be transparent.</param>
            <param name="riid">Reference to the identifier of the interface describing the type of interface pointer to return in ppvRet.</param>
            <param name="ppvRet">
            Address of pointer variable that receives the interface pointer requested in riid. Upon successful return, *ppvRet contains the
            requested interface pointer on the storage of the object identified by the moniker. If *ppvRet is non- <c>NULL</c>, this
            function calls IUnknown::AddRef on the interface; it is the caller's responsibility to call IUnknown::Release. If an error
            occurs, *ppvRet is set to <c>NULL</c>.
            </param>
            <returns>
            <para>This function supports the standard return values E_OUTOFMEMORY and E_UNEXPECTED, as well as the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The dialog box was created successfully.</term>
            </item>
            <item>
            <term>E_FAIL</term>
            <term>Unable to load picture stream.</term>
            </item>
            <item>
            <term>E_POINTER</term>
            <term>The address in ppvRet is NULL.</term>
            </item>
            <item>
            <term>E_NOINTERFACE</term>
            <term>The object does not support the interface specified in riid.</term>
            </item>
            </list>
            </returns>
            <remarks>The stream must be in BMP (bitmap), JPEG, WMF (metafile), ICO (icon), or GIF format.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleSavePictureFile(System.Object,System.String)">
            <summary>Saves a picture to a file.</summary>
            <param name="lpdispPicture">Points to the <c>IPictureDisp</c> picture object.</param>
            <param name="bstrFileName">The name of the file to save the picture to.</param>
            <returns>
            <para>This method returns standard COM error codes in addition to the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The method completed successfully.</term>
            </item>
            <item>
            <term>CTL_E_INVALIDPROPERTYVALUE</term>
            <term>lpdispPicture is NULL.</term>
            </item>
            <item>
            <term>CTL_E_FILENOTFOUND</term>
            <term>bstrFileName cannot be found.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.OleTranslateColor(System.UInt32,Vanara.PInvoke.HPALETTE,Vanara.PInvoke.COLORREF@)">
            <summary>Converts an <c>OLE_COLOR</c> type to a <c>COLORREF</c>.</summary>
            <param name="clr">The OLE color to be converted into a <c>COLORREF</c>.</param>
            <param name="hpal">Palette used as a basis for the conversion.</param>
            <param name="lpcolorref">
            Pointer to the caller's variable that receives the converted <c>COLORREF</c> result. This parameter can be <c>NULL</c>,
            indicating that the caller wants only to verify that a converted color exists.
            </param>
            <returns>
            <para>This function supports the standard return values E_INVALIDARG and E_UNEXPECTED, as well as the following value.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The color was translated successfully.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The following table describes the color conversion.</para>
            <list type="table">
            <listheader>
            <term>OLE_COLOR</term>
            <term>hPal</term>
            <term>COLORREF</term>
            </listheader>
            <item>
            <term>invalid</term>
            <term/>
            <term>Undefined (E_INVALIDARG)</term>
            </item>
            <item>
            <term>0x800000xx, xx is not a valid GetSysColor index</term>
            <term/>
            <term>Undefined (E_INVALIDARG)</term>
            </item>
            <item>
            <term/>
            <term>invalid</term>
            <term>Undefined (E_INVALIDARG)</term>
            </item>
            <item>
            <term>0x0100iiii, iiii is not a valid palette index</term>
            <term>valid palette</term>
            <term>Undefined (E_INVALIDARG)</term>
            </item>
            <item>
            <term>0x800000xx, xx is a valid GetSysColor index</term>
            <term>NULL</term>
            <term>0x00bbggrr</term>
            </item>
            <item>
            <term>0x0100iiii, iiii is a valid palette index</term>
            <term>NULL</term>
            <term>0x0100iiii</term>
            </item>
            <item>
            <term>0x02bbggrr (palette relative)</term>
            <term>NULL</term>
            <term>0x02bbggrr</term>
            </item>
            <item>
            <term>0x00bbggrr</term>
            <term>NULL</term>
            <term>0x00bbggrr</term>
            </item>
            <item>
            <term>0x800000xx, xx is a valid GetSysColor index</term>
            <term>valid palette</term>
            <term>0x00bbggrr</term>
            </item>
            <item>
            <term>0x0100iiii, iiii is a valid palette index in hPal</term>
            <term>valid palette</term>
            <term>0x0100iiii</term>
            </item>
            <item>
            <term>0x02bbggrr (palette relative)</term>
            <term>valid palette</term>
            <term>0x02bbggrr</term>
            </item>
            <item>
            <term>0x00bbggrr</term>
            <term>valid palette</term>
            <term>0x02bbggrr</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.FONTDESC">
            <summary>Contains parameters used to create a font object through the OleCreateFontIndirect function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.cbSizeofstruct">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.lpstrName">
            <summary>
            <para>Pointer to an OLESTR that specifies the caller-owned string specifying the font name.</para>
            <para>cySize</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.cySize">
            <summary>
            Initial point size of the font. Use the <c>int64</c> member of the CY structure and scale your font size (in points) by 10000.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.sWeight">
            <summary>
            Initial weight of the font. If the weight is below 550 (the average of FW_NORMAL, 400, and FW_BOLD, 700), then the
            <c>Bold</c> property is also initialized to <c>FALSE</c>. If the weight is above 550, the <c>Bold</c> property is set to <c>TRUE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.sCharset">
            <summary>Initial character set of the font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.fItalic">
            <summary>Initial italic state of the font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.fUnderline">
            <summary>Initial underline state of the font.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.FONTDESC.fStrikethrough">
            <summary>Initial strikethrough state of the font.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.OCPFIPARAMS">
            <summary>Contains parameters used to invoke a property sheet dialog box through the OleCreatePropertyFrameIndirect function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.cbStructSize">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.hWndOwner">
            <summary>Handle to the parent window of the resulting property sheet dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.x">
            <summary>Horizontal position for the dialog box relative to <c>hWndOwner</c>, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.y">
            <summary>Vertical position for the dialog box relative to <c>hWndOwner</c>, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.lpszCaption">
            <summary>Pointer to an OLESTR that contains the caption of the dialog.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.cObjects">
            <summary>Number of object pointers passed in <c>lplpUnk</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.lplpUnk">
            <summary>
            Array of IUnknown pointers on the objects for which this property sheet is being invoked. The number of elements in the
            array is specified by <c>cObjects</c>. These pointers are passed to each property page through IPropertyPage::SetObjects.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.cPages">
            <summary>Number of property pages specified in <c>lpPages</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.lpPages">
            <summary>
            Pointer to an array of size <c>cPages</c> containing the CLSIDs of each property page to display in the property sheet.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.lcid">
            <summary>Locale identifier for the property sheet. This value will be returned through IPropertyPageSite::GetLocaleID.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.OCPFIPARAMS.dispidInitialProperty">
            <summary>Property that is highlighted when the dialog box is made visible.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC">
            <summary>Contains parameters to create a picture object through the OleCreatePictureIndirect function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.cbSizeofstruct">
            <summary>The size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.picType">
            <summary>
            Type of picture described by this structure, which can be any value from the PICTYPE enumeration. This selects the arm of
            the union that corresponds to one of the picture type structures below.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.bmp">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.wmf">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.icon">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.emf">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.BMP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.BMP.hbitmap">
            <summary>The <c>HBITMAP</c> handle identifying the bitmap assigned to the picture object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.BMP.hpal">
            <summary>The <c>HPALETTE</c> handle identifying the color palette for the bitmap.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.WMF">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.WMF.hmeta">
            <summary>The <c>HMETAFILE</c> handle identifying the metafile assigned to the picture object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.WMF.xExt">
            <summary>Horizontal extent of the metafile in TWIPS units.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.WMF.yExt">
            <summary>Vertical extent of the metafile in TWIPS units.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.ICON">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.ICON.hicon">
            <summary>The <c>HICON</c> handle identifying the icon assigned to the picture object.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.EMF">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.PICTDESC.PICTDEC_UNION.EMF.hemf">
            <summary>The <c>HENHMETAFILE</c> handle identifying the enhanced metafile assigned to the picture object.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID_TO_NAME">
            <summary>
            Provides a quick means by which applications can look up the standard Windows Image Acquisition (WIA) property name from the WIA
            property ID (or vice versa). If the <c>propid</c> does not exist in this array, it is likely not a standard WIA property. Other
            ways to get the property name from the property ID include using the <c>IEnumSTATPROPSTG</c> retrieved by calling
            IWiaPropertyStorage::Enum on a particular item.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IT_MSG">
            <summary>IWiaDataCallback and IWiaMiniDrvCallBack message ID constants</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_DATA_HEADER">
            <summary>The application is receiving a header prior to receiving the actual data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_DATA">
            <summary>The WIA system is transferring data to the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_STATUS">
            <summary>This invocation of the callback is sending only status information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_TERMINATION">
            <summary>The data transfer is complete.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_NEW_PAGE">
            <summary>The data transfer is beginning a new page.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_FILE_PREVIEW_DATA">
            <summary>The WIA system is transferring preview data to the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_FILE_PREVIEW_DATA_HEADER">
            <summary>The application is receiving a header prior to receiving the actual preview data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_MSG.IT_MSG_DEVICE_STATUS">
            <summary>Windows Vista or later. Status at the device has changed.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IT_STATUS">
            <summary>IWiaDataCallback and IWiaMiniDrvCallBack status flag constants</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_STATUS.IT_STATUS_TRANSFER_FROM_DEVICE">
            <summary>Data is currently being transferred from the WIA device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_STATUS.IT_STATUS_PROCESSING_DATA">
            <summary>Data is currently being processed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_STATUS.IT_STATUS_TRANSFER_TO_CLIENT">
            <summary>Data is currently being transferred to the client's data buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.IT_STATUS.IT_STATUS_MASK">
            <summary>Mask</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_PROPID">
            <summary>WIA property identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_DEV_ID">
            <summary>Unique Device ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_VEND_DESC">
            <summary>Manufacturer</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_DEV_DESC">
            <summary>Description</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_DEV_TYPE">
            <summary>Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_PORT_NAME">
            <summary>Port</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_DEV_NAME">
            <summary>Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_SERVER_NAME">
            <summary>Server</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_REMOTE_DEV_ID">
            <summary>Remote Device ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_UI_CLSID">
            <summary>UI Class ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_HW_CONFIG">
            <summary>Hardware Configuration</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_BAUDRATE">
            <summary>BaudRate</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_STI_GEN_CAPABILITIES">
            <summary>STI Generic Capabilities</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_WIA_VERSION">
            <summary>WIA Version</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_DRIVER_VERSION">
            <summary>Driver Version</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_PNP_ID">
            <summary>PnP ID String</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DIP_STI_DRIVER_VERSION">
            <summary>STI Driver Version</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPA_FIRMWARE_VERSION">
            <summary>Firmware Version</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPA_CONNECT_STATUS">
            <summary>Connect Status</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPA_DEVICE_TIME">
            <summary>Device Time</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_PICTURES_TAKEN">
            <summary>Pictures Taken</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_PICTURES_REMAINING">
            <summary>Pictures Remaining</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EXPOSURE_MODE">
            <summary>Exposure Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EXPOSURE_COMP">
            <summary>Exposure Compensation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EXPOSURE_TIME">
            <summary>Exposure Time</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FNUMBER">
            <summary>F Number</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FLASH_MODE">
            <summary>Flash Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCUS_MODE">
            <summary>Focus Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCUS_MANUAL_DIST">
            <summary>Focus Manual Dist</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_ZOOM_POSITION">
            <summary>Zoom Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_PAN_POSITION">
            <summary>Pan Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_TILT_POSITION">
            <summary>Tilt Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_TIMER_MODE">
            <summary>Timer Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_TIMER_VALUE">
            <summary>Timer Value</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_POWER_MODE">
            <summary>Power Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_BATTERY_STATUS">
            <summary>Battery Status</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_THUMB_WIDTH">
            <summary>Thumbnail Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_THUMB_HEIGHT">
            <summary>Thumbnail Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_PICT_WIDTH">
            <summary>Picture Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_PICT_HEIGHT">
            <summary>Picture Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_DIMENSION">
            <summary>Dimension</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_COMPRESSION_SETTING">
            <summary>Compression Setting</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCUS_METERING">
            <summary>Focus Metering Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_TIMELAPSE_INTERVAL">
            <summary>Timelapse Interval</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_TIMELAPSE_NUMBER">
            <summary>Timelapse Number</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_BURST_INTERVAL">
            <summary>Burst Interval</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_BURST_NUMBER">
            <summary>Burst Number</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EFFECT_MODE">
            <summary>Effect Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_DIGITAL_ZOOM">
            <summary>Digital Zoom</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_SHARPNESS">
            <summary>Sharpness</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_CONTRAST">
            <summary>Contrast</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_CAPTURE_MODE">
            <summary>Capture Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_CAPTURE_DELAY">
            <summary>Capture Delay</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EXPOSURE_INDEX">
            <summary>Exposure Index</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_EXPOSURE_METERING_MODE">
            <summary>Exposure Metering Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCUS_METERING_MODE">
            <summary>Focus Metering Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCUS_DISTANCE">
            <summary>Focus Distance</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_FOCAL_LENGTH">
            <summary>Focus Length</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_RGB_GAIN">
            <summary>RGB Gain</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_WHITE_BALANCE">
            <summary>White Balance</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_UPLOAD_URL">
            <summary>Upload URL</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_ARTIST">
            <summary>Artist</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPC_COPYRIGHT_INFO">
            <summary>Copyright Info</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_HORIZONTAL_BED_SIZE">
            <summary>Horizontal Bed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_VERTICAL_BED_SIZE">
            <summary>Vertical Bed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE">
            <summary>Horizontal Sheet Feed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_VERTICAL_SHEET_FEED_SIZE">
            <summary>Vertical Sheet Feed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_SHEET_FEEDER_REGISTRATION">
            <summary>Sheet Feeder Registration</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_HORIZONTAL_BED_REGISTRATION">
            <summary>Horizontal Bed Registration</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_VERTICAL_BED_REGISTRATION">
            <summary>Vertical Bed Registration</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PLATEN_COLOR">
            <summary>Platen Color</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PAD_COLOR">
            <summary>Pad Color</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_FILTER_SELECT">
            <summary>Filter Select</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DITHER_SELECT">
            <summary>Dither Select</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DITHER_PATTERN_DATA">
            <summary>Dither Pattern Data</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES">
            <summary>Document Handling Capabilities</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DOCUMENT_HANDLING_STATUS">
            <summary>Document Handling Status</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DOCUMENT_HANDLING_SELECT">
            <summary>Document Handling Select</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DOCUMENT_HANDLING_CAPACITY">
            <summary>Document Handling Capacity</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_OPTICAL_XRES">
            <summary>Horizontal Optical Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_OPTICAL_YRES">
            <summary>Vertical Optical Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_ENDORSER_CHARACTERS">
            <summary>Endorser Characters</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_ENDORSER_STRING">
            <summary>Endorser String</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_SCAN_AHEAD_PAGES">
            <summary>Scan Ahead Pages</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_MAX_SCAN_TIME">
            <summary>Max Scan Time</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PAGES">
            <summary>Pages</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PAGE_SIZE">
            <summary>Page Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PAGE_WIDTH">
            <summary>Page Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PAGE_HEIGHT">
            <summary>Page Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_PREVIEW">
            <summary>Preview</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_TRANSPARENCY">
            <summary>Transparency Adapter</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_TRANSPARENCY_SELECT">
            <summary>Transparency Adapter Select</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_SHOW_PREVIEW_CONTROL">
            <summary>Show preview control</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE">
            <summary>Minimum Horizontal Sheet Feed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE">
            <summary>Minimum Vertical Sheet Feed Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_TRANSPARENCY_CAPABILITIES">
            <summary>Transparency Adapter Capabilities</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_TRANSPARENCY_STATUS">
            <summary>Transparency Adapter Status</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPF_MOUNT_POINT">
            <summary>Directory mount point</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPV_LAST_PICTURE_TAKEN">
            <summary>Last Picture Taken</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPV_IMAGES_DIRECTORY">
            <summary>Images Directory</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPV_DSHOW_DEVICE_PATH">
            <summary>Directshow Device Path</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEM_NAME">
            <summary>Item Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_FULL_ITEM_NAME">
            <summary>Full Item Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEM_TIME">
            <summary>Item Time Stamp</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEM_FLAGS">
            <summary>Item Flags</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ACCESS_RIGHTS">
            <summary>Access Rights</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_DATATYPE">
            <summary>Data Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_DEPTH">
            <summary>Bits Per Pixel</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_PREFERRED_FORMAT">
            <summary>Preferred Format</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_FORMAT">
            <summary>Format</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_COMPRESSION">
            <summary>Compression</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_TYMED">
            <summary>Media Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_CHANNELS_PER_PIXEL">
            <summary>Channels Per Pixel</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_BITS_PER_CHANNEL">
            <summary>Bits Per Channel</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_PLANAR">
            <summary>Planar</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_PIXELS_PER_LINE">
            <summary>Pixels Per Line</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_BYTES_PER_LINE">
            <summary>Bytes Per Line</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_NUMBER_OF_LINES">
            <summary>Number of Lines</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_GAMMA_CURVES">
            <summary>Gamma Curves</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEM_SIZE">
            <summary>Item Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_COLOR_PROFILE">
            <summary>Color Profiles</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_MIN_BUFFER_SIZE">
            <summary>Buffer Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_BUFFER_SIZE">
            <summary>Buffer Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_REGION_TYPE">
            <summary>Region Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ICM_PROFILE_NAME">
            <summary>Color Profile Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_APP_COLOR_MAPPING">
            <summary>Application Applies Color Mapping</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_PROP_STREAM_COMPAT_ID">
            <summary>Stream Compatibility ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_FILENAME_EXTENSION">
            <summary>Filename extension</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_SUPPRESS_PROPERTY_PAGE">
            <summary>Suppress a property page</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_THUMBNAIL">
            <summary>Thumbnail Data</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_THUMB_WIDTH">
            <summary>Thumbnail Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_THUMB_HEIGHT">
            <summary>Thumbnail Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_AUDIO_AVAILABLE">
            <summary>Audio Available</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_AUDIO_DATA_FORMAT">
            <summary>Audio Format</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_AUDIO_DATA">
            <summary>Audio Data</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_NUM_PICT_PER_ROW">
            <summary>Pictures per Row</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_SEQUENCE">
            <summary>Sequence Number</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPC_TIMEDELAY">
            <summary>Time Delay</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_CUR_INTENT">
            <summary>Current Intent</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_XRES">
            <summary>Horizontal Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_YRES">
            <summary>Vertical Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_XPOS">
            <summary>Horizontal Start Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_YPOS">
            <summary>Vertical Start Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_XEXTENT">
            <summary>Horizontal Extent</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_YEXTENT">
            <summary>Vertical Extent</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PHOTOMETRIC_INTERP">
            <summary>Photometric Interpretation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BRIGHTNESS">
            <summary>Brightness</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_CONTRAST">
            <summary>Contrast</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_ORIENTATION">
            <summary>Orientation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_ROTATION">
            <summary>Rotation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MIRROR">
            <summary>Mirror</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_THRESHOLD">
            <summary>Threshold</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_INVERT">
            <summary>Invert</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_WARM_UP_TIME">
            <summary>Lamp Warm up Time</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_USER_NAME">
            <summary>User Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_SERVICE_ID">
            <summary>Service ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_DEVICE_ID">
            <summary>Device ID</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_GLOBAL_IDENTITY">
            <summary>Global Identity</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_DPS_SCAN_AVAILABLE_ITEM">
            <summary>Scan Available Item</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_DESKEW_X">
            <summary>DeskewX</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_DESKEW_Y">
            <summary>DeskewY</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SEGMENTATION">
            <summary>Segmentation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MAX_HORIZONTAL_SIZE">
            <summary>Maximum Horizontal Scan Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MAX_VERTICAL_SIZE">
            <summary>Maximum Vertical Scan Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MIN_HORIZONTAL_SIZE">
            <summary>Minimum Horizontal Scan Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MIN_VERTICAL_SIZE">
            <summary>Minimum Vertical Scan Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_TRANSFER_CAPABILITIES">
            <summary>Transfer Capabilities</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SHEET_FEEDER_REGISTRATION">
            <summary>Sheet Feeder Registration</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_DOCUMENT_HANDLING_SELECT">
            <summary>Document Handling Select</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OPTICAL_XRES">
            <summary>Horizontal Optical Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OPTICAL_YRES">
            <summary>Vertical Optical Resolution</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PAGES">
            <summary>Pages</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PAGE_SIZE">
            <summary>Page Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PAGE_WIDTH">
            <summary>Page Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PAGE_HEIGHT">
            <summary>Page Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PREVIEW">
            <summary>Preview</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SHOW_PREVIEW_CONTROL">
            <summary>Show preview control</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_FILM_SCAN_MODE">
            <summary>Film Scan Mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_LAMP">
            <summary>Lamp</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_LAMP_AUTO_OFF">
            <summary>Lamp Auto Off</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_AUTO_DESKEW">
            <summary>Automatic Deskew</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SUPPORTS_CHILD_ITEM_CREATION">
            <summary>Supports Child Item Creation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_XSCALING">
            <summary>Horizontal Scaling</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_YSCALING">
            <summary>Vertical Scaling</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PREVIEW_TYPE">
            <summary>Preview Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEM_CATEGORY">
            <summary>Item Category</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_UPLOAD_ITEM_SIZE">
            <summary>Upload Item Size</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_ITEMS_STORED">
            <summary>Items Stored</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPA_RAW_BITS_PER_CHANNEL">
            <summary>Raw Bits Per Channel</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_FILM_NODE_NAME">
            <summary>Film Node Name</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER">
            <summary>Printer/Endorser</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_ORDER">
            <summary>Printer/Endorser Order</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_COUNTER">
            <summary>Printer/Endorser Counter</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_STEP">
            <summary>Printer/Endorser Step</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_XOFFSET">
            <summary>Printer/Endorser Horizontal Offset</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_YOFFSET">
            <summary>Printer/Endorser Vertical Offset</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_NUM_LINES">
            <summary>Printer/Endorser Lines</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_STRING">
            <summary>Printer/Endorser String</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_VALID_CHARACTERS">
            <summary>Printer/Endorser Valid Characters</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_VALID_FORMAT_SPECIFIERS">
            <summary>Printer/Endorser Valid Format Specifiers</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_TEXT_UPLOAD">
            <summary>Printer/Endorser Text Upload</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_TEXT_DOWNLOAD">
            <summary>Printer/Endorser Text Download</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS">
            <summary>Printer/Endorser Graphics</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_POSITION">
            <summary>Printer/Endorser Graphics Position</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_MIN_WIDTH">
            <summary>Printer/Endorser Graphics Minimum Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_MAX_WIDTH">
            <summary>Printer/Endorser Graphics Maximum Width</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_MIN_HEIGHT">
            <summary>Printer/Endorser Graphics Minimum Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_MAX_HEIGHT">
            <summary>Printer/Endorser Graphics Maximum Height</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_UPLOAD">
            <summary>Printer/Endorser Graphics Upload</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_GRAPHICS_DOWNLOAD">
            <summary>Printer/Endorser Graphics Download</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BARCODE_READER">
            <summary>Barcode Reader</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MAXIMUM_BARCODES_PER_PAGE">
            <summary>Maximum Barcodes Per Page</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BARCODE_SEARCH_DIRECTION">
            <summary>Barcode Search Direction</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MAXIMUM_BARCODE_SEARCH_RETRIES">
            <summary>Barcode Search Retries</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BARCODE_SEARCH_TIMEOUT">
            <summary>Barcode Search Timeout</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SUPPORTED_BARCODE_TYPES">
            <summary>Supported Barcode Types</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_ENABLED_BARCODE_TYPES">
            <summary>Enabled Barcode Types</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PATCH_CODE_READER">
            <summary>Patch Code Reader</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SUPPORTED_PATCH_CODE_TYPES">
            <summary>Supported Patch Code Types</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_ENABLED_PATCH_CODE_TYPES">
            <summary>Enabled Path Code Types</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MICR_READER">
            <summary>MICR Reader</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_JOB_SEPARATORS">
            <summary>Job Separators</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_LONG_DOCUMENT">
            <summary>Long Document</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BLANK_PAGES">
            <summary>Blank Pages</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MULTI_FEED">
            <summary>Multi-Feed</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MULTI_FEED_SENSITIVITY">
            <summary>Multi-Feed Sensitivity</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_AUTO_CROP">
            <summary>Auto-Crop</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OVER_SCAN">
            <summary>Overscan</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OVER_SCAN_LEFT">
            <summary>Overscan Left</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OVER_SCAN_RIGHT">
            <summary>Overscan Right</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OVER_SCAN_TOP">
            <summary>Overscan Top</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_OVER_SCAN_BOTTOM">
            <summary>Overscan Bottom</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_COLOR_DROP">
            <summary>Color Drop</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_COLOR_DROP_RED">
            <summary>Color Drop Red</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_COLOR_DROP_GREEN">
            <summary>Color Drop Green</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_COLOR_DROP_BLUE">
            <summary>Color Drop Blue</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SCAN_AHEAD">
            <summary>Scan Ahead</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_SCAN_AHEAD_CAPACITY">
            <summary>Scan Ahead Capacity</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_FEEDER_CONTROL">
            <summary>Feeder Control</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_PADDING">
            <summary>Printer/Endorser Padding</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_FONT_TYPE">
            <summary>Printer/Endorser Font Type</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_ALARM">
            <summary>Alarm</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_INK">
            <summary>Printer/Endorser Ink</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_CHARACTER_ROTATION">
            <summary>Printer/Endorser Character Rotation</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_MAX_CHARACTERS">
            <summary>Printer/Endorser Maximum Characters</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_MAX_GRAPHICS">
            <summary>Printer/Endorser Maximum Graphics</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_PRINTER_ENDORSER_COUNTER_DIGITS">
            <summary>Printer/Endorser Counter Digits</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_COLOR_DROP_MULTI">
            <summary>Color Drop Multiple</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_BLANK_PAGES_SENSITIVITY">
            <summary>Blank Pages Sensitivity</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_PROPID.WIA_IPS_MULTI_FEED_DETECT_METHOD">
            <summary>Multi-Feed Detection Method</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WiaDevCap">
            <summary>Selects the type of capabilities to enumerate in IWiaItem.EnumDeviceCapabilities.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaDevCap.WIA_DEVICE_COMMANDS">
            <summary>Enumerate device commands.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaDevCap.WIA_DEVICE_EVENTS">
            <summary>Enumerate device events.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WiaDevDlg">
            <summary>Options for IWiaItem.DeviceDlg.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaDevDlg.WIA_DEVICE_DIALOG_SINGLE_IMAGE">
            <summary>Restrict image selection to a single image in the device image acquisition dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaDevDlg.WIA_DEVICE_DIALOG_USE_COMMON_UI">
            <summary>
            Use the system UI, if available, rather than the vendor-supplied UI. If the system UI is not available, the vendor UI is
            used. If neither UI is available, the function returns E_NOTIMPL.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WiaImageIntent">
            <summary>Image Intent Constants.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_NONE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_IMAGE_TYPE_COLOR">
            <summary>Preset properties for color content.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_IMAGE_TYPE_GRAYSCALE">
            <summary>Preset properties for grayscale content.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_IMAGE_TYPE_TEXT">
            <summary>Preset properties for text content.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_MINIMIZE_SIZE">
            <summary>Preset properties to minimize image size.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_MAXIMIZE_QUALITY">
            <summary>Preset properties to maximize image quality.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaImageIntent.WIA_INTENT_BEST_PREVIEW">
            <summary>Specifies the best quality preview.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WiaItemType">
            <summary>Specify the Windows Image Acquisition (WIA) item type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeFree">
            <summary>The item is uninitialized or has been deleted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeImage">
            <summary>The item is an image file. Only valid for items that also have the WiaItemTypeFile attribute.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeFile">
            <summary>The item is a file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeFolder">
            <summary>The item is a folder.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeRoot">
            <summary>
            Identifies the root item in the device's tree of item objects. This constant is supported only by Windows Vista and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeAnalyze">
            <summary>This item supports the IWiaItem::AnalyzeItem method. This constant is not supported by Windows Vista and later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeAudio">
            <summary>The item is an audio file. Only valid for items that also have the WiaItemTypeFile attribute.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeDevice">
            <summary>The item represents a connected device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeDeleted">
            <summary>The item is marked as deleted from the tree.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeDisconnected">
            <summary>The item represents a disconnected device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeHPanorama">
            <summary>The item represents a horizontal panoramic image. This constant is not supported by Windows Vista and later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeVPanorama">
            <summary>The item represents a vertical panoramic image. This constant is not supported by Windows Vista and later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeBurst">
            <summary>
            For folders only. Images in this folder were taken in a continuous time sequence. This constant is not supported by Windows
            Vista and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeStorage">
            <summary>The item represents a storage medium.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeTransfer">
            <summary>The item can be transferred.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeGenerated">
            <summary>
            This item was created by the application or the driver, and does not have a corresponding item in the driver item tree.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeHasAttachments">
            <summary>The item has file attachments. This constant is not supported by Windows Vista and later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeVideo">
            <summary>
            The item represents streaming video. This constant is not supported by either Windows Server 2003*,* Windows Vista*, or later.*
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeTwainCapabilityPassThrough">
            <summary>
            This type indicates that the WIA device is capable of receiving TWAIN capability data from the TWAIN compatibility layer. If
            this type is set, any TWAIN capability that isn't understood by the TWAIN compatibility layer, during a TWAIN session, will
            be passed to the WIA driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeRemoved">
            <summary>The item has been removed from the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeDocument">
            <summary>The item represents a document. This constant is supported only by Windows Vista and later.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WiaItemType.WiaItemTypeProgrammableDataSource">
            <summary>The item represents a programmable data source. This constant is supported only by Windows Vista and later.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS">
            <summary>
            The <c>IEnumWIA_DEV_CAPS</c> interface enumerates the currently available Windows Image Acquisition (WIA) hardware device
            capabilities. Device capabilities include commands and events that the device supports.
            </summary>
            <remarks>
            <para>
            The <c>IEnumWIA_DEV_CAPS</c> interface is a specific implementation for WIA of the standard OLE enumeration interface. For
            details, see IEnumXXXX.
            </para>
            <para>
            Applications obtain a pointer to the <c>IEnumWIA_DEV_CAPS</c> interface by invoking the IWiaItem::EnumDeviceCapabilities method.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS.Next(System.UInt32,Vanara.PInvoke.OleAut32.WIA_DEV_CAP[],System.UInt32@)">
            <summary>The <c>IEnumWIA_DEV_CAPS::Next</c> method fills an array of pointers to WIA_DEV_CAP structures.</summary>
            <param name="celt">Specifies the number of array elements in the array indicated by the rgelt parameter.</param>
            <param name="rgelt">Pointer to an array of WIA_DEV_CAP structures. IEnumWIA_DEV_CAPS::Next fills this array of structures.</param>
            <param name="pceltFetched">
            On output, this parameter contains the number of structure pointers actually stored in the array indicated by the rgelt parameter.
            </param>
            <returns>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <remarks>
            <para>
            Applications use this method to query the capabilities of each available Windows Image Acquisition (WIA) hardware device. To
            do so, the application passes a pointer to an array of WIA_DEV_CAP structures that it allocates. It also passes in the
            number of array elements in the parameter celt. The <c>IEnumWIA_DEV_CAPS::Next</c> method fills the array with structures.
            Applications then use the structures to enumerate WIA hardware device capabilities.
            </para>
            <para>
            WIA device capabilities are defined as events and commands that the device supports. Using the rgelt array,
            <c>IEnumWIA_DEV_CAPS::Next</c> passes a single structure to the application for each event and command that the device supports.
            </para>
            <para>
            Note that <c>IEnumWIA_DEV_CAPS::Next</c> dynamically allocates the WIA_DEV_CAP structures it provides to applications.
            Therefore, applications must delete the <c>WIA_DEV_CAP</c> structures they receive through the rgelt parameter. Applications
            should use SysFreeString to free the bstrName, bstrDescription, and bstrIcon fields of all <c>WIA_DEV_CAP</c> structures.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS.Skip(System.UInt32)">
            <summary>
            The <c>IEnumWIA_DEV_CAPS::Skip</c> method skips the specified number of hardware device capabilities during an enumeration
            of available device capabilities.
            </summary>
            <param name="celt">Specifies the number of items to skip.</param>
            <returns>
            If the method succeeds, the method returns S_OK. It returns S_FALSE if it could not skip the specified number of device
            capabilities. If the method fails, it returns a standard COM error code.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS.Reset">
            <summary>The <c>IEnumWIA_DEV_CAPS::Reset</c> method is used by applications to restart the enumeration of device capabilities.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS.Clone">
            <summary>
            The <c>IEnumWIA_DEV_CAPS::Clone</c> method creates an additional instance of the IEnumWIA_DEV_CAPS interface and sends back
            a pointer to it.
            </summary>
            <returns>Contains the address of a pointer to the instance of IEnumWIA_DEV_CAPS that IEnumWIA_DEV_CAPS::Clone creates.</returns>
            <remarks>Applications must call the IUnknown::Release method on the pointers they receive through the ppIEnum parameter.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_CAPS.GetCount">
            <summary>The <c>IEnumWIA_DEV_CAPS::GetCount</c> method returns the number of elements stored by this enumerator.</summary>
            <returns>The number of elements in the enumeration.</returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO">
            <summary>
            The <c>IEnumWIA_DEV_INFO</c> interface enumerates the currently available Windows Image Acquisition (WIA) hardware devices and
            their properties. Device information properties describe the installation and configuration of WIA hardware devices.
            </summary>
            <remarks>
            <para>
            The <c>IEnumWIA_DEV_INFO</c> interface is a specific implementation for WIA of the standard OLE enumeration interface. For
            details, see IEnumXXXX.
            </para>
            <para>Applications obtain a pointer to the <c>IEnumWIA_DEV_INFO</c> interface by invoking the IWiaDevMgr::EnumDeviceInfo method.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO.Next(System.UInt32,Vanara.PInvoke.OleAut32.IWiaPropertyStorage[],System.UInt32@)">
            <summary>The <c>IEnumWIA_DEV_INFO::Next</c> method fills an array of pointers to IWiaPropertyStorage interfaces.</summary>
            <param name="celt">Specifies the number of array elements in the array indicated by the rgelt parameter.</param>
            <param name="rgelt">
            Receives the address of an array of IWiaPropertyStorage interface pointers. IEnumWIA_DEV_INFO::Next fills this array with
            interface pointers.
            </param>
            <param name="pceltFetched">
            On output, this parameter contains the number of interface pointers actually stored in the array indicated by the rgelt parameter.
            </param>
            <returns>
            While there are devices left to enumerate, this method returns S_OK. It returns S_FALSE when the enumeration is finished. If
            the method fails, it returns a standard COM error code.
            </returns>
            <remarks>
            <para>
            Applications use this method to query the properties of each available Windows Image Acquisition (WIA) hardware device. To
            do so, the application passes an array of IWiaPropertyStorage interface pointers that it allocates. It also passes the
            number of array elements in the parameter celt. The <c>IEnumWIA_DEV_INFO::Next</c> method fills the array with pointers to
            <c>IWiaPropertyStorage</c> interfaces. Applications can query the interfaces for the properties that the device supports.
            </para>
            <para>Applications must call the IUnknown::Release method on the interface pointers they receive through the rgelt parameter.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO.Skip(System.UInt32)">
            <summary>
            The <c>IEnumWIA_DEV_INFO::Skip</c> method skips the specified number of hardware devices during an enumeration of available devices.
            </summary>
            <param name="celt">Specifies the number of devices to skip.</param>
            <returns>
            If the method succeeds, the method returns S_OK. If it is unable to skip the specified number of devices, it returns
            S_FALSE. If the method fails, it returns a standard COM error code.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO.Reset">
            <summary>The <c>IEnumWIA_DEV_INFO::Reset</c> method is used by applications to restart the enumeration of device information.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO.Clone">
            <summary>
            The <c>IEnumWIA_DEV_INFO::Clone</c> method creates an additional instance of the IEnumWIA_DEV_INFO interface and sends back
            a pointer to it.
            </summary>
            <returns>
            Pointer to an IEnumWIA_DEV_INFO interface. This parameter contains a pointer to the IEnumWIA_DEV_INFO interface instance
            that IEnumWIA_DEV_INFO::Clone creates.
            </returns>
            <remarks>Applications must call the IUnknown::Release method on the pointers they receive through the ppIEnum parameter.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_DEV_INFO.GetCount">
            <summary>The <c>IEnumWIA_DEV_INFO::GetCount</c> method returns the number of elements stored by this enumerator.</summary>
            <returns>The number of elements in the enumeration.</returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO">
            <summary>Use the <c>IEnumWIA_FORMAT_INFO</c> interface to enumerate the format and media type information for a device.</summary>
            <remarks>
            <para>
            The <c>IEnumWIA_FORMAT_INFO</c> interface is a specific implementation for Windows Image Acquisition (WIA) of the standard
            Component Object Model (COM) enumeration interface. For details, see IEnumXXXX.
            </para>
            <para>
            Applications obtain a pointer to the <c>IEnumWIA_FORMAT_INFO</c> interface by invoking the
            IWiaDataTransfer::idtEnumWIA_FORMAT_INFO method of an item's IWiaDataTransfer interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO.Next(System.UInt32,Vanara.PInvoke.OleAut32.WIA_FORMAT_INFO[],System.UInt32@)">
            <summary>The <c>IEnumWIA_FORMAT_INFO::Next</c> method returns an array of WIA_FORMAT_INFO structures.</summary>
            <param name="celt">Specifies the number of elements requested.</param>
            <param name="rgelt">Receives the address of the array of WIA_FORMAT_INFO structures.</param>
            <param name="pceltFetched">
            On output, receives the address of a ULONG that contains the number of WIA_FORMAT_INFO structures actually returned in the
            rgelt parameter.
            </param>
            <returns>
            If the enumeration is continuing, this method returns S_OK and sets the value pointed to by pceltFetched to the number of
            capabilities returned. If the enumeration is complete, it returns S_FALSE and sets the value pointed to by pceltFetched to
            zero. If the method fails, it returns a standard COM error.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO.Skip(System.UInt32)">
            <summary>The <c>IEnumWIA_FORMAT_INFO::Skip</c> method skips the specified number of structures in the enumeration.</summary>
            <param name="celt">Specifies the number of structures to skip.</param>
            <returns>
            This method returns S_OK if it is able to skip the specified number of elements. It returns S_FALSE if it is unable to skip
            the specified number of elements. If the method fails, it returns a standard COM error.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO.Reset">
            <summary>The <c>IEnumWIA_FORMAT_INFO::Reset</c> method sets the enumeration back to the first WIA_FORMAT_INFO structure.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO.Clone">
            <summary>
            The <c>IEnumWIA_FORMAT_INFO::Clone</c> method creates an additional instance of the IEnumWIA_FORMAT_INFO interface and
            returns an interface pointer to the new interface.
            </summary>
            <returns>Pointer to a new IEnumWIA_FORMAT_INFO interface.</returns>
            <remarks>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnum parameter.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWIA_FORMAT_INFO.GetCount">
            <summary>The <c>IEnumWIA_FORMAT_INFO::GetCount</c> method returns the number of elements stored by this enumerator.</summary>
            <returns>The number of elements in the enumeration.</returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IEnumWiaItem">
            <summary>
            <para>
            The <c>IEnumWiaItem</c> interface is used by applications to enumerate IWiaItem objects in the tree's current folder. The
            Windows Image Acquisition (WIA) run-time system represents every WIA hardware device to applications as a hierarchical tree of
            <c>IWiaItem</c> objects.
            </para>
            <para><c>Note</c> For Windows Vista applications, use IEnumWiaItem2 instead of <c>IEnumWiaItem</c>.</para>
            </summary>
            <remarks>
            <para>
            The <c>IEnumWiaItem</c> interface is a specific implementation for WIA of the standard Component Object Model (COM) enumeration
            interface. For details, see IEnumXXXX.
            </para>
            <para>Applications obtain a pointer to the <c>IEnumWiaItem</c> interface by invoking the IWiaItem::EnumChildItems method.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWiaItem.Next(System.UInt32,Vanara.PInvoke.OleAut32.IWiaItem[],System.UInt32@)">
            <summary>The <c>IEnumWiaItem::Next</c> method fills an array of pointers to IWiaItem interfaces.</summary>
            <param name="celt">Specifies the number of array elements in the array indicated by the ppIWiaItem parameter.</param>
            <param name="rgelt">
            Receives the address of an array of IWiaItem interface pointers. IEnumWiaItem::Next fills this array with interface pointers.
            </param>
            <param name="pceltFetched">
            On output, this parameter receives the number of interface pointers actually stored in the array indicated by the ppIWiaItem
            parameter. When the enumeration is complete, this parameter will contain zero.
            </param>
            <returns>
            If the method succeeds, the method returns S_OK. When the enumeration is complete, it returns S_FALSE. If the method fails,
            it returns a standard COM error code.
            </returns>
            <remarks>
            <para>
            The Windows Image Acquisition (WIA) run-time system represents WIA hardware devices as a hierarchical tree of IWiaItem
            objects. Applications use the <c>IEnumWiaItem::Next</c> method to obtain an <c>IWiaItem</c> interface pointer for each item
            in the current folder of a hardware device's <c>IWiaItem</c> object tree.
            </para>
            <para>
            To obtain the list of pointers, the application passes an array of IWiaItem interface pointers that it allocates. It also
            passes the number of array elements in the celt parameter. The <c>IEnumWiaItem::Next</c> method fills the array with
            pointers to <c>IWiaItem</c> interfaces.
            </para>
            <para>
            Until the enumeration process completes, the <c>IEnumWiaItem::Next</c> method returns S_OK. Each time it does, it sets the
            value pointed to by pceltFetched to the number of items it inserted into the array. When <c>IEnumWiaItem::Next</c> finishes
            the process of enumerating IWiaItem objects, it returns S_FALSE and sets the memory location pointed to by pceltFetched to zero.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIWiaItem parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWiaItem.Skip(System.UInt32)">
            <summary>
            The <c>IEnumWiaItem::Skip</c> method skips the specified number of items during an enumeration of available IWiaItem objects.
            </summary>
            <param name="celt">Specifies the number of items to skip.</param>
            <returns>
            If the method succeeds, the method returns S_OK. If it is unable to skip the specified number of items, it returns S_FALSE.
            If the method fails, it returns a standard COM error code.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWiaItem.Reset">
            <summary>The <c>IEnumWiaItem::Reset</c> method is used by applications to restart the enumeration of item information.</summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWiaItem.Clone">
            <summary>
            The <c>IEnumWiaItem::Clone</c> method creates an additional instance of the IEnumWiaItem interface and sends back a pointer
            to it.
            </summary>
            <returns>
            Pointer to the IEnumWiaItem interface. Receives the address of the IEnumWiaItem interface instance that IEnumWiaItem::Clone creates.
            </returns>
            <remarks>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnum parameter.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IEnumWiaItem.GetCount">
            <summary>The <c>IEnumWiaItem::GetCount</c> method returns the number of elements stored by this enumerator.</summary>
            <returns>The number of elements in the enumeration.</returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaDataCallback">
            <summary>
            <para>
            Provides an application callback mechanism during data transfers from Windows Image Acquisition (WIA) hardware devices to applications.
            </para>
            <para><c>Note</c> For Windows Vista applications, use IWiaTransferCallback instead of <c>IWiaDataCallback</c>.</para>
            </summary>
            <remarks>
            <para>
            The <c>IWiaDataCallback</c> interface, like all Component Object Model (COM) interfaces, inherits the IUnknown interface methods.
            </para>
            <list type="table">
            <listheader>
            <term>IUnknown Methods</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IUnknown::QueryInterface</term>
            <term>Returns pointers to supported interfaces.</term>
            </item>
            <item>
            <term>IUnknown::AddRef</term>
            <term>Increments reference count.</term>
            </item>
            <item>
            <term>IUnknown::Release</term>
            <term>Decrements reference count.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataCallback.BandedDataCallback(Vanara.PInvoke.OleAut32.IT_MSG,Vanara.PInvoke.OleAut32.IT_STATUS,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Provides data transfer status notifications. Windows Image Acquisition (WIA) data transfer methods of the IWiaDataTransfer
            interface periodically call this method.
            </summary>
            <param name="lMessage">
            <para>Type: <c>int</c></para>
            <para>Specifies a constant that indicates the reason for the callback. Can be one of the following values:</para>
            <para>IT_MSG_DATA</para>
            <para>The WIA system is transferring data to the application.</para>
            <para>IT_MSG_DATA_HEADER</para>
            <para>The application is receiving a header prior to receiving the actual data.</para>
            <para>IT_MSG_DEVICE_STATUS</para>
            <para>Windows Vista or later. Status at the device has changed.</para>
            <para>IT_MSG_FILE_PREVIEW_DATA</para>
            <para>The WIA system is transferring preview data to the application.</para>
            <para>IT_MSG_FILE_PREVIEW_DATA_HEADER</para>
            <para>The application is receiving a header prior to receiving the actual preview data.</para>
            <para>IT_MSG_NEW_PAGE</para>
            <para>The data transfer is beginning a new page.</para>
            <para>IT_MSG_STATUS</para>
            <para>This invocation of the callback is sending only status information.</para>
            <para>IT_MSG_TERMINATION</para>
            <para>The data transfer is complete.</para>
            </param>
            <param name="lStatus">
            <para>Type: <c>int</c></para>
            <para>Specifies a constant that indicates the status of the WIA device. Can be set to a combination of the following:</para>
            <para>IT_STATUS_TRANSFER_FROM_DEVICE</para>
            <para>Data is currently being transferred from the WIA device.</para>
            <para>IT_STATUS_PROCESSING_DATA</para>
            <para>Data is currently being processed.</para>
            <para>IT_STATUS_TRANSFER_TO_CLIENT</para>
            <para>Data is currently being transferred to the client's data buffer.</para>
            </param>
            <param name="lPercentComplete">
            <para>Type: <c>int</c></para>
            <para>Specifies the percentage of the total data that has been transferred so far.</para>
            </param>
            <param name="lOffset">
            <para>Type: <c>int</c></para>
            <para>Specifies an offset, in bytes, from the beginning of the buffer where the current band of data begins.</para>
            </param>
            <param name="lLength">
            <para>Type: <c>int</c></para>
            <para>Specifies the length, in bytes, of the current band of data.</para>
            </param>
            <param name="lReserved">
            <para>Type: <c>int</c></para>
            <para>Reserved for internal use by the WIA run-time system.</para>
            </param>
            <param name="lResLength">
            <para>Type: <c>int</c></para>
            <para>Reserved for internal use by the WIA run-time system.</para>
            </param>
            <param name="pbBuffer">
            <para>Type: <c>BYTE*</c></para>
            <para>Pointer to the data buffer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            If the method succeeds, the method returns S_OK. To cancel the data transfer, it returns S_FALSE. If the method fails, it
            returns a standard COM error code.
            </para>
            </returns>
            <remarks>
            <para>
            Your application must provide the <c>IWiaDataCallback::BandedDataCallback</c> method. This method is periodically invoked by
            the data transfer methods of the IWiaDataTransfer interface. It provides status messages to the application during the data
            transfer. By returning S_FALSE, your program can also use this method to prematurely terminate the data transfer.
            </para>
            <para>
            When this method is invoked, the lMessage parameter will contain the reason for the call. Not all parameters will contain
            data on all calls. For example, when <c>IWiaDataCallback::BandedDataCallback</c> is invoked with a message of
            IT_MSG_TERMINATION, it should not attempt to use the values in the pbBuffer, lOffset, and lLength parameters.
            </para>
            <para>
            If the value of lMessage is IT_MSG_DATA, the buffer pointed to by pbBuffer contains a band of image data. The lOffset
            parameter contains an offset in bytes from the beginning of the buffer where the current band of data begins. The lLength
            parameter specified the length in bytes of the current band of data.
            </para>
            <para>
            During calls where lMessage is set to IT_MSG_DATA or IT_MSG_STATUS, the lStatus parameter contains a valid value. Its
            contents should not be used when lMessage contains other values.
            </para>
            <para>If lMessage is IT_MSG_DATA_HEADER, the pbBuffer parameter points to a WIA_DATA_CALLBACK_HEADER structure.</para>
            <para>
            When an error has occurred during an image data transfer, the driver sets lMessage to IT_MSG_DEVICE_STATUS. The proxy
            callback object calls ReportStatus, which handles the error and displays messages to the user.
            </para>
            <para>Examples</para>
            <para>The following example shows one possible way to implement the <c>IWiaDataCallback::BandedDataCallback</c> method.</para>
            <para>
            The example application code defines the <c>CDataCallback</c> object that it derives from the IWiaDataCallback interface.
            The application must instantiate a <c>CDataCallback</c> object. It then calls <c>CDataCallback::QueryInterface</c> to obtain
            an <c>IWiaDataCallback</c> interface pointer. When the application is ready to receive data, it invokes the idtGetBandedData
            method and passes the method a pointer to the <c>IWiaDataCallback</c> interface.
            </para>
            <para>
            Periodically, the idtGetBandedData method uses the IWiaDataCallback interface pointer to invoke the
            <c>CDataCallback::BandedDataCallback</c> method of the application. The first invocations send status messages. These are
            followed by a call that transfers a data header to the callback method. After the application receives the data header,
            <c>idtGetBandedData</c> invokes <c>CDataCallback::BandedDataCallback</c> to transfer data to the application. When the data
            transfer is complete, it calls the callback method a final time to transmit a termination message.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaDataTransfer">
            <summary>
            <para>
            The <c>IWiaDataTransfer</c> interface is a high performance data transfer interface. This interface supports a shared memory
            window to transfer data from the device object to the application, and eliminates unnecessary data copies during marshalling. A
            callback mechanism is provided in the form of the IWiaDataCallback interface. It enables applications to obtain data transfer
            status notification, transfer data from the Windows Image Acquisition (WIA) device to the application, and cancel pending data transfers.
            </para>
            <para><c>Note</c> For Windows Vista applications, use IWiaTransfer instead of <c>IWiaDataTransfer</c>.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataTransfer.idtGetData(System.Runtime.InteropServices.ComTypes.STGMEDIUM@,Vanara.PInvoke.OleAut32.IWiaDataCallback)">
            <summary>
            The <c>IWiaDataTransfer::idtGetData</c> method retrieves complete files from a Windows Image Acquisition (WIA) device.
            </summary>
            <param name="pMedium">
            <para>Type: <c>LPSTGMEDIUM</c></para>
            <para>Pointer to the STGMEDIUM structure.</para>
            </param>
            <param name="pIWiaDataCallback">
            <para>Type: <c>IWiaDataCallback*</c></para>
            <para>Pointer to the IWiaDataCallback interface.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method can return any one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters to this method contain invalid data.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>This method cannot allocate enough memory to complete its operation.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unknown error occurred.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The application canceled the operation.</term>
            </item>
            <item>
            <term>S_OK</term>
            <term>The image was successfully acquired.</term>
            </item>
            <item>
            <term>STG_E_MEDIUMFULL</term>
            <term>The storage medium the application is using to acquire the image is full.</term>
            </item>
            <item>
            <term>WIA_S_NO_DEVICE_AVAILABLE</term>
            <term>There are no WIA hardware devices attached to the user's computer.</term>
            </item>
            </list>
            <para>
            This method will return a value specified in Error Codes, or a standard COM error if it fails for any reason other than
            those specified in the preceding table.
            </para>
            </returns>
            <remarks>
            <para>
            In most respects, this method operates identically to the IDataObject::GetData method. The primary difference is that
            <c>IWiaDataTransfer::idtGetData</c> provides an additional parameter for a pointer to the IWiaDataCallback interface.
            Applications use this optional parameter to obtain status notifications during the data transfer. If no status notifications
            are needed, it should be set to zero.
            </para>
            <para>
            The format of the data transfer is determined by the values of the item's WIA_IPA_FORMAT and <c>WIA_IPA_TYMED</c>
            properties. The application sets these properties with calls to the IWiaPropertyStorage::WriteMultiple method.
            </para>
            <para>
            Unlike the IWiaDataTransfer::idtGetBandedData method, <c>IWiaDataTransfer::idtGetData</c> transfers a complete file from a
            WIA device to an application rather than just a single band of data. The pMedium parameter is a pointer to the STGMEDIUM
            structure which contains information on the storage medium to be used for the data transfer. Programs use the
            pIWiaDataCallback parameter to pass this method a pointer to the IWiaDataCallback interface. Periodically, this method will
            use the interface pointer to invoke the BandedDataCallback method and provide the application with status information about
            the data transfer in progress.
            </para>
            <para>
            Pass <c>NULL</c> as the value of the <c>lpszFileName</c> member of the pMedium structure to allow WIA to determine the file
            name and location for the new file. Upon return, the <c>lpszFileName</c> member of the pMedium structure contains the
            location and name of the new file.
            </para>
            <para>
            If the value returned by this method is a COM SUCCESS value or the transfer is a multipage file transfer, and the error code
            returned is WIA_ERROR_PAPER_JAM, WIA_ERROR_PAPER_EMPTY, or WIA_ERROR_PAPER_PROBLEM, WIA does not delete the file.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataTransfer.idtGetBandedData(Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO@,Vanara.PInvoke.OleAut32.IWiaDataCallback)">
            <summary>
            The <c>IWiaDataTransfer::idtGetBandedData</c> method transfers a band of data from a hardware device to an application. For
            efficiency, applications retrieve data from Windows Image Acquisition (WIA) hardware devices in successive bands.
            </summary>
            <param name="pWiaDataTransInfo">
            <para>Type: <c>PWIA_DATA_TRANSFER_INFO</c></para>
            <para>Pointer to the WIA_DATA_TRANSFER_INFO structure.</para>
            </param>
            <param name="pIWiaDataCallback">
            <para>Type: <c>IWiaDataCallback*</c></para>
            <para>
            Pointer to the IWiaDataCallback interface. Periodically, this method will call the BandedDataCallback method to provide the
            application with data transfer status notification.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method can return any one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>E_INVALIDARG</term>
            <term>One or more parameters to this method contain invalid data.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>This method cannot allocate enough memory to complete its operation.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>An unknown error occurred.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The application canceled the operation.</term>
            </item>
            <item>
            <term>S_OK</term>
            <term>The image was successfully acquired.</term>
            </item>
            <item>
            <term>STG_E_MEDIUMFULL</term>
            <term>The storage medium the application is using to acquire the image is full.</term>
            </item>
            <item>
            <term>WIA_S_NO_DEVICE_AVAILABLE</term>
            <term>There are no WIA hardware devices attached to the user's computer.</term>
            </item>
            </list>
            <para>
            This method will return a value specified in Error Codes, or a standard COM error if it fails for any reason other than
            those specified in the preceding table.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>IWiaDataTransfer::idtGetBandedData</c> method allocates a section of memory to transfer data without requiring an
            extra data copy through the Component Object Model/Remote Procedure Call (COM/RPC) marshalling layer. This memory section is
            shared between the application and the hardware device's item tree.
            </para>
            <para>
            Optionally, the application can pass in a pointer to a block of memory that <c>IWiaDataTransfer::idtGetBandedData</c> will
            use as its shared section. The application passes this handle by storing the pointer in the <c>ulSection</c> member of the
            WIA_DATA_TRANSFER_INFO structure prior to calling <c>IWiaDataTransfer::idtGetBandedData</c>.
            </para>
            <para>
            Applications can improve performance by using double buffering. To do this, applications must set the <c>bDoubleBuffer</c>
            member of the WIA_DATA_TRANSFER_INFO structure to <c>TRUE</c>. The <c>IWiaDataTransfer::idtGetBandedData</c> method will
            divide the data buffer in half. When one half of the buffer is full, <c>IWiaDataTransfer::idtGetBandedData</c> will send a
            notification to the application using the IWiaDataCallback pointer passed in through the pIWiaDataCallback parameter. While
            the application is retrieving the data from the full half of the buffer, the device driver can fill the other half with data.
            </para>
            <para>
            The format of the data transfer is determined by the values of the item's WIA_IPA_FORMAT and <c>WIA_IPA_TYMED</c>
            properties. The application sets these properties with calls to the IWiaPropertyStorage::WriteMultiple method.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataTransfer.idtQueryGetData(Vanara.PInvoke.OleAut32.WIA_FORMAT_INFO@)">
            <summary>
            The <c>IWiaDataTransfer::idtQueryGetData</c> method is used by applications to query a Windows Image Acquisition (WIA)
            device to determine what types of data formats it supports.
            </summary>
            <param name="pfe">
            <para>Type: <c>WIA_FORMAT_INFO*</c></para>
            <para>Pointer to a WIA_FORMAT_INFO structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            If this method succeeds, it returns S_OK. Otherwise it returns a value specified in Error Codes, or a standard COM error.
            </para>
            </returns>
            <remarks>
            This method queries a device to determine the data formats it supports. Prior to a data transfer, an application can fill in
            the WIA_FORMAT_INFO structure with the intended medium and data format information. It then calls
            <c>IWiaDataTransfer::idtQueryGetData</c> and receives a return value of S_OK if the data format and media type are supported
            by this device.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataTransfer.idtEnumWIA_FORMAT_INFO">
            <summary>
            The <c>IWiaDataTransfer::idtEnumWIA_FORMAT_INFO</c> method creates a banded transfer implementation of the
            IEnumWIA_FORMAT_INFO interface.
            </summary>
            <returns>Receives the address of a pointer to the IEnumWIA_FORMAT_INFO interface.</returns>
            <remarks>
            <para>
            This method creates the IEnumWIA_FORMAT_INFO interface that applications use to enumerate an array of WIA_FORMAT_INFO
            structures. This provides applications with the ability to determine the formats and media types of incoming data when
            transferring banded data.
            </para>
            <para>
            Note that applications must call IUnknown::Release method on the interface pointers they receive through the ppEnum parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDataTransfer.idtGetExtendedTransferInfo(Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO@)">
            <summary>
            The <c>IWiaDataTransfer::idtGetExtendedTransferInfo</c> retrieves extended information relating to data transfer buffers in
            the case of banded data transfers. Applications typically use this method to retrieve driver recommended settings for
            minimum buffer size, maximum buffer size, and optimal buffer size for banded data transfers.
            </summary>
            <param name="pExtendedTransferInfo">
            <para>Type: <c>PWIA_EXTENDED_TRANSFER_INFO</c></para>
            <para>Pointer to a WIA_EXTENDED_TRANSFER_INFO structure containing the extended information.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaDevMgr">
            <summary>
            <para>
            Applications use the <c>IWiaDevMgr</c> interface to create and manage image acquisition devices. They also use it to register to
            receive device events.
            </para>
            <para><c>Note</c> For Windows Vista applications, use IWiaDevMgr2 instead of <c>IWiaDevMgr</c>.</para>
            </summary>
            <remarks>
            <para>The <c>IWiaDevMgr</c> interface, like all Component Object Model (COM) interfaces, inherits the IUnknown interface methods.</para>
            <list type="table">
            <listheader>
            <term>IUnknown Methods</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IUnknown::QueryInterface</term>
            <term>Returns pointers to supported interfaces.</term>
            </item>
            <item>
            <term>IUnknown::AddRef</term>
            <term>Increments reference count.</term>
            </item>
            <item>
            <term>IUnknown::Release</term>
            <term>Decrements reference count.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.EnumDeviceInfo(System.Int32)">
            <summary>
            Applications use the <c>IWiaDevMgr::EnumDeviceInfo</c> method to enumerate property information for each available Windows
            Image Acquisition (WIA) device.
            </summary>
            <param name="lFlag">
            <para>Type: <c>LONG</c></para>
            <para>Specifies the types of WIA devices to enumerate. Should be set to WIA_DEVINFO_ENUM_LOCAL.</para>
            </param>
            <returns>
            <para>Type: <c>IEnumWIA_DEV_INFO**</c></para>
            <para>Receives the address of a pointer to the IEnumWIA_DEV_INFO interface.</para>
            </returns>
            <remarks>
            <para>
            The <c>IWiaDevMgr::EnumDeviceInfo</c> method creates an enumerator object, that supports the IEnumWIA_DEV_INFO interface.
            <c>IWiaDevMgr::EnumDeviceInfo</c> stores a pointer to the <c>IEnumWIA_DEV_INFO</c> interface in the parameter ppIEnum.
            Applications can use the <c>IEnumWIA_DEV_INFO</c> interface pointer to enumerate the properties of each WIA device attached
            to the user's computer.
            </para>
            <para>Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnum parameter.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.CreateDevice(System.String)">
            <summary>
            The <c>IWiaDevMgr::CreateDevice</c> creates a hierarchical tree of IWiaItem objects for a Windows Image Acquisition (WIA) device.
            </summary>
            <param name="bstrDeviceID">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the unique identifier of the WIA device.</para>
            </param>
            <returns>
            <para>Type: <c>IWiaItem**</c></para>
            <para>Pointer to a pointer to the IWiaItem interface of the root item in the hierarchical tree for the WIA device.</para>
            </returns>
            <remarks>
            <para>
            Applications use the <c>IWiaDevMgr::CreateDevice</c> method to create a device object for the WIA devices specified by the
            bstrDeviceID parameter.
            </para>
            <para>
            When it returns, the <c>IWiaDevMgr::CreateDevice</c> method stores an address of a pointer in the parameter ppWiaItemRoot.
            The pointer points to the root item of the tree of IWiaItem objects created by <c>IWiaDevMgr::CreateDevice</c>. Applications
            can use this tree of objects to control and retrieve data from the WIA device.
            </para>
            <para>
            Note that applications must call the IUnknown::Release method on the pointers they receive through the ppWiaItemRoot parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.SelectDeviceDlg(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.String@,Vanara.PInvoke.OleAut32.IWiaItem@)">
            <summary>
            The <c>IWiaDevMgr::SelectDeviceDlg</c> displays a dialog box that enables the user to select a hardware device for image acquisition.
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>Handle of the window that owns the <c>Select Device</c> dialog box.</para>
            </param>
            <param name="lDeviceType">
            <para>Type: <c>LONG</c></para>
            <para>
            Specifies which type of WIA device to use. Can be set to <c>StiDeviceTypeDefault</c>, <c>StiDeviceTypeScanner</c>, or <c>StiDeviceTypeDigitalCamera</c>.
            </para>
            </param>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies dialog box behavior. Can be set to any of the following values:</para>
            <list type="table">
            <listheader>
            <term>Constant</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Use the default behavior.</term>
            </item>
            <item>
            <term>WIA_SELECT_DEVICE_NODEFAULT</term>
            <term>
            Display the dialog box even if there is only one matching device. For more information, see the Remarks section of this
            reference page.
            </term>
            </item>
            </list>
            </param>
            <param name="pbstrDeviceID">
            <para>Type: <c>BSTR*</c></para>
            <para>
            On output, receives a string which contains the device's identifier string. On input, pass the address of a pointer if this
            information is needed, or <c>NULL</c> if it is not needed.
            </para>
            </param>
            <param name="ppItemRoot">
            <para>Type: <c>IWiaItem**</c></para>
            <para>
            Receives the address of a pointer to the IWiaItem interface of the root item of the tree that represents the selected WIA
            device. If no devices are found, it contains the value <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method returns the following values:</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A device was successfully selected.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The user canceled the dialog box.</term>
            </item>
            <item>
            <term>WIA_S_NO_DEVICE_AVAILABLE</term>
            <term>There are no WIA hardware devices that match the specifications given in the lDeviceType parameter.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method creates and displays the <c>Select Device</c> dialog box so the user can select a WIA device for image
            acquisition. If a device is successfully selected, the <c>IWiaDevMgr::SelectDeviceDlg</c> method creates a hierarchical tree
            of IWiaItem objects for the device. It stores a pointer to the <c>IWiaItem</c> interface of the root item in the parameter ppItemRoot.
            </para>
            <para>
            Particular types of devices may be displayed to the user by specifying the device types through the lDeviceType parameter.
            If only one device meets the specification, <c>IWiaDevMgr::SelectDeviceDlg</c> does not display the <c>Select Device</c>
            dialog box. Instead it creates the IWiaItem tree for the device and store a pointer to the <c>IWiaItem</c> interface of the
            root item in the parameter ppItemRoot. You can override this behavior and force <c>IWiaDevMgr::SelectDeviceDlg</c> to
            display the <c>Select Device</c> dialog box by passing WIA_SELECT_DEVICE_NODEFAULT as the value for the lFlags parameter.
            </para>
            <para>
            If more than one WIA device matches the specification, all matching devices are displayed in the <c>Select Device</c> dialog
            box so the user may choose one.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppItemRoot parameter.
            </para>
            <para>
            It is recommended that applications make device and image selection available through a menu item named <c>From scanner or
            camera</c> on the <c>File</c> menu.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.SelectDeviceDlgID(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.String@)">
            <summary>
            The <c>IWiaDevMgr::SelectDeviceDlgID</c> method displays a dialog box that enables the user to select a hardware device for
            image acquisition.
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>Handle of the window that owns the <c>Select Device</c> dialog box.</para>
            </param>
            <param name="lDeviceType">
            <para>Type: <c>LONG</c></para>
            <para>
            Specifies which type of WIA device to use. Can be set to <c>StiDeviceTypeDefault</c>, <c>StiDeviceTypeScanner</c>, or <c>StiDeviceTypeDigitalCamera</c>.
            </para>
            </param>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies dialog box behavior. Can be set to any of the following values:</para>
            <list type="table">
            <listheader>
            <term>Constant</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Use the default behavior.</term>
            </item>
            <item>
            <term>WIA_SELECT_DEVICE_NODEFAULT</term>
            <term>
            Display the dialog box even if there is only one matching device. For more information, see the Remarks section of this
            reference page.
            </term>
            </item>
            </list>
            </param>
            <param name="pbstrDeviceID">
            <para>Type: <c>BSTR*</c></para>
            <para>Pointer to a string that receives the identifier string of the device.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method returns the following values:</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>A device was successfully selected.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The user canceled the dialog box.</term>
            </item>
            <item>
            <term>WIA_S_NO_DEVICE_AVAILABLE</term>
            <term>There are no WIA hardware devices attached to the user's computer that match the specifications.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method works in a similar manner to IWiaDevMgr::SelectDeviceDlg. The primary difference is that if it finds a matching
            device, it does not create the hierarchical tree of IWiaItem objects for the device.
            </para>
            <para>
            Like IWiaDevMgr::SelectDeviceDlg, the <c>IWiaDevMgr::SelectDeviceDlgID</c> method creates and displays the <c>Select
            Device</c> dialog box. This enables the user to select a WIA device for image acquisition. If a device is successfully
            selected, the <c>IWiaDevMgr::SelectDeviceDlgID</c> method passes its identifier string to the application through its
            pbstrDeviceID parameter.
            </para>
            <para>
            Particular types of devices may be displayed to the user by specifying the device types through the lDeviceType parameter.
            If only one device meets the specification, <c>IWiaDevMgr::SelectDeviceDlgID</c> does not display the <c>Select Device</c>
            dialog box. Instead it passes the device's identifier string to the application without displaying the dialog box. You can
            override this behavior and force <c>IWiaDevMgr::SelectDeviceDlgID</c> to display the <c>Select Device</c> dialog box by
            passing WIA_SELECT_DEVICE_NODEFAULT as the value for the lFlags parameter.
            </para>
            <para>
            If more than one WIA device matches the specification, all matching devices are displayed in the <c>Select Device</c> dialog
            box so the user may choose one.
            </para>
            <para>
            It is recommended that applications make device and image selection available through a menu item named <c>From scanner or
            camera</c> on the <c>File</c> menu.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.GetImageDlg(Vanara.PInvoke.HWND,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.OleAut32.IWiaItem,System.String,System.Guid@)">
            <summary>
            The <c>IWiaDevMgr::GetImageDlg</c> method displays one or more dialog boxes that enable a user to acquire an image from a
            Windows Image Acquisition (WIA) device and write the image to a specified file. This method combines the functionality of
            IWiaDevMgr::SelectDeviceDlg to completely encapsulate image acquisition within a single API call.
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>Handle of the window that owns the <c>Get Image</c> dialog box.</para>
            </param>
            <param name="lDeviceType">
            <para>Type: <c>LONG</c></para>
            <para>
            Specifies which type of WIA device to use. Is set to <c>StiDeviceTypeDefault</c>, <c>StiDeviceTypeScanner</c>, or <c>StiDeviceTypeDigitalCamera</c>.
            </para>
            </param>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies dialog box behavior. Can be set to the following values:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Default behavior.</term>
            </item>
            <item>
            <term>WIA_SELECT_DEVICE_NODEFAULT</term>
            <term>
            Force this method to display the Select Device dialog box. For more information, see the Remarks section of this reference page.
            </term>
            </item>
            <item>
            <term>WIA_DEVICE_DIALOG_SINGLE_IMAGE</term>
            <term>Restrict image selection to a single image in the device image acquisition dialog box.</term>
            </item>
            <item>
            <term>WIA_DEVICE_DIALOG_USE_COMMON_UI</term>
            <term>
            Use the system UI, if available, rather than the vendor-supplied UI. If the system UI is not available, the vendor UI is
            used. If neither UI is available, the function returns E_NOTIMPL.
            </term>
            </item>
            </list>
            </param>
            <param name="lIntent">
            <para>Type: <c>LONG</c></para>
            <para>
            Specifies what type of data the image is intended to represent. For a list of image intent values, see Image Intent Constants.
            </para>
            </param>
            <param name="pItemRoot">
            <para>Type: <c>IWiaItem*</c></para>
            <para>Pointer to the interface of the hierarchical tree of IWiaItem objects returned by IWiaDevMgr::CreateDevice.</para>
            </param>
            <param name="bstrFilename">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the name of the file to which the image data is written.</para>
            </param>
            <param name="pguidFormat">
            <para>Type: <c>GUID*</c></para>
            <para>
            On input, contains a pointer to a GUID that specifies the format to use. On output, holds the format used. Pass IID_NULL to
            use the default format.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            <c>IWiaDevMgr::GetImageDlg</c> returns S_FALSE if the user cancels the device selection or image acquisition dialog boxes,
            WIA_S_NO_DEVICE_AVAILABLE if no WIA device is currently available, E_NOTIMPL if no UI is available, and S_OK if the data is
            transferred successfully.
            </para>
            <para>
            <c>IWiaDevMgr::GetImageDlg</c> returns a value specified in Error Codes, or a standard COM error if it fails for any reason
            other than those specified.
            </para>
            </returns>
            <remarks>
            <para>
            Invoking this method displays a dialog box that enables users to acquire images. It can also display the <c>Select
            Device</c> dialog box created by the IWiaDevMgr::SelectDeviceDlg method.
            </para>
            <para>
            If the application passes <c>NULL</c> for the value of the pItemRoot parameter, <c>IWiaDevMgr::GetImageDlg</c> displays the
            <c>Select Device</c> dialog box that lets the user select the WIA input device. If the application specifies a WIA input
            device by passing a pointer to the device's item tree through the pItemRoot parameter, <c>IWiaDevMgr::GetImageDlg</c> does
            not display the <c>Select Device</c> dialog box. Instead, it will use the specified input device to acquire the image.
            </para>
            <para>
            When using the <c>Select Device</c> dialog box, applications can specify types of WIA input devices. To do so, they must set
            the pItemRoot parameter to <c>NULL</c> and pass the appropriate constants through the lDeviceType parameter. If more than
            one device of the specified type is present, the <c>IWiaDevMgr::GetImageDlg</c> displays the <c>Select Device</c> dialog box
            to let the user select which device will be used.
            </para>
            <para>
            If <c>IWiaDevMgr::GetImageDlg</c> finds only one matching device, it will not display the <c>Select Device</c> dialog box.
            Instead, it will select the matching device. You can override this behavior and force <c>IWiaDevMgr::GetImageDlg</c> to
            display the <c>Select Device</c> dialog box by passing WIA_SELECT_DEVICE_NODEFAULT as the value for the lFlags parameter.
            </para>
            <para>
            It is recommended that applications make device and image selection available through a menu item named <c>From scanner or
            camera</c> on the <c>File</c> menu.
            </para>
            <para>
            The dialog must have sufficient rights to the folder for bstrFilename that it can save the file with a unique file name. The
            folder should also be protected with an access control list (ACL) because it contains user data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.RegisterEventCallbackProgram(System.Int32,System.String,System.Guid@,System.String,System.String,System.String,System.String)">
            <summary>
            The <c>IWiaDevMgr::RegisterEventCallbackProgram</c> method registers an application to receive device events. It is
            primarily provided for backward compatibility with applications that were not written for WIA.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies registration flags. Can be set to the following values:</para>
            <list type="table">
            <listheader>
            <term>Registration Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_REGISTER_EVENT_CALLBACK</term>
            <term>Register for the event.</term>
            </item>
            <item>
            <term>WIA_UNREGISTER_EVENT_CALLBACK</term>
            <term>Delete the registration for the event.</term>
            </item>
            <item>
            <term>WIA_SET_DEFAULT_HANDLER</term>
            <term>Set the application as the default event handler.</term>
            </item>
            </list>
            </param>
            <param name="bstrDeviceID">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies a device identifier. Pass <c>NULL</c> to register for the event on all WIA devices.</para>
            </param>
            <param name="pEventGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>Specifies the event for which the application is registering. For a list of valid event GUIDs, see WIA Event Identifiers.</para>
            </param>
            <param name="bstrCommandline">
            <para>Type: <c>BSTR</c></para>
            <para>
            Specifies a string that contains the full path name and the appropriate command-line arguments needed to invoke the
            application. Two pairs of quotation marks should be used, for example, ""C:\Program Files\MyExe.exe" /arg1".
            </para>
            </param>
            <param name="bstrName">
            <para>Type: <c>BSTR</c></para>
            <para>
            Specifies the name of the application. This name is displayed to the user when multiple applications register for the same event.
            </para>
            </param>
            <param name="bstrDescription">
            <para>Type: <c>BSTR</c></para>
            <para>
            Specifies the description of the application. This description is displayed to the user when multiple applications register
            for the same event.
            </para>
            </param>
            <param name="bstrIcon">
            <para>Type: <c>BSTR</c></para>
            <para>
            Specifies the icon that represents the application. The icon is displayed to the user when multiple applications register
            for the same event. The string contains the name of the application and the 0-based index of the icon (there may be more
            than one icon that represent application) separated by a comma. For example, "MyApp, 0".
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Use <c>IWiaDevMgr::RegisterEventCallbackProgram</c> to register for hardware device events of the type WIA_ACTION_EVENT.
            When an event occurs for which an application is registered, the application is launched and the event information is
            transmitted to the application.
            </para>
            <para>
            Applications use the EnumRegisterEventInfo method to retrieve a pointer to an enumerator object for event registration properties.
            </para>
            <para>
            An application can find whether an event is an action type or notification type (or both) event by examinging the
            <c>ulFlags</c> value of a WIA_DEV_CAP structure returned by event enumeration.
            </para>
            <para>
            Programs should only use the <c>IWiaDevMgr::RegisterEventCallbackProgram</c> method for backward compatibility with
            applications not written for the WIA architecture. New applications should use the Component Object Model (COM) interfaces
            provided by the WIA architecture. Specifically, they should call IWiaDevMgr::RegisterEventCallbackInterface or
            IWiaDevMgr::RegisterEventCallbackCLSID to register for device events.
            </para>
            <para>
            Typically, this method is called by an install program or a script. The install program or script registers the application
            to receive WIA device events. When the event occurs, the application will be started by the WIA run-time system.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.RegisterEventCallbackInterface(System.Int32,System.String,System.Guid@,Vanara.PInvoke.OleAut32.IWiaEventCallback)">
            <summary>
            The <c>IWiaDevMgr::RegisterEventCallbackInterface</c> method registers a running application Windows Image Acquisition (WIA)
            event notification.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <param name="bstrDeviceID">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies a device identifier. Pass <c>NULL</c> to register for the event on all WIA devices.</para>
            </param>
            <param name="pEventGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>Specifies the event for which the application is registering. For a list of standard events, see WIA Event Identifiers.</para>
            </param>
            <param name="pIWiaEventCallback">
            <para>Type: <c>IWiaEventCallback*</c></para>
            <para>Pointer to the IWiaEventCallback interface that the WIA system used to send the event notification.</para>
            </param>
            <returns>
            <para>Type: <c>IUnknown**</c></para>
            <para>Receives the address of a pointer to the IUnknown interface.</para>
            </returns>
            <remarks>
            <para>
            <c>Warning</c> Using the <c>IWiaDevMgr::RegisterEventCallbackInterface</c>, IWiaDevMgr2::RegisterEventCallbackInterface, and
            DeviceManager.RegisterEvent methods from the same process after the Still Image Service is restarted may cause an access
            violation, if the functions were used before the service was stopped.
            </para>
            <para>
            When they begin executing, WIA applications use this method to register to receive hardware device events of the type
            WIA_NOTIFICATION_EVENT. This prevents the application from being restarted when another event for which it is registered
            occurs. Once a program invokes <c>IWiaDevMgr::RegisterEventCallbackInterface</c> to register itself to receive WIA events
            from a device, the registered events are routed to the program by the WIA system.
            </para>
            <para>
            Applications use the EnumRegisterEventInfo method to retrieve a pointer to an enumerator object for event registration properties.
            </para>
            <para>
            An application can find whether an event is an action type or notification type (or both) event by examinging the
            <c>ulFlags</c> value of a WIA_DEV_CAP structure returned by event enumeration.
            </para>
            <para>
            Applications can unregister for events by using the IUnknown pointer returned through the pEventObject parameter to call the
            IUnknown::Release method.
            </para>
            <para>
            <c>Note</c> In a multi-threaded application, there is no guarantee that the event notification callback will come in on the
            same thread that registered the callback.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.RegisterEventCallbackCLSID(System.Int32,System.String,System.Guid@,System.Guid@,System.String,System.String,System.String)">
            <summary>
            The <c>IWiaDevMgr::RegisterEventCallbackCLSID</c> method registers an application to receive events even if the application
            may not be running.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies registration flags. Can be set to the following values:</para>
            <list type="table">
            <listheader>
            <term>Registration Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_REGISTER_EVENT_CALLBACK</term>
            <term>Register for the event.</term>
            </item>
            <item>
            <term>WIA_UNREGISTER_EVENT_CALLBACK</term>
            <term>Delete the registration for the event.</term>
            </item>
            <item>
            <term>WIA_SET_DEFAULT_HANDLER</term>
            <term>Set the application as the default event handler.</term>
            </item>
            </list>
            </param>
            <param name="bstrDeviceID">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies a device identifier. Pass <c>NULL</c> to register for the event on all WIA devices.</para>
            </param>
            <param name="pEventGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>Specifies the event for which the application is registering. For a list of standard events, see WIA Event Identifiers.</para>
            </param>
            <param name="pClsID">
            <para>Type: <c>const GUID*</c></para>
            <para>
            Pointer to the application's class ID ( <c>CLSID</c>). The WIA run-time system uses the application's <c>CLSID</c> to start
            the application when an event occurs for which it is registered.
            </para>
            </param>
            <param name="bstrName">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the name of the application that registers for the event.</para>
            </param>
            <param name="bstrDescription">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies a text description of the application that registers for the event.</para>
            </param>
            <param name="bstrIcon">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the name of an image file to be used for the icon for the application that registers for the event.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            WIA applications use this method to register to receive hardware device events of the type WIA_ACTION_EVENT. Once programs
            call <c>IWiaDevMgr::RegisterEventCallbackCLSID</c>, they are registered to receive WIA device events even if they are not running.
            </para>
            <para>
            When the event occurs, the WIA system determines which application is registered to receive the event. It uses the
            CoCreateInstance function and the class ID specified in the pClsID parameter to create an instance of the application. It
            then calls the application's ImageEventCallback method to transmit the event information.
            </para>
            <para>An application can invoke the EnumRegisterEventInfo method to enumerate event registration information.</para>
            <para>
            An application can find whether an event is an action type or notification type (or both) event by examinging the
            <c>ulFlags</c> value of a WIA_DEV_CAP structure returned by event enumeration.
            </para>
            <para>
            If the application is not a registered Component Object Model (COM) component and is not compatible with the WIA
            architecture, developers should use IWiaDevMgr::RegisterEventCallbackProgram instead of this method.
            </para>
            <para>
            <c>Note</c> In a multi-threaded application, there is no guarantee that the event notification callback will come in on the
            same thread that registered the callback.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaDevMgr.AddDeviceDlg(Vanara.PInvoke.HWND,System.Int32)">
            <summary>This method is not implemented.</summary>
            <param name="hwndParent">Type: <c>HWND</c></param>
            <param name="lFlags">Type: <c>LONG</c></param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaEventCallback">
            <summary>
            The <c>IWiaEventCallback</c> interface is used by applications to receive notification of Windows Image Acquisition (WIA)
            hardware device events. An application registers itself to receive event notifications by passing a pointer to the
            <c>IWiaEventCallback</c> interface to the IWiaDevMgr::RegisterEventCallbackInterface method.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaEventCallback.ImageEventCallback(System.Guid@,System.String,System.String,System.String,System.UInt32,System.String,System.UInt32@,System.UInt32)">
            <summary>
            The <c>IWiaEventCallback::ImageEventCallback</c> method is invoked by the Windows Image Acquisition (WIA) run-time system
            when a hardware device event occurs.
            </summary>
            <param name="pEventGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>Specifies the unique identifier of the event. For a complete list of device events, see WIA Event Identifiers.</para>
            </param>
            <param name="bstrEventDescription">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the string description of the event.</para>
            </param>
            <param name="bstrDeviceID">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the unique identifier of the WIA device.</para>
            </param>
            <param name="bstrDeviceDescription">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the string description of the device.</para>
            </param>
            <param name="dwDeviceType">
            <para>Type: <c>DWORD</c></para>
            <para>Specifies the type of the device. See WIA Device Type Specifiers for a list of possible values.</para>
            </param>
            <param name="bstrFullItemName">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the full name of the WIA item that represents the device.</para>
            </param>
            <param name="pulEventType">
            <para>Type: <c>ULONG*</c></para>
            <para>
            Pointer to a <c>ULONG</c> that specifies whether an event is a notification event, an action event, or both. A value of 1
            indicates a notification event, a value of 2 indicates an action event, and a value of 3 indicates that the event is of both
            notification and action type.
            </para>
            </param>
            <param name="ulReserved">
            <para>Type: <c>ULONG</c></para>
            <para>Reserved for user information.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            To receive notification of WIA hardware device events, applications pass a pointer to the IWiaEventCallback interface to the
            RegisterEventCallbackInterface method. The WIA run-time system then uses that interface pointer to invoke the
            <c>IWiaEventCallback::ImageEventCallback</c> method whenever a WIA hardware device event occurs.
            </para>
            <para>
            Note that there is no guarantee the callback will be invoked on the same thread that registered the IWiaEventCallback interface.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaItem">
            <summary>
            Each Windows Image Acquisition (WIA) hardware device is represented to an application as a hierarchical tree of <c>IWiaItem</c>
            objects. The <c>IWiaItem</c> interface provides applications with the ability to query devices to discover their capabilities.
            It also provides access to data transfer interfaces and item properties. In addition, the <c>IWiaItem</c> interface provides
            methods to enable applications to control the device.
            </summary>
            <remarks>
            <para>
            Some of the methods of the <c>IWiaItem</c> interface are valid only on the root item of the device's tree. Other methods are
            valid on all items. The methods are grouped as follows:
            </para>
            <list type="table">
            <item>
            <term>Valid On Root Item Only</term>
            <term>IWiaItem::DeviceCommand</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::DeviceDlg</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::EnumDeviceCapabilities</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::EnumRegisterEventInfo</term>
            </item>
            <item>
            <term>Valid On All Items</term>
            <term>IWiaItem::AnalyzeItem</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::CreateChildItem</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::DeleteItem</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::EnumChildItems</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::FindItemByName</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::GetItemType</term>
            </item>
            <item>
            <term/>
            <term>IWiaItem::GetRootItem</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.GetItemType">
            <summary>The <c>IWiaItem::GetItemType</c> method is called by applications to obtain the type information of an item.</summary>
            <returns>
            <para>Type: <c>LONG*</c></para>
            <para>Receives the address of a <c>LONG</c> variable that contains a combination of WIA Item Type Flags.</para>
            </returns>
            <remarks>
            <para>
            Every IWiaItem object in the hierarchical tree of objects associated with a Windows Image Acquisition (WIA) hardware device
            has a specific data type. Item objects represent folders and files. Folders contain file objects. File objects contain data
            acquired by the device such as images and sounds. This method enables applications to identify the type of any item in a
            hierarchical tree of item objects in a device.
            </para>
            <para>
            An item may have more than one type. For example, an item that represents an audio file will have the type attributes
            WiaItemTypeAudio | <c>WiaItemTypeFile</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.AnalyzeItem(System.Int32)">
            <summary>
            The <c>IWiaItem::AnalyzeItem</c> method causes the Windows Image Acquisition (WIA) hardware device to acquire and try to
            detect what data types are present.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <remarks>
            <para>
            This method is used with scanners to detect what type of data is on a page. When an application calls this method, the WIA
            hardware device driver scans and analyzes the current page. For each data type it detects, it creates an IWiaItem object to
            represent the region on the page the data occupies.
            </para>
            <para>
            Image processing and OCR software can use this capability to detect graphics and text on a page. This method adds the
            regions it creates into the WIA device's IWiaItem tree. The application can select the individual regions and use the
            standard data transfer methods to acquire data from them.
            </para>
            <para>If necessary, applications can override the regions created by this method.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.EnumChildItems">
            <summary>
            The <c>IWiaItem::EnumChildItems</c> method creates an enumerator object and passes back a pointer to its IEnumWiaItem
            interface for non-empty folders in a IWiaItem tree of a Windows Image Acquisition (WIA) device.
            </summary>
            <returns>
            <para>Type: <c>IEnumWiaItem**</c></para>
            <para>Receives the address of a pointer to the IEnumWiaItem interface that <c>IWiaItem::EnumChildItems</c> creates.</para>
            </returns>
            <remarks>
            <para>
            The WIA run-time system represents each WIA hardware device as a hierarchical tree of IWiaItem objects. The
            <c>IWiaItem::EnumChildItems</c> method enables applications to enumerate child items in the current item. However, it can
            only be applied to items that are folders.
            </para>
            <para>
            If the folder is not empty, it contains a subtree of IWiaItem objects. The <c>IWiaItem::EnumChildItems</c> method enumerates
            all of the items contained in the folder. It stores a pointer to an enumerator in the ppIEnumWiaItem parameter. Applications
            use the enumerator pointer to perform the enumeration of an object's child items.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnumWiaItem parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DeleteItem(System.Int32)">
            <summary>The <c>IWiaItem::DeleteItem</c> method removes the current IWiaItem object from the object tree of the device.</summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            This method returns S_OK regardless of how many items were deleted. If the method fails, it returns a standard COM error code.
            </para>
            </returns>
            <remarks>
            <para>
            The Windows Image Acquisition (WIA) run-time system represents each WIA hardware device connected to the user's computer as
            a hierarchical tree of IWiaItem objects. A given WIA device may or may not allow applications to delete <c>IWiaItem</c>
            objects from its tree. Use the IEnumWIA_DEV_CAPS interface to query the device for item deletion capability.
            </para>
            <para>
            If the device supports item deletion in its IWiaItem tree, invoke the <c>IWiaItem::DeleteItem</c> method to remove the
            <c>IWiaItem</c> object. Note that this method will only delete an object after all references to the object have been released.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.CreateChildItem(Vanara.PInvoke.OleAut32.WiaItemType,System.String,System.String)">
            <summary>
            The <c>IWiaItem::CreateChildItem</c> method is used by applications to add IWiaItem objects to the <c>IWiaItem</c> tree of a device.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies the WIA item type. Must be set to one of the values listed in WIA Item Type Flags.</para>
            </param>
            <param name="bstrItemName">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the WIA item name, such as "Top". You can think of this parameter as being equivalent to a file name.</para>
            </param>
            <param name="bstrFullItemName">
            <para>Type: <c>BSTR</c></para>
            <para>
            Specifies the full WIA item name. You can think of this parameter as equivalent to a full path to a file, such as "003\Root\Top".
            </para>
            </param>
            <returns>
            <para>Type: <c>IWiaItem**</c></para>
            <para>Receives the address of a pointer to the IWiaItem interface that sets the <c>IWiaItem::CreateChildItem</c> method.</para>
            </returns>
            <remarks>
            <para>
            Some WIA hardware devices allow applications to create new items in the IWiaItem tree that represents the device.
            Applications must test the devices to see if they support this capability. Use the IEnumWIA_DEV_CAPS interface to enumerate
            the current device's capabilities.
            </para>
            <para>
            If the device allows the creation of new items in the IWiaItem tree, invoking <c>IWiaItem::CreateChildItem</c> creates a new
            <c>IWiaItem</c> that is a child of the current node. <c>IWiaItem::CreateChildItem</c> passes a pointer to the new node to
            the application through the ppIWiaItem parameter.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIWiaItem parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.EnumRegisterEventInfo(System.Int32,System.Guid@)">
            <summary>
            The <c>IWiaItem::EnumRegisterEventInfo</c> method creates an enumerator used to obtain information about events for which an
            application is registered.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <param name="pEventGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>Pointer to an identifier that specifies the hardware event for which you want registration information.</para>
            </param>
            <returns>
            <para>Type: <c>IEnumWIA_DEV_CAPS**</c></para>
            <para>Receives the address of a pointer to the IEnumWIA_DEV_CAPS interface.</para>
            </returns>
            <remarks>
            <para>
            An application invokes this method to create an enumerator object for the event information.
            <c>IWiaItem::EnumRegisterEventInfo</c> stores the address of the IEnumWIA_DEV_CAPS interface of the enumerator object in the
            ppIEnum parameter. The program then uses the interface pointer to enumerate the properties of the event for which it is registered.
            </para>
            <para>
            Each WIA_DEV_CAP structure includes an indication of whether the event is of type WIA_NOTIFICATION_EVENT or WIA_ACTION_EVENT
            or both.
            </para>
            <para>Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnum parameter.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.FindItemByName(System.Int32,System.String,Vanara.PInvoke.OleAut32.IWiaItem@)">
            <summary>
            The <c>IWiaItem::FindItemByName</c> method searches an item's tree of sub-items using the name as the search key. Each
            IWiaItem object has a name as one of its standard properties.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <param name="bstrFullItemName">
            <para>Type: <c>BSTR</c></para>
            <para>Specifies the name of the item for which to search.</para>
            </param>
            <param name="ppIWiaItem">
            <para>Type: <c>IWiaItem**</c></para>
            <para>Pointer to the IWiaItem interface.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>
            This method returns S_OK if it finds the item, or S_FALSE if it does not find the item. If the method fails, it returns a
            standard COM error code.
            </para>
            </returns>
            <remarks>
            <para>
            This method searches the current item's tree of sub-items using the name as the search key. If
            <c>IWiaItem::FindItemByName</c> finds the item specified by bstrFullItemName, it stores the address of a pointer to the
            IWiaItem interface of the item in the ppIWiaItem parameter.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIWiaItem parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DeviceDlg(Vanara.PInvoke.HWND,Vanara.PInvoke.OleAut32.WiaDevDlg,Vanara.PInvoke.OleAut32.WiaImageIntent,System.Int32@,Vanara.InteropServices.SafeCoTaskMemHandle@)">
            <summary>
            The <c>IWiaItem::DeviceDlg</c> method is used by applications to display a dialog box to the user to prepare for image acquisition.
            </summary>
            <param name="hwndParent">
            <para>Type: <c>HWND</c></para>
            <para>Handle of the parent window of the dialog box.</para>
            </param>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies a set of flags that control the dialog box's operation. Can be set to any of the following values:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Default behavior.</term>
            </item>
            <item>
            <term>WIA_DEVICE_DIALOG_SINGLE_IMAGE</term>
            <term>Restrict image selection to a single image in the device image acquisition dialog box.</term>
            </item>
            <item>
            <term>WIA_DEVICE_DIALOG_USE_COMMON_UI</term>
            <term>
            Use the system UI, if available, rather than the vendor-supplied UI. If the system UI is not available, the vendor UI is
            used. If neither UI is available, the function returns E_NOTIMPL.
            </term>
            </item>
            </list>
            </param>
            <param name="lIntent">
            <para>Type: <c>LONG</c></para>
            <para>
            Specifies what type of data the image is intended to represent. For a list of image intent values, see Image Intent Constants.
            </para>
            <para><c>Note</c> This method ignores all WIA_INTENT_IMAGE_* image intents.</para>
            </param>
            <param name="plItemCount">
            <para>Type: <c>LONG*</c></para>
            <para>Receives the number of items in the array indicated by the ppIWiaItem parameter.</para>
            </param>
            <param name="ppIWiaItem">
            <para>Type: <c>IWiaItem***</c></para>
            <para>Receives the address of an array of pointers to IWiaItem interfaces.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This method displays a dialog box to the user that an application uses to gather all the information required for image
            acquisition. For instance, this dialog box enables the user to select images to download from a camera. When using a
            scanner, it is also used to specify image scan properties such as brightness and contrast.
            </para>
            <para>After this method returns, the application can use the IWiaDataTransfer interface to acquire the image.</para>
            <para>
            Applications must call the IUnknown::Release method for each element in the array of interface pointers they receive through
            the ppIWiaItem parameter. Applications must also free the array using CoTaskMemFree.
            </para>
            <para>
            It is recommended that applications make device and image selection available through a menu item named <c>From scanner or
            camera</c> on the <c>File</c> menu.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DeviceCommand(System.Int32,System.Guid@)">
            <summary>The <c>IWiaItem::DeviceCommand</c> issues a command to a Windows Image Acquisition (WIA) hardware device.</summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Currently unused. Should be set to zero.</para>
            </param>
            <param name="pCmdGUID">
            <para>Type: <c>const GUID*</c></para>
            <para>
            Specifies a unique identifier that specifies the command to send to the WIA hardware device. For a list of valid device
            commands, see WIA Device Commands.
            </para>
            </param>
            <returns>
            <para>Type: <c>IWiaItem**</c></para>
            <para>On output, this pointer points to the item created by the command, if any.</para>
            </returns>
            <remarks>
            <para>Applications use this method to send WIA commands to hardware devices.</para>
            <para>
            When the application sends the WIA_CMD_TAKE_PICTURE command to the device, <c>IWiaItem::DeviceCommand</c>, the WIA run-time
            system creates the IWiaItem object to represent the image. The <c>IWiaItem::DeviceCommand</c> method stores the address of
            the interface in the pIWiaItem parameter.
            </para>
            <para>Applications must call the IUnknown::Release method on the interface pointers they receive through the pIWiaItem parameter.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.GetRootItem">
            <summary>
            The <c>IWiaItem::GetRootItem</c> method retrieves the root item of a tree of item objects used to represent a Windows Image
            Acquisition (WIA) hardware device.
            </summary>
            <returns>
            <para>Type: <c>IWiaItem**</c></para>
            <para>
            Receives the address of a pointer to the IWiaItem interface that contains a pointer to the <c>IWiaItem</c> interface of the
            root item.
            </para>
            </returns>
            <remarks>
            <para>
            Given any IWiaItem object in the object tree of a WIA hardware device, the application retrieves a pointer to the root item
            by calling this function.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIWiaItem parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.EnumDeviceCapabilities(Vanara.PInvoke.OleAut32.WiaDevCap)">
            <summary>
            The <c>IWiaItem::EnumDeviceCapabilities</c> method creates an enumerator that is used to ascertain the commands and events a
            Windows Image Acquisition (WIA) device supports.
            </summary>
            <param name="lFlags">
            <para>Type: <c>LONG</c></para>
            <para>Specifies a flag that selects the type of capabilities to enumerate. Can be set to one or more of the following values:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_DEVICE_COMMANDS</term>
            <term>Enumerate device commands.</term>
            </item>
            <item>
            <term>WIA_DEVICE_EVENTS</term>
            <term>Enumerate device events.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Type: <c>IEnumWIA_DEV_CAPS**</c></para>
            <para>Pointer to IEnumWIA_DEV_CAPS interface created by <c>IWiaItem::EnumDeviceCapabilities</c>.</para>
            </returns>
            <remarks>
            <para>
            Use this method to create an enumerator object to obtain the set of commands and events that a WIA device supports. You can
            use the lFlags parameter to specify which kinds of device capabilities to enumerate. The
            <c>IWiaItem::EnumDeviceCapabilities</c> method stores the address of the interface of the enumerator object in the
            ppIEnumWIA_DEV_CAPS parameter.
            </para>
            <para>
            Applications must call the IUnknown::Release method on the interface pointers they receive through the ppIEnumWIA_DEV_CAPS parameter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DumpItemData">
            <summary>This method is not supported.</summary>
            <returns>Type: <c>BSTR*</c></returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DumpDrvItemData">
            <summary>This method is not supported.</summary>
            <returns>Type: <c>BSTR*</c></returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.DumpTreeItemData">
            <summary>This method is not supported.</summary>
            <returns>Type: <c>BSTR*</c></returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItem.Diagnostic(System.UInt32,System.IntPtr)">
            <summary>This method is not supported.</summary>
            <param name="ulSize">Type: <c>ULONG</c></param>
            <param name="pBuffer">Type: <c>BYTE*</c></param>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaItemExtras">
            <summary>
            The <c>IWiaItemExtras</c> interface provides several methods that enable applications to communicate with hardware drivers.
            </summary>
            <remarks>
            <para>
            The <c>IWiaItemExtras</c> interface, like all Component Object Model (COM) interfaces, inherits the IUnknown interface methods.
            </para>
            <list type="table">
            <listheader>
            <term>IUnknown Methods</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IUnknown::QueryInterface</term>
            <term>Returns pointers to supported interfaces.</term>
            </item>
            <item>
            <term>IUnknown::AddRef</term>
            <term>Increments reference count.</term>
            </item>
            <item>
            <term>IUnknown::Release</term>
            <term>Decrements reference count.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItemExtras.GetExtendedErrorInfo">
            <summary>
            The <c>IWiaItemExtras::GetExtendedErrorInfo</c> method gets a string from the device driver that contains information about
            the most recent error. Call this method after an error during an operation on a Windows Image Acquisition (WIA) item (such
            as data transfer).
            </summary>
            <returns>
            <para>Type: <c>BSTR*</c></para>
            <para>Pointer to a string that contains the error information.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItemExtras.Escape(System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>
            The <c>IWiaItemExtras::Escape</c> method sends a request for a vendor-specific I/O operation to a still image device.
            </summary>
            <param name="dwEscapeCode">
            <para>Type: <c>DWORD</c></para>
            <para>Calling application-supplied, vendor-defined, DWORD-sized value that represents an I/O operation.</para>
            </param>
            <param name="lpInData">
            <para>Type: <c>BYTE*</c></para>
            <para>Pointer to a calling application-supplied buffer that contains data to be sent to the device.</para>
            </param>
            <param name="cbInDataSize">
            <para>Type: <c>DWORD</c></para>
            <para>Calling application-supplied length, in bytes, of the data contained in the buffer pointed to by lpInData.</para>
            </param>
            <param name="pOutData">
            <para>Type: <c>BYTE*</c></para>
            <para>Pointer to a calling application-supplied memory buffer to receive data from the device.</para>
            </param>
            <param name="dwOutDataSize">
            <para>Type: <c>DWORD</c></para>
            <para>Calling application-supplied length, in bytes, of the buffer pointed to by pOutData.</para>
            </param>
            <param name="pdwActualDataSize">
            <para>Type: <c>DWORD*</c></para>
            <para>Receives the number of bytes actually written to pOutData.</para>
            </param>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaItemExtras.CancelPendingIO">
            <summary>The <c>IWiaItemExtras::CancelPendingIO</c> method cancels all pending input/output operations on the driver.</summary>
            <remarks>Drivers are not required to support this method.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.IWiaPropertyStorage">
            <summary>
            The <c>IWiaPropertyStorage</c> interface is used to access information about the IWiaItem object's properties. Applications must
            query an item to obtain its <c>IWiaPropertyStorage</c> interface.
            </summary>
            <remarks>
            <para>
            The <c>IWiaPropertyStorage</c> interface includes several methods that are very similar to the following methods from the <see
            cref="T:Vanara.PInvoke.Ole32.IPropertyStorage"/> interface. The descriptions and remarks for the IPropertyStorage version of these methods applies to
            the <c>IWiaPropertyStorage</c> as well.
            </para>
            <list type="table">
            <listheader>
            <term>IPropertyStorage Methods</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IPropertyStorage::ReadMultiple</term>
            <term>Reads property values in a property set.</term>
            </item>
            <item>
            <term>IPropertyStorage::WriteMultiple</term>
            <term>Writes property values in a property set.</term>
            </item>
            <item>
            <term>IPropertyStorage::DeleteMultiple</term>
            <term>Deletes properties in a property set.</term>
            </item>
            <item>
            <term>IPropertyStorage::ReadPropertyNames</term>
            <term>Gets string names that correspond to given property identifiers.</term>
            </item>
            <item>
            <term>IPropertyStorage::WritePropertyNames</term>
            <term>Creates or changes string names that corresponds to given property identifiers.</term>
            </item>
            <item>
            <term>IPropertyStorage::DeletePropertyNames</term>
            <term>Deletes string names for given property identifiers.</term>
            </item>
            <item>
            <term>IPropertyStorage::SetClass</term>
            <term>Assigns a CLSID to the property set.</term>
            </item>
            <item>
            <term>IPropertyStorage::Commit</term>
            <term>As in IStorage::Commit, flushes or commits changes to the property storage object.</term>
            </item>
            <item>
            <term>IPropertyStorage::Revert</term>
            <term>When the property storage is opened in transacted mode, discards all changes since the last commit.</term>
            </item>
            <item>
            <term>IPropertyStorage::Enum</term>
            <term>Creates and gets a pointer to an enumerator for properties within this set.</term>
            </item>
            <item>
            <term>IPropertyStorage::Stat</term>
            <term>Receives statistics about this property set.</term>
            </item>
            <item>
            <term>IPropertyStorage::SetTimes</term>
            <term>Sets modification, creation, and access times for the property set.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.ReadMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[],Vanara.PInvoke.Ole32.PROPVARIANT[])">
            <summary>
            <para>The <c>ReadMultiple</c> method reads specified properties from the current property set.</para>
            </summary>
            <param name="cpspec">
            <para>
            The numeric count of properties to be specified in the array. The value of this parameter can be set to zero; however, that
            defeats the purpose of the method as no properties are thereby read, regardless of the values set in .
            </para>
            </param>
            <param name="rgpspec">
            <para>
            An array of PROPSPEC structures specifies which properties are read. Properties can be specified either by a property ID or
            by an optional string name. It is not necessary to specify properties in any particular order in the array. The array can
            contain duplicate properties, resulting in duplicate property values on return for simple properties. Nonsimple properties
            should return access denied on an attempt to open them a second time. The array can contain a mixture of property IDs and
            string IDs.
            </para>
            </param>
            <param name="rgpropvar">
            <para>
            Caller-allocated array of a PROPVARIANT structure that, on return, contains the values of the properties specified by the
            corresponding elements in the array. The array must be at least large enough to hold values of the parameter of the
            <c>PROPVARIANT</c> structure. The parameter specifies the number of properties set in the array. The caller is not required
            to initialize these <c>PROPVARIANT</c> structure values in any specific order. However, the implementation must fill all
            members correctly on return. If there is no other appropriate value, the implementation must set the <c>vt</c> member of
            each <c>PROPVARIANT</c> structure to <c>VT_EMPTY</c>.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value <c>E_UNEXPECTED</c>, as well as the following:</para>
            <para>
            This function can also return any file system errors or Win32 errors wrapped in an <c>HRESULT</c> data type. For more
            information, see Error Handling Strategies.
            </para>
            <para>For more information, see Property Storage Considerations.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.WriteMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[],Vanara.PInvoke.Ole32.PROPVARIANT[],System.UInt32)">
            <summary>
            <para>
            The <c>WriteMultiple</c> method writes a specified group of properties to the current property set. If a property with a
            specified name or property identifier already exists, it is replaced, even when the old and new types for the property value
            are different. If a property of a given name or property ID does not exist, it is created.
            </para>
            </summary>
            <param name="cpspec">
            <para>
            The number of properties set. The value of this parameter can be set to zero; however, this defeats the purpose of the
            method as no properties are then written.
            </para>
            </param>
            <param name="rgpspec">
            <para>
            An array of the property IDs (PROPSPEC) to which properties are set. These need not be in any particular order, and may
            contain duplicates, however the last specified property ID is the one that takes effect. A mixture of property IDs and
            string names is permitted.
            </para>
            </param>
            <param name="rgpropvar">
            <para>
            An array (of size ) of PROPVARIANT structures that contain the property values to be written. The array must be the size
            specified by .
            </para>
            </param>
            <param name="propidNameFirst">
            <para>
            The minimum value for the property IDs that the method must assign if the parameter specifies string-named properties for
            which no property IDs currently exist. If all string-named properties specified already exist in this set, and thus already
            have property IDs, this value is ignored. When not ignored, this value must be greater than, or equal to, two and less than
            0x80000000. Property IDs 0 and 1 and greater than 0x80000000 are reserved for special use.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            <para>
            This function can also return any file system errors or Win32 errors wrapped in an <c>HRESULT</c> data type. For more
            information, see Error Handling Strategies.
            </para>
            </returns>
            <remarks>
            <para>
            If a specified property already exists, its value is replaced with the one specified in , even when the old and new types
            for the property value are different. If the specified property does not already exist, that property is created. The
            changes are not persisted to the underlying storage until IPropertyStorage::Commit has been called.
            </para>
            <para>
            Property names are stored in a special dictionary section of the property set, which maps such names to property IDs. All
            properties have an ID, but names are optional. A string name is supplied by specifying PRSPEC_LPWSTR in the <c>ulKind</c>
            member of the PROPSPEC structure. If a string name is supplied for a property, and the name does not already exist in the
            dictionary, the method will allocate a property ID, and add the property ID and the name to the dictionary. The property ID
            is allocated in such a way that it does not conflict with other IDs in the property set. The value of the property ID also
            is no less than the value specified by the parameter. If the parameter specifies string-named properties for which no
            property IDs currently exist, the parameter specifies the minimum value for the property IDs that the <c>WriteMultiple</c>
            method must assign.
            </para>
            <para>
            When a new property set is created, the special <c>codepage (</c> Property ID 1 <c>)</c> and <c>Locale ID (</c> Property ID
            0x80000000 <c>)</c> properties are written to the property set automatically. These properties can subsequently be read,
            using the IPropertyStorage::ReadMultiple method, by specifying property IDs with the header-defined PID_CODEPAGE and
            PID_LOCALE values, respectively. If a property set is non-empty — has one or more properties in addition to the
            <c>codepage</c> and <c>Locale ID</c> properties or has one or more names in its dictionary — the special <c>codepage</c> and
            <c>Locale ID</c> properties cannot be modified by calling <c>IPropertyStorage::WriteMultiple</c>. However, if the property
            set is empty, one or both of these special properties can be modified.
            </para>
            <para>
            If an element in the array is set with a PRSPEC_PROPID value of 0xffffffff (PID_ILLEGAL), the corresponding value in the
            array is ignored by <c>IPropertyStorage::WriteMultiple</c>. For example, if this method is called with the parameter set to
            3, but is set to PRSPEC_PROPID and is set to PID_ILLEGAL, only two properties will be written. The element is silently ignored.
            </para>
            <para>Use the PropVariantInit macro to initialize PROPVARIANT structures.</para>
            <para>
            Property sets, not including the data for nonsimple properties, are limited to 256 KB in size for Windows NT 4.0 and
            earlier. For Windows 2000, Windows XP and Windows Server 2003, OLE property sets are limited to 1 MB. If these limits are
            exceeded, the operation fails and the caller receives an error message. There is no possibility of a memory leak or overrun.
            For more information, see Managing Property Sets.
            </para>
            <para>
            Unless PROPSETFLAG_CASE_SENSITIVE is passed to IPropertySetStorage::Create, property set names are case insensitive.
            Specifying a property by its name in <c>IPropertyStorage::WriteMultiple</c> will result in a case-insensitive search of the
            names in the property set. To compare case-insensitive strings, the locale of the strings must be known. For more
            information, see IPropertyStorage::WritePropertyNames.
            </para>
            <para>For more information, see Property Storage Considerations.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.DeleteMultiple(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[])">
            <summary>
            <para>The <c>DeleteMultiple</c> method deletes as many of the indicated properties as exist in this property set.</para>
            </summary>
            <param name="cpspec">
            <para>
            The numerical count of properties to be deleted. The value of this parameter can legally be set to zero, however that
            defeats the purpose of the method as no properties are thereby deleted, regardless of the value set in .
            </para>
            </param>
            <param name="rgpspec">
            <para>
            Properties to be deleted. A mixture of property identifiers and string-named properties is permitted. There may be
            duplicates, and there is no requirement that properties be specified in any order.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::DeleteMultiple</c> must delete as many of the indicated properties as are in the current property set.
            If a deletion of a stream- or storage-valued property occurs while that property is open, the deletion will succeed and
            place the previously returned IStream or IStorage pointer in the reverted state.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.ReadPropertyNames(System.UInt32,System.UInt32[],System.String[])">
            <summary>
            <para>The <c>ReadPropertyNames</c> method retrieves any existing string names for the specified property IDs.</para>
            </summary>
            <param name="cpropid">
            <para>
            The number of elements on input of the array . The value of this parameter can be set to zero, however that defeats the
            purpose of this method as no property names are thereby read.
            </para>
            </param>
            <param name="rgpropid">
            <para>An array of property IDs for which names are to be retrieved.</para>
            </param>
            <param name="rglpwstrName">
            <para>
            A caller-allocated array of size of <c>LPWSTR</c> members. On return, the implementation fills in this array. A given entry
            contains either the corresponding string name of a property ID or it can be empty if the property ID has no string names.
            </para>
            <para>Each <c>LPWSTR</c> member of the array should be freed using the CoTaskMemFree function.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For each property ID in the list of property IDs supplied in the array, <c>ReadPropertyNames</c> retrieves the corresponding
            string name, if there is one. String names are created either by specifying the names in calls to
            IPropertyStorage::WriteMultiple when creating the property, or through a call to IPropertyStorage::WritePropertyNames. In
            either case, the string name is optional, however all properties must have a property ID.
            </para>
            <para>String names mapped to property IDs must be unique within the set.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.WritePropertyNames(System.UInt32,System.UInt32[],System.String[])">
            <summary>
            <para>
            The <c>WritePropertyNames</c> method assigns string IPropertyStoragenames to a specified array of property IDs in the
            current property set.
            </para>
            </summary>
            <param name="cpropid">
            <para>The size on input of the array . Can be zero. However, making it zero causes this method to become non-operational.</para>
            </param>
            <param name="rgpropid">
            <para>An array of the property IDs for which names are to be set.</para>
            </param>
            <param name="rglpwstrName">
            <para>
            An array of new names to be assigned to the corresponding property IDs in the array. These names may not exceed 255
            characters (not including the <c>NULL</c> terminator).
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value <c>E_UNEXPECTED</c>, in addition to the following:</para>
            </returns>
            <remarks>
            <para>For more information about property sets and memory management, see Managing Property Sets.</para>
            <para>
            <c>IPropertyStorage::WritePropertyNames</c> assigns string names to property IDs passed to the method in the array. It
            associates each string name in the array with the respective property ID in . It is explicitly valid to define a name for a
            property ID that is not currently present in the property storage object.
            </para>
            <para>
            It is also valid to change the mapping for an existing string name (determined by a case-insensitive match). That is, you
            can use the <c>WritePropertyNames</c> method to map an existing name to a new property ID, or to map a new name to a
            property ID that already has a name in the dictionary. In either case, the original mapping is deleted. Property names must
            be unique (as are property IDs) within the property set.
            </para>
            <para>
            The storage of string property names preserves the case. Unless <c>PROPSETFLAG_CASE_SENSITIVE</c> is passed to
            IPropertySetStorage::Create, property set names are case insensitive by default. With case-insensitive property sets, the
            name strings passed by the caller are interpreted according to the locale of the property set, as specified by the
            <c>PID_LOCALE</c> property. If the property set has no locale property, the current user is assumed by default. String
            property names are limited in length to 128 characters. Property names that begin with the binary Unicode characters 0x0001
            through 0x001F are reserved for future use.
            </para>
            <para>
            If the value of an element in the array parameter is set to 0xffffffff (PID_ILLEGAL), the corresponding name is ignored by
            <c>IPropertyStorage::WritePropertyNames</c>. For example, if this method is called with a parameter of 3, but the first
            element of the array, , is set to <c>PID_ILLEGAL</c>, then only two property names are written. The element is ignored.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.DeletePropertyNames(System.UInt32,System.UInt32[])">
            <summary>
            <para>The <c>DeletePropertyNames</c> method deletes specified string names from the current property set.</para>
            </summary>
            <param name="cpropid">
            <para>The size on input of the array . If 0, no property names are deleted.</para>
            </param>
            <param name="rgpropid">
            <para>Property identifiers for which string names are to be deleted.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For each property identifier in , <c>IPropertyStorage::DeletePropertyNames</c> removes any corresponding name-to-property ID
            mapping. An attempt is silently ignored to delete the name of a property that either does not exist or does not currently
            have a string name associated with it. This method has no effect on the properties themselves.
            </para>
            <para>
            <c>Note</c> All the stored string property names can be deleted by deleting property identifier zero, but must be equal to 1
            for this to be a valid parameter error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.Commit(System.UInt32)">
            <summary>
            <para>The <c>IPropertyStorage::Commit</c> method saves changes made to a property storage object to the parent storage object.</para>
            </summary>
            <param name="grfCommitFlags">
            <para>
            The flags that specify the conditions under which the commit is to be performed. For more information about specific flags
            and their meanings, see the Remarks section.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, as well as the following:</para>
            </returns>
            <remarks>
            <para>
            Like IStorage::Commit, the <c>IPropertyStorage::Commit</c> method ensures that any changes made to a property storage object
            are reflected in the parent storage.
            </para>
            <para>
            In direct mode in the compound file implementation, a call to this method causes any changes currently in the memory buffers
            to be flushed to the underlying property stream. In the compound-file implementation for nonsimple property sets,
            IStorage::Commit is also called on the underlying substorage object with the passed parameter.
            </para>
            <para>
            In transacted mode, this method causes the changes to be permanently reflected in the persistent image of the storage
            object. The changes that are committed must have been made to this property set since it was opened or since the last commit
            on this opening of the property set. The <c>commit</c> method publishes the changes made on one object level to the next
            level. Of course, this remains subject to any outer-level transaction that may be present on the object in which this
            property set is contained. Write permission must be specified when the property set is opened (through IPropertySetStorage)
            on the property set opening for the commit operation to succeed.
            </para>
            <para>
            If the commit operation fails for any reason, the state of the property storage object remains as it was before the commit.
            </para>
            <para>
            This call has no effect on existing storage- or stream-valued properties opened from this property storage, but it does
            commit them.
            </para>
            <para>Valid values for the parameter are listed in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>STGC_DEFAULT</term>
            <term>Commits per the usual transaction semantics. Last writer wins. This flag may not be specified with other flag values.</term>
            </item>
            <item>
            <term>STGC_ONLYIFCURRENT</term>
            <term>
            Commits the changes only if the current persistent contents of the property set are the ones on which the changes about to
            be committed are based. That is, does not commit changes if the contents of the property set have been changed by a commit
            from another opening of the property set. The error STG_E_NOTCURRENT is returned if the commit does not succeed for this reason.
            </term>
            </item>
            <item>
            <term>STGC_OVERWRITE</term>
            <term>
            Useful only when committing a transaction that has no further outer nesting level of transactions, though acceptable in all cases.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> Using <c>IPropertyStorage::Commit</c> to write properties to image files on Windows XP does not work. Affected
            image file formats include:Due to a bug in the image file property handler on Windows XP, calling
            <c>IPropertyStorage::Commit</c> actually discards any changes made rather than persisting them.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.Revert">
            <summary>
            <para>
            The <c>Revert</c> method discards all changes to the named property set since it was last opened or discards changes that
            were last committed to the property set. This method has no effect on a direct-mode property set.
            </para>
            </summary>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            For transacted-mode property sets, this method discards all changes that have been made in this property set since the set
            was opened or since the time it was last committed, (whichever is later). After this operation, any existing storage- or
            stream-valued properties that have been opened from the property set being reverted are no longer valid and cannot be used.
            The error STG_E_REVERTED will be returned on all calls, except those to <c>Release</c>, using these streams or storages.
            </para>
            <para>For direct-mode property sets, this request is ignored and returns S_OK.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.Enum(Vanara.PInvoke.Ole32.IEnumSTATPROPSTG@)">
            <summary>
            <para>
            The <c>Enum</c> method creates an enumerator object designed to enumerate data of type STATPROPSTG, which contains
            information on the current property set. On return, this method supplies a pointer to the IEnumSTATPROPSTG pointer on this object.
            </para>
            </summary>
            <param name="ppenum">
            <para>Pointer to IEnumSTATPROPSTG pointer variable that receives the interface pointer to the new enumerator object.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::Enum</c> creates an enumeration object that can be used to iterate STATPROPSTG structures. On return,
            this method supplies a pointer to an instance of the IEnumSTATPROPSTG interface on this object, whose methods you can call
            to obtain information about the current property set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.SetTimes(System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            <para>
            The <c>SetTimes</c> method sets the modification, access, and creation times of this property set, if supported by the
            implementation. Not all implementations support all these time values.
            </para>
            </summary>
            <param name="pctime">
            <para>
            Pointer to the new creation time for the property set. May be <c>NULL</c>, indicating that this time is not to be modified
            by this call.
            </para>
            </param>
            <param name="patime">
            <para>
            Pointer to the new access time for the property set. May be <c>NULL</c>, indicating that this time is not to be modified by
            this call.
            </para>
            </param>
            <param name="pmtime">
            <para>
            Pointer to the new modification time for the property set. May be <c>NULL</c>, indicating that this time is not to be
            modified by this call.
            </para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            Sets the modification, access, and creation times of the current open property set, if supported by the implementation (not
            all implementations support all these time values). Unsupported time stamps are always reported as zero, enabling the caller
            to test for support. A call to IPropertyStorage::Stat supplies (among other data) time-stamp information.
            </para>
            <para>
            Notice that this functionality is provided as an IPropertyStorage method on a property-storage object that is already open,
            in contrast to being provided as a method in IPropertySetStorage. Normally, when the <c>SetTimes</c> method is not
            explicitly called, the access and modification times are updated as a side effect of reading and writing the property set.
            When <c>SetTimes</c> is used, the latest specified times supersede either default times or time values specified in previous
            calls to <c>SetTimes</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.SetClass(System.Guid@)">
            <summary>
            <para>
            The <c>SetClass</c> method assigns a new CLSID to the current property storage object, and persistently stores the CLSID
            with the object.
            </para>
            </summary>
            <param name="clsid">
            <para>New CLSID to be associated with the property set.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            Assigns a CLSID to the current property storage object. The CLSID has no relationship to the stored property IDs. Assigning
            a CLSID allows a piece of code to be associated with a given instance of a property set; such code, for example, might
            manage the user interface (UI). Different CLSIDs can be associated with different property set instances that have the same FMTID.
            </para>
            <para>
            If the property set is created with the parameter of the IPropertySetStorage::Create method specified as <c>NULL</c>, the
            CLSID is set to all zeroes.
            </para>
            <para>
            The current CLSID on a property storage object can be retrieved with a call to IPropertyStorage::Stat. The initial value for
            the CLSID can be specified at the time that the storage is created with a call to IPropertySetStorage::Create.
            </para>
            <para>
            Setting the CLSID on a nonsimple property set (one that can legally contain storage- or stream-valued properties, as
            described in IPropertySetStorage::Create) also sets the CLSID on the underlying sub-storage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.Stat(Vanara.PInvoke.Ole32.STATPROPSETSTG@)">
            <summary>
            <para>The <c>Stat</c> method retrieves information about the current open property set.</para>
            </summary>
            <param name="pstatpsstg">
            <para>Pointer to a STATPROPSETSTG structure, which contains statistics about the current open property set.</para>
            </param>
            <returns>
            <para>This method supports the standard return value E_UNEXPECTED, in addition to the following:</para>
            </returns>
            <remarks>
            <para>
            <c>IPropertyStorage::Stat</c> fills in and returns a pointer to a STATPROPSETSTG structure, containing statistics about the
            current property set.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.GetPropertyAttributes(System.UInt32,Vanara.PInvoke.Ole32.PROPSPEC[],System.UInt32[],Vanara.PInvoke.Ole32.PROPVARIANT[])">
            <summary>
            The <c>IWiaPropertyStorage::GetPropertyAttributes</c> method retrieves access rights and legal value information for a
            specified set of properties.
            </summary>
            <param name="cpspec">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies the number of property attributes to query.</para>
            </param>
            <param name="rgpspec">
            <para>Type: <c>PROPSPEC[]</c></para>
            <para>Specifies an array of Device Information Property Constants. Each constant in the array selects a property to query.</para>
            </param>
            <param name="rgflags">
            <para>Type: <c>ULONG[]</c></para>
            <para>
            An array that receives a property attribute descriptor for each property specified in the rgpspec array. Each element in the
            array is one or more descriptor values combined with a bitwise <c>OR</c> operation.
            </para>
            </param>
            <param name="rgpropvar">
            <para>Type: <c>PROPVARIANT[]</c></para>
            <para>
            An array that receives a property attribute descriptor for each property specified in the pPROPSPEC array. For more
            information, see PROPVARIANT.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This method returns one of the following values or a standard COM error code:</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>This method succeeded.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The specified property names do not exist. No attributes were retrieved.</term>
            </item>
            <item>
            <term>STG_E_ACCESSDENIED</term>
            <term>The application does not have access to the property stream or the stream may already be open.</term>
            </item>
            <item>
            <term>STG_E_INSUFFICIENTMEMORY</term>
            <term>There is not enough memory to complete the operation.</term>
            </item>
            <item>
            <term>ERROR_NOT_SUPPORTED</term>
            <term>The property type is not supported.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPARAMETER</term>
            <term>One or more parameters are invalid. One or more of the PROPSPEC structures contain invalid data.</term>
            </item>
            <item>
            <term>STG_E_INVALIDPOINTER</term>
            <term>One or more of the pointers passed to this method are invalid.</term>
            </item>
            <item>
            <term>ERROR_NO_UNICODE_TRANSLATION</term>
            <term>A translation from Unicode to ANSI or ANSI to Unicode failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This method retrieves both property access rights and valid property values. Access rights report whether the property is
            readable, writeable, or both. Valid property values are specified as a range of values, a list of values, or a group of flag
            values. For more information, see Property Attributes.
            </para>
            <para>
            If the property access rights flag has the <c>WIA_PROP_NONE</c> bit set, no legal value information is available for this
            property. Read only properties and properties with a binary data type are examples of properties that would have the
            <c>WIA_PROP_NONE</c> bit set.
            </para>
            <para>
            If the property has a range of valid values, they can be determined through the rgpropvar parameter upon completion of this
            method. The ppvValidValues parameter specifies an array of PROPVARIANT structures.
            </para>
            <para>
            For example, if the property range is specified as VT_VECTOR | VT_UI4, range information can be retrieved through the
            structure member
            </para>
            <para>rgpropvar[n].caul.pElems[range_specifier]</para>
            <para>where n is the index number of the property that is inspected and range_specifier is one of the following:</para>
            <list type="table">
            <listheader>
            <term>Range Specifier</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_RANGE_MAX</term>
            <term>Maximum value to which the property may be set.</term>
            </item>
            <item>
            <term>WIA_RANGE_MIN</term>
            <term>Minimum value to which the property may be set.</term>
            </item>
            <item>
            <term>WIA_RANGE_NOM</term>
            <term>Normal or default property value.</term>
            </item>
            <item>
            <term>WIA_RANGE_STEP</term>
            <term>Increment or decrement between property values.</term>
            </item>
            </list>
            <para>
            If the property has a list of valid values, applications determine them through the ppvValidValues parameter upon completion
            of this method.
            </para>
            <para>
            For example, if the property range is specified as VT_VECTOR | VT_UI4, the list of valid property values can be retrieved
            through the structure member
            </para>
            <para>rgpropspecValues[n].caul.pElems[list_specifier]</para>
            <para>where n is the index number of the property that is inspected and list_specifier is one of the following:</para>
            <list type="table">
            <listheader>
            <term>Range Specifier</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_LIST_COUNT</term>
            <term>Total number of list elements excluding the nominal value.</term>
            </item>
            <item>
            <term>WIA_LIST_NOM</term>
            <term>Nominal value for the property.</term>
            </item>
            <item>
            <term>WIA_LIST_VALUES</term>
            <term>The index number of the first value.</term>
            </item>
            </list>
            <para>
            Programs also use the ppvValidValues parameter to retrieve valid flag values. For instance, if the property flags are
            specified as VT_UI4, valid flag values can be determined through the structure member
            </para>
            <para>rgpropspec[n].caul.pElems[flag_specifier]</para>
            <para>where n is the index number of the property that is inspected, and flag_specifier is one of the following:</para>
            <list type="table">
            <listheader>
            <term>Range Specifier</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIA_FLAG_NOM</term>
            <term>The nominal value for the property.</term>
            </item>
            <item>
            <term>WIA_FLAG_NUM_ELEMS</term>
            <term>Total number of list elements excluding the nominal value.</term>
            </item>
            <item>
            <term>WIA_FLAG_VALUES</term>
            <term>All values with all valid flag bits set.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.GetCount">
            <summary>The <c>IWiaPropertyStorage::GetCount</c> method returns the number of properties stored in the property storage.</summary>
            <returns>
            <para>Type: <c>ULONG*</c></para>
            <para>Receives the number of properties stored in the property storage.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.GetPropertyStream(System.Guid@)">
            <summary>The <c>IWiaPropertyStorage::GetPropertyStream</c> method retrieves the property stream of an item.</summary>
            <param name="pCompatibilityId">
            <para>Type: <c>GUID*</c></para>
            <para>Receives a unique identifier for a set of property values.</para>
            </param>
            <returns>
            <para>Type: <c>IStream**</c></para>
            <para>Pointer to a stream that receives the item properties. For more information, see IStream.</para>
            </returns>
            <remarks>
            <para>
            Applications use this method to get a snapshot of the current properties of an item. These are subsequently restored by
            calling IWiaPropertyStorage::SetPropertyStream.
            </para>
            <para>
            Applications can use the pCompatibilityID parameter to check if a device supports a specific set of property values before
            attempting to write these values to the device.
            </para>
            <para>When it is finished using the item's property stream, the application must release it.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.IWiaPropertyStorage.SetPropertyStream(System.Guid@,System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>
            The <c>IWiaPropertyStorage::SetPropertyStream</c> sets the property stream of an item in the tree of IWiaItem objects of a
            Windows Image Acquisition (WIA) hardware device.
            </summary>
            <param name="pCompatibilityId">
            <para>Type: <c>GUID*</c></para>
            <para>Specifies a unique identifier for a set of property values.</para>
            </param>
            <param name="pIStream">
            <para>Type: <c>IStream*</c></para>
            <para>Pointer to the property stream that is used to set the current item's property stream.</para>
            </param>
            <remarks>
            <para>
            Applications use the pCompatibilityID parameter to check whether a device supports a specific set of property values before
            attempting to write these values to the device.
            </para>
            <para>Set pIStream to <c>NULL</c> to check whether the device driver accepts the CompatibilityID specified by pCompatibilityID.</para>
            <para>
            If the application obtained the property stream of the item using the IWiaPropertyStorage::GetPropertyStream method, the
            application must release it. For more information, see IStream.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserFree(System.IntPtr,System.IntPtr)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The safe array to free.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserFree64(System.IntPtr,System.IntPtr)">
            <summary>Frees resources on the server side when called by RPC stub files.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">The safe array to free.</param>
            <returns>This function does not return a value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserMarshal(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Marshals data from the specified SAFEARRAY object to the user's RPC buffer on the client or server side.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer. This pointer may or may not be aligned on entry. The function aligns the buffer pointer, marshals the data,
            and returns the new buffer position, which is the address of the first byte after the marshaled object.
            </param>
            <param name="arg3">The safe array that contains the data to marshal.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppSafeArray parameter is not a valid safe array.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserMarshal64(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Marshals data from the specified SAFEARRAY object to the user's RPC buffer on the client or server side.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer. This pointer may or may not be aligned on entry. The function aligns the buffer pointer, marshals the data,
            and returns the new buffer position, which is the address of the first byte after the marshaled object.
            </param>
            <param name="arg3">The safe array that contains the data to marshal.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppSafeArray parameter is not a valid safe array.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be locked.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserSize(System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>Calculates the wire size of the SAFEARRAY object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">Sets the buffer offset so that the SAFEARRAY object is properly aligned when it is marshaled to the buffer.</param>
            <param name="arg3">The safe array that contains the data to marshal.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserSize64(System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>Calculates the wire size of the SAFEARRAY object, and gets its handle and data.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">Sets the buffer offset so that the SAFEARRAY object is properly aligned when it is marshaled to the buffer.</param>
            <param name="arg3">The safe array that contains the data to marshal.</param>
            <returns>The value obtained from the returned <c>HRESULT</c> value is <c>S_OK</c>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserUnmarshal(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Unmarshals a SAFEARRAY object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer. This pointer may or may not be aligned on entry. The function aligns the buffer pointer, marshals the data,
            and returns the new buffer position, which is the address of the first byte after the marshaled object.
            </param>
            <param name="arg3">Receives the safe array that contains the data.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>RPC_X_BAD_STUB_DATA</term>
            <term>The stub has received bad data.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be found.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            <item>
            <term>DISP_E_BADCALLEE</term>
            <term>The SAFEARRAY object does not have the correct dimensions, does not have the correct features, or memory cannot be reallocated.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.OleAut32.LPSAFEARRAY_UserUnmarshal64(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Unmarshals a SAFEARRAY object from the RPC buffer.</summary>
            <param name="arg1">The data used by RPC.</param>
            <param name="arg2">
            The current buffer. This pointer may or may not be aligned on entry. The function aligns the buffer pointer, marshals the data,
            and returns the new buffer position, which is the address of the first byte after the marshaled object.
            </param>
            <param name="arg3">Receives the safe array that contains the data.</param>
            <returns>
            <para>The value obtained from the returned <c>HRESULT</c> value is one of the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Success.</term>
            </item>
            <item>
            <term>RPC_X_BAD_STUB_DATA</term>
            <term>The stub has received bad data.</term>
            </item>
            <item>
            <term>E_UNEXPECTED</term>
            <term>The array could not be found.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Insufficient memory for this function to perform.</term>
            </item>
            <item>
            <term>DISP_E_BADCALLEE</term>
            <term>The SAFEARRAY object does not have the correct dimensions, does not have the correct features, or memory cannot be reallocated.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_DATA_CALLBACK_HEADER">
            <summary>
            The <c>WIA_DATA_CALLBACK_HEADER</c> is transmitted to an application during a series of calls by the Windows Image Acquisition
            (WIA) run-time system to the IWiaDataCallback::BandedDataCallback method.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_CALLBACK_HEADER.lSize">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Must contain the size of this structure in bytes. Should be initialized to <c>sizeof(WIA_DATA_CALLBACK_HEADER)</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_CALLBACK_HEADER.guidFormatID">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>
            Indicates the image clipboard format. For a list of clipboard formats, see SetClipboardData Function. This parameter is
            queried during a callback to the IWiaDataCallback::BandedDataCallback method with the lMessage parameter set to IT_MSG_DATA_HEADER.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_CALLBACK_HEADER.lBufferSize">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Specifies the size in bytes of the buffer needed for a complete data transfer. This value can be zero, which indicates that
            the total image size is unknown. (when using compressed data formats, for example). In this case, the application should
            dynamically increase the size of its buffer. For more information, see Common WIA Item Property Constants in WIA_IPA_ITEM_SIZE.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_CALLBACK_HEADER.lPageCount">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Specifies the page count. Indicates the number of callbacks to the IWiaDataCallback::BandedDataCallback method with the
            lMessage parameter set to IT_MSG_NEW_PAGE.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO">
            <summary>
            The <c>WIA_DATA_TRANSFER_INFO</c> structure is used by applications to describe the buffer used to retrieve bands of data from
            Windows Image Acquisition (WIA) devices. It is primarily used in conjunction with the methods of the IWiaDataTransfer interface.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>
            Contains the size of this structure. Must be set to <c>sizeof(WIA_DATA_TRANSFER_INFO)</c> before your application passes
            this structure to any WIA interface methods.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulSection">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>
            Specifies an optional handle to a shared section of memory allocated by the application. If this member is set to
            <c>NULL</c>, IWiaDataTransfer::idtGetBandedData allocates the shared memory itself.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulBufferSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>The size in bytes of the buffer that is used for the data transfer.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.bDoubleBuffer">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>Contains <c>TRUE</c> if the device is double buffered, <c>FALSE</c> if the device is not double buffered.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulReserved1">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Reserved for use by the WIA system DLLs. Must be set to zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulReserved2">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Reserved for use by the WIA system DLLs. Must be set to zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DATA_TRANSFER_INFO.ulReserved3">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Reserved for use by the WIA system DLLs. Must be set to zero.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_DEV_CAP">
            <summary>
            Applications use the WIA_DEV_CAP structure to enumerate device capabilities. A device capability is defined by an event or
            command that the device supports. For more information, see IEnumWIA_DEV_CAPS.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.guid">
            <summary>
            Specifies a GUID that identifies the device capability. This member can be set to any of the values specified in WIA Device
            Commands or WIA Event Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.ulFlags">
            <summary>Used when enumerating event handlers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.bstrName">
            <summary>Specifies a string that contains a short version of the capability name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.bstrDescription">
            <summary>Specifies a string that contains a description of the capability that is displayed to the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.bstrIcon">
            <summary>
            Specifies a string that represents the location and resource ID of the icon that represents this capability or handler. The
            string must be of the following form: <c>drive:path module,n</c>, where n is the icon's negated resource ID (that is, if the
            resource ID of the icon is 100, then n is -100).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DEV_CAP.bstrCommandline">
            <summary>Specifies a string that represents command line arguments.</summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA">
            <summary>
            The <c>WIA_DITHER_PATTERN_DATA</c> structure specifies a dither pattern for scanners. It is used in conjunction with the scanner
            device property constant WIA_DPS_DITHER_PATTERN_DATA.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.lSize">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Specifies the size of this structure in bytes. Should be set to <c>sizeof(WIA_DITHER_PATTERN_DATA)</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.bstrPatternName">
            <summary>
            <para>Type: <c>BSTR</c></para>
            <para>Specifies a string that contains the name of this dither pattern.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.lPatternWidth">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Indicates the width of the dither pattern in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.lPatternLength">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Indicates the length of the dither pattern in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.cbPattern">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Specifies the total number of bytes in the array pointed to by the <c>pbPattern</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_DITHER_PATTERN_DATA.pbPattern">
            <summary>
            <para>Type: <c>BYTE*</c></para>
            <para>Specifies a pointer to a buffer that contains the dither pattern.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO">
            <summary>
            The <c>WIA_EXTENDED_TRANSFER_INFO</c> structure specifies extended transfer information for the
            IWiaDataTransfer::idtGetExtendedTransferInfo method.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO.ulSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Size of this structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO.ulMinBufferSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Minimum buffer size the application should request in a call to IWiaDataTransfer::idtGetBandedData.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO.ulOptimalBufferSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>Driver-recommended buffer size the application should request in a call to IWiaDataTransfer::idtGetBandedData.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO.ulMaxBufferSize">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>
            Driver-recommended maximum buffer size the application could request in a call to IWiaDataTransfer::idtGetBandedData. Going
            over this limit is not detrimental, however, the driver can simply not use the whole buffer and limit each band of data to
            this maximum size.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_EXTENDED_TRANSFER_INFO.ulNumBuffers">
            <summary>
            <para>Type: <c>ULONG</c></para>
            <para>This value is not used and should be ignored.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.OleAut32.WIA_FORMAT_INFO">
            <summary>The <c>WIA_FORMAT_INFO</c> structure specifies valid format and media type pairs for a device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_FORMAT_INFO.guidFormatID">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>GUID that identifies the format.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.OleAut32.WIA_FORMAT_INFO.lTymed">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The media type that corresponds to the <c>guidFormatID</c> member.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys">
            <summary>Platform invokable enumerated types, constants and functions from propsys.h</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS">
            <summary>
            <para>
            Indicates flags that modify the property store object retrieved by methods that create a property store, such as
            IShellItem2::GetPropertyStore or IPropertyStoreFactory::GetPropertyStore.
            </para>
            </summary>
            <remarks>
            <para>If the Shell item is a file, the property store contains the following items.</para>
            <list type="bullet">
            <item>Properties from the file system that concern the file.</item>
            <item>Properties from the file itself that are provided by the file's property handler, unless the file is offline (see GPS_OPENSLOWITEM).</item>
            </list>
            <para>Non-file Shell items return a similar read-only store.</para>
            <para><c>Note</c> GPS_INCLUDEOFFLINEPROPERTIES has been superseded by GPS_OPENSLOWITEM.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_BESTEFFORT">
            <summary>
            Meaning to a calling process: Succeed at getting the store, even if some properties are not returned. Note: Some values may
            be different, or missing, compared to a store without this flag.
            <para>
            Meaning to a file folder: Succeed and return a store, even if the handler or innate store has an error during creation. Only
            fail if substores fail.
            </para>
            <para>Meaning to other folders: Succeed on getting the store, even if some properties are not returned.</para>
            <para>Combination with other flags: Cannot be combined with GPS_TEMPORARY, GPS_READWRITE, or GPS_HANDLERPROPERTIESONLY.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_DEFAULT">
            <summary>
            Meaning to a calling process: Return a read-only property store that contains all properties. Slow items (offline files) are
            not opened.
            <para>Combination with other flags: Can be overridden by other flags.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_DELAYCREATION">
            <summary>
            Meaning to a calling process: Delay memory-intensive operations, such as file access, until a property is requested that
            requires such access.
            <para>
            Meaning to a file folder: Do not create the handler until needed; for example, either GetCount/GetAt or GetValue, where the
            innate store does not satisfy the request. Note: GetValue might fail due to file access problems.
            </para>
            <para>
            Meaning to other folders: If the folder has memory-intensive properties, such as delegating to a file folder or network
            access, it can optimize performance by supporting IDelayedPropertyStoreFactory and splitting up its properties into a fast
            and a slow store. It can then use delayed MUX to recombine them.
            </para>
            <para>Combination with other flags: Cannot be combined with GPS_TEMPORARY or GPS_READWRITE.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_FASTPROPERTIESONLY">
            <summary>
            Meaning to a calling process: Provides a store that does not involve reading from the disk or network. Note: Some values may
            be different, or missing, compared to a store without this flag.
            <para>Meaning to a file folder: Include the "innate" and "fallback" stores only. Do not load the handler.</para>
            <para>
            Meaning to other folders: Include only properties that are available in memory or can be computed very quickly (no properties
            from disk, network, or peripheral IO devices). This is normally only data sources from the IDLIST. When delegating to other
            folders, pass this flag on to them.
            </para>
            <para>
            Combination with other flags: Cannot be combined with GPS_TEMPORARY, GPS_READWRITE, GPS_HANDLERPROPERTIESONLY, or GPS_DELAYCREATION.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_HANDLERPROPERTIESONLY">
            <summary>
            Meaning to a calling process: Include only properties directly from the property handler, which opens the file on the disk,
            network, or device.
            <para>Meaning to a file folder: Only include properties directly from the handler.</para>
            <para>
            Meaning to other folders: When delegating to a file folder, pass this flag on to the file folder; do not do any multiplexing
            (MUX). When not delegating to a file folder, ignore this flag instead of returning a failure code.
            </para>
            <para>Combination with other flags: Cannot be combined with GPS_TEMPORARY, GPS_FASTPROPERTIESONLY, or GPS_BESTEFFORT.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_MASK_VALID">
            <summary>Mask for valid GETPROPERTYSTOREFLAGS values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_NO_OPLOCK">
            <summary>
            Windows 7 and later. Callers should use this flag only if they are already holding an opportunistic lock (oplock) on the file
            because without an oplock, the bind operation cannot continue. By default, the Shell requests an oplock on a file before
            binding to the property handler. This flag disables the default behavior.
            <para><c>Windows Server 2008 and Windows Vista:</c> This flag is not available.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_OPENSLOWITEM">
            <summary>
            Meaning to a calling process: Open a slow item (offline file) if necessary.
            <para>
            Meaning to a file folder: Retrieve a file from offline storage, if necessary. Note: Without this flag, the handler is not
            created for offline files.
            </para>
            <para>Meaning to other folders: Do not return any properties that are very slow.</para>
            <para>Combination with other flags: Cannot be combined with GPS_TEMPORARY or GPS_FASTPROPERTIESONLY.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_READWRITE">
            <summary>
            Meaning to a calling process: Can write properties to the item. Note: The store may contain fewer properties than a read-only store.
            <para>Meaning to a file folder: ReadWrite.</para>
            <para>
            Meaning to other folders: ReadWrite. Note: When using default MUX, return a single unmultiplexed store because the default
            MUX does not support ReadWrite.
            </para>
            <para>
            Combination with other flags: Cannot be combined with GPS_TEMPORARY, GPS_FASTPROPERTIESONLY, GPS_BESTEFFORT, or
            GPS_DELAYCREATION. Implies GPS_HANDLERPROPERTIESONLY.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_TEMPORARY">
            <summary>
            Meaning to a calling process: Provides a writable store, with no initial properties, that exists for the lifetime of the
            Shell item instance; basically, a property bag attached to the item instance.
            <para>Meaning to a file folder: Not applicable. Handled by the Shell item.</para>
            <para>Meaning to other folders: Not applicable. Handled by the Shell item.</para>
            <para>Combination with other flags: Cannot be combined with any other flag. Implies GPS_READWRITE.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_PREFERQUERYPROPERTIES">
            <summary>Windows 8 and later. Use this flag to retrieve only properties from the indexer for WDS results.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_EXTRINSICPROPERTIES">
            <summary>Include properties from the file's secondary stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_EXTRINSICPROPERTIESONLY">
            <summary>Include only properties from the file's secondary stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_VOLATILEPROPERTIES">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS.GPS_VOLATILEPROPERTIESONLY">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PERSIST_SPROPSTORE_FLAGS">
            <summary>Set options for the behavior of the property storage.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PERSIST_SPROPSTORE_FLAGS.FPSPS_DEFAULT">
            <summary>Windows 7 and later. The property store object is read/write.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PERSIST_SPROPSTORE_FLAGS.FPSPS_READONLY">
            <summary>The property store object is read-only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PERSIST_SPROPSTORE_FLAGS.FPSPS_TREAT_NEW_VALUES_AS_DIRTY">
            <summary>
            Introduced in Windows 8. New property values that are added to the property store through the IPropertyStore::SetValue
            method will cause the IPersistStream::IsDirty method to return S_OK. If this flag is not set, the addition of new property
            values to the property store does not affect the value returned by IPersistStream::IsDirty.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCoerceToCanonicalValue(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Converts the value of a property to the canonical value, according to the property description.</para>
            </summary>
            <param name="key">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>Reference to a PROPERTYKEY structure that identifies the property whose value is to be coerced.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>
            On entry, contains a pointer to a PROPVARIANT structure that contains the original value. When this function returns
            successfully, contains the canonical value.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Possible return values include the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The function succeeded. The property value specified by ppropvar is now in a canonical form.</term>
            </item>
            <item>
            <term>INPLACE_S_TRUNCATED</term>
            <term>The property value specified by ppropvar is now in a truncated, canonical form.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppropvar parameter is invalid. The PROPVARIANT structure has been cleared.</term>
            </item>
            <item>
            <term>TYPE_E_TYPEMISMATCH</term>
            <term>
            Coercion from the value's type to the property description's type was not possible. The PROPVARIANT structure has been cleared.
            </term>
            </item>
            <item>
            <term>Any other failure code</term>
            <term>
            Coercion from the value's type to the property description's type was not possible. The PROPVARIANT structure has been cleared.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function is a wrapper around the system's implementation of IPropertyDescription::CoerceToCanonicalValue.</para>
            <para>
            Most property descriptions specify the type that their values are expected to use. For example, the property description for
            System.Title specifies that System.Title values should be of type VT_LPWSTR. This function coerces values to this type, and then
            coerces the result into a canonical form.
            </para>
            <para>
            It is important to note that if this function fails, it will have already called PropVariantClear on the input PROPVARIANT
            structure. Only if this function succeeds is the calling application responsible for calling <c>PropVariantClear</c> on ppropvar
            when the structure is no longer needed.
            </para>
            <para>
            The coercion performed by this function is also performed by the property system during calls to IPropertyStore::GetValue and
            IPropertyStore::SetValue. Applications can either depend on the property system to perform the coercions or can use this function
            to perform the coercion at a time of the application's choosing.
            </para>
            <para>The coercion is performed in four steps, as follows:</para>
            <list type="number">
            <item>
            <term>The following values are converted to VT_EMPTY.</term>
            </item>
            <item>
            <term>
            If the value is not of type VT_EMPTY after Step 1, it is converted to the type specified by the property description. The type of
            a property description can be obtained by calling IPropertyDescription::GetPropertyType. For information on how the property
            schema influences the type of a property description, see typeInfo. Conversions are performed as follows:
            </term>
            </item>
            <item>
            <term>
            After Steps 2 and 3, the value is coerced into a canonical form based on its type. The canonical forms are summarized in the
            following table.
            </term>
            </item>
            <item>
            <term>
            If applicable, the value is checked against the property description type enumeration. The checks in the following table apply.
            </term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSCoerceToCanonicalValue to coerce a
            value to the type required for PKEY_Keywords.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreateAdapterFromPropertyStore(Vanara.PInvoke.PropSys.IPropertyStore,System.Guid@,System.Object@)">
            <summary>
            <para>Creates an adapter from an IPropertyStore.</para>
            </summary>
            <param name="pps">
            <para>Type: <c>IPropertyStore*</c></para>
            <para>Pointer to an IPropertyStore object that represents the property store.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to an IID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>The adapter object implements IPropertySetStorage, IPropertyStore, IPropertyStoreCapabilities, and IObjectProvider.</para>
            <para>
            Use this function if you need an object that implements IPropertyStore with an API that requires an IPropertySetStorage
            interface. The object created can also be useful to a namespace extension that wants to provide support for binding to namespace
            items using <c>IPropertySetStorage</c>. Applications must call this object from only one thread at a time.
            </para>
            <para>
            The adapter property store created by this function retains a reference to the source IPropertyStore interface. Therefore, the
            calling application is free to release its reference to the source <c>IPropertyStore</c> whenever convenient after calling this function.
            </para>
            <para>
            The adapter property store makes calls to methods on the IPropertyStore interface as appropriate. Therefore, if the calling
            application is writing values to the store, it should call the IPropertyStore::Commit method on only one of the interfaces.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSCreateAdapterFromPropertyStore to
            use an adapter property store to convert an IPropertyStore interface into an IPropertySetStorage interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreateDelayedMultiplexPropertyStore(Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory,System.UInt32[],System.UInt32,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>Creates a read-only, delayed-binding property store that contains multiple property stores.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>One or more GETPROPERTYSTOREFLAGS values. These values specify details of the created property store object.</para>
            </param>
            <param name="pdpsf">
            <para>Type: <c>IDelayedPropertyStoreFactory*</c></para>
            <para>Interface pointer to an instance of IDelayedPropertyStoreFactory.</para>
            </param>
            <param name="rgStoreIds">
            <para>Type: <c>const DWORD*</c></para>
            <para>Pointer to an array of property store IDs. This array does not need to be initialized.</para>
            </param>
            <param name="cStores">
            <para>Type: <c>DWORD</c></para>
            <para>The number of elements in the array pointed to by rgStoreIds.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the requested IID of the interface that will represent the created property store.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid. This is typically IPropertyStore.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function creates a Component Object Model (COM) object that implements IPropertyStore, INamedPropertyStore, IObjectProvider,
            and IPropertyStoreCapabilities.
            </para>
            <para>Applications must call this object from only one thread at a time.</para>
            <para>
            You must initialize COM with CoInitialize or OleInitialize before you call PSCreateDelayedMultiplexPropertyStore. COM must remain
            initialized for the lifetime of this object.
            </para>
            <para>
            PSCreateDelayedMultiplexPropertyStore is designed as an alternative to PSCreateMultiplexPropertyStore, which requires that the
            array of property stores be initialized before it creates the multiplex property store.
            </para>
            <para>
            The delayed binding mechanism is designed as a performance enhancement for calls to IPropertyStore::GetValue on a multiplex
            property store. When asked for the value of a property, the delayed multiplex property store checks each of the property stores
            for the value. After the value is found, there is no need to create and initialize subsequent stores. The delayed multiplex
            property store stops searching for a value when one of the property stores returns a success code and a non-VT_EMPTY value.
            </para>
            <para>
            When the delayed multiplex property store needs to access a particular property store, it first checks to see if it has already
            obtained an interface to that property store. If not, it calls IDelayedPropertyStoreFactory::GetDelayedPropertyStore with the
            appropriate property store ID to obtain the property store. It always uses the property store IDs in the order in which they are
            provided by the application. It is possible that not all IDs will be used.
            </para>
            <para>
            If the call to IDelayedPropertyStoreFactory fails with E_NOTIMPL or E_ACCESSDENIED for a particular property store ID, or if the
            application specified GPS_BESTEFFORT, then the failure is ignored and the delayed multiplex property store moves on to the next
            property store.
            </para>
            <para>
            In some cases, it might be beneficial to use PSCreateDelayedMultiplexPropertyStore in place of PSCreateMultiplexPropertyStore.
            For example, if an application needs to multiplex two property stores and the first property store is not memory-intensive to
            initialize and provides PKEY_Size information. Often, calling applications ask for a multiplex property store and then ask for
            only PKEY_Size before they release the object. In such a case, the application could avoid the cost of initializing the second
            property store by calling <c>PSCreateDelayedMultiplexPropertyStore</c> and implementing IDelayedPropertyStoreFactory.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSCreateDelayedMultiplexPropertyStore
            in an implementation of IPropertyStoreFactory::GetPropertyStore.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreateMemoryPropertyStore(System.Guid@,System.Object@)">
            <summary>
            <para>Creates an in-memory property store.</para>
            </summary>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the requested interface ID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains a pointer to the desired interface, typically IPropertyStore or IPersistSerializedPropStorage.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function creates an in-memory property store object that implements IPropertyStore, INamedPropertyStore,
            IPropertyStoreCache, IPersistStream, IPropertyBag, and IPersistSerializedPropStorage.
            </para>
            <para>
            The memory property store does not correspond to a file and is designed for use as a cache. IPropertyStore::Commit is a no-op,
            and the data stored in the object persists only as long as the object does.
            </para>
            <para>
            The memory property store is thread safe. It aggregates the free-threaded marshaller and uses critical sections to protect its
            data members.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSCreateMemoryPropertyStore.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreateMultiplexPropertyStore(System.Object[],System.UInt32,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>
            Creates a read-only property store that contains multiple property stores, each of which must support either IPropertyStore or IPropertySetStorage.
            </para>
            </summary>
            <param name="prgpunkStores">
            <para>Type: <c>IUnknown**</c></para>
            <para>Address of a pointer to an array of property stores that implement either IPropertyStore or IPropertySetStorage.</para>
            </param>
            <param name="cStores">
            <para>Type: <c>DWORD</c></para>
            <para>The number of elements in the array referenced in prgpunkStores.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the requested IID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid. This is typically IPropertyStore.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function creates a Component Object Model (COM) object that implements IPropertyStore, INamedPropertyStore, IObjectProvider,
            and IPropertyStoreCapabilities. The multiplex property store object aggregates the properties exposed from multiple property stores.
            </para>
            <para>
            This object can be useful for aggregating the properties from multiple existing property store implementations in a Shell
            namespace extension, or for reusing an existing property store and providing additional read-only properties.
            </para>
            <para>Applications must call this object from only one thread at a time.</para>
            <para>
            You must initialize COM with CoInitialize or OleInitialize before you call PSCreateDelayedMultiplexPropertyStore. COM must remain
            initialized for the lifetime of this object.
            </para>
            <para>
            Each of the objects in the array prgpunkStores must implement either IPropertyStore or IPropertySetStorage. If an object
            implements <c>IPropertySetStorage</c>, it is wrapped using PSCreatePropertyStoreFromPropertySetStorage for use in the multiplex
            property store.
            </para>
            <para>
            The multiplex property store implementation of IPropertyStore::GetValue asks each of the provided property stores for the value.
            The multiplex property store stops searching when one of the property stores returns a success code and a non-VT_EMPTY value.
            Failure codes cause the search to end and are passed back to the calling application.
            </para>
            <para>
            The multiplex property store implementation of IPropertyStoreCapabilities::IsPropertyWritable delegates the call to the first
            store that implements IPropertyStoreCapabilities. If multiple stores implement <c>IPropertyStoreCapabilities</c>, the subsequent
            ones are ignored. If no store implements <c>IPropertyStoreCapabilities</c>, this method returns <c>S_OK</c>.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSCreateMultiplexPropertyStore in an
            implementation of IPropertyStoreFactory::GetPropertyStore.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreatePropertyStoreFromObject(System.Object,Vanara.PInvoke.STGM,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>
            Accepts the IUnknown interface of an object that supports IPropertyStore or IPropertySetStorage. If the object supports
            <c>IPropertySetStorage</c>, it is wrapped so that it supports <c>IPropertyStore</c>.
            </para>
            </summary>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to an interface that supports either IPropertyStore or IPropertySetStorage.</para>
            </param>
            <param name="grfMode">
            <para>Type: <c>DWORD</c></para>
            <para>Specifies the access mode to use. One of these values:</para>
            <para>STGM_READ</para>
            <para>Open for reading.</para>
            <para>STGM_READWRITE</para>
            <para>Open for reading and writing.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the requested IID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns successfully, contains the address of a pointer to an interface guaranteed to support IPropertyStore.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>If the object pointed to by punk already supports IPropertyStore, no wrapper is created and the punk is returned unaltered.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreatePropertyStoreFromPropertySetStorage(Vanara.PInvoke.Ole32.IPropertySetStorage,Vanara.PInvoke.STGM,System.Guid@,System.Object@)">
            <summary>
            <para>Wraps an IPropertySetStorage interface in an IPropertyStore interface.</para>
            </summary>
            <param name="ppss">
            <para>Type: <c>IPropertySetStorage*</c></para>
            <para>A pointer to an IPropertySetStorage interface.</para>
            </param>
            <param name="grfMode">
            <para>Type: <c>DWORD</c></para>
            <para>
            Specifies the access mode to enforce. grfMode should match the access mode used to open the IPropertySetStorage. Valid values are
            as follows:
            </para>
            <para>STGM_READ</para>
            <para>
            Calls to IPropertyStore::SetValueupdate an internal cache of properties, and calls to IPropertyStore::Commitcall the appropriate
            IPropertySetStorage methods to write out the changed properties.
            </para>
            <para>STGM_WRITE</para>
            <para>Not supported.</para>
            <para>STGM_READWRITE</para>
            <para>Not supported.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to an IID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer specified in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function wraps an IPropertySetStorage interface in an IPropertyStore interface. Any value other than <c>STGM_READ</c> for
            grfMode, causes calls to IPropertyStore::SetValue and IPropertyStore::Commit to fail with <c>STG_E_ACCESSDENIED.</c>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSEnumeratePropertyDescriptions(Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER,System.Guid@,Vanara.PInvoke.PropSys.IPropertyDescriptionList@)">
            <summary>
            <para>
            A wrapper API that calls the schema subsystem's IPropertySystem::EnumeratePropertyDescriptions. This function retrieves an
            instance of the subsystem object that implements IPropertyDescriptionList, to obtain either the entire list or a partial list of
            property descriptions in the system.
            </para>
            </summary>
            <param name="filterOn">
            <para>Type: <c>PROPDESC_ENUMFILTER</c></para>
            <para>The list to return. PROPDESC_ENUMFILTER shows the valid values for this method.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the interface ID of the requested interface.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>The address of an IPropertyDescriptionList interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Indicates an interface is obtained.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>Indicates that ppv is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            We recommend that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a coding error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSFormatForDisplay(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>
            Gets a formatted, Unicode string representation of a property value stored in a PROPVARIANT structure. The caller is responsible
            for allocating the output buffer.
            </para>
            </summary>
            <param name="propkey">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>Reference to a PROPERTYKEY that names the property whose value is being retrieved.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a PROPVARIANT structure that contains the type and value of the property.</para>
            </param>
            <param name="pdfFlags">
            <para>Type: <c>PROPDESC_FORMAT_FLAGS</c></para>
            <para>A flag that specifies the format to apply to the property string. See PROPDESC_FORMAT_FLAGS for possible values.</para>
            </param>
            <param name="pwszText">
            <para>Type: <c>LPWSTR</c></para>
            <para>
            When the function returns, contains a pointer to the formatted value as a null-terminated, Unicode string. The calling
            application is responsible for allocating memory for the buffer before it calls PSFormatForDisplay.
            </para>
            </param>
            <param name="cchText">
            <para>Type: <c>DWORD</c></para>
            <para>Specifies the length of the buffer at pwszText in <c>WCHAR</c><c>s</c>, including the terminating null character.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The formatted string was successfully created.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The formatted string was not created. S_FALSE indicates that an empty string resulted from a VT_EMPTY.</term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Indicates allocation failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function calls the schema subsystem's implementation of IPropertySystem::FormatForDisplay. That call provides a Unicode
            string representation of a property value, with additional formatting based on one or more PROPDESC_FORMAT_FLAGS. If the
            PROPERTYKEY is not recognized by the schema subsystem, <c>IPropertySystem::FormatForDisplay</c> attempts to format the value
            according to the value's VARTYPE.
            </para>
            <para>You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before you call PSFormatPropertyValue.</para>
            <para>
            The purpose of this function is to convert data into a string suitable for display to the user. The value is formatted according
            to the current locale, the language of the user, the PROPDESC_FORMAT_FLAGS, and the property description specified by the
            property key. For information on how the property description schema influences the formatting of the value, see the following topics:
            </para>
            <list type="bullet">
            <item>
            <term>displayInfo</term>
            </item>
            <item>
            <term>stringFormat</term>
            </item>
            <item>
            <term>booleanFormat</term>
            </item>
            <item>
            <term>numberFormat</term>
            </item>
            <item>
            <term>NMDATETIMEFORMAT</term>
            </item>
            <item>
            <term>enumeratedList</term>
            </item>
            </list>
            <para>Typically, the <c>PROPDESC_FORMAT_FLAGS</c> are used to modify the format prescribed by the property description.</para>
            <para>
            The output string can contain Unicode directional characters. These nonspacing characters influence the Unicode bidirectional
            algorithm so that the values appear correctly when a left-to-right (LTR) language is drawn on a right-to-left (RTL) window, or an
            RTL is drawn on a LTR window. These characters include the following:
            </para>
            <para>
            The following properties use special formats and are unaffected by the PROPDESC_FORMAT_FLAGS. Note that examples cited are for
            strings with a current locale set to English; typically, output is localized except where noted.
            </para>
            <list type="table">
            <listheader>
            <term>Property</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>System.FileAttributes</term>
            <term>
            The following file attributes are converted to letters and appended to create a string (for example, a value of 0x1801 is
            converted to "RCO"):
            </term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_READONLY- 'R'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_SYSTEM - 'S'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_ARCHIVE -'A'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_COMPRESSED - 'C'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_ENCRYPTED - 'E'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_OFFLINE - 'O'</term>
            </item>
            <item>
            <term/>
            <term>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED - 'I'</term>
            </item>
            <item>
            <term>System.Photo.ISOSpeed</term>
            <term>For example, "ISO-400".</term>
            </item>
            <item>
            <term>System.Photo.ShutterSpeed</term>
            <term>The APEX value is converted to an exposure time using this formula: For example, "2 sec."or "1/125 sec.".</term>
            </item>
            <item>
            <term>System.Photo.ExposureTime</term>
            <term>For example, "2 sec."or "1/125 sec."</term>
            </item>
            <item>
            <term>System.Photo.Aperture</term>
            <term>The APEX value is converted to an F number using this formula: For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.FNumber</term>
            <term>For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.SubjectDistance</term>
            <term>For example, "15 m"or "250 mm".</term>
            </item>
            <item>
            <term>System.Photo.FocalLength</term>
            <term>For example, "50 mm".</term>
            </item>
            <item>
            <term>System.Photo.FlashEnergy</term>
            <term>For example, "500 bpcs".</term>
            </item>
            <item>
            <term>System.Photo.ExposureBias</term>
            <term>For example, "-2 step", " 0 step", or "+3 step".</term>
            </item>
            <item>
            <term>System.Computer.DecoratedFreeSpace</term>
            <term>For example, "105 MB free of 13.2 GB".</term>
            </item>
            <item>
            <term>System.ItemType</term>
            <term>For example, "Application" or "JPEG Image".</term>
            </item>
            <item>
            <term>System.ControlPanel.Category</term>
            <term>For example, "Appearance and Personalization".</term>
            </item>
            <item>
            <term>System.ComputerName</term>
            <term>For example, "LITWARE05 (this computer)" or "testbox07".</term>
            </item>
            </list>
            <para>
            If the property key does not correspond to a property description in any of the registered property schemas, then this function
            chooses a format based on the type of the value.
            </para>
            <list type="table">
            <listheader>
            <term>Type of the value</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>VT_BOOLEAN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>VT_FILETIME</term>
            <term>
            Date/time string as specified by PROPDESC_FORMAT_FLAGS and the current locale. PDFF_SHORTTIME and PDFF_SHORTDATE are the default.
            For example, "11/13/2006 3:22 PM".
            </term>
            </item>
            <item>
            <term>Numeric VARTYPE</term>
            <term>Decimal string in the current locale. For example, "42".</term>
            </item>
            <item>
            <term>VT_LPWSTR or other</term>
            <term>Converted to a string. Sequences of "\r", "\t", or "\n" are replaced with a single space.</term>
            </item>
            <item>
            <term>VT_VECTOR | anything</term>
            <term>Semicolon separated values. A semicolon is used regardless of locale.</term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSFormatForDisplay to format a rating value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSFormatForDisplayAlloc(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS,System.String@)">
            <summary>
            <para>
            Gets a formatted, Unicode string representation of a property value stored in a PROPVARIANT structure. This function allocates
            memory for the output string.
            </para>
            </summary>
            <param name="key">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>Reference to a PROPERTYKEY that names the property whose value is being retrieved.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a PROPVARIANT structure that contains the type and value of the property.</para>
            </param>
            <param name="pdff">
            <para>Type: <c>PROPDESC_FORMAT_FLAGS</c></para>
            <para>One or more flags that specify the format to apply to the property string. See PROPDESC_FORMAT_FLAGS for possible values.</para>
            </param>
            <param name="ppszDisplay">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            When the function returns, contains a pointer to a null-terminated, Unicode string representation of the requested property value.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>
            The formatted string was successfully created. S_OK together with an empty return string indicates that there was an empty input
            string or a non-empty value that was formatted as an empty string.
            </term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>
            The formatted string was not created. S_FALSE together with an empty return string indicates that the empty string resulted from
            a VT_EMPTY.
            </term>
            </item>
            <item>
            <term>E_OUTOFMEMORY</term>
            <term>Indicates allocation failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function calls the schema subsystem's implementation of IPropertySystem::FormatForDisplayAlloc. That call provides a Unicode
            string representation of a property value, with additional formatting based on one or more PROPDESC_FORMAT_FLAGS. If the
            PROPERTYKEY is not recognized by the schema subsystem, <c>IPropertySystem::FormatForDisplayAlloc</c> attempts to format the value
            according to the value's VARTYPE.
            </para>
            <para>You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before you call PSFormatForDisplayAlloc.</para>
            <para>
            The function allocates memory through CoTaskMemAlloc and returns a pointer to that memory through the ppszDisplay parameter. The
            calling application must use CoTaskMemFree to release that resource when it is no longer needed.
            </para>
            <para>
            The purpose of this function is to convert data into a string suitable for display to the user. The value is formatted according
            to the current locale, the language of the user, the PROPDESC_FORMAT_FLAGS, and the property description specified by the
            property key. For information on how the property description schema influences the formatting of the value, see the following topics:
            </para>
            <list type="bullet">
            <item>
            <term>displayInfo</term>
            </item>
            <item>
            <term>stringFormat</term>
            </item>
            <item>
            <term>booleanFormat</term>
            </item>
            <item>
            <term>numberFormat</term>
            </item>
            <item>
            <term>NMDATETIMEFORMAT</term>
            </item>
            <item>
            <term>enumeratedList</term>
            </item>
            </list>
            <para>Typically, the <c>PROPDESC_FORMAT_FLAGS</c> are used to modify the format prescribed by the property description.</para>
            <para>
            The output string can contain Unicode directional characters. These nonspacing characters influence the Unicode bidirectional
            algorithm so that the values appear correctly when a left-to-right (LTR) language is drawn on a right-to-left (RTL) window, or an
            RTL is drawn on a LTR window. These characters include the following:
            </para>
            <para>
            The following properties use special formats and are unaffected by the PROPDESC_FORMAT_FLAGS. Note that examples cited are for
            strings with a current locale set to English; typically, output is localized except where noted.
            </para>
            <list type="table">
            <listheader>
            <term>Property</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>System.FileAttributes</term>
            <term>
            The following file attributes are converted to letters and appended to create a string (for example, a value of 0x1801
            (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE) is converted to "RCO"):
            </term>
            </item>
            <item>
            <term>System.Photo.ISOSpeed</term>
            <term>For example, "ISO-400".</term>
            </item>
            <item>
            <term>System.Photo.ShutterSpeed</term>
            <term>The APEX value is converted to an exposure time using this formula: For example, "2 sec."or "1/125 sec.".</term>
            </item>
            <item>
            <term>System.Photo.ExposureTime</term>
            <term>For example, "2 sec."or "1/125 sec."</term>
            </item>
            <item>
            <term>System.Photo.Aperture</term>
            <term>The APEX value is converted to an F number using this formula: For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.FNumber</term>
            <term>For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.SubjectDistance</term>
            <term>For example, "15 m"or "250 mm".</term>
            </item>
            <item>
            <term>System.Photo.FocalLength</term>
            <term>For example, "50 mm".</term>
            </item>
            <item>
            <term>System.Photo.FlashEnergy</term>
            <term>For example, "500 bpcs".</term>
            </item>
            <item>
            <term>System.Photo.ExposureBias</term>
            <term>For example, "-2 step", " 0 step", or "+3 step".</term>
            </item>
            <item>
            <term>System.Computer.DecoratedFreeSpace</term>
            <term>For example, "105 MB free of 13.2 GB".</term>
            </item>
            <item>
            <term>System.ItemType</term>
            <term>For example, "Application" or "JPEG Image".</term>
            </item>
            <item>
            <term>System.ControlPanel.Category</term>
            <term>For example, "Appearance and Personalization".</term>
            </item>
            <item>
            <term>System.ComputerName</term>
            <term>For example, "LITWARE05 (this computer)" or "testbox07".</term>
            </item>
            </list>
            <para>
            If the property key does not correspond to a property description in any of the registered property schemas, then this function
            chooses a format based on the type of the value.
            </para>
            <list type="table">
            <listheader>
            <term>Type of the value</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>VT_BOOLEAN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>VT_FILETIME</term>
            <term>
            Date/time string as specified by PROPDESC_FORMAT_FLAGS and the current locale. PDFF_SHORTTIME and PDFF_SHORTDATE are the default.
            For example, "11/13/2006 3:22 PM".
            </term>
            </item>
            <item>
            <term>Numeric VARTYPE</term>
            <term>Decimal string in the current locale. For example, "42".</term>
            </item>
            <item>
            <term>VT_LPWSTR or other</term>
            <term>Converted to a string. Sequences of "\r", "\t", or "\n" are replaced with a single space.</term>
            </item>
            <item>
            <term>VT_VECTOR | anything</term>
            <term>Semicolon separated values. A semicolon is used regardless of locale.</term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSFormatForDisplayAlloc to format a
            rating value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSFormatPropertyValue(Vanara.PInvoke.PropSys.IPropertyStore,Vanara.PInvoke.PropSys.IPropertyDescription,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS,System.String@)">
            <summary>
            <para>
            Gets a formatted, Unicode string representation of a property value stored in a property store. This function allocates memory
            for the output string.
            </para>
            </summary>
            <param name="pps">
            <para>Type: <c>IPropertyStore*</c></para>
            <para>Pointer to an IPropertyStore, which represents the property store from which the property value is taken.</para>
            </param>
            <param name="ppd">
            <para>Type: <c>IPropertyDescription*</c></para>
            <para>Pointer to an IPropertyDescription, which represents the property whose value is being retrieved.</para>
            </param>
            <param name="pdff">
            <para>Type: <c>PROPDESC_FORMAT_FLAGS</c></para>
            <para>
            One or more PROPDESC_FORMAT_FLAGS that specify the format to apply to the property string. See <c>PROPDESC_FORMAT_FLAGS</c> for
            possible values.
            </para>
            </param>
            <param name="ppszDisplay">
            <para>Type: <c>LPWSTR*</c></para>
            <para>When the function returns, contains a pointer to the formatted value as a null-terminated, Unicode string.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function uses the ppd parameter to call IPropertyDescription::FormatForDisplay. That call provides a Unicode string
            representation of a property value, with additional formatting based on one or more PROPDESC_FORMAT_FLAGS.
            </para>
            <para>You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before you call PSFormatPropertyValue.</para>
            <para>
            The function allocates memory and returns a pointer to that memory in ppszDisplay. The calling application must use CoTaskMemFree
            to release the string specified by ppszDisplay when it is no longer needed.
            </para>
            <para>
            The purpose of this function is to convert data into a string suitable for display to the user. The value is formatted according
            to the current locale, the language of the user, the PROPDESC_FORMAT_FLAGS, and the property description specified by the
            property key. For information on how the property description schema influences the formatting of the value, see the following topics:
            </para>
            <list type="bullet">
            <item>
            <term>displayInfo</term>
            </item>
            <item>
            <term>stringFormat</term>
            </item>
            <item>
            <term>booleanFormat</term>
            </item>
            <item>
            <term>numberFormat</term>
            </item>
            <item>
            <term>NMDATETIMEFORMAT</term>
            </item>
            <item>
            <term>enumeratedList</term>
            </item>
            </list>
            <para>Typically, the <c>PROPDESC_FORMAT_FLAGS</c> are used to modify the format prescribed by the property description.</para>
            <para>
            The output string can contain Unicode directional characters. These nonspacing characters influence the Unicode bidirectional
            algorithm so that the values appear correctly when a left-to-right (LTR) language is drawn on a right-to-left (RTL) window, or an
            RTL is drawn on a LTR window. These characters include the following:
            </para>
            <para>
            The following properties use special formats and are unaffected by the PROPDESC_FORMAT_FLAGS. Note that examples cited are for
            strings with a current locale set to English; typically, output is localized except where noted.
            </para>
            <list type="table">
            <listheader>
            <term>Property</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>System.FileAttributes</term>
            <term>
            The following file attributes are converted to letters and appended to create a string (for example, a value of 0x1801
            (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE) is converted to "RCO"):
            </term>
            </item>
            <item>
            <term>System.Photo.ISOSpeed</term>
            <term>For example, "ISO-400".</term>
            </item>
            <item>
            <term>System.Photo.ShutterSpeed</term>
            <term>The APEX value is converted to an exposure time using this formula: For example, "2 sec."or "1/125 sec.".</term>
            </item>
            <item>
            <term>System.Photo.ExposureTime</term>
            <term>For example, "2 sec."or "1/125 sec."</term>
            </item>
            <item>
            <term>System.Photo.Aperture</term>
            <term>The APEX value is converted to an F number using this formula: For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.FNumber</term>
            <term>For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.SubjectDistance</term>
            <term>For example, "15 m"or "250 mm".</term>
            </item>
            <item>
            <term>System.Photo.FocalLength</term>
            <term>For example, "50 mm".</term>
            </item>
            <item>
            <term>System.Photo.FlashEnergy</term>
            <term>For example, "500 bpcs".</term>
            </item>
            <item>
            <term>System.Photo.ExposureBias</term>
            <term>For example, "-2 step", " 0 step", or "+3 step".</term>
            </item>
            <item>
            <term>System.Computer.DecoratedFreeSpace</term>
            <term>For example, "105 MB free of 13.2 GB".</term>
            </item>
            <item>
            <term>System.ItemType</term>
            <term>For example, "Application" or "JPEG Image".</term>
            </item>
            <item>
            <term>System.ControlPanel.Category</term>
            <term>For example, "Appearance and Personalization".</term>
            </item>
            <item>
            <term>System.ComputerName</term>
            <term>For example, "LITWARE05 (this computer)" or "testbox07".</term>
            </item>
            </list>
            <para>
            If the property key does not correspond to a property description in any of the registered property schemas, then this function
            chooses a format based on the type of the value.
            </para>
            <list type="table">
            <listheader>
            <term>Type of the value</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>VT_BOOLEAN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>VT_FILETIME</term>
            <term>
            Date/time string as specified by PROPDESC_FORMAT_FLAGS and the current locale. PDFF_SHORTTIME and PDFF_SHORTDATE are the default.
            For example, "11/13/2006 3:22 PM".
            </term>
            </item>
            <item>
            <term>Numeric VARTYPE</term>
            <term>Decimal string in the current locale. For example, "42".</term>
            </item>
            <item>
            <term>VT_LPWSTR or other</term>
            <term>Converted to a string. Sequences of "\r", "\t", or "\n" are replaced with a single space.</term>
            </item>
            <item>
            <term>VT_VECTOR | anything</term>
            <term>Semicolon separated values. A semicolon is used regardless of locale.</term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSFormatPropertyValue to format a
            rating value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetImageReferenceForValue(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,System.String@)">
            <summary>
            <para>Gets an instance of a property description interface for a specified property.</para>
            </summary>
            <param name="propkey">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A reference to a PROPERTYKEY structure that specifies the property.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the interface to retrieve through ppv.</para>
            </param>
            <param name="ppszImageRes">
            <para>Type: <c>void**</c></para>
            <para>When this function returns successfully, contains the interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise, including the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term/>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            We recommend that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding
            error in riid that could lead to unexpected results.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetItemPropertyHandler(System.Object,System.Boolean,System.Guid@,System.Object@)">
            <summary>
            <para>Retrieves a property handler for a Shell item.</para>
            </summary>
            <param name="punkItem">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown interface of a Shell item that supports IShellItem.</para>
            <para><c>Windows XP:</c> Use SHCreateShellItem to create the Shell item.</para>
            <para>
            <c>Windows Vista:</c> Use SHCreateItemFromIDList, SHCreateItemFromParsingName, SHCreateItemFromRelativeName,
            SHCreateItemInKnownFolder, or SHCreateItemWithParent to create the Shell item.
            </para>
            </param>
            <param name="fReadWrite">
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> to retrieve a read/write property handler. <c>FALSE</c> to retrieve a read-only property handler.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>
            Reference to the IID of the interface the handler object should return. This should be IPropertyStore or an interface derived
            from <c>IPropertyStore</c>.
            </para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function is supported in Windows XP and Windows Vista. For applications supported only on Windows Vista or later, it is
            recommended that you use IShellItem2::GetPropertyStore instead of PSGetItemPropertyHandler. That method provides a richer set of
            properties in the property store that is returned.
            </para>
            <para>This function is approximately equivalent to passing the GPS_HANDLERPROPERTIESONLY flag to IShellItem2::GetPropertyStore.</para>
            <para>
            You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before you call PSGetItemPropertyHandler. COM
            must remain initialized for the lifetime of this object.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSGetItemPropertyHandler to obtain a
            property handler for an item.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetItemPropertyHandlerWithCreateObject(System.Object,System.Boolean,System.Object,System.Guid@,System.Object@)">
            <summary>
            <para>Retrieves a property handler for a Shell item.</para>
            </summary>
            <param name="punkItem">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to the IUnknown interface of a Shell item that supports IShellItem.</para>
            <para><c>Windows XP:</c> Use SHCreateShellItem to create the Shell item.</para>
            <para>
            <c>Windows Vista:</c> Use SHCreateItemFromIDList, SHCreateItemFromParsingName, SHCreateItemFromRelativeName,
            SHCreateItemInKnownFolder, or SHCreateItemWithParent to create the Shell item.
            </para>
            </param>
            <param name="fReadWrite">
            <para>Type: <c>BOOL</c></para>
            <para><c>TRUE</c> to retrieve a read/write property handler. <c>FALSE</c> to retrieve a read-only property handler.</para>
            </param>
            <param name="punkCreateObject">
            <para>Type: <c>IUnknown*</c></para>
            <para>Pointer to the IUnknown interface of a class factory object that supports ICreateObject.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the interface to retrieve through ppv.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>
            When this function returns successfully, contains the interface pointer requested in riid. This is typically IPropertyStore or IPropertyStoreCapabilities.
            </para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function is supported in Windows XP as part of the Microsoft Windows Desktop Search (WDS) redistributable which includes
            IPropertyStore and supporting interfaces. For applications supported only on Windows Vista or later, we recommend that you use
            IShellItem2::GetPropertyStoreWithCreateObject instead of PSGetItemPropertyHandlerWithCreateObject because
            <c>IShellItem2::GetPropertyStoreWithCreateObject</c> provides a richer set of properties in the property store that is returned.
            </para>
            <para>This function is approximately equivalent to passing the GPS_HANDLERPROPERTIESONLY flag to IShellItem2::GetPropertyStoreWithCreateObject.</para>
            <para>
            The punkCreateObject parameter enables the creation of a property store in a different context than that of the caller. For
            instance, the ICreateObject implementation can cause the property store to be created in another process. This parameter is used
            only for property handlers that support it and that are registered under
            </para>
            <para>
            You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before you call
            PSGetItemPropertyHandlerWithCreateObject. COM must remain initialized for the lifetime of this object.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use
            PSGetItemPropertyHandlerWithCreateObject to obtain a property handler for an item.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetNamedPropertyFromPropertyStorage(System.IntPtr,System.UInt32,System.String,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Gets a value from serialized property storage by property name.</para>
            </summary>
            <param name="psps">
            <para>Type: <c>PCUSERIALIZEDPROPSTORAGE</c></para>
            <para>
            A pointer to an allocated buffer that contains the serialized properties. Call IPersistSerializedPropStorage::GetPropertyStorage
            to obtain the buffer.
            </para>
            </param>
            <param name="cb">
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the USERIALIZESPROPSTORAGE buffer pointed to by psps.</para>
            </param>
            <param name="pszName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated, Unicode string that contains the name of the property.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>When this function returns, contains the requested value.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function is intended to be called if the calling application already has a serialized property storage and needs no more
            than a few properties from storage. If many properties need to be retrieved, performance can be enhanced by creating a memory
            property store by calling PSCreateMemoryPropertyStore, initializing the property store by calling
            IPersistSerializedPropStorage::SetPropertyStorage, and using INamedPropertyStore or IPropertyStore to retrieve the properties.
            </para>
            <para>
            Note that PSGetNamedPropertyFromPropertyStorage works only on serialized buffers created by the system implementation of
            IPersistSerializedPropStorage. You must first obtain a memory property store by calling PSCreateMemoryPropertyStore; that store
            can then create a serialized buffer using the <c>IPersistSerializedPropStorage</c> interface.
            </para>
            <para>
            Although SERIALIZEDPROPSTORAGE is an opaque serialized data structure whose format may change in the future, earlier formats will
            be supported on subsequent versions of Windows. Because the format is opaque, applications should use supported property storage
            APIs to access and manipulate the serialized buffer (see IPersistSerializedPropStorage and PSGetPropertyFromPropertyStorage).
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSGetNamedPropertyFromPropertyStorage
            to read a value from serialized property storage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetNameFromPropertyKey(Vanara.PInvoke.Ole32.PROPERTYKEY@,System.String@)">
            <summary>Retrieves the property's canonical name given its PROPERTYKEY.</summary>
            <param name="propkey">A pointer to a PROPERTYKEY structure containing the property's identifiers.</param>
            <param name="ppszCanonicalName">
            The address of a pointer to a buffer that receives the property name as a null-terminated Unicode string.
            </param>
            <returns>The result of the operation. S_OK indicates success.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyDescription(Vanara.PInvoke.Ole32.PROPERTYKEY@,System.Guid@,System.Object@)">
            <summary>Gets an instance of a property description interface for a property specified by a PROPERTYKEY structure.</summary>
            <param name="propkey">Reference to a PROPERTYKEY.</param>
            <param name="riid">Reference to the interface ID of the requested interface.</param>
            <param name="ppv">
            When this function returns, contains the interface pointer requested in riid. This is typically IPropertyDescription,
            IPropertyDescriptionAliasInfo, or IPropertyDescriptionSearchInfo.
            </param>
            <returns>The result of the operation. S_OK indicates success.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyDescriptionByName(System.String,System.Guid@,System.Object@)">
            <summary>
            <para>Gets an instance of a property description interface for a specified property name.</para>
            </summary>
            <param name="pszCanonicalName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated, Unicode string that identifies the property.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the interface ID of the requested property.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>
            When this function returns, contains the interface pointer requested in riid. This is typically IPropertyDescription,
            IPropertyDescriptionAliasInfo, or IPropertyDescriptionSearchInfo.
            </para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface was obtained.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The pszCanonicalName parameter is NULL.</term>
            </item>
            <item>
            <term>TYPE_E_ELEMENTNOTFOUND</term>
            <term>The canonical name does not exist in the schema subsystem cache.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a coding error.
            </para>
            <para>
            We recommend that pszCanonicalName point to the canonical name of a property, for example, . The canonical name is case sensitive.
            </para>
            <para>
            In addition to the new canonical names, callers can pass a legacy name for a property. The following table contains the complete
            list of supported legacy names and the canonical names they correspond to.
            </para>
            <list type="table">
            <listheader>
            <term>Property name</term>
            <term>Maps to property</term>
            </listheader>
            <item>
            <term>Access</term>
            <term>System.DateAccessed</term>
            </item>
            <item>
            <term>Album</term>
            <term>System.Music.AlbumTitle</term>
            </item>
            <item>
            <term>AllocSize</term>
            <term>System.FileAllocationSize</term>
            </item>
            <item>
            <term>Aperture</term>
            <term>System.Photo.Aperture</term>
            </item>
            <item>
            <term>Artist</term>
            <term>System.Music.Artist</term>
            </item>
            <item>
            <term>Attrib</term>
            <term>System.FileAttributes</term>
            </item>
            <item>
            <term>Attributes</term>
            <term>System.FileAttributes</term>
            </item>
            <item>
            <term>AttributesDescription</term>
            <term>System.FileAttributesDisplay</term>
            </item>
            <item>
            <term>Audio Format</term>
            <term>System.Audio.Format</term>
            </item>
            <item>
            <term>Audio Sample Size</term>
            <term>System.Audio.SampleSize</term>
            </item>
            <item>
            <term>BitDepth</term>
            <term>System.Image.BitDepth</term>
            </item>
            <item>
            <term>Bitrate</term>
            <term>System.Audio.EncodingBitrate</term>
            </item>
            <item>
            <term>CameraModel</term>
            <term>System.Photo.CameraModel</term>
            </item>
            <item>
            <term>Capacity</term>
            <term>System.Capacity</term>
            </item>
            <item>
            <term>Channels</term>
            <term>System.Audio.ChannelCount</term>
            </item>
            <item>
            <term>ColorSpace</term>
            <term>System.Image.ColorSpace</term>
            </item>
            <item>
            <term>Company</term>
            <term>System.Company</term>
            </item>
            <item>
            <term>Compression</term>
            <term>System.Video.Compression</term>
            </item>
            <item>
            <term>Compression</term>
            <term>System.Video.Compression</term>
            </item>
            <item>
            <term>Copyright</term>
            <term>System.Copyright</term>
            </item>
            <item>
            <term>Copyright</term>
            <term>System.Copyright</term>
            </item>
            <item>
            <term>Copyright</term>
            <term>System.Image.Copyright</term>
            </item>
            <item>
            <term>Create</term>
            <term>System.DateCreated</term>
            </item>
            <item>
            <term>CSCStatus</term>
            <term>System.OfflineStatus</term>
            </item>
            <item>
            <term>Data Rate</term>
            <term>System.Video.EncodingBitrate</term>
            </item>
            <item>
            <term>DateDeleted</term>
            <term>System.Recycle.DateDeleted</term>
            </item>
            <item>
            <term>DeletedFrom</term>
            <term>System.Recycle.DeletedFrom</term>
            </item>
            <item>
            <term>Dimensions</term>
            <term>System.Image.Dimensions</term>
            </item>
            <item>
            <term>Directory</term>
            <term>System.ItemFolderNameDisplay</term>
            </item>
            <item>
            <term>Distance</term>
            <term>System.Photo.SubjectDistance</term>
            </item>
            <item>
            <term>DocAppName</term>
            <term>System.ApplicationName</term>
            </item>
            <item>
            <term>DocAuthor</term>
            <term>System.Author</term>
            </item>
            <item>
            <term>DocByteCount</term>
            <term>System.Document.ByteCount</term>
            </item>
            <item>
            <term>DocCategory</term>
            <term>System.Category</term>
            </item>
            <item>
            <term>DocCharCount</term>
            <term>System.Document.CharacterCount</term>
            </item>
            <item>
            <term>DocComments</term>
            <term>System.Comment</term>
            </item>
            <item>
            <term>DocCompany</term>
            <term>System.Company</term>
            </item>
            <item>
            <term>DocCreatedTm</term>
            <term>System.Document.DateCreated</term>
            </item>
            <item>
            <term>DocEditTime</term>
            <term>System.Document.TotalEditingTime</term>
            </item>
            <item>
            <term>DocHiddenCount</term>
            <term>System.Document.HiddenSlideCount</term>
            </item>
            <item>
            <term>DocKeywords</term>
            <term>System.Keywords</term>
            </item>
            <item>
            <term>DocLastAuthor</term>
            <term>System.Document.LastAuthor</term>
            </item>
            <item>
            <term>DocLastPrinted</term>
            <term>System.Document.DatePrinted</term>
            </item>
            <item>
            <term>DocLastSavedTm</term>
            <term>System.Document.DateSaved</term>
            </item>
            <item>
            <term>DocLineCount</term>
            <term>System.Document.LineCount</term>
            </item>
            <item>
            <term>DocManager</term>
            <term>System.Document.Manager</term>
            </item>
            <item>
            <term>DocNoteCount</term>
            <term>System.Document.NoteCount</term>
            </item>
            <item>
            <term>DocPageCount</term>
            <term>System.Document.PageCount</term>
            </item>
            <item>
            <term>DocParaCount</term>
            <term>System.Document.ParagraphCount</term>
            </item>
            <item>
            <term>DocPresentationTarget</term>
            <term>System.Document.PresentationFormat</term>
            </item>
            <item>
            <term>DocRevNumber</term>
            <term>System.Document.RevisionNumber</term>
            </item>
            <item>
            <term>DocSlideCount</term>
            <term>System.Document.SlideCount</term>
            </item>
            <item>
            <term>DocSubject</term>
            <term>System.Subject</term>
            </item>
            <item>
            <term>DocTemplate</term>
            <term>System.Document.Template</term>
            </item>
            <item>
            <term>DocTitle</term>
            <term>System.Title</term>
            </item>
            <item>
            <term>DocWordCount</term>
            <term>System.Document.WordCount</term>
            </item>
            <item>
            <term>DRM Description</term>
            <term>System.DRM.Description</term>
            </item>
            <item>
            <term>Duration</term>
            <term>System.Media.Duration</term>
            </item>
            <item>
            <term>EquipMake</term>
            <term>System.Photo.CameraManufacturer</term>
            </item>
            <item>
            <term>ExposureBias</term>
            <term>System.Photo.ExposureBias</term>
            </item>
            <item>
            <term>ExposureProg</term>
            <term>System.Photo.ExposureProgram</term>
            </item>
            <item>
            <term>ExposureTime</term>
            <term>System.Photo.ExposureTime</term>
            </item>
            <item>
            <term>FaxCallerID</term>
            <term>System.Fax.CallerID</term>
            </item>
            <item>
            <term>FaxCSID</term>
            <term>System.Fax.CSID</term>
            </item>
            <item>
            <term>FaxRecipientName</term>
            <term>System.Fax.RecipientName</term>
            </item>
            <item>
            <term>FaxRecipientNumber</term>
            <term>System.Fax.RecipientNumber</term>
            </item>
            <item>
            <term>FaxRouting</term>
            <term>System.Fax.Routing</term>
            </item>
            <item>
            <term>FaxSenderName</term>
            <term>System.Fax.SenderName</term>
            </item>
            <item>
            <term>FaxTime</term>
            <term>System.Fax.Time</term>
            </item>
            <item>
            <term>FaxTSID</term>
            <term>System.Fax.TSID</term>
            </item>
            <item>
            <term>FileDescription</term>
            <term>System.FileDescription</term>
            </item>
            <item>
            <term>FileSystem</term>
            <term>System.Volume.FileSystem</term>
            </item>
            <item>
            <term>FileType</term>
            <term>System.Image.FileType</term>
            </item>
            <item>
            <term>FileVersion</term>
            <term>System.FileVersion</term>
            </item>
            <item>
            <term>Flash</term>
            <term>System.Photo.Flash</term>
            </item>
            <item>
            <term>FlashEnergy</term>
            <term>System.Photo.FlashEnergy</term>
            </item>
            <item>
            <term>FNumber</term>
            <term>System.Photo.FNumber</term>
            </item>
            <item>
            <term>FocalLength</term>
            <term>System.Photo.FocalLength</term>
            </item>
            <item>
            <term>Frame Rate</term>
            <term>System.Video.FrameRate</term>
            </item>
            <item>
            <term>FrameCount</term>
            <term>System.Media.FrameCount</term>
            </item>
            <item>
            <term>FreeSpace</term>
            <term>System.FreeSpace</term>
            </item>
            <item>
            <term>Genre</term>
            <term>System.Music.Genre</term>
            </item>
            <item>
            <term>ImageX</term>
            <term>System.Image.HorizontalSize</term>
            </item>
            <item>
            <term>ImageY</term>
            <term>System.Image.VerticalSize</term>
            </item>
            <item>
            <term>ISOSpeed</term>
            <term>System.Photo.ISOSpeed</term>
            </item>
            <item>
            <term>LightSource</term>
            <term>System.Photo.LightSource</term>
            </item>
            <item>
            <term>LinksUpToDate</term>
            <term>System.Document.LinksDirty</term>
            </item>
            <item>
            <term>LinkTarget</term>
            <term>System.Link.TargetParsingPath</term>
            </item>
            <item>
            <term>Lyrics</term>
            <term>System.Music.Lyrics</term>
            </item>
            <item>
            <term>Manager</term>
            <term>System.Document.Manager</term>
            </item>
            <item>
            <term>MeteringMode</term>
            <term>System.Photo.MeteringMode</term>
            </item>
            <item>
            <term>MMClipCount</term>
            <term>System.Document.MultimediaClipCount</term>
            </item>
            <item>
            <term>Name</term>
            <term>System.ItemNameDisplay</term>
            </item>
            <item>
            <term>Owner</term>
            <term>System.FileOwner</term>
            </item>
            <item>
            <term>Play Count</term>
            <term>System.DRM.PlayCount</term>
            </item>
            <item>
            <term>Play Expires</term>
            <term>System.DRM.DatePlayExpires</term>
            </item>
            <item>
            <term>Play Starts</term>
            <term>System.DRM.DatePlayStarts</term>
            </item>
            <item>
            <term>PresentationTarget</term>
            <term>System.Document.PresentationFormat</term>
            </item>
            <item>
            <term>ProductName</term>
            <term>System.Software.ProductName</term>
            </item>
            <item>
            <term>ProductVersion</term>
            <term>System.Software.ProductVersion</term>
            </item>
            <item>
            <term>Project</term>
            <term>System.Media.Project</term>
            </item>
            <item>
            <term>Protected</term>
            <term>System.DRM.IsProtected</term>
            </item>
            <item>
            <term>Rank</term>
            <term>System.Search.Rank</term>
            </item>
            <item>
            <term>Rating</term>
            <term>System.Rating</term>
            </item>
            <item>
            <term>ResolutionX</term>
            <term>System.Image.HorizontalResolution</term>
            </item>
            <item>
            <term>ResolutionY</term>
            <term>System.Image.VerticalResolution</term>
            </item>
            <item>
            <term>Sample Rate</term>
            <term>System.Audio.SampleRate</term>
            </item>
            <item>
            <term>Scale</term>
            <term>System.Document.Scale</term>
            </item>
            <item>
            <term>ShutterSpeed</term>
            <term>System.Photo.ShutterSpeed</term>
            </item>
            <item>
            <term>Size</term>
            <term>System.Size</term>
            </item>
            <item>
            <term>Software</term>
            <term>System.SoftwareUsed</term>
            </item>
            <item>
            <term>Status</term>
            <term>System.Media.Status</term>
            </item>
            <item>
            <term>Status</term>
            <term>System.Status</term>
            </item>
            <item>
            <term>Stream Name</term>
            <term>System.Video.StreamName</term>
            </item>
            <item>
            <term>SyncCopyIn</term>
            <term>System.Sync.CopyIn</term>
            </item>
            <item>
            <term>Track</term>
            <term>System.Music.TrackNumber</term>
            </item>
            <item>
            <term>Type</term>
            <term>System.ItemTypeText</term>
            </item>
            <item>
            <term>Video Sample Size</term>
            <term>System.Video.SampleSize</term>
            </item>
            <item>
            <term>WhenTaken</term>
            <term>System.Photo.DateTaken</term>
            </item>
            <item>
            <term>Write</term>
            <term>System.DateModified</term>
            </item>
            <item>
            <term>Year</term>
            <term>System.Media.Year</term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSGetPropertyDescriptionByName to
            retrieve the description for the ratings property.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyDescriptionListFromString(System.String,System.Guid@,Vanara.PInvoke.PropSys.IPropertyDescriptionList@)">
            <summary>
            <para>Gets an instance of a property description list interface for a specified property list.</para>
            </summary>
            <param name="pszPropList">
            <para>Type: <c>LPCWSTR</c></para>
            <para>
            Pointer to a null-terminated, Unicode string that identifies the property list. See
            IPropertySystem::GetPropertyDescriptionListFromString for more information about the format of this parameter.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the interface ID of the requested interface.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid. This is typically IPropertyDescriptionList.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface was obtained.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppv parameter is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function calls the property subsystem implementation of IPropertySystem::GetPropertyDescriptionListFromString to obtain a
            collection of properties provided as a semicolon-delimited property list string.
            </para>
            <para>
            We recommend that you use the <c>IID_PPV_ARGS</c> macro, defined in Objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding error.
            </para>
            <para>For more information about property schemas, see Property Schemas.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSGetPropertyDescriptionListFromString.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyFromPropertyStorage(System.IntPtr,System.UInt32,Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Gets the value of a property as stored in serialized property storage.</para>
            </summary>
            <param name="psps">
            <para>Type: <c>PCUSERIALIZEDPROPSTORAGE</c></para>
            <para>Pointer to an allocated buffer that contains the serialized properties. This buffer is obtained by a call to IPersistSerializedPropStorage::GetPropertyStorage.</para>
            </param>
            <param name="cb">
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the <c>USERIALIZESPROPSTORAGE</c> buffer pointed to by psps.</para>
            </param>
            <param name="rpkey">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>Reference to the PROPERTYKEY that identifies the property for which to get the value.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT**</c></para>
            <para>When this function returns, contains the requested value.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise.</para>
            </returns>
            <remarks>
            <para>
            This function is intended to be called if the calling application already has a serialized property storage and needs no more
            than a few properties from storage. If many properties need to be retrieved, performance can be enhanced by creating a memory
            property store through PSCreateMemoryPropertyStore, initializing the property store by calling
            IPersistSerializedPropStorage::SetPropertyStorage, and by using IPropertyStore to retrieve the properties.
            </para>
            <para>
            Note that PSGetPropertyFromPropertyStorage works only on serialized buffers created by the system implementation of
            IPersistSerializedPropStorage. You must first obtain a memory property store by calling PSCreateMemoryPropertyStore. That store
            can then create a serialized buffer using the <c>IPersistSerializedPropStorage</c> interface.
            </para>
            <para>
            Although SERIALIZEDPROPSTORAGE is an opaque serialized data structure whose format may change in the future, earlier formats will
            be supported on subsequent versions of Windows. Because the format is opaque, applications should use supported property storage
            APIs to access and manipulate the serialized buffer (see IPersistSerializedPropStorage).
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PSGetPropertyFromPropertyStorage to
            read a value from serialized property storage.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyKeyFromName(System.String,Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Gets the property key for a canonical property name.</summary>
            <param name="pszName">Pointer to a property name as a null-terminated, Unicode string.</param>
            <param name="ppropkey">When this function returns, contains the requested property key.</param>
            <returns>The result of the operation. S_OK indicates success.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertySystem(System.Guid@,Vanara.PInvoke.PropSys.IPropertySystem@)">
            <summary>
            <para>Gets an instance of the subsystem object that implements IPropertySystem.</para>
            </summary>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>Reference to the IID of the requested interface.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this function returns, contains the interface pointer requested in riid. This is typically IPropertySystem.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The interface was obtained.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The ppv parameter is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You must initialize Component Object Model (COM) with CoInitialize or OleInitialize prior to calling PSGetPropertySystem. COM
            must remain initialized for the lifetime of this object. The property system object aggregates the free-threaded marshaller and
            is thread-safe.
            </para>
            <para>
            We recommend that you use the IID_PPV_ARGS macro defined in Objbase.h to package the riid and ppv parameters. This macro provides
            the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding error.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSGetPropertySystem.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSGetPropertyValue(Vanara.PInvoke.PropSys.IPropertyStore,Vanara.PInvoke.PropSys.IPropertyDescription,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Gets a property value from a property store.</para>
            </summary>
            <param name="pps">
            <para>Type: <c>IPropertyStore*</c></para>
            <para>Pointer to an instance of the IPropertyStore interface, which represents the property store from which to get the value.</para>
            </param>
            <param name="ppd">
            <para>Type: <c>IPropertyDescription*</c></para>
            <para>Pointer to an instance of the IPropertyDescription interface, which represents the property in the property store.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>Pointer to an uninitialized PROPVARIANT structure. When this function returns, points to the requested property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used to read a property value from a store. If the calling code already has a PROPERTYKEY structure, it
            might be simpler to call IPropertyStore::GetValue directly.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSGetPropertyValue.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSLookupPropertyHandlerCLSID(System.String,System.Guid@)">
            <summary>
            <para>Gets the class identifier (CLSID) of a per-computer, registered file property handler.</para>
            </summary>
            <param name="pszFilePath">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            Pointer to a null-terminated, Unicode buffer that contains the absolute path of the file whose property handler CLSID is requested.
            </para>
            </param>
            <param name="pclsid">
            <para>Type: <c>CLSID*</c></para>
            <para>When this function returns, contains the requested property handler CLSID.</para>
            </param>
            <returns>
            <para>Type: <c>PSSTDAPI</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise.</para>
            </returns>
            <remarks>
            <para>For information on how to register your handler, see Initializing Property Handlers.</para>
            <para>This function returns only those handlers registered under <c>HKEY_LOCAL_MACHINE</c>.</para>
            <para>
            Most calling applications should not need to call this method or use CoCreateInstance to create a property handler directly.
            Instead, calling applications should use IShellItem2::GetPropertyStore to create a property store for a Shell item on Windows
            Vista. <c>IShellItem2::GetPropertyStore</c> provides the largest set of available properties for a Shell item, and the most
            options for customizing exactly which properties to return.
            </para>
            <para>
            If no property handler is registered for the specified file, this function returns an error code. When this happens, it might
            still be possible to read certain file system properties from the property store returned from IShellItem2::GetPropertyStore.
            </para>
            <para>
            Applications that need to create a property handler from code and that must run both on Windows Vista and on Windows XP can call
            PSGetItemPropertyHandler to create a property store for a Shell item through the Microsoft Windows Desktop Search (WDS) redistributable.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSLookupPropertyHandlerCLSID.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyKeyFromString(System.String,Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>
            <para>Converts a string to a PROPERTYKEY structure.</para>
            </summary>
            <param name="pszString">
            <para>Type: <c>LPCWSTR</c></para>
            <para>Pointer to a null-terminated, Unicode string to be converted.</para>
            </param>
            <param name="pkey">
            <para>Type: <c>PROPERTYKEY*</c></para>
            <para>When this function returns, contains a pointer to a PROPERTYKEY structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The string to be converted must be formatted as . For instance, the string that corresponds to is: . PSStringFromPropertyKey
            outputs strings in this format.
            </para>
            <para>This function succeeds for any valid property key string, even if the property does not exist in the property schema.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSPropertyKeyFromString.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSRefreshPropertySchema">
            <summary>
            <para>Not supported.</para>
            <para>It is valid to call this function, but it is not implemented to perform any function so there is no reason to do so.</para>
            </summary>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Schema files reloaded.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The calling context does not have proper privileges.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSRegisterPropertySchema(System.String)">
            <summary>
            <para>Informs the schema subsystem of the addition of a property description schema file.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            Pointer to the full file path, as a Unicode string, to the property description schema (.propdesc) file on the local machine.
            This can be either a fully-specified full path, or a full path that includes environment variables such as .
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>All property descriptions in the schema were registered.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The calling context does not have proper privileges.</term>
            </item>
            <item>
            <term>INPLACE_S_TRUNCATED</term>
            <term>
            One or more property descriptions in the schema failed to register. The specific failures are logged in the application event log.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is a wrapper API for the schema subsystem's implementation of IPropertySystem::RegisterPropertySchema. Call this
            function only when the file is first installed on the computer. Typically, a setup application calls this function after it
            installs the .propdesc file, which should be stored in the install directory of the application under Program Files. Multiple
            calls can be made to <c>IPropertySystem::RegisterPropertySchema</c> in order to register multiple schema files.
            </para>
            <para>
            When registering property schema files, remember that they can be read by processes running as different users. Therefore, it is
            important to place a schema file in a location that grants read access to all users on the machine. Similarly, use the absolute
            path to the file in this function's pszPath parameter.
            </para>
            <para>
            <c>Note</c> Because schemas are specific to the machine and cannot be registered for each individual user, registering a file
            path under user profiles is not supported on Windows Vista.
            </para>
            <para>
            If a full or partial failure is encountered that prevents a property description from being loaded, the cause is recorded in the
            application event log. This function fails with E_ACCESSDENIED if the calling context does not have proper privileges, which
            includes write access to HKEY_LOCAL_MACHINE. It is the responsibility of the calling application to obtain privileges through
            User Account Control (UAC) mechanisms.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSSetPropertyValue(Vanara.PInvoke.PropSys.IPropertyStore,Vanara.PInvoke.PropSys.IPropertyDescription,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Sets the value of a property in a property store.</para>
            </summary>
            <param name="pps">
            <para>Type: <c>IPropertyStore*</c></para>
            <para>Pointer to an instance of the IPropertyStore interface, which represents the property store that contains the property.</para>
            </param>
            <param name="ppd">
            <para>Type: <c>IPropertyDescription*</c></para>
            <para>Pointer to an instance of the IPropertyDescription interface, which identifies the individual property.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a PROPVARIANT structure that contains the new value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used to write a property value to a store. If the calling code already has a PROPERTYKEY structure, it
            might be simpler to call IPropertyStore::SetValue directly.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use PSSetPropertyValue.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSStringFromPropertyKey(Vanara.PInvoke.Ole32.PROPERTYKEY@,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Creates a string that identifies a property from that property's key.</para>
            </summary>
            <param name="pkey">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>Reference to a PROPERTYKEY structure that identifies a property.</para>
            </param>
            <param name="psz">
            <para>Type: <c>LPWSTR</c></para>
            <para>Pointer to a buffer that receives the output string. The buffer should be large enough to contain PKEYSTR_MAX <c>WCHAR</c><c>s</c>.</para>
            </param>
            <param name="cch">
            <para>Type: <c>UINT</c></para>
            <para>The length of the buffer pointed to by psz, in <c>WCHAR</c><c>s</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>The string format retrieved is . For example, the output string for is .</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates the use of PSPropertyKeyFromString.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSUnregisterPropertySchema(System.String)">
            <summary>
            <para>Informs the schema subsystem of the removal of a property description schema file.</para>
            </summary>
            <param name="pszPath">
            <para>Type: <c>PCWSTR</c></para>
            <para>
            Pointer to the full file path, as a Unicode string, to the property description schema (.propdesc) file on the local machine.
            This can be either a fully-specified full path, or a full path that includes environment variables such as .
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The schema was unregistered.</term>
            </item>
            <item>
            <term>E_ACCESSDENIED</term>
            <term>The calling context does not have proper privileges.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is a wrapper for the schema subsystem's implementation of IPropertySystem::UnregisterPropertySchema. Call this
            method when the file is being uninstalled from the computer. Typically, a setup application calls this method before or after
            uninstalling the .propdesc file. This method can be called after the file no longer exists.
            </para>
            <para>
            This function fails with a code of E_ACCESSDENIED if the calling context does not have proper privileges, which include write
            access to HKLM (HKEY_LOCAL_MACHINE). It is the responsibility of the calling application to obtain privileges through User
            Account Control (UAC) mechanisms.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.CONDITION_OPERATION">
            <summary>
            Provides a set of flags to be used with following methods to indicate the operation in ICondition::GetComparisonInfo,
            ICondition2::GetLeafConditionInfo, IConditionFactory::MakeLeaf, IConditionFactory2::CreateBooleanLeaf,
            IConditionFactory2::CreateIntegerLeaf, IConditionFactory2::MakeLeaf, IConditionFactory2::CreateStringLeaf, and IConditionGenerator::GenerateForLeaf.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_IMPLICIT">
            <summary>
            An implicit comparison between the value of the property and the value of the constant. For an unresolved condition,
            COP_IMPLICIT means that a user did not type an operation. In contrast, a resolved condition will always have a condition
            other than the COP_IMPLICIT operation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_EQUAL">
            <summary>The value of the property and the value of the constant must be equal.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_NOTEQUAL">
            <summary>The value of the property and the value of the constant must not be equal.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_LESSTHAN">
            <summary>The value of the property must be less than the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_GREATERTHAN">
            <summary>The value of the property must be greater than the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_LESSTHANOREQUAL">
            <summary>The value of the property must be less than or equal to the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_GREATERTHANOREQUAL">
            <summary>The value of the property must be greater than or equal to the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_VALUE_STARTSWITH">
            <summary>The value of the property must begin with the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_VALUE_ENDSWITH">
            <summary>The value of the property must end with the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_VALUE_CONTAINS">
            <summary>The value of the property must contain the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_VALUE_NOTCONTAINS">
            <summary>The value of the property must not contain the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_DOSWILDCARDS">
            <summary>
            The value of the property must match the value of the constant, where '?' matches any single character and '*' matches any
            sequence of characters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_WORD_EQUAL">
            <summary>The value of the property must contain a word that is the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_WORD_STARTSWITH">
            <summary>The value of the property must contain a word that begins with the value of the constant.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.CONDITION_OPERATION.COP_APPLICATION_SPECIFIC">
            <summary>The application is free to interpret this in any suitable way.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE">
            <summary>
            Describes how property values are displayed when multiple items are selected. For a particular property,
            PROPDESC_AGGREGATION_TYPE describes how the property should be displayed when multiple items that have a value for the property
            are selected, such as whether the values should be summed, or averaged, or just displayed with the default "Multiple Values" string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_DEFAULT">
            <summary>Display the string "Multiple Values".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_FIRST">
            <summary>Display the first value in the selection.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_SUM">
            <summary>Display the sum of the selected values. This flag is never returned for data types VT_LPWSTR, VT_BOOL, and VT_FILETIME.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_AVERAGE">
            <summary>
            Display the numerical average of the selected values. This flag is never returned for data types VT_LPWSTR, VT_BOOL, and VT_FILETIME.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_DATERANGE">
            <summary>
            Display the date range of the selected values. This flag is returned only for values of the VT_FILETIME data type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_UNION">
            <summary>
            Display a concatenated string of all the values. The order of individual values in the string is undefined. The concatenated
            string omits duplicate values; if a value occurs more than once, it appears only once in the concatenated string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_MAX">
            <summary>Display the highest of the selected values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_AGGREGATION_TYPE.PDAT_MIN">
            <summary>Display the lowest of the selected values.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE">
            <summary>
            Describes the condition type to use when displaying the property in the query builder UI in Windows Vista, but not in Windows 7
            and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_NONE">
            <summary>The default value; it means the condition type is unspecified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_STRING">
            <summary>Use the string condition type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_SIZE">
            <summary>Use the size condition type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_DATETIME">
            <summary>Use the date/time condition type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_BOOLEAN">
            <summary>Use the Boolean condition type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE.PDCOT_NUMBER">
            <summary>Use the number condition type.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE">
            <summary>A value that indicates the display type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE.PDDT_STRING">
            <summary>The value is displayed as a string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE.PDDT_NUMBER">
            <summary>The value is displayed as an integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE.PDDT_BOOLEAN">
            <summary>The value is displayed as a Boolean value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE.PDDT_DATETIME">
            <summary>The value is displayed as date and time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_DISPLAYTYPE.PDDT_ENUMERATED">
            <summary>
            The value is displayed as an enumerated type-list. Use IPropertyDescription::GetEnumTypeList to handle this type.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER">
            <summary>Describes the filtered list of property descriptions that is returned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_ALL">
            <summary>The list contains all property descriptions in the system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_SYSTEM">
            <summary>
            The list contains system property descriptions only. It excludes third-party property descriptions that are registered on
            the computer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_NONSYSTEM">
            <summary>The list contains only third-party property descriptions that are registered on the computer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_VIEWABLE">
            <summary>The list contains only viewable properties, where &lt;typeInfo isViewable="true"&gt;.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_QUERYABLE">
            <summary>
            Deprecated in Windows 7 and later. The list contains only queryable properties, where &lt;typeInfo isViewable="true" isQueryable="true"&gt;.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_INFULLTEXTQUERY">
            <summary>Deprecated in Windows 7 and later. The list contains only properties to be included in full-text queries.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER.PDEF_COLUMN">
            <summary>The list contains only properties that are columns.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS">
            <summary>
            Used by property description helper functions, such as PSFormatForDisplay, to indicate the format of a property string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_DEFAULT">
            <summary>Use the format settings specified in the property's .propdesc file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_PREFIXNAME">
            <summary>
            Precede the value with the property's display name. If the hideLabelPrefix attribute of the labelInfo element in the
            property's .propinfo file is set to true, then this flag is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_FILENAME">
            <summary>Treat the string as a file name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_ALWAYSKB">
            <summary>
            Byte sizes are always displayed in KB, regardless of size. This enables clean alignment of the values in the column. This
            flag applies only to properties that have been declared as type Integer in the displayType attribute of the displayInfo
            element in the property's .propinfo file. This flag overrides the numberFormat setting.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_RESERVED_RIGHTTOLEFT">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_SHORTTIME">
            <summary>Display time as "hh:mm am/pm".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_LONGTIME">
            <summary>Display time as "hh:mm:ss am/pm".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_HIDETIME">
            <summary>Hide the time portion of datetime.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_SHORTDATE">
            <summary>Display date as "MM/DD/YY". For example, "03/21/04".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_LONGDATE">
            <summary>Display date as "DayOfWeek, Month day, year". For example, "Monday, March 21, 2009".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_HIDEDATE">
            <summary>Hide the date portion of datetime.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_RELATIVEDATE">
            <summary>Use friendly date descriptions. For example, "Yesterday".</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_USEEDITINVITATION">
            <summary>
            Return the invitation text if formatting failed or the value was empty. Invitation text is text displayed in a text box as a
            cue for the user, such as "Enter your name". Formatting can fail if the data entered is not of an expected type, such as
            when alpha characters have been entered in a phone-number field.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_READONLY">
            <summary>
            If this flag is used, the PDFF_USEEDITINVITATION flag must also be specified. When the formatting flags are PDFF_READONLY |
            PDFF_USEEDITINVITATION and the algorithm would have shown invitation text, a string is returned that indicates the value is
            "Unknown" instead of returning the invitation text.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS.PDFF_NOAUTOREADINGORDER">
            <summary>
            Do not detect reading order automatically. Useful when converting to ANSI to omit the Unicode reading order characters.
            However, reading order characters for some values are still returned.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE">
            <summary>A flag value that indicates the grouping type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_DISCRETE">
            <summary>Displays individual values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_ALPHANUMERIC">
            <summary>Displays static alphanumeric ranges.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_SIZE">
            <summary>Displays static size ranges.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_DYNAMIC">
            <summary>Displays dynamically created ranges.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_DATE">
            <summary>Displays month and year groups.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_PERCENT">
            <summary>Displays percent groups.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_GROUPING_RANGE.PDGR_ENUMERATED">
            <summary>Displays percent groups returned by IPropertyDescription::GetEnumTypeList.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE">
            <summary>
            Describes the relative description type for a property description, as determined by the relativeDescriptionType attribute of
            the displayInfo element.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_GENERAL">
            <summary>General type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_DATE">
            <summary>Date type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_SIZE">
            <summary>Size type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_COUNT">
            <summary>Count type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_REVISION">
            <summary>Revision type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_LENGTH">
            <summary>Length type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_DURATION">
            <summary>Duration type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_SPEED">
            <summary>Speed type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_RATE">
            <summary>Rate type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_RATING">
            <summary>Rating type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_RELATIVEDESCRIPTION_TYPE.PDRDT_PRIORITY">
            <summary>Priority type.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION">
            <summary>Indicate the sort types available to the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION.PDSD_GENERAL">
            <summary>Default. "Sort going up", "Sort going down"</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION.PDSD_A_Z">
            <summary>"A on top", "Z on top"</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION.PDSD_LOWEST_HIGHEST">
            <summary>"Lowest on top", "Highest on top"</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION.PDSD_SMALLEST_BIGGEST">
            <summary>"Smallest on top", "Largest on top"</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_SORTDESCRIPTION.PDSD_OLDEST_NEWEST">
            <summary>"Oldest on top", "Newest on top"</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS">
            <summary>Describes attributes of the typeInfo element in the property's .propdesc file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_DEFAULT">
            <summary>The property uses the default values for all attributes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_MULTIPLEVALUES">
            <summary>
            The property can have multiple values. These values are stored as a VT_VECTOR in the PROPVARIANT structure. This value is
            set by the multipleValues attribute of the typeInfo element in the property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISINNATE">
            <summary>
            This flag indicates that a property is read-only, and cannot be written to. This value is set by the isInnate attribute of
            the typeInfo element in the property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISGROUP">
            <summary>
            The property is a group heading. This value is set by the isGroup attribute of the typeInfo element in the property's
            .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_CANGROUPBY">
            <summary>
            The user can group by this property. This value is set by the canGroupBy attribute of the typeInfo element in the property's
            .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_CANSTACKBY">
            <summary>
            The user can stack by this property. This value is set by the canStackBy attribute of the typeInfo element in the property's
            .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISTREEPROPERTY">
            <summary>
            This property contains a hierarchy. This value is set by the isTreeProperty attribute of the typeInfo element in the
            property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_INCLUDEINFULLTEXTQUERY">
            <summary>
            Deprecated in Windows 7 and later. Include this property in any full text query that is performed. This value is set by the
            includeInFullTextQuery attribute of the typeInfo element in the property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISVIEWABLE">
            <summary>
            This property is meant to be viewed by the user. This influences whether the property shows up in the "Choose Columns"
            dialog box, for example. This value is set by the isViewable attribute of the typeInfo element in the property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISQUERYABLE">
            <summary>
            Deprecated in Windows 7 and later. This property is included in the list of properties that can be queried. A queryable
            property must also be viewable. This influences whether the property shows up in the query builder UI. This value is set by
            the isQueryable attribute of the typeInfo element in the property's .propdesc file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_CANBEPURGED">
            <summary>
            Windows Vista with Service Pack 1 (SP1) and later. Used with an innate property (that is, a value calculated from other
            property values) to indicate that it can be deleted. This value is used by the Remove Properties UI to determine whether to
            display a check box next to a property that enables that property to be selected for removal. Note that a property that is
            not innate can always be purged regardless of the presence or absence of this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_SEARCHRAWVALUE">
            <summary>Windows 7 and later. The unformatted (raw) property value should be used for searching.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_DONTCOERCEEMPTYSTRINGS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ALWAYSINSUPPLEMENTALSTORE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_ISSYSTEMPROPERTY">
            <summary>This property is owned by the system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS.PDTF_MASK_ALL">
            <summary>A mask used to retrieve all flags.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS">
            <summary>These flags describe properties in property description list strings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_DEFAULT">
            <summary>Show this property by default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_CENTERALIGN">
            <summary>This property should be centered.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_RIGHTALIGN">
            <summary>This property should be right aligned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_BEGINNEWGROUP">
            <summary>Show this property as the beginning of the next collection of properties in the view.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_FILLAREA">
            <summary>Fill the remainder of the view area with the content of this property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_SORTDESCENDING">
            <summary>Sort this property in reverse (descending) order. Applies to a property in a list of sorted properties.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_SHOWONLYIFPRESENT">
            <summary>Show this property only if it is present.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_SHOWBYDEFAULT">
            <summary>This property should be shown by default in a view (where applicable).</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_SHOWINPRIMARYLIST">
            <summary>This property should be shown by default in the primary column selection UI.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_SHOWINSECONDARYLIST">
            <summary>This property should be shown by default in the secondary column selection UI.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_HIDELABEL">
            <summary>Hide the label of this property if the view normally shows the label.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_HIDDEN">
            <summary>This property should not be displayed as a column in the UI.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_CANWRAP">
            <summary>This property can be wrapped to the next row.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPDESC_VIEW_FLAGS.PDVF_MASK_ALL">
            <summary>A mask used to retrieve all flags.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPENUMTYPE">
            <summary>Property Enumeration Types</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPENUMTYPE.PET_DISCRETEVALUE">
            <summary>Use DisplayText and either RangeMinValue or RangeSetValue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPENUMTYPE.PET_RANGEDVALUE">
            <summary>Use DisplayText and either RangeMinValue or RangeSetValue</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPENUMTYPE.PET_DEFAULTVALUE">
            <summary>Use DisplayText</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPENUMTYPE.PET_ENDRANGE">
            <summary>Use Value or RangeMinValue</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.STOREID">
            <summary>Values used by <see cref="M:Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory.GetDelayedPropertyStore(Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,Vanara.PInvoke.PropSys.STOREID,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.STOREID.STOREID_INNATE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.STOREID.STOREID_FILE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.STOREID.STOREID_FALLBACK">
            <summary>Undocumented.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.ICreateObject">
            <summary>Exposes a method that creates an object of a specified class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.ICreateObject.CreateObject(System.Guid@,System.Object,System.Guid@,System.Object@)">
            <summary>
            <para>Creates a local object of a specified class and returns a pointer to a specified interface on the object.</para>
            </summary>
            <param name="clsid">
            <para>Type: <c>REFCLSID</c></para>
            <para>A reference to a CLSID.</para>
            </param>
            <param name="pUnkOuter">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            A pointer to the IUnknown interface that aggregates the object created by this function, or <c>NULL</c> if no aggregation is desired.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the interface the created object should return.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of the pointer to the interface requested in riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This method can be used with GetPropertyStoreWithCreateObject.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory">
            <summary>
            Exposes a method to create a specified IPropertyStore object in circumstances where property access is potentially slow.
            </summary>
            <seealso cref="T:Vanara.PInvoke.PropSys.IPropertyStoreFactory"/>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory.GetPropertyStore(Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,Vanara.PInvoke.PropSys.ICreateObject,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>Gets an IPropertyStore object that corresponds to the supplied flags.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>GETPROPERTYSTOREFLAGS values that modify the store that is returned.</para>
            </param>
            <param name="pUnkFactory">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            Optional. A pointer to the IUnknown of an object that implements ICreateObject. If pUnkFactory is provided, this method can
            create the handler instance using <c>ICreateObject</c> rather than CoCreateInstance, if implemented. The reason to provide
            pUnkFactory is usually to create the handler in a different process. However, for most users, passing <c>NULL</c> in this
            parameter is sufficient.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to IID of the object to create.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of an IPropertyStore interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a
            coding error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory.GetPropertyStoreForKeys(Vanara.PInvoke.Ole32.PROPERTYKEY[],System.UInt32,Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>
            Gets an IPropertyStore object, given a set of property keys. This provides an alternative, possibly faster, method of
            getting an <c>IPropertyStore</c> object compared to calling IPropertyStoreFactory::GetPropertyStore.
            </para>
            </summary>
            <param name="rgKeys">
            <para>Type: <c>const PROPERTYKEY*</c></para>
            <para>A pointer to an array of PROPERTYKEY structures.</para>
            </param>
            <param name="cKeys">
            <para>Type: <c>UINT</c></para>
            <para>The number of PROPERTYKEY structures in the array pointed to by rgKeys.</para>
            </param>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>GETPROPERTYSTOREFLAGS values that modify the store that is returned.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to IID of the object to create.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of an IPropertyStore interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a
            coding error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IDelayedPropertyStoreFactory.GetDelayedPropertyStore(Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,Vanara.PInvoke.PropSys.STOREID,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>Gets an IPropertyStore interface object, as specified.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>The GPS_XXX flags that modify the store that is returned. See GETPROPERTYSTOREFLAGS.</para>
            </param>
            <param name="dwStoreId">
            <para>Type: <c>DWORD</c></para>
            <para>The property store ID. Valid values are.</para>
            <para>STOREID_INNATE</para>
            <para>Value is 0.</para>
            <para>STOREID_FILE</para>
            <para>Value is 1.</para>
            <para>STOREID_FALLBACK</para>
            <para>Value is 2.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the desired IID.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>The address of an IPropertyStore interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IInitializeWithStream">
            <summary>
            Exposes a method that initializes a handler, such as a property handler, thumbnail handler, or preview handler, with a stream.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IInitializeWithStream.Initialize(System.Runtime.InteropServices.ComTypes.IStream,Vanara.PInvoke.STGM)">
            <summary>Initializes a handler with a stream.</summary>
            <param name="pstream">A pointer to an IStream interface that represents the stream source.</param>
            <param name="grfMode">One of the following STGM values that indicates the access mode for pstream. STGM_READ or STGM_READWRITE.</param>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPersistSerializedPropStorage">
            <summary>
            Exposes methods to persist serialized property storage data for later use and to restore persisted data to a new property store instance.
            </summary>
            <remarks>
            <para>Use the IPropertyStore interface to read and write values from and to the property store.</para>
            <para>When to Use</para>
            <para>
            The in-memory property store, created by calling PSCreateMemoryPropertyStore, provides an implementation of this interface. Use
            this implementation when you want to persist or restore serialized property storage data.
            </para>
            <para>When to Implement</para>
            <para>
            <c>IPersistSerializedPropStorage</c> is not intended for custom implementation. Use the system-provided implementation
            associated with the in-memory property store.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPersistSerializedPropStorage.SetFlags(Vanara.PInvoke.PropSys.PERSIST_SPROPSTORE_FLAGS)">
            <summary>Toggles the property store object between the read-only and read/write state.</summary>
            <param name="flags">
            <para>Type: <c>PERSIST_SPROPSTORE_FLAGS</c></para>
            <para>The flags parameter takes one of the following values to set options for the behavior of the property storage:</para>
            <para>FPSPS_DEFAULT (0x00000000)</para>
            <para><c>Windows 7 and later</c>. The property store object is read/write.</para>
            <para>FPSPS_READONLY (0x00000001)</para>
            <para>The property store object is read-only.</para>
            <para>FPSPS_TREAT_NEW_VALUES_AS_DIRTY (0x00000002)</para>
            <para>
            <c>Introduced in Windows 8</c>. New property values that are added to the property store through the
            IPropertyStore::SetValue method will cause the IPersistStream::IsDirty method to return S_OK. If this flag is not set, the
            addition of new property values to the property store does not affect the value returned by <c>IPersistStream::IsDirty</c>.
            </para>
            </param>
            <remarks>
            <para>
            Read/write is the default setting. <c>IPersistSerializedPropStorage::SetFlags</c> can be called at any time to toggle the
            read-only and read/write state of the property store.
            </para>
            <para>
            In versions of Windows before Windows 7, callers can assign a literal zero value directly into the flags parameter to set
            the read/write state. As of Windows 7, the FPSPS_DEFAULT flag value should be used instead.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPersistSerializedPropStorage.SetPropertyStorage(System.IntPtr,System.UInt32)">
            <summary>Initializes the property store instance from the specified serialized property storage data.</summary>
            <param name="psps">
            <para>Type: <c>PCUSERIALIZEDPROPSTORAGE</c></para>
            <para>A pointer to the serialized property store data that will be used to initialize the property store.</para>
            </param>
            <param name="cb">
            <para>Type: <c>DWORD</c></para>
            <para>The count of bytes contained in the serialized property storage data pointed to by psps.</para>
            </param>
            <remarks>
            The <c>SERIALIZEDPROPSTORAGE</c> type is defined in Propsys.h as an incomplete type. It should be treated as an array of
            <c>BYTE</c> values; the format of the data returned is not specified. The data stored as a <c>SERIALIZEDPROPSTORAGE</c>
            structure must have been obtained through a call to IPersistSerializedPropStorage::GetPropertyStorage, either directly or
            through persisted data that was generated by a call to that method.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPersistSerializedPropStorage.GetPropertyStorage(System.IntPtr@,System.UInt32@)">
            <summary>Gets the serialized property storage data from the property store instance.</summary>
            <param name="ppsps">
            <para>Type: <c>SERIALIZEDPROPSTORAGE**</c></para>
            <para>When this method returns, contains the address of a pointer to the serialized property storage data.</para>
            </param>
            <param name="pcb">
            <para>Type: <c>DWORD*</c></para>
            <para>
            When this method returns, contains the count of bytes contained in the serialized property storage data pointed to by ppsps.
            </para>
            </param>
            <remarks>
            <para>
            The <c>SERIALIZEDPROPSTORAGE</c> type is defined in Propsys.h as an incomplete type. It should be treated as an array of
            <c>BYTE</c> values; the format of the returned data is not specified. The contents of the <c>SERIALIZEDPROPSTORAGE</c>
            structure are suitable for persisting to disk or other storage and can be used to initialize another property store through IPersistSerializedPropStorage::SetPropertyStorage.
            </para>
            <para>
            <c>Note</c> It is the responsibility of the application that calls <c>IPersistSerializedPropStorage::GetPropertyStorage</c>
            to later call CoTaskMemFree to release the memory referred to by ppsps when it is no longer needed.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyDescription">
            <summary>Exposes methods that enumerate and retrieve individual property description details.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetPropertyKey">
            <summary>Gets a structure that acts as a property's unique identifier.</summary>
            <returns>When this method returns, contains a pointer to a PROPERTYKEY structure.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetCanonicalName">
            <summary>Gets the case-sensitive name by which a property is known to the system, regardless of its localized name.</summary>
            <returns>
            When this method returns, contains the address of a pointer to the property's canonical name as a null-terminated Unicode string.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetPropertyType">
            <summary>Gets the variant type of the property.</summary>
            <returns>
            When this method returns, contains a pointer to a VARTYPE that indicates the property type. If the property is multi-valued,
            the value pointed to is a VT_VECTOR mask (VT_VECTOR ORed to the VARTYPE.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetDisplayName(Vanara.InteropServices.SafeCoTaskMemString@)">
            <summary>Gets the display name of the property as it is shown in any UI.</summary>
            <param name="pszName">Contains the address of a pointer to the property's name as a null-terminated Unicode string.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetEditInvitation">
            <summary>Gets the text used in edit controls hosted in various dialog boxes.</summary>
            <returns>
            When this method returns, contains the address of a pointer to a null-terminated Unicode buffer that holds the invitation text.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetTypeFlags(Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS)">
            <summary>Gets a set of flags that describe the uses and capabilities of the property.</summary>
            <param name="mask">
            A mask that specifies which type flags to retrieve. A combination of values found in the PROPDESC_TYPE_FLAGS constants. To
            retrieve all type flags, pass PDTF_MASK_ALL
            </param>
            <returns>When this method returns, contains a pointer to a value that consists of bitwise PROPDESC_TYPE_FLAGS values.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetViewFlags">
            <summary>Gets the current set of flags governing the property's view.</summary>
            <returns>
            When this method returns, contains a pointer to a value that includes one or more of the following flags. See
            PROPDESC_VIEW_FLAGS for valid values.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetDefaultColumnWidth">
            <summary>Gets the default column width of the property in a list view.</summary>
            <returns>A pointer to the column width value, in characters.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetDisplayType">
            <summary>Gets the current data type used to display the property.</summary>
            <returns>Contains a pointer to a value that indicates the display type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetColumnState">
            <summary>
            Gets the column state flag, which describes how the property should be treated by interfaces or APIs that use this flag.
            </summary>
            <returns>When this method returns, contains a pointer to the column state flag.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetGroupingRange">
            <summary>Gets the grouping method to be used when a view is grouped by a property, and retrieves the grouping type.</summary>
            <returns>Receives a pointer to a flag value that indicates the grouping type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetRelativeDescriptionType">
            <summary>Gets the relative description type for a property description.</summary>
            <returns>
            When this method returns, contains a pointer to the relative description type value. See PROPDESC_RELATIVEDESCRIPTION_TYPE
            for valid values.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetRelativeDescription(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,System.String@,System.String@)">
            <summary>
            Compares two property values in the manner specified by the property description. Returns two display strings that describe
            how the two properties compare.
            </summary>
            <param name="propvar1">A reference to a PROPVARIANT structure that contains the type and value of the first property.</param>
            <param name="propvar2">A reference to a PROPVARIANT structure that contains the type and value of the second property.</param>
            <param name="ppszDesc1">
            When this method returns, contains the address of a pointer to the description string that compares the first property with
            the second property. The string is null-terminated.
            </param>
            <param name="ppszDesc2">
            When this method returns, contains the address of a pointer to the description string that compares the second property with
            the first property. The string is null-terminated.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetSortDescription">
            <summary>Gets the current sort description flags for the property, which indicate the particular wordings of sort offerings.</summary>
            <returns>
            When this method returns, contains a pointer to the value of one or more of the following flags that indicate the sort types
            available to the user. Note that the strings shown are English versions only. Localized strings are used for other locales.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetSortDescriptionLabel(System.Boolean)">
            <summary>Gets the localized display string that describes the current sort order.</summary>
            <param name="fDescending">
            TRUE if ppszDescription should reference the string "Z on top"; FALSE to reference the string "A on top".
            </param>
            <returns>
            When this method returns, contains the address of a pointer to the sort description as a null-terminated Unicode string.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetAggregationType">
            <summary>Gets a value that describes how the property values are displayed when multiple items are selected in the UI.</summary>
            <returns>When this method returns, contains a pointer to a value that indicates the aggregation type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetConditionType(Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE@,Vanara.PInvoke.PropSys.CONDITION_OPERATION@)">
            <summary>
            Gets the condition type and default condition operation to use when displaying the property in the query builder UI. This
            influences the list of predicate conditions (for example, equals, less than, and contains) that are shown for this property.
            </summary>
            <param name="pcontype">A pointer to a value that indicates the condition type.</param>
            <param name="popDefault">When this method returns, contains a pointer to a value that indicates the default condition operation.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.GetEnumTypeList(System.Guid@)">
            <summary>Gets an instance of an IPropertyEnumTypeList, which can be used to enumerate the possible values for a property.</summary>
            <param name="riid">Reference to the interface ID of the requested interface.</param>
            <returns>When this method returns, contains the address of an IPropertyEnumTypeList interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.CoerceToCanonicalValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Coerces the value to the canonical value, according to the property description.</summary>
            <param name="propvar">
            On entry, contains a pointer to a PROPVARIANT structure that contains the original value. When this method returns, contains
            the canonical value.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.FormatForDisplay(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS)">
            <summary>Gets a formatted, Unicode string representation of a property value.</summary>
            <param name="propvar">A reference to a PROPVARIANT structure that contains the type and value of the property.</param>
            <param name="pdfFlags">
            One or more of the PROPDESC_FORMAT_FLAGS flags, which are either bitwise or multiple values, that indicate the property
            string format.
            </param>
            <returns>
            When this method returns, contains the formatted value as a null-terminated, Unicode string. The calling application must
            allocate memory for the buffer, and use CoTaskMemFree to release the string specified by pszText when it is no longer needed.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription.IsValueCanonical(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a value that indicates whether a property is canonical according to the definition of the property description.</summary>
            <param name="propvar">A reference to a PROPVARIANT structure that contains the type and value of the property.</param>
            <returns>Returns one of the following values: S_OK = The value is canonical; S_FALSE = The value is not canonical.</returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyDescription2">
            <summary>Exposes methods that enumerate and retrieve individual property description details.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetPropertyKey">
            <summary>Gets a structure that acts as a property's unique identifier.</summary>
            <returns>When this method returns, contains a pointer to a PROPERTYKEY structure.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetCanonicalName">
            <summary>Gets the case-sensitive name by which a property is known to the system, regardless of its localized name.</summary>
            <returns>
            When this method returns, contains the address of a pointer to the property's canonical name as a null-terminated Unicode string.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetPropertyType">
            <summary>Gets the variant type of the property.</summary>
            <returns>
            When this method returns, contains a pointer to a VARTYPE that indicates the property type. If the property is multi-valued,
            the value pointed to is a VT_VECTOR mask (VT_VECTOR ORed to the VARTYPE.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetDisplayName(Vanara.InteropServices.SafeCoTaskMemString@)">
            <summary>Gets the display name of the property as it is shown in any UI.</summary>
            <param name="pszName">Contains the address of a pointer to the property's name as a null-terminated Unicode string.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetEditInvitation">
            <summary>Gets the text used in edit controls hosted in various dialog boxes.</summary>
            <returns>
            When this method returns, contains the address of a pointer to a null-terminated Unicode buffer that holds the invitation text.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetTypeFlags(Vanara.PInvoke.PropSys.PROPDESC_TYPE_FLAGS)">
            <summary>Gets a set of flags that describe the uses and capabilities of the property.</summary>
            <param name="mask">
            A mask that specifies which type flags to retrieve. A combination of values found in the PROPDESC_TYPE_FLAGS constants. To
            retrieve all type flags, pass PDTF_MASK_ALL
            </param>
            <returns>When this method returns, contains a pointer to a value that consists of bitwise PROPDESC_TYPE_FLAGS values.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetViewFlags">
            <summary>Gets the current set of flags governing the property's view.</summary>
            <returns>
            When this method returns, contains a pointer to a value that includes one or more of the following flags. See
            PROPDESC_VIEW_FLAGS for valid values.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetDefaultColumnWidth">
            <summary>Gets the default column width of the property in a list view.</summary>
            <returns>A pointer to the column width value, in characters.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetDisplayType">
            <summary>Gets the current data type used to display the property.</summary>
            <returns>Contains a pointer to a value that indicates the display type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetColumnState">
            <summary>
            Gets the column state flag, which describes how the property should be treated by interfaces or APIs that use this flag.
            </summary>
            <returns>When this method returns, contains a pointer to the column state flag.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetGroupingRange">
            <summary>Gets the grouping method to be used when a view is grouped by a property, and retrieves the grouping type.</summary>
            <returns>Receives a pointer to a flag value that indicates the grouping type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetRelativeDescriptionType">
            <summary>Gets the relative description type for a property description.</summary>
            <returns>
            When this method returns, contains a pointer to the relative description type value. See PROPDESC_RELATIVEDESCRIPTION_TYPE
            for valid values.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetRelativeDescription(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,System.String@,System.String@)">
            <summary>
            Compares two property values in the manner specified by the property description. Returns two display strings that describe
            how the two properties compare.
            </summary>
            <param name="propvar1">A reference to a PROPVARIANT structure that contains the type and value of the first property.</param>
            <param name="propvar2">A reference to a PROPVARIANT structure that contains the type and value of the second property.</param>
            <param name="ppszDesc1">
            When this method returns, contains the address of a pointer to the description string that compares the first property with
            the second property. The string is null-terminated.
            </param>
            <param name="ppszDesc2">
            When this method returns, contains the address of a pointer to the description string that compares the second property with
            the first property. The string is null-terminated.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetSortDescription">
            <summary>Gets the current sort description flags for the property, which indicate the particular wordings of sort offerings.</summary>
            <returns>
            When this method returns, contains a pointer to the value of one or more of the following flags that indicate the sort types
            available to the user. Note that the strings shown are English versions only. Localized strings are used for other locales.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetSortDescriptionLabel(System.Boolean)">
            <summary>Gets the localized display string that describes the current sort order.</summary>
            <param name="fDescending">
            TRUE if ppszDescription should reference the string "Z on top"; FALSE to reference the string "A on top".
            </param>
            <returns>
            When this method returns, contains the address of a pointer to the sort description as a null-terminated Unicode string.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetAggregationType">
            <summary>Gets a value that describes how the property values are displayed when multiple items are selected in the UI.</summary>
            <returns>When this method returns, contains a pointer to a value that indicates the aggregation type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetConditionType(Vanara.PInvoke.PropSys.PROPDESC_CONDITION_TYPE@,Vanara.PInvoke.PropSys.CONDITION_OPERATION@)">
            <summary>
            Gets the condition type and default condition operation to use when displaying the property in the query builder UI. This
            influences the list of predicate conditions (for example, equals, less than, and contains) that are shown for this property.
            </summary>
            <param name="pcontype">A pointer to a value that indicates the condition type.</param>
            <param name="popDefault">When this method returns, contains a pointer to a value that indicates the default condition operation.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetEnumTypeList(System.Guid@)">
            <summary>Gets an instance of an IPropertyEnumTypeList, which can be used to enumerate the possible values for a property.</summary>
            <param name="riid">Reference to the interface ID of the requested interface.</param>
            <returns>When this method returns, contains the address of an IPropertyEnumTypeList interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.CoerceToCanonicalValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Coerces the value to the canonical value, according to the property description.</summary>
            <param name="propvar">
            On entry, contains a pointer to a PROPVARIANT structure that contains the original value. When this method returns, contains
            the canonical value.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.FormatForDisplay(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS)">
            <summary>Gets a formatted, Unicode string representation of a property value.</summary>
            <param name="propvar">A reference to a PROPVARIANT structure that contains the type and value of the property.</param>
            <param name="pdfFlags">
            One or more of the PROPDESC_FORMAT_FLAGS flags, which are either bitwise or multiple values, that indicate the property
            string format.
            </param>
            <returns>
            When this method returns, contains the formatted value as a null-terminated, Unicode string. The calling application must
            allocate memory for the buffer, and use CoTaskMemFree to release the string specified by pszText when it is no longer needed.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.IsValueCanonical(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a value that indicates whether a property is canonical according to the definition of the property description.</summary>
            <param name="propvar">A reference to a PROPVARIANT structure that contains the type and value of the property.</param>
            <returns>Returns one of the following values: S_OK = The value is canonical; S_FALSE = The value is not canonical.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescription2.GetImageReferenceForValue(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemString@)">
            <summary>Gets the image reference associated with a property value.</summary>
            <param name="propvar">The PROPVARIANT for which to get an image.</param>
            <param name="ppszImageRes">
            A string that receives, when this method returns successfully, a string of the form &lt;dll name&gt;,-&lt;resid&gt; that is
            suitable to be passed to PathParseIconLocation.
            </param>
            <returns>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyDescriptionList">
            <summary>Exposes methods that enumerate and retrieve property description list details.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescriptionList.GetCount">
            <summary>Gets the number of properties included in the property list.</summary>
            <returns>
            <para>Type: <c>UINT*</c></para>
            <para>When this method returns, contains a pointer to the count of properties.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyDescriptionList.GetAt(System.UInt32,System.Guid@)">
            <summary>Gets the property description at the specified index in a property description list.</summary>
            <param name="iElem">
            <para>Type: <c>UINT</c></para>
            <para>The number of the property in the list string.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the IID of the requested property description interface, typically IID_IPropertyDescription.</para>
            </param>
            <returns>
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the interface pointer requested in riid. Typically, this is IPropertyDescription.</para>
            </returns>
            <remarks>It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This macro provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a coding error.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyEnumType">
            <summary>
            Exposes methods that extract data from enumeration information. IPropertyEnumType gives access to the enum and enumRange
            elements in the property schema in a programmatic way at run time.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType.GetEnumType">
            <summary>Gets an enumeration type from an enumeration information structure.</summary>
            <returns>When this method returns, contains a value that indicate the enumeration type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType.GetValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a value from an enumeration information structure.</summary>
            <param name="ppropvar">When this method returns, contains a pointer to the property value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType.GetRangeMinValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a minimum value from an enumeration information structure.</summary>
            <param name="ppropvarMin">When this method returns, contains a pointer to the minimum value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType.GetRangeSetValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a set value from an enumeration information structure.</summary>
            <param name="ppropvarSet">When this method returns, contains a pointer to the set value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType.GetDisplayText(System.String@)">
            <summary>Gets display text from an enumeration information structure.</summary>
            <param name="ppszDisplay">
            When this method returns, contains the address of a pointer to a null-terminated Unicode string that contains the display text.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyEnumType2">
            <summary>Exposes methods that extract data from enumeration information. IPropertyEnumType2 extends IPropertyEnumType.</summary>
            <seealso cref="T:Vanara.PInvoke.PropSys.IPropertyEnumType"/>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetEnumType">
            <summary>Gets an enumeration type from an enumeration information structure.</summary>
            <returns>When this method returns, contains a value that indicate the enumeration type.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a value from an enumeration information structure.</summary>
            <param name="ppropvar">When this method returns, contains a pointer to the property value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetRangeMinValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a minimum value from an enumeration information structure.</summary>
            <param name="ppropvarMin">When this method returns, contains a pointer to the minimum value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetRangeSetValue(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets a set value from an enumeration information structure.</summary>
            <param name="ppropvarSet">When this method returns, contains a pointer to the set value.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetDisplayText(System.String@)">
            <summary>Gets display text from an enumeration information structure.</summary>
            <param name="ppszDisplay">
            When this method returns, contains the address of a pointer to a null-terminated Unicode string that contains the display text.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumType2.GetImageReference(System.String@)">
            <summary>Retrieves the image reference associated with a property enumeration.</summary>
            <param name="ppszImageRes">
            A pointer to a buffer that, when this method returns successfully, receives a string of the form &lt;dll
            name&gt;,-&lt;resid&gt; that is suitable to be passed to PathParseIconLocation.
            </param>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyEnumTypeList">
            <summary>Exposes methods that enumerate the possible values for a property.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumTypeList.GetCount">
            <summary>Gets the number of elements in the list.</summary>
            <returns>The number of list elements.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumTypeList.GetAt(System.UInt32,System.Guid@)">
            <summary>Gets the IPropertyEnumType object at the specified index in the list.</summary>
            <param name="itype">The index of the object in the list.</param>
            <param name="riid">The IID of IPropertyEnumType</param>
            <returns>An IPropertyEnumType instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumTypeList.GetConditionAt(System.UInt32,System.Guid@)">
            <summary>Gets the condition at the specified index.</summary>
            <param name="index">Index of the desired condition.</param>
            <param name="riid">A reference to the IID of the interface to retrieve.</param>
            <returns>An ICondition interface pointer.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyEnumTypeList.FindMatchingIndex(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32@)">
            <summary>Compares the specified property value against the enumerated values in a list and returns the matching index.</summary>
            <param name="propvarCmp">A reference to a PROPVARIANT structure that represents the property value.</param>
            <param name="pnIndex">
            When this method returns, contains a pointer to the index in the enumerated type list that matches the property value, if any.
            </param>
            <returns>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyStore">
            <summary>This interface exposes methods used to enumerate and manipulate property values.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStore.GetCount">
            <summary>This method returns a count of the number of properties that are attached to the file.</summary>
            <returns>A value that indicates the property count.</returns>
            <remarks>
            <para>
            <c>IPropertyStore</c> provides an abstraction over an array of property keys via the and IPropertyStore::GetAt methods. The
            property keys in this array represent the properties that are currently stored by the <c>IPropertyStore</c>.
            </para>
            <para>
            When succeeds, the value pointed to by cProps is a count of property keys in the array. The caller can expect calls to
            <c>IPropertyStore::GetAt</c> to succeed for values of iProp less than cProps.
            </para>
            <para>
            In the case of failures such as E_OUTOFMEMORY, you should set cProps to zero. It is preferable that errors are discovered
            during creation or initialization of the property store.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStore.GetAt(System.UInt32)">
            <summary>Gets a property key from an item's array of properties.</summary>
            <param name="iProp">
            <para>[in] Type: <c>DWORD</c></para>
            <para>The index of the property key in the array of <c>PROPERTYKEY</c> structures. This is a zero-based index.</para>
            </param>
            <returns>
            <para>[out] Type: <c>PROPERTYKEY*</c></para>
            <para>When this method returns, contains a <c>PROPERTYKEY</c> structure that receives the unique identifier for a property.</para>
            </returns>
            <remarks>
            <para>The <c>PROPERTYKEY</c> returned in pkey can be used in subsequent calls to <c>IPropertyStore::GetValue</c> and <c>IPropertyStore::SetValue</c>.</para>
            <para>
            There is no specific order to an item's set of enumerated properties. To find a specific property, you must walk the array
            until you find the property that matches your criteria.
            </para>
            <para>
            iProp cannot be greater than or equal to the cProps parameter retrieved by <c>IPropertyStore::GetCount</c>. If it is greater
            than or equal to that value, <c>IPropertyStore::GetAt</c> returns E_INVALIDARG and pkey is set to <c>NULL</c> by the
            property handler.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStore.GetValue(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Gets data for a specific property.</summary>
            <param name="pkey">The pkey.</param>
            <param name="pv">
            <para>[out] Type: <c>PROPVARIANT*</c></para>
            <para>When this method returns, contains a <c>PROPVARIANT</c> structure that contains the property data.</para>
            </param>
            <remarks>
            <para>
            If the <c>PROPERTYKEY</c> referenced in key is not present in the property store, this method returns <c>S_OK</c> and the
            <c>vt</c> member of the structure pointed to by pv is set to VT_EMPTY.
            </para>
            <para>
            File property handler implementers can use <c>IPropertyStore::GetValue</c> to retrieve the property value by using the
            filestream with which <c>Initialize</c> initialized the property handler. The value can also be computed from an in-memory
            cache, or other means. However, most consumers of the property system obtain <c>IPropertyStore</c> through
            <c>GetPropertyStore</c> and are not—and have no need to be—aware of the method of initialization.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStore.SetValue(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Sets a new property value, or replaces or removes an existing value.</summary>
            <param name="pkey">The pkey.</param>
            <param name="pv">The pv.</param>
            <remarks>
            <para>
            <c>Note</c> When this method is implemented under <c>IPropertyStoreCache</c>, be aware that the interface is used only by
            the in-memory store. Many of the following remarks may not apply in that case.
            </para>
            <para>
            <c>SetValue</c> affects the current property store instance only. A property handler implements <c>SetValue</c> by
            accumulating property changes in an in-memory data structure. Property changes are written to the stream only when
            <c>IPropertyStore::Commit</c> is called.
            </para>
            <para>If <c>Commit</c> is called on a read-only property store, the property handler determines this and returns STG_E_ACCESSDENIED.</para>
            <para>
            In general, errors should be detected and reported by <c>SetValue</c>. However, when processing is deferred until
            <c>Commit</c> is called, the same error semantics apply.
            </para>
            <para>
            If a value was added or removed as a result of <c>SetValue</c>, subsequent enumerations by <c>IPropertyStore::GetCount</c>
            and <c>IPropertyStore::GetAt</c> reflect that change and subsequent calls to <c>SetValue</c> reflect the changed value.
            </para>
            <para>Adding a New Property</para>
            <para>If the property value pointed to by key does not exist in the store, <c>SetValue</c> adds the value to the store.</para>
            <para>Replacing an Existing Property Value</para>
            <para>If the property value pointed to by the key parameter already exists in the store, the stored value is replaced.</para>
            <para>Removing an Existing Property</para>
            <para>Removing a property values from a property store is not supported and could lead to unexpected results.</para>
            <para>Support for Different Properties</para>
            <para>
            A property handler must handle three types of properties in <c>SetValue</c>: new properties introduced by the handler
            author, pre-existing properties that are germane to the property handler, and other properties that do not fall in either of
            those categories.
            </para>
            <list type="bullet">
            <item>
            <term>
            New properties introduced by the property handler author must be described in a property description XML file. Clients
            consume a file property handler through a wrapping layer called the Windows Property Provider. This layer delegates calls to
            <c>SetValue</c> to the property handler after it enforces restrictions on the new property according to the property
            description XML. Therefore, a handler should not attempt to enforce restrictions itself and must store any values that
            satisfy the property description XML. If the property description does not provide the necessary information to restrict
            values for the new property, the handler must alter the value as necessary to store those values successfully. For example,
            in the property description XML there is no way to specify that an integer-valued property can never be an odd number. If an
            odd integer were provided to <c>SetValue</c>, the handler is still required to store a value successfully. It could
            accomplish this by perhaps adding one to the value. If data is lost, <c>SetValue</c> must succeed with the return value INPLACE_S_TRUNCATED.
            </term>
            </item>
            <item>
            <term>
            Pre-existing properties that are germane to the handler are those that have a representation in the handler's property
            storage format. For example, Adobe Acrobat .pdf files have representations for PKEY_Author and PKEY_Comments. These
            properties are described in a property description XML file provided by Windows. It is likely that the restrictions provided
            by Windows do not exactly match how the equivalent property must be stored in the author's file format. For example, the
            author value may be restricted to fewer characters in Acrobat files than in the property description for PKEY_Author. In
            this case, the handler author must make a best-effort attempt to coerce the property value. If data is lost, <c>SetValue</c>
            must succeed with the return value INPLACE_S_TRUNCATED. In the unusual case that the value cannot be coerced,
            <c>SetValue</c> can return E_FAIL. If the author's file format is less restrictive than a property description provided by
            Windows, the Windows Property Provider layer described earlier will already have returned an error and therefore the
            property handler's <c>SetValue</c> will never be called to store the value.
            </term>
            </item>
            <item>
            <term>
            Properties that are neither new nor pre-existing properties germane to the handler must still be stored by the property
            handler. The utility class CLSID_InMemoryPropertyStore, provided by Windows, can be used by handler authors to temporarily
            store such properties in memory and save those properties to a stream for storage in the file.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStore.Commit">
            <summary>After a change has been made, this method saves the changes.</summary>
            <remarks>
            <para>
            Before the method returns, it releases the file stream or path that was initialized to be used by the method. Therefore, no
            <c>IPropertyStore</c> methods succeed after returns. At that point, they return E_FAIL.
            </para>
            <para>
            Property handlers must ensure that property changes result in a valid destination file, even if the process terminates
            abnormally, or encounters any errors.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyStoreCapabilities">
            <summary>Exposes a method that determines whether a property can be edited in the UI by the user.</summary>
            <remarks>
            <para>When to Implement</para>
            <para>
            Property handlers implement this interface to disable a user's ability to edit specific properties. These properties are
            typically editable in the UI, but are not supported for writing by the property handler. For example, the property System.Author
            is typically editable. If a property handler author created a file type that exposed System.Author for reading, but could not
            support writing this property back, the handler author could return S_FALSE from IPropertyStoreCapabilities::IsPropertyWritable
            for System.Author.
            </para>
            <para>
            The Shell user interfaces that allow property editing, such as the <c>Details Pane</c> and <c>Details Tab</c> of the Properties
            dialog, call this method as part of determining whether to allow editing of a specific property. This allows the Shell property
            editing UI to disable controls rather than showing errors when the property handler fails to set or commit the property value.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStoreCapabilities.IsPropertyWritable(Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Queries whether the property handler allows a specific property to be edited in the UI by the user.</summary>
            <param name="key">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A reference to PROPERTYKEY structure that represents the property being queried.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The property can be edited and stored by the handler.</term>
            </item>
            <item>
            <term>S_FALSE</term>
            <term>The property cannot be edited.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The Shell disables the editing of controls by the user as appropriate through this method. A handler that does not support
            IPropertyStoreCapabilities is assumed to support writing of any property.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyStoreFactory">
            <summary>
            <para>Exposes methods to get an IPropertyStore object.</para>
            </summary>
            <remarks>
            <para>
            This interface is typically obtained through IShellFolder::BindToObject or IShellItem::BindToHandler. It is useful for data
            source implementers who want to avoid the additional overhead of creating a property store through
            IShellItem2::GetPropertyStore. However, <c>IShellItem2::GetPropertyStore</c> is the recommended method to obtain a property
            store unless you are implementing a data source through a Shell folder extension.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStoreFactory.GetPropertyStore(Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,Vanara.PInvoke.PropSys.ICreateObject,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>Gets an IPropertyStore object that corresponds to the supplied flags.</para>
            </summary>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>GETPROPERTYSTOREFLAGS values that modify the store that is returned.</para>
            </param>
            <param name="pUnkFactory">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            Optional. A pointer to the IUnknown of an object that implements ICreateObject. If pUnkFactory is provided, this method can
            create the handler instance using <c>ICreateObject</c> rather than CoCreateInstance, if implemented. The reason to provide
            pUnkFactory is usually to create the handler in a different process. However, for most users, passing <c>NULL</c> in this
            parameter is sufficient.
            </para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to IID of the object to create.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of an IPropertyStore interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a
            coding error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyStoreFactory.GetPropertyStoreForKeys(Vanara.PInvoke.Ole32.PROPERTYKEY[],System.UInt32,Vanara.PInvoke.PropSys.GETPROPERTYSTOREFLAGS,System.Guid@,Vanara.PInvoke.PropSys.IPropertyStore@)">
            <summary>
            <para>
            Gets an IPropertyStore object, given a set of property keys. This provides an alternative, possibly faster, method of
            getting an <c>IPropertyStore</c> object compared to calling IPropertyStoreFactory::GetPropertyStore.
            </para>
            </summary>
            <param name="rgKeys">
            <para>Type: <c>const PROPERTYKEY*</c></para>
            <para>A pointer to an array of PROPERTYKEY structures.</para>
            </param>
            <param name="cKeys">
            <para>Type: <c>UINT</c></para>
            <para>The number of PROPERTYKEY structures in the array pointed to by rgKeys.</para>
            </param>
            <param name="flags">
            <para>Type: <c>GETPROPERTYSTOREFLAGS</c></para>
            <para>GETPROPERTYSTOREFLAGS values that modify the store that is returned.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to IID of the object to create.</para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of an IPropertyStore interface pointer.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this method succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a
            coding error.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertySystem">
            <summary>
            Exposes methods that get property descriptions, register and unregister property schemas, enumerate property descriptions, and
            format property values in a type-strict way.
            </summary>
            <remarks>
            Many of the exported APIs (such as PSGetPropertyDescription) are simply wrappers around the IPropertySystem methods. If your
            code calls a lot of these helper APIs in sequence, it may be worthwhile to instantiate a single <c>IPropertySystem</c> object,
            and call the methods directly, rather than calling the helper APIs. (To improve the performance, the helper APIs do obtain a
            cached instance of the <c>IPropertySystem</c> object.)
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.GetPropertyDescription(Vanara.PInvoke.Ole32.PROPERTYKEY@,System.Guid@)">
            <summary>
            Gets an instance of the subsystem object that implements IPropertyDescription, to obtain the property description for a
            given PROPERTYKEY.
            </summary>
            <param name="propkey">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A reference to the desired property key. See PROPERTYKEY.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the desired IID.</para>
            </param>
            <returns>
            <para>Type: <c>void**</c></para>
            <para>The address of an IPropertyDescription interface pointer.</para>
            </returns>
            <remarks>
            It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a
            coding error.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.GetPropertyDescriptionByName(System.String,System.Guid@)">
            <summary>
            Gets an instance of the subsystem object that implements IPropertyDescription, to obtain the property description for a
            given canonical name.
            </summary>
            <param name="pszCanonicalName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a string that identifies the property.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the desired IID.</para>
            </param>
            <returns>
            <para>Type: <c>void**</c></para>
            <para>The address of an IPropertyDescription interface pointer.</para>
            </returns>
            <remarks>
            It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a
            coding error.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.GetPropertyDescriptionListFromString(System.String,System.Guid@)">
            <summary>
            <para>
            Gets an instance of the subsystem object that implements IPropertyDescriptionList, to obtain an ordered collection of
            property descriptions, based on the provided string.
            </para>
            </summary>
            <param name="pszPropList">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a string that identifies the property list.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the desired IID.</para>
            </param>
            <returns>
            <para>The address of an IPropertyDescriptionList interface pointer.</para>
            </returns>
            <remarks>
            <para>
            The property description list string ("proplist") syntax consists of a sequence of canonical property names, with flags
            associated with each property name. The string starts with "prop:". The syntax looks like this:
            </para>
            <para>The flags are optional and can be any of those below. Note: These flags translate to the PROPDESC_VIEW_FLAGS enum.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>-</term>
            <term>Sort in reverse order (PDVF_REVERSESORT).</term>
            </item>
            <item>
            <term>0</term>
            <term>Show by default in both the primary and secondary lists (PDVF_SHOWBYDEFAULT | PDVF_SHOWINPRIMARYLIST | PDVF_SHOWINSECONDARYLIST).</term>
            </item>
            <item>
            <term>1</term>
            <term>Show in the primary and secondary lists (PDVF_SHOWINPRIMARYLIST | PDVF_SHOWINSECONDARYLIST).</term>
            </item>
            <item>
            <term>2</term>
            <term>Show in secondary list (PDVF_SHOWINSECONDARYLIST).</term>
            </item>
            <item>
            <term>^</term>
            <term>Begin a new group (PDVF_BEGINNEWGROUP).</term>
            </item>
            <item>
            <term>/</term>
            <term>Right align (PDVF_RIGHTALIGN).</term>
            </item>
            <item>
            <term>*</term>
            <term>Hide if the value is not present.</term>
            </item>
            <item>
            <term>|</term>
            <term>Center align. (PDVF_CENTERALIGN).</term>
            </item>
            <item>
            <term>~</term>
            <term>Hide the label. (PDVF_HIDELABEL).</term>
            </item>
            <item>
            <term>#</term>
            <term>Fill area. (PDVF_FILLAREA).</term>
            </item>
            <item>
            <term>?</term>
            <term>Hide if unsupported by property handler (PDVF_HIDEIFUNSUPPORTED).</term>
            </item>
            <item>
            <term>&lt;</term>
            <term>Parse as link (PDVF_PARSEASLINK).</term>
            </item>
            <item>
            <term>&amp;</term>
            <term>Show as whole link (PDVF_SHOWASWHOLELINK).</term>
            </item>
            </list>
            <para>From the dbfolder and file folder perspective:</para>
            <list type="table">
            <listheader>
            <term>0</term>
            <term>Show as a column in defview, column chooser menu, and column chooser dialog.</term>
            </listheader>
            <item>
            <term>1</term>
            <term>Show in the column chooser menu and dialog.</term>
            </item>
            <item>
            <term>2</term>
            <term>Show in the column chooser dialog.</term>
            </item>
            <item>
            <term>NULL</term>
            <term>Include in the search results, but hide in the UI.</term>
            </item>
            </list>
            <para>The endflags are also optional and can be the following:</para>
            <list type="table">
            <listheader>
            <term>EndFlag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>]</term>
            <term>End column (used for extended tiles view).</term>
            </item>
            </list>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a
            coding error.
            </para>
            <para>For more information about property schemas, see Property Schemas.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.EnumeratePropertyDescriptions(Vanara.PInvoke.PropSys.PROPDESC_ENUMFILTER,System.Guid@)">
            <summary>
            Gets an instance of the subsystem object that implements IPropertyDescriptionList, to obtain either the entire or a partial
            list of property descriptions in the system.
            </summary>
            <param name="filterOn">
            <para>Type: <c>PROPDESC_ENUMFILTER</c></para>
            <para>The list to return. See PROPDESC_ENUMFILTER. Valid values for this method are 0 through 4.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>A reference to the desired IID.</para>
            </param>
            <returns>
            <para>Type: <c>void**</c></para>
            <para>The address of an IPropertyDescriptionList interface pointer.</para>
            </returns>
            <remarks>
            <para>This method is not implemented where BUILDING_DOWNLEVEL_LIB is defined.</para>
            <para>
            It is recommended that you use the IID_PPV_ARGS macro, defined in objbase.h, to package the riid and ppv parameters. This
            macro provides the correct IID based on the interface pointed to by the value in ppv, eliminating the possibility of a
            coding error.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.FormatForDisplay(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS,System.Text.StringBuilder,System.UInt32)">
            <summary>Gets a formatted, Unicode string representation of a property value.</summary>
            <param name="key">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A reference to the requested property key.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>A reference to a PROPVARIANT structure containing the type and value of the property.</para>
            </param>
            <param name="pdff">
            <para>Type: <c>PROPDESC_FORMAT_FLAGS</c></para>
            <para>The format of the property string. See PROPDESC_FORMAT_FLAGS for possible values.</para>
            </param>
            <param name="pszText">
            <para>Type: <c>LPWSTR</c></para>
            <para>
            Receives the formatted value as a null-terminated, Unicode string. The calling application must allocate memory for the buffer.
            </para>
            </param>
            <param name="cchText">
            <para>Type: <c>DWORD</c></para>
            <para>
            The length of the buffer at pszText in <c>WCHAR</c><c>s</c>, including the terminating <c>NULL</c>. The maximum size is
            0x8000 (32K).
            </para>
            </param>
            <remarks>
            <para>You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before calling IPropertySystem::FormatForDisplay.</para>
            <para>
            When it succeeds, this method gets a formatted Unicode string representation of a property value for a specified
            PROPERTYKEY, and one or more PROPDESC_FORMAT_FLAGS. If the <c>PROPERTYKEY</c> is not recognized by the schema subsystem,
            IPropertySystem::FormatForDisplay attempts to format the value according to its VARTYPE.
            </para>
            <para>
            The purpose of this method is to convert data into a string suitable for display to the user. The value is formatted
            according to the current locale, the language of the user, the PROPDESC_FORMAT_FLAGS, and the property description specified
            by the property key. For information about how the property description schema influences the formatting of the value, see
            displayInfo, stringFormat, booleanFormat, numberFormat, NMDATETIMEFORMAT, and enumeratedList. Typically, the
            <c>PROPDESC_FORMAT_FLAGS</c> are used to modify the format prescribed by the property description.
            </para>
            <para>
            The output string may contain Unicode directional characters. These nonspacing characters influence the Unicode
            bidirectional algorithm so that the values appear correctly when a left-to-right (LTR) language is drawn on a right-to-left
            (RTL) window, and vice versa. These characters include the following:
            </para>
            <para>
            The properties in the following table use special formats and are unaffected by the PROPDESC_FORMAT_FLAGS (examples cited
            are for strings with a current locale set to English; typically, output is localized except where noted).
            </para>
            <list type="table">
            <listheader>
            <term>Property</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>System.FileAttributes</term>
            <term>
            The following file attributes are converted to letters and appended to create a string (for example, a value of 0x1801
            (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE) is converted to "RCO"):
            </term>
            </item>
            <item>
            <term>System.Photo.ISOSpeed</term>
            <term>For example, "ISO-400".</term>
            </item>
            <item>
            <term>System.Photo.ShutterSpeed</term>
            <term>The APEX value is converted to an exposure time using this formula: For example, "2 sec."or "1/125 sec.".</term>
            </item>
            <item>
            <term>System.Photo.ExposureTime</term>
            <term>For example, "2 sec."or "1/125 sec."</term>
            </item>
            <item>
            <term>System.Photo.Aperture</term>
            <term>The APEX value is converted to an F number using this formula: For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.FNumber</term>
            <term>For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.SubjectDistance</term>
            <term>For example, "15 m"or "250 mm".</term>
            </item>
            <item>
            <term>System.Photo.FocalLength</term>
            <term>For example, "50 mm".</term>
            </item>
            <item>
            <term>System.Photo.FlashEnergy</term>
            <term>For example, "500 bpcs".</term>
            </item>
            <item>
            <term>System.Photo.ExposureBias</term>
            <term>For example, "-2 step", " 0 step", or "+3 step".</term>
            </item>
            <item>
            <term>System.Computer.DecoratedFreeSpace</term>
            <term>For example, "105 MB free of 13.2 GB".</term>
            </item>
            <item>
            <term>System.ItemType</term>
            <term>For example, "Application" or "JPEG Image".</term>
            </item>
            <item>
            <term>System.ControlPanel.Category</term>
            <term>For example, "Appearance and Personalization".</term>
            </item>
            <item>
            <term>System.ComputerName</term>
            <term>For example, "LITWARE05 (this computer)" or "testbox07".</term>
            </item>
            </list>
            <para>
            If the property key does not correspond to a property description in any of the registered property schemas, this method
            chooses a format based on the type of the value, as described in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Type of the value</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>VT_BOOLEAN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>VT_FILETIME</term>
            <term>
            Date/time string as specified by PROPDESC_FORMAT_FLAGS and the current locale. PDFF_SHORTTIME and PDFF_SHORTDATE are the
            default. For example, "11/13/2006 3:22 PM".
            </term>
            </item>
            <item>
            <term>Numeric VARTYPE</term>
            <term>Decimal string in the current locale. For example, "42".</term>
            </item>
            <item>
            <term>VT_LPWSTR or other</term>
            <term>String. Sequences of "\r", "\t", or "\n" are replaced with a single space.</term>
            </item>
            <item>
            <term>VT_VECTOR | anything</term>
            <term>Semicolon separated values—a semicolon is used regardless of locale.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.FormatForDisplayAlloc(Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPDESC_FORMAT_FLAGS)">
            <summary>Gets a string representation of a property value to an allocated memory buffer.</summary>
            <param name="key">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A reference to the desired PROPERTYKEY.</para>
            </param>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>A reference to a PROPVARIANT structure that contains the type and value of the property.</para>
            </param>
            <param name="pdff">
            <para>Type: <c>PROPDESC_FORMAT_FLAGS</c></para>
            <para>The format of the property string. See PROPDESC_FORMAT_FLAGS.</para>
            </param>
            <returns>
            <para>Type: <c>LPWSTR*</c></para>
            <para>When this method returns, contains a pointer to the formatted value as a null-terminated, Unicode string.</para>
            </returns>
            <remarks>
            <para>You must initialize Component Object Model (COM) with CoInitialize or OleInitialize before calling IPropertySystem::FormatForDisplayAlloc.</para>
            <para>
            On success, this method gets a formatted Unicode string representation of a property value for a specified PROPERTYKEY, and
            one or more PROPDESC_FORMAT_FLAGS. If the <c>PROPERTYKEY</c> is not recognized by the schema subsystem,
            IPropertySystem::FormatForDisplayAlloc attempts to format the value according to its VARTYPE.
            </para>
            <para>
            This method allocates memory for the buffer and returns a pointer to it at ppszDisplay. The calling application must use
            CoTaskMemFree to release the string specified by ppszDisplay when it is no longer needed.
            </para>
            <para>
            The purpose of this method is to convert data into a string suitable for display to the user. The value is formatted
            according to the current locale, the language of the user, the PROPDESC_FORMAT_FLAGS, and the property description specified
            by the property key. For information about how the property description schema influences the formatting of the value, see
            displayInfo, stringFormat, booleanFormat, numberFormat, NMDATETIMEFORMAT, and enumeratedList. Typically, the
            <c>PROPDESC_FORMAT_FLAGS</c> are used to modify the format prescribed by the property description.
            </para>
            <para>
            The output string may contain Unicode directional characters. These nonspacing characters influence the Unicode
            bidirectional algorithm so that the values appear correctly when a left to right (LTR) language is drawn on a right to left
            (RTL) window, and vice versa. These characters include the following:
            </para>
            <para>
            The following properties use special formats and are unaffected by the PROPDESC_FORMAT_FLAGS (examples cited are for strings
            with a current locale set to English; typically, output is localized except where noted).
            </para>
            <list type="table">
            <listheader>
            <term>Property</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>System.FileAttributes</term>
            <term>
            The following file attributes are converted to letters and appended to create a string (for example, a value of 0x1801
            (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE) is converted to "RCO"):
            </term>
            </item>
            <item>
            <term>System.Photo.ISOSpeed</term>
            <term>For example, "ISO-400".</term>
            </item>
            <item>
            <term>System.Photo.ShutterSpeed</term>
            <term>The APEX value is converted to an exposure time using this formula: For example, "2 sec."or "1/125 sec.".</term>
            </item>
            <item>
            <term>System.Photo.ExposureTime</term>
            <term>For example, "2 sec."or "1/125 sec."</term>
            </item>
            <item>
            <term>System.Photo.Aperture</term>
            <term>The APEX value is converted to an F number using this formula: For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.FNumber</term>
            <term>For example, "f/5.6".</term>
            </item>
            <item>
            <term>System.Photo.SubjectDistance</term>
            <term>For example, "15 m"or "250 mm".</term>
            </item>
            <item>
            <term>System.Photo.FocalLength</term>
            <term>For example, "50 mm".</term>
            </item>
            <item>
            <term>System.Photo.FlashEnergy</term>
            <term>For example, "500 bpcs".</term>
            </item>
            <item>
            <term>System.Photo.ExposureBias</term>
            <term>For example, "-2 step", " 0 step", or "+3 step".</term>
            </item>
            <item>
            <term>System.Computer.DecoratedFreeSpace</term>
            <term>For example, "105 MB free of 13.2 GB".</term>
            </item>
            <item>
            <term>System.ItemType</term>
            <term>For example, "Application" or "JPEG Image".</term>
            </item>
            <item>
            <term>System.ControlPanel.Category</term>
            <term>For example, "Appearance and Personalization".</term>
            </item>
            <item>
            <term>System.ComputerName</term>
            <term>For example, "LITWARE05 (this computer)" or "testbox07".</term>
            </item>
            </list>
            <para>
            If the property key does not correspond to a property description in any of the registered property schemas, then this
            method chooses a format based on the type of the value.
            </para>
            <list type="table">
            <listheader>
            <term>Type of the value</term>
            <term>Format</term>
            </listheader>
            <item>
            <term>VT_BOOLEAN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>VT_FILETIME</term>
            <term>
            Date/time string as specified by PROPDESC_FORMAT_FLAGS and the current locale. PDFF_SHORTTIME and PDFF_SHORTDATE are the
            default. For example, "11/13/2006 3:22 PM".
            </term>
            </item>
            <item>
            <term>Numeric VARTYPE</term>
            <term>Decimal string in the current locale. For example, "42".</term>
            </item>
            <item>
            <term>VT_LPWSTR or other</term>
            <term>Converted to a string. Sequences of "\r", "\t", or "\n" are replaced with a single space.</term>
            </item>
            <item>
            <term>VT_VECTOR | anything</term>
            <term>Semicolon separated values—a semicolon is used regardless of locale.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.RegisterPropertySchema(System.String)">
            <summary>Informs the schema subsystem of the addition of a property description schema file.</summary>
            <param name="pszPath">
            <para>Type: <c>LPCWSTR</c></para>
            <para>Pointer to the file path for the .propdesc file on the local machine.</para>
            </param>
            <remarks>
            <para>
            This method informs the schema subsystem of the addition of a property description schema (.propdesc) file, using a file
            path to the .propdesc file on the local computer. Call this method only when the file has first been installed on the
            computer. Typically, a setup application calls this method after installing the .propdesc file, which should be stored in
            the install directory of the application under "Program Files". Multiple calls may be made to
            IPropertySystem::RegisterPropertySchema in order to batch-register multiple schema files.
            </para>
            <para>
            If a failure is encountered that prevents a property description from getting loaded, the cause will be recorded in the
            application event log. This method fails with E_ACCESSDENIED if the calling context does not have proper privileges, which
            include write access to HKLM (HKEY_LOCAL_MACHINE). It is the responsibility of the calling application to obtain privileges
            via limited user account (LUA) mechanisms.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.UnregisterPropertySchema(System.String)">
            <summary>
            Informs the schema subsystem of the removal of a property description schema (.propdesc) file, using a file path to the
            .propdesc file on the local machine.
            </summary>
            <param name="pszPath">
            <para>Type: <c>LPCWSTR</c></para>
            <para>Pointer to the file path for the .propdesc file on the local machine.</para>
            </param>
            <remarks>
            <para>
            Call this method when the file is being uninstalled from the machine. Typically, a setup application calls this method
            before or after uninstalling the .propdesc file. This method can be called after the file no longer exists.
            </para>
            <para>
            Call IPropertySystem::RefreshPropertySchema in order for the newly-unregistered schema files to be unincorporated from the
            search index and the schema subsystem cache.
            </para>
            <para>
            This method fails with E_ACCESSDENIED if the calling context does not have proper privileges, which include write access to
            the local machine. It is the caller's responsibility to obtain privileges via least-privileged user account (LUA) mechanisms.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertySystem.RefreshPropertySchema">
            <summary>Not supported.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.CreateObject``1(Vanara.PInvoke.PropSys.ICreateObject,System.Guid@,System.Object)">
            <summary>Creates a local object of a specified class and returns a pointer to a specified interface on the object.</summary>
            <typeparam name="T">The type of the interface the created object should return.</typeparam>
            <param name="co">The <see cref="T:Vanara.PInvoke.PropSys.ICreateObject"/> instance.</param>
            <param name="clsid">
            <para>Type: <c>REFCLSID</c></para>
            <para>A reference to a CLSID.</para>
            </param>
            <param name="pUnkOuter">
            <para>Type: <c>IUnknown*</c></para>
            <para>
            A pointer to the IUnknown interface that aggregates the object created by this function, or <c>NULL</c> if no aggregation is desired.
            </para>
            </param>
            <returns>
            <para>Type: <c>void**</c></para>
            <para>When this method returns, contains the address of the pointer to the interface requested in riid.</para>
            </returns>
            <remarks>This method can be used with GetPropertyStoreWithCreateObject.</remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PKA_FLAGS">
            <summary>Describes property change array behavior.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PKA_FLAGS.PKA_SET">
            <summary>Replace current value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PKA_FLAGS.PKA_APPEND">
            <summary>Append to current value - multi-value properties only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PKA_FLAGS.PKA_DELETE">
            <summary>Delete from current value - multi-value properties only.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IObjectWithPropertyKey">
            <summary>Exposes methods for getting and setting the property key.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IObjectWithPropertyKey.SetPropertyKey(Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Sets the property key.</summary>
            <param name="key">The property key.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IObjectWithPropertyKey.GetPropertyKey">
            <summary>Gets the property key.</summary>
            <returns>When this returns, contains the property key.</returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyChange">
            <summary>Exposes a method that encapsulates a change to a single property.</summary>
            <seealso cref="T:Vanara.PInvoke.PropSys.IObjectWithPropertyKey"/>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChange.SetPropertyKey(Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Sets the property key.</summary>
            <param name="key">The property key.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChange.GetPropertyKey">
            <summary>Gets the property key.</summary>
            <returns>When this returns, contains the property key.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChange.ApplyToPropVariant(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT@)">
            <summary>Applies a change to a property value.</summary>
            <param name="propvarIn">A reference to a source PROPVARIANT structure.</param>
            <param name="ppropvarOut">A pointer to a changed PROPVARIANT structure.</param>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.IPropertyChangeArray">
            <summary>Exposes methods for several multiple change operations that may be passed to IFileOperation.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.GetCount">
            <summary>Gets the number of change operations in the array.</summary>
            <returns>The number of change operations.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.GetAt(System.UInt32,System.Guid@)">
            <summary>Gets the change operation at a specified array index.</summary>
            <param name="iIndex">The index of the change to retrieve.</param>
            <param name="riid">A reference to the desired IID.</param>
            <returns>The address of a pointer to the interface specified by riid, usually IPropertyChange.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.InsertAt(System.UInt32,Vanara.PInvoke.PropSys.IPropertyChange)">
            <summary>Inserts a change operation into an array at the specified position.</summary>
            <param name="iIndex">The index at which the change is inserted.</param>
            <param name="ppropChange">A pointer to the interface that contains the change.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.Append(Vanara.PInvoke.PropSys.IPropertyChange)">
            <summary>Inserts a change operation at the end of an array.</summary>
            <param name="ppropChange">A pointer to the interface that contains the change.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.AppendOrReplace(Vanara.PInvoke.PropSys.IPropertyChange)">
            <summary>
            Replaces the first occurrence of a change that affects the same property key as the provided change. If the property key is
            not already in the array, this method appends the change to the end of the array.
            </summary>
            <param name="ppropChange">A pointer to the interface that contains the change.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.RemoveAt(System.UInt32)">
            <summary>Removes a specified change.</summary>
            <param name="iIndex">The index of the change to remove.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.IPropertyChangeArray.IsKeyInArray(Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Specifies whether a particular property key exists in the change array.</summary>
            <param name="key">A reference to the PROPERTYKEY structure of interest.</param>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.GetAt``1(Vanara.PInvoke.PropSys.IPropertyChangeArray,System.UInt32)">
            <summary>Gets the change operation at a specified array index.</summary>
            <typeparam name="T">The type of the interface to retrieve.</typeparam>
            <param name="pca">The <see cref="T:Vanara.PInvoke.PropSys.IPropertyChangeArray"/> instance.</param>
            <param name="iIndex">The index of the change to retrieve.</param>
            <returns>The address of a pointer to the interface specified by <typeparamref name="T"/>, usually IPropertyChange.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreatePropertyChangeArray(Vanara.PInvoke.Ole32.PROPERTYKEY[],Vanara.PInvoke.PropSys.PKA_FLAGS[],Vanara.PInvoke.Ole32.PROPVARIANT[],System.UInt32,System.Guid@,Vanara.PInvoke.PropSys.IPropertyChangeArray@)">
            <summary>
            Creates a container for a set of IPropertyChange objects. This container can be used with IFileOperation to apply a set of
            property changes to a set of files.
            </summary>
            <param name="rgpropkey">
            Pointer to an array of PROPERTYKEY structures that name the specific properties whose changes are being stored. If this value is
            NULL, cChanges must be 0.
            </param>
            <param name="rgflags">Pointer to an array of PKA_FLAGS values. If this value is NULL, cChanges must be 0.</param>
            <param name="rgpropvar">Pointer to an array of PROPVARIANT structures. If this value is NULL, cChanges must be 0.</param>
            <param name="cChanges">
            Count of changes to be applied. This is the number of elements in each of the arrays rgpropkey, rgflags, and rgpropvar.
            </param>
            <param name="riid">Reference to the ID of the requested interface.</param>
            <param name="ppv">When this function returns, contains the interface pointer requested in riid. This is typically IPropertyChangeArray.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSCreateSimplePropertyChange(Vanara.PInvoke.PropSys.PKA_FLAGS,Vanara.PInvoke.Ole32.PROPERTYKEY@,Vanara.PInvoke.Ole32.PROPVARIANT,System.Guid@,Vanara.PInvoke.PropSys.IPropertyChange@)">
            <summary>Creates a simple property change.</summary>
            <param name="flags">PKA_FLAGS flags.</param>
            <param name="key">Reference to a PROPERTYKEY structure.</param>
            <param name="propvar">Reference to a PROPVARIANT structure.</param>
            <param name="riid">Reference to a specified IID.</param>
            <param name="ppv">The address of an IPropertyChange interface pointer.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_Delete(Vanara.PInvoke.OleAut32.IPropertyBag,System.String)">
            <summary>
            <para>Deletes a property from a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadBOOL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Boolean@)">
            <summary>
            <para>Reads the <c>BOOL</c> data value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>BOOL*</c></para>
            <para>When this function returns successfully, contains a pointer to the value read from the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between windows types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadBSTR(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.String@)">
            <summary>
            <para>Reads a <c>BSTR</c> data value from a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>BSTR*</c></para>
            <para>When this function returns, contains a pointer to a <c>BSTR</c> property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadDWORD(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.UInt32@)">
            <summary>
            <para>Reads a <c>DWORD</c> data value from property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>DWORD*</c></para>
            <para>When this function returns, contains a pointer to a <c>DWORD</c> property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadGUID(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Guid@)">
            <summary>
            <para>Reads the GUID data value from a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>GUID*</c></para>
            <para>When this function returns, contains a pointer to a GUID property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadInt(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int32@)">
            <summary>
            <para>Reads an <c>int</c> data value from a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>int*</c></para>
            <para>When this function returns, contains a pointer to an <c>int</c> property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>If the property bag does not already contain the specified property, the call still succeeds.</para>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadLONG(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int32@)">
            <summary>
            <para>Reads a <c>LONG</c> data value from a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>LONG*</c></para>
            <para>When this function returns, contains a pointer to a <c>LONG</c> property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>If the property bag does not already contain the specified property, the call still succeeds.</para>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadPOINTL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Drawing.Point@)">
            <summary>
            <para>Retrieves the property coordinates stored in a POINTL structure of a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>POINTL*</c></para>
            <para>When this function returns, contains a pointer to a POINTL structure that contains the property coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadPOINTS(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.POINTS@)">
            <summary>
            <para>Retrieves the property coordinates stored in a POINTS structure of a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>POINTS*</c></para>
            <para>When this function returns successfully, contains a pointer to a POINTS structure that contains the property coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadPropertyKey(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>
            <para>Reads the property key of a property in a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>PROPERTYKEY*</c></para>
            <para>When this function returns, contains a pointer to a property key value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadRECTL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.RECT@)">
            <summary>
            <para>Retrieves the coordinates of a rectangle stored in a property contained in a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>RECTL*</c></para>
            <para>When this function returns, contains a pointer to a RECTL structure that contains the property coordinates.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadSHORT(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int16@)">
            <summary>
            <para>Reads the SHORT data value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>SHORT*</c></para>
            <para>When this function returns, contains a pointer to a SHORT property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadStr(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Text.StringBuilder,System.Int32)">
            <summary>
            <para>Reads the string data value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>LPCWSTR</c></para>
            <para>When this function returns, contains a pointer to a string property value.</para>
            </param>
            <param name="characterCount">
            <para>Type: <c>int</c></para>
            <para>
            This function returns the integer that represents the size (maximum number of characters) of the value parameter being returned.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadStrAlloc(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.String@)">
            <summary>
            <para>Reads a string data value from a property in a property bag and allocates memory for the string that is read.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            When this function returns, contains a pointer to a string data value from a property in a property bag and allocates memory for
            the string that is read. The caller of the PSPropertyBag_ReadStrAlloc function needs to call a CoTaskMemFree function on this parameter.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadStream(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Runtime.InteropServices.ComTypes.IStream@)">
            <summary>
            <para>Reads the data stream stored in a given property contained in a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object, that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>IStream**</c></para>
            <para>The address of a pointer that, when this function returns successfully, receives the IStream object.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The caller of the PSPropertyBag_ReadStream function needs to call a IUnknown::Release method on the IStream object returned by
            this function.
            </para>
            <para>
            IPropertyBag and IPersistPropertyBag optimize Save As Text functionality. <c>IPropertyBag</c> and IPropertyBag2 provide an object
            with a property bag in which the object can save its properties persistently. <c>IPropertyBag2</c> allows the object to obtain
            type information for each property: IPropertyBag2::Read causes one or more properties to be read from the property bag, and
            IPropertyBag2::Write causes one or more properties to be saved into the property bag.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadType(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Object@,Vanara.PInvoke.Ole32.VARTYPE)">
            <summary>
            <para>Reads the type of data value of a property that is stored in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object, that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="var">
            <para>Type: <c>VARIANT*</c></para>
            <para>Returns on successful function completion a pointer to a <c>VARIANT</c> data type that contains the property value.</para>
            </param>
            <param name="type">
            <para>Type: <c>VARTYPE*</c></para>
            <para>
            If type is VT_EMPTY, this function reads the <c>VARIANT</c> of the property in the IPropertyBag propBag parameter. If type is not
            VT_EMPTY and not the same as the <c>VARIANT</c> read, then this function attempts to convert the <c>VARIANT</c> read to the
            <c>VARTYPE</c> defined by type parameter before returning.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            IPropertyBag and IPersistPropertyBag optimize Save As Text functionality. <c>IPropertyBag</c> and IPropertyBag2 provide an object
            with a property bag in which the object can save its properties persistently. <c>IPropertyBag2</c> allows the object to obtain
            type information for each property: IPropertyBag2::Read causes one or more properties to be read from the property bag, and
            IPropertyBag2::Write causes one or more properties to be saved into the property bag.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadULONGLONG(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.UInt64@)">
            <summary>
            <para>Reads a <c>ULONGLONG</c> data value from a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>ULONGLONG</c></para>
            <para>When this function returns, contains a pointer to a <c>ULONGLONG</c> property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_ReadUnknown(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Guid@,System.Object@)">
            <summary>
            <para>Reads a given property of an unknown data value in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object, that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="riid">
            <para>Type: <c>REFIID</c></para>
            <para>
            A reference to the IID of the interface to retrieve through ppv. This interface IID should be IPropertyBag or an interface
            derived from <c>IPropertyBag</c>.
            </para>
            </param>
            <param name="ppv">
            <para>Type: <c>void**</c></para>
            <para>When this method returns successfully, contains the interface pointer requested in riid. This is typically riid.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            IPropertyBag and IPersistPropertyBag optimize Save As Text functionality. <c>IPropertyBag</c> and IPropertyBag2 provide an object
            with a property bag in which the object can save its properties persistently. <c>IPropertyBag2</c> allows the object to obtain
            type information for each property: IPropertyBag2::Read causes one or more properties to be read from the property bag, and
            IPropertyBag2::Write causes one or more properties to be saved into the property bag.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteBOOL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Boolean)">
            <summary>
            <para>Sets the <c>BOOL</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>BOOL</c></para>
            <para>The <c>BOOL</c> value to which the named property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteBSTR(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.String)">
            <summary>
            <para>Sets the <c>BSTR</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>BSTR</c></para>
            <para>The <c>BSTR</c> value to which the named property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteDWORD(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.UInt32)">
            <summary>
            <para>Sets the <c>DWORD</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>DWORD</c></para>
            <para>A <c>DWORD</c> value to which the named property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteGUID(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Guid@)">
            <summary>
            <para>Sets the GUID value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>const GUID*</c></para>
            <para>A pointer to a GUID value to which the named property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteInt(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int32)">
            <summary>
            <para>Sets the <c>int</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>int</c></para>
            <para>The <c>int</c> value to which the property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteLONG(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int32)">
            <summary>
            <para>Sets the <c>LONG</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>LONG</c></para>
            <para>The <c>LONG</c> value to which the property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WritePOINTL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Drawing.Point@)">
            <summary>
            <para>Stores the property coordinates in aPOINTL structure of a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>const POINTL*</c></para>
            <para>A pointer to a POINTL structure that specifies the coordinates to store in the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WritePOINTS(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.POINTS@)">
            <summary>
            <para>Stores the property coordinates in aPOINTS structure of a specified property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>const POINTS*</c></para>
            <para>Pointer to a POINTS structure that specifies the coordinates to store in the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WritePropertyKey(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>
            <para>Sets the property key value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>REFPROPERTYKEY</c></para>
            <para>A PROPERTYKEY structure that specifies the property key value to store in the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Property keys uniquely identify a property. For example, corresponds to . This function succeeds only for properties registered
            as part of the property schema.
            </para>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteRECTL(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,Vanara.PInvoke.RECT@)">
            <summary>
            <para>Stores the coordinates of a rectangle in a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>const RECTL*</c></para>
            <para>A pointer to a RECTL structure that specifies the coordinates to store in the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteSHORT(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Int16)">
            <summary>
            <para>Sets the SHORT value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>SHORT</c></para>
            <para>The SHORT value to which the property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteStr(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.String)">
            <summary>
            <para>Sets the string value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>LPCWSTR</c></para>
            <para>The string value to which the property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteStream(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Runtime.InteropServices.ComTypes.IStream)">
            <summary>
            <para>Writes a data stream to a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>IStream*</c></para>
            <para>A pointer to the IStream object to write to the property.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteULONGLONG(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.UInt64)">
            <summary>
            <para>Sets the <c>ULONGLONG</c> value of a property in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A null-terminated property name string.</para>
            </param>
            <param name="value">
            <para>Type: <c>ULONGLONG</c></para>
            <para>An <c>ULONGLONG</c> value to which the property should be set.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PSPropertyBag_WriteUnknown(Vanara.PInvoke.OleAut32.IPropertyBag,System.String,System.Object)">
            <summary>
            <para>Writes a property of an unknown data value in a property bag.</para>
            </summary>
            <param name="propBag">
            <para>Type: <c>IPropertyBag*</c></para>
            <para>A pointer to an IPropertyBag object that represents the property bag in which the property is stored.</para>
            </param>
            <param name="propName">
            <para>Type: <c>LPCWSTR</c></para>
            <para>A pointer to a null-terminated property name string.</para>
            </param>
            <param name="punk">
            <para>Type: <c>IUnknown*</c></para>
            <para>A pointer to an IUnknown derived interface that copies the specified property of an unknown data value in a property bag.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            The property bag property function API converts between window types and the <c>VARIANT</c> type that is used to express values
            in a property bag. Doing so eases property bag usage, simplifies applications, and avoids common coding errors.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS">
            <summary>Values used by the <see cref="M:Vanara.PInvoke.PropSys.PropVariantChangeType(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS,Vanara.PInvoke.Ole32.VARTYPE)"/> function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_DEFAULT">
            <summary>The PVCHF default</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_NOVALUEPROP">
            <summary>Maps to VARIANT_NOVALUEPROP for VariantChangeType</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_ALPHABOOL">
            <summary>Maps to VARIANT_ALPHABOOL for VariantChangeType</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_NOUSEROVERRIDE">
            <summary>Maps to VARIANT_NOUSEROVERRIDE for VariantChangeType</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_LOCALBOOL">
            <summary>Maps to VARIANT_LOCALBOOL for VariantChangeType</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS.PVCHF_NOHEXSTRING">
            <summary>Don't convert a string that looks like hexadecimal (0xABCD) to the numerical equivalent.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS">
            <summary>Values used by the <see cref="M:Vanara.PInvoke.PropSys.PropVariantCompareEx(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS)"/> function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_DEFAULT">
            <summary>When comparing strings, use StrCmpLogical</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_TREATEMPTYASGREATERTHAN">
            <summary>Empty/null values are greater-than non-empty values</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_USESTRCMP">
            <summary>When comparing strings, use StrCmp</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_USESTRCMPC">
            <summary>When comparing strings, use StrCmpC</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_USESTRCMPI">
            <summary>When comparing strings, use StrCmpI</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_USESTRCMPIC">
            <summary>When comparing strings, use StrCmpIC</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS.PVCF_DIGITSASNUMBERS_CASESENSITIVE">
            <summary>
            When comparing strings, use CompareStringEx with LOCALE_NAME_USER_DEFAULT and SORT_DIGITSASNUMBERS. This corresponds to the
            linguistically correct order for UI lists.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT">
            <summary>Values used by the <see cref="M:Vanara.PInvoke.PropSys.PropVariantCompareEx(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS)"/> function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_DEFAULT">
            <summary>The default unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_SECOND">
            <summary>The second comparison unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_MINUTE">
            <summary>The minute comparison unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_HOUR">
            <summary>The hour comparison unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_DAY">
            <summary>The day comparison unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_MONTH">
            <summary>The month comparison unit.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT.PVCU_YEAR">
            <summary>The year comparison unit.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.PSTIME_FLAGS">
            <summary>Values used by the <see cref="M:Vanara.PInvoke.PropSys.PropVariantToFileTime(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PSTIME_FLAGS,System.Runtime.InteropServices.ComTypes.FILETIME@)"/> function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PSTIME_FLAGS.PSTF_UTC">
            <summary>Indicates the output will use coordinated universal time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.PSTIME_FLAGS.PSTF_LOCAL">
            <summary>Indicates the output will use local time.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.ClearPropVariantArray(Vanara.PInvoke.Ole32.PROPVARIANT[],System.UInt32)">
            <summary>
            <para>Frees the memory and references used by an array of PROPVARIANT structures stored in an array.</para>
            </summary>
            <param name="rgPropVar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>Array of PROPVARIANT structures to free.</para>
            </param>
            <param name="cVars">
            <para>Type: <c>UINT</c></para>
            <para>The number of elements in the array specified by rgPropVar.</para>
            </param>
            <returns>
            <para>No return value.</para>
            </returns>
            <remarks>
            <para>
            This function releases the memory and references held by each structure in the array before setting the structures to zero.
            </para>
            <para>This function performs the same action as FreePropVariantArray, but <c>FreePropVariantArray</c> returns an <c>HRESULT</c>.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use ClearPropVariantArray</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.ClearVariantArray(Vanara.PInvoke.OleAut32.VARIANT[],System.UInt32)">
            <summary>Frees the memory and references used by an array of VARIANT structures stored in an array.</summary>
            <param name="pvars">
            <para>Type: <c>VARIANT*</c></para>
            <para>Array of VARIANT structures to free.</para>
            </param>
            <param name="cvars">
            <para>Type: <c>UINT</c></para>
            <para>The number of elements in the array specified by pvars.</para>
            </param>
            <returns>No return value.</returns>
            <remarks>
            <para>
            This function releases the memory and references held by each structure in the array before it sets the structures to zero.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use ClearVariantArray</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromBooleanVector(System.Boolean[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure from a specified Boolean vector.</summary>
            <param name="prgf">
            Pointer to the Boolean vector used to initialize the structure. If this parameter is NULL, the elements pointed to by the
            cabool.pElems structure member are initialized with VARIANT_FALSE.
            </param>
            <param name="cElems">The number of vector elements.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromBuffer(System.Byte[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure using the contents of a buffer.</summary>
            <param name="pv">Pointer to the buffer.</param>
            <param name="cb">The length of the buffer, in bytes.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromCLSID(System.Guid@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a class identifier (CLSID).</summary>
            <param name="clsid">Reference to the CLSID.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromDoubleVector(System.Double[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified vector of double values.</summary>
            <param name="prgn">
            Pointer to a double vector. If this value is NULL, the elements pointed to by the cadbl.pElems structure member are initialized
            with 0.0.
            </param>
            <param name="cElems">The number of vector elements.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromFileTime(System.Runtime.InteropServices.ComTypes.FILETIME@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on information stored in a <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> structure.</summary>
            <param name="pftIn">Pointer to the date and time as a <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> structure.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromFileTimeVector(System.Runtime.InteropServices.ComTypes.FILETIME[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure from a specified vector of <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> values.</summary>
            <param name="prgft">
            Pointer to the date and time as a <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> vector. If this value is NULL, the elements pointed to by the
            cafiletime.pElems structure member is initialized with (FILETIME)0.
            </param>
            <param name="cElems">The number of vector elements.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromGUIDAsString(System.Guid@,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Initializes a PROPVARIANT structure based on a <c>GUID</c>. The structure is initialized as VT_LPWSTR.</para>
            </summary>
            <param name="guid">
            <para>Type: <c>REFGUID</c></para>
            <para>Reference to the source <c>GUID</c>.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>When this function returns, contains the initialized PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_LPWSTR PROPVARIANT, which formats the GUID in a form similar to .</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use <c>InitPropVariantFromGUIDAsString</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromInt16Vector(System.Int16[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified vector of 16-bit integer values.</summary>
            <param name="prgn">Pointer to a source vector of SHORT values. If this parameter is NULL, the vector is initialized with zeros.</param>
            <param name="cElems">The number of elements in the vector.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromInt32Vector(System.Int32[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified vector of 32-bit integer values.</summary>
            <param name="prgn">Pointer to a source vector of LONG values. If this parameter is NULL, the vector is initialized with zeros.</param>
            <param name="cElems">The number of elements in the vector.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromInt64Vector(System.Int64[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified vector of 64-bit integer values.</summary>
            <param name="prgn">
            Pointer to a source vector of LONGLONG values. If this parameter is NULL, the vector is initialized with zeros.
            </param>
            <param name="cElems">The number of elements in the vector.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromPropVariantVectorElem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> vector element.</summary>
            <remarks>
            This function extracts a single value from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure and uses that value to initialize the
            output <c>PROPVARIANT</c> structure. The calling application must use <see cref="M:Vanara.PInvoke.Ole32.PropVariantClear(Vanara.PInvoke.Ole32.PROPVARIANT)"/> to free the
            <c>PROPVARIANT</c> referred to by ppropvar when it is no longer needed.
            <para>
            If the source <c>PROPVARIANT</c> is a vector or array, iElem must be less than the number of elements in the vector or array.
            </para>
            <para>If the source <c>PROPVARIANT</c> has a single value, iElem must be 0.</para>
            <para>If the source <c>PROPVARIANT</c> is empty, this function always returns an error code.</para>
            <para>You can use <see cref="M:Vanara.PInvoke.PropSys.PropVariantGetElementCount(Vanara.PInvoke.Ole32.PROPVARIANT)"/> to obtain the number of elements in the vector or array.</para>
            </remarks>
            <param name="propvarIn">The source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="iElem">The index of the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure element.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromResource(Vanara.PInvoke.HINSTANCE,System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Initializes a PROPVARIANT structure based on a string resource embedded in an executable file.</para>
            </summary>
            <param name="hinst">
            <para>Type: <c>HINSTANCE</c></para>
            <para>Handle to an instance of the module whose executable file contains the string resource.</para>
            </param>
            <param name="id">
            <para>Type: <c>UINT</c></para>
            <para>Integer identifier of the string to be loaded.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>When this function returns, contains the initialized PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This function creates a VT_LPWSTR propvariant. If the specified resource does not exist, it initializes the PROPVARIANT with an
            empty string. Resource strings longer than 1024 characters are truncated and null-terminated.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitPropVariantFromResource.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromString(System.String,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes the property variant from string.</summary>
            <param name="psz">Pointer to a buffer that contains the source Unicode string.</param>
            <param name="ppropvar">When this function returns, contains the initialized PROPVARIANT structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromStringAsVector(System.String,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>
            Initializes a PROPVARIANT structure from a specified string. The string is parsed as a semi-colon delimited list (for example: "A;B;C").
            </para>
            </summary>
            <param name="psz">
            <para>Type: <c>PCWSTR</c></para>
            <para>Pointer to a buffer that contains the source Unicode string.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>When this function returns, contains the initialized PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Creates a VT_VECTOR | VT_LPWSTR propvariant. It parses the source string as a semicolon list of values. The string "a; b; c"
            creates a vector with three values. Leading and trailing whitespace are removed, and empty values are omitted.
            </para>
            <para>If psz is <c>NULL</c> or contains no values, the PROPVARIANT structure is initialized as VT_EMPTY.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitPropVariantFromStringAsVector.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromStringVector(System.String[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified string vector.</summary>
            <param name="prgsz">Pointer to a buffer that contains the source string vector.</param>
            <param name="cElems">The number of vector elements in <paramref name="prgsz"/>.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromStrRet(System.IntPtr,System.IntPtr,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>
            <para>Initializes a PROPVARIANT structure based on a string stored in a STRRET structure.</para>
            </summary>
            <param name="pstrret">
            <para>Type: <c>STRRET*</c></para>
            <para>Pointer to a STRRET structure that contains the string.</para>
            </param>
            <param name="pidl">
            <para>Type: <c>PCUITEMID_CHILD</c></para>
            <para>PIDL of the item whose details are being retrieved.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c>PROPVARIANT*</c></para>
            <para>When this function returns, contains the initialized PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_LPWSTR propvariant.</para>
            <para><c>Note</c> This function frees the memory used for the STRRET contents.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitPropVariantFromStrRet.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromUInt16Vector(System.UInt16[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a specified string vector.</summary>
            <param name="prgn">The PRGN.</param>
            <param name="cElems">The number of vector elements in <paramref name="prgn"/>.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromUInt32Vector(System.UInt32[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a vector of 32-bit unsigned integer values.</summary>
            <param name="prgn">
            Pointer to a source vector of ULONG values. If this parameter is NULL, the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> is initialized with zeros.
            </param>
            <param name="cElems">The number of vector elements in <paramref name="prgn"/>.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantFromUInt64Vector(System.UInt64[],System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure based on a vector of 64-bit unsigned integer values.</summary>
            <param name="prgn">
            Pointer to a source vector of ULONGLONG values. If this parameter is NULL, the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> is initialized with zeros.
            </param>
            <param name="cElems">The number of vector elements in <paramref name="prgn"/>.</param>
            <param name="ppropvar">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitPropVariantVectorFromPropVariant(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Initializes a vector element in a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure with a value stored in another PROPVARIANT.</summary>
            <param name="propvarSingle">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure that contains a single value.</param>
            <param name="ppropvarVector">When this function returns, contains the initialized <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>
            Returns S_OK if successful, or a standard COM error value otherwise. If the requested coercion is not possible, an error is returned.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromBooleanArray(System.Boolean[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure from an array of Boolean values.</summary>
            <param name="prgf">
            <para>Type: <c>const BOOL*</c></para>
            <para>Pointer to source array of Boolean values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_BOOL variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromBooleanArray.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromBuffer(System.Byte[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with the contents of a buffer.</summary>
            <param name="pv">
            <para>Type: <c>const VOID*</c></para>
            <para>Pointer to the source buffer.</para>
            </param>
            <param name="cb">
            <para>Type: <c>UINT</c></para>
            <para>The length of the buffer, in bytes.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_UI1 variant..</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromBuffer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromDoubleArray(System.Double[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of values of type DOUBLE.</summary>
            <param name="prgn">
            <para>Type: <c>const DOUBLE*</c></para>
            <para>Pointer to the source array of DOUBLE values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_R8 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromDoubleArray.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromFileTime(System.Runtime.InteropServices.ComTypes.FILETIME@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with the contents of a FILETIME structure.</summary>
            <param name="pft">
            <para>Type: <c>const FILETIME*</c></para>
            <para>Pointer to date and time information stored in a FILETIME structure.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_DATE variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromFileTime.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromFileTimeArray(System.Runtime.InteropServices.ComTypes.FILETIME[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of FILETIME structures.</summary>
            <param name="prgft">
            <para>Type: <c>const FILETIME*</c></para>
            <para>Pointer to an array of FILETIME structures.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgft.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_DATE variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromFileTimeArray.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromGUIDAsString(System.Guid@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure based on a <c>GUID</c>. The structure is initialized as a <c>VT_BSTR</c> type.</summary>
            <param name="guid">
            <para>Type: <c>REFGUID</c></para>
            <para>Reference to the source <c>GUID</c>.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_BSTR variant, formatting the GUID in a form similar to .</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use <c>InitVariantFromGUIDAsString</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromInt16Array(System.Int16[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of 16-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const SHORT*</c></para>
            <para>Pointer to the source array of <c>SHORT</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_I2 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromInt16Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromInt32Array(System.Int32[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of 32-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const LONG*</c></para>
            <para>Pointer to the source array of <c>LONG</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_I4 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromInt32Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromInt64Array(System.Int64[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of 64-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const LONGLONG*</c></para>
            <para>Pointer to the source array of <c>LONGLONG</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            <para>The number of array elements.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_I8 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromInt64Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromResource(Vanara.PInvoke.HINSTANCE,System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure based on a string resource imbedded in an executable file.</summary>
            <param name="hinst">
            <para>Type: <c>HINSTANCE</c></para>
            <para>Handle to an instance of the module whose executable file contains the string resource.</para>
            </param>
            <param name="id">
            <para>Type: <c>UINT</c></para>
            <para>Integer identifier of the string to be loaded.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            Creates a VT_BSTR variant. If the resource does not exist, this function initializes the VARIANT as VT_EMPTY and returns a
            failure code.
            </para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromResource.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromStringArray(System.String[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of strings.</summary>
            <param name="prgsz">
            <para>Type: <c>PCWSTR*</c></para>
            <para>Pointer to an array of strings.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgsz.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_BSTR variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromStringArray.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromUInt16Array(System.UInt16[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of unsigned 16-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const USHORT*</c></para>
            <para>Pointer to the source array of <c>USHORT</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_UI2 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromUInt16Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromUInt32Array(System.UInt32[],System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with an array of unsigned 32-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const ULONG*</c></para>
            <para>Pointer to the source array of <c>ULONG</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_UI4 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromUInt32Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromUInt64Array(System.UInt64[],System.UInt32,System.Object@)">
            <summary>Initializes a VARIANT structure with an array of unsigned 64-bit integer values.</summary>
            <param name="prgn">
            <para>Type: <c>const ULONGLONG*</c></para>
            <para>Pointer to the source array of <c>ULONGLONG</c> values.</para>
            </param>
            <param name="cElems">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the array pointed to by prgn.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>Creates a VT_ARRAY | VT_UI8 variant.</para>
            <para>Examples</para>
            <para>The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromUInt64Array.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.InitVariantFromVariantArrayElem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Initializes a VARIANT structure with a value stored in another <c>VARIANT</c> structure.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to the source VARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Index of one of the source VARIANT structure elements.</para>
            </param>
            <param name="pvar">
            <para>Type: <c>VARIANT*</c></para>
            <para>When this function returns, contains the initialized VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for VARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_BSTR</term>
            </item>
            <item>
            <term>VT_BOOL</term>
            </item>
            <item>
            <term>VT_I2</term>
            </item>
            <item>
            <term>VT_I4</term>
            </item>
            <item>
            <term>VT_I8</term>
            </item>
            <item>
            <term>VT_U12</term>
            </item>
            <item>
            <term>VT_U14</term>
            </item>
            <item>
            <term>VT_U18</term>
            </item>
            <item>
            <term>VT_DATE</term>
            </item>
            <item>
            <term>VT_ARRAY | (any one of VT_BSTR, VT_BOOL, VT_I2, VT_I4, VT_I8, VT_U12, VT_U14, VT_U18, VT_DATE)</term>
            </item>
            </list>
            <para>Additional types may be supported in the future.</para>
            <para>
            This function extracts a single value from the source VARIANT structure and uses that value to initialize the output
            <c>VARIANT</c> structure. The calling application must use VariantClear to free the <c>VARIANT</c> referred to by pvar when it is
            no longer needed.
            </para>
            <para>If the source VARIANT is an array, iElem must be less than the number of elements in the array.</para>
            <para>If the source VARIANT has a single value, iElem must be 0.</para>
            <para>If the source VARIANT is empty, this function always returns an error code.</para>
            <para>You can use VariantGetElementCount to obtain the number of elements in the array or array.</para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use InitVariantFromVariantArrayElem in an
            iteration statement to access the values in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantChangeType(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPVAR_CHANGE_FLAGS,Vanara.PInvoke.Ole32.VARTYPE)">
            <summary>Coerces a value stored as a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure to an equivalent value of a different variant type.</summary>
            <param name="ppropvarDest">
            A pointer to a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure that, when this function returns successfully, receives the coerced value and
            its new type.
            </param>
            <param name="propvarSrc">
            A reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure that contains the value expressed as its original type.
            </param>
            <param name="flags">Reserved, must be 0.</param>
            <param name="vt">Specifies the new type for the value. See the tables below for recognized type names.</param>
            <returns>
            Returns S_OK if successful, or a standard COM error value otherwise. If the requested coercion is not possible, an error is returned.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantCompare(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Compares two <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structures, based on default comparison units and settings.</summary>
            <param name="propvar1">Reference to the first <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="propvar2">Reference to the second <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>
            <list type="bullet">
            <item>
            <description>Returns 1 if propvar1 is greater than propvar2</description>
            </item>
            <item>
            <description>Returns 0 if propvar1 equals propvar2</description>
            </item>
            <item>
            <description>Returns -1 if propvar1 is less than propvar2</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantCompareEx(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_UNIT,Vanara.PInvoke.PropSys.PROPVAR_COMPARE_FLAGS)">
            <summary>Compares two <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structures, based on specified comparison units and flags.</summary>
            <param name="propvar1">Reference to the first <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="propvar2">Reference to the second <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="unit">Specifies, where appropriate, one of the comparison units defined in PROPVAR_COMPARE_UNIT.</param>
            <param name="flags">Specifies one of the following:</param>
            <returns>
            <list type="bullet">
            <item>
            <description>Returns 1 if propvar1 is greater than propvar2</description>
            </item>
            <item>
            <description>Returns 0 if propvar1 equals propvar2</description>
            </item>
            <item>
            <description>Returns -1 if propvar1 is less than propvar2</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetBooleanElem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Boolean@)">
            <summary>
            <para>Extracts a single Boolean element from a PROPVARIANT structure of type , , or .</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>A reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies the vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pfVal">
            <para>Type: <c>BOOL*</c></para>
            <para>When this function returns, contains the extracted Boolean value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            If the source PROPVARIANT structure has type , iElem must be 0. Otherwise iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>The following example uses this function to loop through the values in a PROPVARIANT structure.</para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetDoubleElem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Double@)">
            <summary>
            <para>Extracts a single <c>double</c> element from a PROPVARIANT structure of type , , or .</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>DOUBLE*</c></para>
            <para>When this function returns, contains the extracted double value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            If the source PROPVARIANT has type , iElem must be 0. Otherwise iElem must be less than the number of elements in the vector or
            array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>The following example uses this function to loop through the values in a PROPVARIANT structure.</para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetElementCount(Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Retrieves the element count of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <returns>
            Returns the element count of a VT_VECTOR or VT_ARRAY value: for single values, returns 1; for empty structures, returns 0.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetFileTimeElem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>
            <para>
            Extracts a single FILETIME element from a PROPVARIANT structure of type VT_FILETIME, VT_VECTOR | VT_FILETIME, or VT_ARRAY | VT_FILETIME.
            </para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>The source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, this value must be 0.</para>
            </param>
            <param name="pftVal">
            <para>Type: <c>FILETIME*</c></para>
            <para>When this function returns, contains the extracted filetime value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            If the source PROPVARIANT has type VT_FILETIME, iElem must be 0; otherwise, iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following code example, to be included as part of a larger program, demonstrates how to use PropVariantGetFileTimeElem in an
            iteration statement to access the values in PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetInt16Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Int16@)">
            <summary>
            <para>Extracts a single Int16 element from a PROPVARIANT structure of type VT_I2, VT_VECTOR | VT_I2, or VT_ARRAY | VT_I2.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, this value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>SHORT*</c></para>
            <para>When this function returns, contains the extracted Int32 element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types.</para>
            <list type="bullet">
            <item>
            <term>VT_I2</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_I2</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_I2</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_I2, iElem must be 0. Otherwise, iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantGetInt16Elem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetInt32Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Int32@)">
            <summary>
            <para>Extracts a single Int32 element from a PROPVARIANT of type VT_I4, VT_VECTOR | VT_I4, or VT_ARRAY | VT_I4.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>LONG*</c></para>
            <para>When this function, contains the extracted Int32 value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_I4</term>
            </item>
            <item>
            <term>VT_VECTTOR | VT_I4</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_I4</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_I4, iElem must be 0. Otherwise, iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example uses this PropVariantGetInt32Elem with an interation statement to access the values in a PROPVARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetInt64Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.Int64@)">
            <summary>
            <para>Extracts a single Int64 element from a PROPVARIANT structure of type VT_I8, VT_VECTOR | VT_I8, or VT_ARRAY | VT_I8.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>LONGLONG*</c></para>
            <para>When this function returns, contains the extracted Int64 value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works forPROPVARIANTstructures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_I8</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_I8</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_I8</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_I8, iElem must be 0. Otherwise, iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantGetInt64Elem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetStringElem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.String@)">
            <summary>
            <para>
            Extracts a single Unicode string element from a PROPVARIANT structure of type VT_LPWSTR, VT_BSTR, VT_VECTOR | VT_LPWSTR,
            VT_VECTOR | VT_BSTR, or VT_ARRAY | VT_BSTR.
            </para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="ppszVal">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            When this function returns, contains the extracted string value. The calling application is responsible for freeing this string
            by calling CoTaskMemFree when it is no longer needed.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_LPWSTR</term>
            </item>
            <item>
            <term>VT_BSTR</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_LPWSTR</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_BSTR</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_BSTR</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_LPWSTR or VT_BSTR, iElem must be 0. Otherwise iElem must be less than the number of
            elements in the vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>If a BSTR element has a <c>NULL</c> pointer, this function allocates an empty string.</para>
            <para>Examples</para>
            <para>
            The following code example, to be included as part of a larger program, demonstrates how to use PropVariantGetStringElem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetUInt16Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.UInt16@)">
            <summary>
            <para>
            Extracts a single unsigned Int16 element from a PROPVARIANT structure of type VT_U12, VT_VECTOR | VT_U12, or VT_ARRAY | VT_U12.
            </para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to the source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>USHORT*</c></para>
            <para>When this function returns, contains the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_UI2</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_UI2</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_UI2</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_UI2, iElem must be 0. Otherwise iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantGetUInt16Elem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetUInt32Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.UInt32@)">
            <summary>
            <para>
            Extracts a single unsigned Int32 element from a PROPVARIANT structure of type VT_UI4, VT_VECTOR | VT_UI4, or VT_ARRAY | VT_UI4.
            </para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>The source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>A vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the extracted unsigned Int32 value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_UI4</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_UI4</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_UI4</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_UI4, iElem must be 0. Otherwise, iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantGetUInt32Elem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantGetUInt64Elem(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.UInt64@)">
            <summary>
            <para>
            Extracts a single unsigned Int64 element from a PROPVARIANT structure of type VT_UI8, VT_VECTOR | VT_UI8, or VT_ARRAY | VT_UI8.
            </para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>The source PROPVARIANT structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>The vector or array index; otherwise, iElem must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>ULONGLONG*</c></para>
            <para>When this function returns, contains the extracted Int64 value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function works for PROPVARIANT structures of the following types:</para>
            <list type="bullet">
            <item>
            <term>VT_UI8</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_UI8</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_UI8</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has type VT_UI8, iElem must be 0. Otherwise iElem must be less than the number of elements in the
            vector or array. You can use PropVariantGetElementCount to obtain the number of elements in the vector or array.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantGetUInt64Elem with an
            iteration statement to access the values in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBoolean(Vanara.PInvoke.Ole32.PROPVARIANT,System.Boolean@)">
            <summary>
            Extracts a Boolean property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pfRet">When this function returns, contains the extracted property value if one exists; otherwise, contains FALSE.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBooleanVector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Boolean[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts a Boolean vector from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgf">
            <para>Type: <c>BOOL*</c></para>
            <para>
            Points to a buffer that contains crgf <c>BOOL</c> values. When this function returns, the buffer has been initialized with pcElem
            Boolean elements extracted from the source PROPVARIANT structure.
            </para>
            </param>
            <param name="crgf">
            <para>Type: <c>ULONG</c></para>
            <para>Number of elements in the buffer pointed to by prgf.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of Boolean elements extracted from source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgf values. The buffer pointed to by prgf.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a PROPVARIANT to hold a Boolean vector value with a fixed
            number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type VT_VECTOR | VT_BOOL or VT_ARRAY | VT_BOOL, this helper function extracts up to crgf Boolean
            values an places them into the buffer pointed to by prgf. If the <c>PROPVARIANT</c> contains more elements than will fit into the
            prgf buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToBooleanVector to access a
            Boolean vector stored in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBooleanVectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated Boolean vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of Boolean values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of Boolean elements extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>
            Returns S_OK if successful, or an error value otherwise. E_INVALIDARG indicates that the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> was not of the
            appropriate type.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBooleanWithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.Boolean)">
            <summary>
            <para>
            Extracts the Boolean property value of a PROPVARIANT structure. If no value exists, then the specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="fDefault">
            <para>Type: <c>BOOL</c></para>
            <para>Specifies the default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>The extracted Boolean value or the default value.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a Boolean value and would like
            to use a default value if it does not. For instance, an application that obtains values from a property store can use this to
            safely extract the Boolean value for Boolean properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_BOOL</c>, this helper function extracts the Boolean value. Otherwise, it attempts to
            convert the value in the <c>PROPVARIANT</c> structure into a Boolean. If the source <c>PROPVARIANT</c> has type <c>VT_EMPTY</c>
            or a conversion is not possible, then PropVariantToBooleanWithDefault returns the default provided by fDefault. See
            PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToBooleanWithDefault to
            access a Boolean value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBSTR(Vanara.PInvoke.Ole32.PROPVARIANT,System.String@)">
            <summary>Extracts the BSTR property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pbstrOut">Pointer to the extracted property value if one exists; otherwise, contains an empty string.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToBuffer(Vanara.PInvoke.Ole32.PROPVARIANT,System.Byte[],System.UInt32)">
            <summary>Extracts the buffer value from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure of type VT_VECTOR | VT_UI1 or VT_ARRRAY | VT_UI1.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pv">
            Pointer to a buffer of length cb bytes. When this function returns, contains the first cb bytes of the extracted buffer value.
            </param>
            <param name="cb">The buffer length, in bytes.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToDouble(Vanara.PInvoke.Ole32.PROPVARIANT,System.Double@)">
            <summary>Extracts double value from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pdblRet">
            When this function returns, contains the extracted property value if one exists; otherwise, contains 0.0.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToDoubleVector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Double[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts a vector of doubles from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>DOUBLE*</c></para>
            <para>
            Points to a buffer containing crgn DOUBLE values. When this function returns, the buffer has been initialized with pcElem double
            elements extracted from the source PROPVARIANT structure.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size in elements of the buffer pointed to by prgn.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of double elements extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a double vector value with a
            fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type VT_VECTOR | VT_R8 or VT_ARRAY | VT_R8, this helper function extracts up to crgn double values
            and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c> contains more elements than will fit into the prgn
            buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToDoubleVectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly-allocated double vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of double values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of double elements extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToDoubleWithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.Double)">
            <summary>
            <para>Extracts a double property value of a PROPVARIANT structure. If no value exists, then the specified default value is returned.</para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="dblDefault">
            <para>Type: <c>DOUBLE</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>DOUBLE</c></para>
            <para>Returns extracted <c>double</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a double value and would like
            to use a default value if it does not. For instance, an application obtaining values from a property store can use this to safely
            extract the double value for double properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_R8</c>, this helper function extracts the double value. Otherwise, it attempts to
            convert the value in the <c>PROPVARIANT</c> structure into a double. If the source <c>PROPVARIANT</c> has type <c>VT_EMPTY</c> or
            a conversion is not possible, then PropVariantToDoubleWithDefault will return the default provided by dblDefault. See
            PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToFileTime(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.PInvoke.PropSys.PSTIME_FLAGS,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>Extracts the <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> structure from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pstfOut">Specifies one of the time flags.</param>
            <param name="pftOut">When this function returns, contains the extracted <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> structure.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToFileTimeVector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Runtime.InteropServices.ComTypes.FILETIME[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts data from a PROPVARIANT structure into a FILETIME vector.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgft">
            <para>Type: <c>FILETIME*</c></para>
            <para>
            Points to a buffer containing crgft FILETIME values. When this function returns, the buffer has been initialized with pcElem
            FILETIME elements extracted from the source PROPVARIANT structure.
            </para>
            </param>
            <param name="crgft">
            <para>Type: <c>ULONG</c></para>
            <para>Size in elements of the buffer pointed to by prgft.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of FILETIME elements extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgft.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a filetime vector value with a
            fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type VT_VECTOR | VT_FILETIME, this helper function extracts up to crgft FILETIME values and places
            them into the buffer pointed to by prgft. If the <c>PROPVARIANT</c> contains more elements than will fit into the prgft buffer,
            this function returns an error and sets pcElem to 0.
            </para>
            <para>The output FILETIMEs will use the same time zone as the source FILETIMEs.</para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToFileTimeVector to access
            a FILETIME vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToFileTimeVectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly-allocated <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> values extracted from the source
            <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/> elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToGUID(Vanara.PInvoke.Ole32.PROPVARIANT,System.Guid@)">
            <summary>Extracts a GUID value from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pguid">When this function returns, contains the extracted property value if one exists.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt16(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int16@)">
            <summary>Extracts an Int16 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="piRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt16Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int16[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts a vector of <c>Int16</c> values from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>SHORT*</c></para>
            <para>
            Points to a buffer containing crgn SHORT values. When this function returns, the buffer has been initialized with pcElem SHORT
            elements extracted from the source PROPVARIANT structure.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>Int16</c> elements extracted from source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>ThePROPVARIANTwas not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an <c>Int16</c> vector value
            with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type VT_VECTOR | VT_I2 or VT_ARRAY | VT_I2, this helper function extracts up to crgn Int16 values
            and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c> contains more elements than will fit into the prgn
            buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt16VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated Int16 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of Int16 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of Int16 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt16WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int16)">
            <summary>
            <para>
            Extracts the Int16 property value of a PROPVARIANT structure. If no value currently exists, then specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="iDefault">
            <para>Type: <c>SHORT</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>Returns the extracted <c>short</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an <c>Int16</c> value and
            would like to use a default value if it does not. For instance, an application obtaining values from a property store can use
            this to safely extract the <c>SHORT</c> value for <c>Int16</c> properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_I2</c>, this helper function extracts the <c>Int16</c> value. Otherwise, it attempts to
            convert the value in the <c>PROPVARIANT</c> structure into a <c>SHORT</c>. If the source <c>PROPVARIANT</c> has type
            <c>VT_EMPTY</c> or a conversion is not possible, then PropVariantToInt16WithDefault will return the default provided by iDefault.
            See PropVariantChangeType for a list of possible conversions.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt32(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int32@)">
            <summary>Extracts an Int32 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="plRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt32Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int32[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts a vector of <c>long</c> values from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>LONG*</c></para>
            <para>
            Points to a buffer containing crgn <c>LONG</c> values. When this function returns, the buffer has been initialized with pcElem
            <c>LONG</c> elements extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>LONG</c> elements extracted from source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of <c>LONG</c>
            values with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_VECTOR</c> | <c>VT_I4</c> or <c>VT_ARRAY</c> | <c>VT_I4</c>, this helper function
            extracts up to crgn <c>LONG</c> values and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c> contains
            more elements than will fit into the prgn buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToInt32Vector to access an
            Int32 vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt32VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated Int32 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of Int32 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of Int32 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt32WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int32)">
            <summary>
            <para>
            Extracts an <c>Int32</c> value from a PROPVARIANT structure. If no value currently exists, then the specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="lDefault">
            <para>Type: <c>LONG</c></para>
            <para>Specifies a default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>Returns extracted <c>LONG</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a <c>LONG</c> value and would
            like to use a default value if it does not. For instance, an application obtaining values from a property store can use this to
            safely extract the <c>LONG</c> value for <c>Int32</c> properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_I4</c>, this helper function extracts the <c>LONG</c> value. Otherwise, it attempts to
            convert the value in the <c>PROPVARIANT</c> structure into a <c>LONG</c>. If the source <c>PROPVARIANT</c> has type
            <c>VT_EMPTY</c> or a conversion is not possible, then PropVariantToInt32WithDefault will return the default provided by lDefault.
            See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToInt32WithDefault to
            access a <c>LONG</c> value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt64(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int64@)">
            <summary>Extracts an Int64 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pllRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt64Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int64[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts data from a PROPVARIANT structure into an <c>Int64</c> vector.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>LONGLONG*</c></para>
            <para>
            Points to a buffer containing crgn <c>LONGLONG</c> values. When this function returns, the buffer has been initialized with
            pcElem <c>LONGLONG</c> elements extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>LONGLONG</c> values extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of <c>LONGLONG</c>
            values with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_VECTOR</c> | <c>VT_I8</c> or <c>VT_ARRAY</c> | <c>VT_I8</c>, this helper function
            extracts up to crgn <c>LONGLONG</c> values and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c> contains
            more elements than will fit into the prgn buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToInt64Vector to access an
            Int64 vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt64VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated Int64 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of Int64 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of Int64 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToInt64WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.Int64)">
            <summary>
            <para>
            Extracts the <c>Int64</c> property value of a PROPVARIANT structure. If no value exists, then specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="llDefault">
            <para>Type: <c>LONGLONG</c></para>
            <para>Specifies a default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>LONGLONG</c></para>
            <para>Returns the extracted <c>LONGLONG</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a <c>LONGLONG</c> value and
            would like to use a default value if it does not. For instance, an application obtaining values from a property store can use
            this to safely extract the <c>LONGLONG</c> value for Int64 properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_I8</c>, this helper function extracts the <c>LONGLONG</c> value. Otherwise, it attempts
            to convert the value in the <c>PROPVARIANT</c> structure into a <c>LONGLONG</c>. If the source <c>PROPVARIANT</c> has type
            <c>VT_EMPTY</c> or a conversion is not possible, then PropVariantToInt64WithDefault will return the default provided by
            llDefault. See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToInt64WithDefault to
            access a <c>LONGLONG</c> value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToString(Vanara.PInvoke.Ole32.PROPVARIANT,System.Text.StringBuilder,System.UInt32)">
            <summary>
            <para>Extracts a string value from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="psz">
            <para>Type: <c>PWSTR</c></para>
            <para>
            Points to a string buffer. When this function returns, the buffer is initialized with a <c>NULL</c> terminated Unicode string value.
            </para>
            </param>
            <param name="cch">
            <para>Type: <c>UINT</c></para>
            <para>Size of the buffer pointed to by psz, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>The value was extracted and the result buffer was NULL terminated.</term>
            </item>
            <item>
            <term>STRSAFE_E_INSUFFICIENT_BUFFER</term>
            <term>
            The copy operation failed due to insufficient buffer space. The destination buffer contains a truncated, null-terminated version
            of the intended result. In situations where truncation is acceptable, this may not necessarily be seen as a failure condition.
            </term>
            </item>
            <item>
            <term>Some other error value</term>
            <term>The extraction failed for some other reason.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a string value. For instance,
            an application obtaining values from a property store can use this to safely extract a string value for string properties.
            </para>
            <para>
            If the source PROPVARIANT has type VT_LPWSTR or <c>VT_BSTR</c>, this function extracts the string and places it into the provided
            buffer. Otherwise, it attempts to convert the value in the <c>PROPVARIANT</c> structure into a string. If a conversion is not
            possible, PropVariantToString will return a failure code and set psz to '\0'. See PropVariantChangeType for a list of possible
            conversions. Of note, <c>VT_EMPTY</c> is successfully converted to "".
            </para>
            <para>
            In addition to the terminating <c>NULL</c>, at most cch-1 characters are written into the buffer pointed to by psz. If the value
            in the source PROPVARIANT is longer than will fit into the buffer, a truncated <c>NULL</c> Terminated copy of the string is
            written to the buffer and this function returns <c>STRSAFE_E_INSUFFICIENT_BUFFER</c>. The resulting string will always be
            <c>NULL</c> terminated.
            </para>
            <para>In addition to the conversions provided by PropVariantChangeType, the following special cases apply to PropVariantToString.</para>
            <list type="bullet">
            <item>
            <term>
            Vector-valued PROPVARIANTs are converted to strings by separating each element with using "; ". For example, PropVariantToString
            converts a vector of 3 integers, {3, 1, 4}, to the string "3; 1; 4". The semicolon is independent of the current locale.
            </term>
            </item>
            <item>
            <term>
            VT_BLOB, VT_STREAM, VT_STREAMED_OBJECT, and VT_UNKNOWN values are converted to strings using an unsupported encoding. It is not
            possible to decode strings created in this way and the format may change in the future.
            </term>
            </item>
            </list>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToString to access a string
            value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStringAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,System.String@)">
            <summary>Extracts a string property value from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="ppszOut">When this function returns, contains a pointer to the extracted property value if one exists.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStringVector(Vanara.PInvoke.Ole32.PROPVARIANT,System.IntPtr,System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts a vector of strings from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgsz">
            <para>Type: <c>PWSTR*</c></para>
            <para>
            Pointer to a vector of string pointers. When this function returns, the buffer has been initialized with pcElem elements pointing
            to newly allocated strings containing the data extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgsz">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgsz, in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of strings extracted from source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The sourcePROPVARIANTcontained more than crgsz values. The buffer pointed to by prgsz.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>ThePROPVARIANTwas not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of string values
            with a fixed number of elements.
            </para>
            <para>This function works for the following PROPVARIANT types:</para>
            <list type="bullet">
            <item>
            <term>VT_VECTOR | VT_LPWSTR</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_BSTR</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_BSTR</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has a supported type, this helper function extracts up to crgsz string values and places an allocated
            copy of each into the buffer pointed to by prgsz. If the <c>PROPVARIANT</c> contains more elements than will fit into the prgsz
            buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>
            Since each string in pointed to by the output buffer has been newly allocated, the calling application is responsible for using
            CoTaskMemFree to free each string in the output buffer when they are no longer needed.
            </para>
            <para>
            If a <c>BSTR</c> in the source PROPVARIANT is <c>NULL</c>, it is converted to a newly allocated string containing "" in the output.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStringVector(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32,System.String[]@)">
            <summary>
            <para>Extracts a vector of strings from a PROPVARIANT structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="crgsz">
            <para>Type: <c>ULONG</c></para>
            <para>The number of strings requested.</para>
            </param>
            <param name="prgsz">
            <para>Type: <c>PWSTR*</c></para>
            <para>When this function returns, the array of strings containing the data extracted from the source PROPVARIANT.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The sourcePROPVARIANTcontained more than crgsz values. The buffer pointed to by prgsz.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>ThePROPVARIANTwas not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of string values
            with a fixed number of elements.
            </para>
            <para>This function works for the following PROPVARIANT types:</para>
            <list type="bullet">
            <item>
            <term>VT_VECTOR | VT_LPWSTR</term>
            </item>
            <item>
            <term>VT_VECTOR | VT_BSTR</term>
            </item>
            <item>
            <term>VT_ARRAY | VT_BSTR</term>
            </item>
            </list>
            <para>
            If the source PROPVARIANT has a supported type, this helper function extracts up to crgsz string values and places an allocated
            copy of each into the buffer pointed to by prgsz. If the <c>PROPVARIANT</c> contains more elements than will fit into the prgsz
            buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>
            Since each string in pointed to by the output buffer has been newly allocated, the calling application is responsible for using
            CoTaskMemFree to free each string in the output buffer when they are no longer needed.
            </para>
            <para>
            If a <c>BSTR</c> in the source PROPVARIANT is <c>NULL</c>, it is converted to a newly allocated string containing "" in the output.
            </para>
            <para>Examples</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStringVectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated strings in a newly allocated vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of strings extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of string elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStringWithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.String)">
            <summary>
            Extracts the string property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure. If no value exists, then the specified default value
            is returned.
            </summary>
            <param name="propvarIn">Reference to a source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pszDefault">Pointer to a default Unicode string value, for use where no value currently exists. May be NULL.</param>
            <returns>Returns string value or the default.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToStrRet(Vanara.PInvoke.Ole32.PROPVARIANT,System.IntPtr)">
            <summary>
            <para>Extracts a string from a PROPVARIANT structure and places it into a STRRET structure.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="pstrret">
            <para>Type: <c>STRRET*</c></para>
            <para>
            Points to the STRRET structure. When this function returns, the structure has been initialized to contain a copy of the extracted string.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in applications that wish to convert a string value in a PROPVARIANT structure into a STRRET
            structure. For instance, an application implementing IShellFolder::GetDisplayNameOf may find this function useful.
            </para>
            <para>
            If the source PROPVARIANT has type VT_LPWSTR or VT_BSTR, this function extracts the string and places it into the STRRET
            structure. Otherwise, it attempts to convert the value in the <c>PROPVARIANT</c> structure into a string. If a conversion is not
            possible, PropVariantToString will return a failure code. See PropVariantChangeType for a list of possible conversions. Of note,
            VT_EMPTY is successfully converted to "".
            </para>
            <para>In addition to the conversions provided by PropVariantChangeType, the following special cases apply to PropVariantToString.</para>
            <list type="bullet">
            <item>
            <term>
            Vector-valued PROPVARIANTs are converted to strings by separating each element with using "; ". For example, PropVariantToString
            converts a vector of 3 integers, {3, 1, 4}, to the string "3; 1; 4". The semicolon is independent of the current locale.
            </term>
            </item>
            <item>
            <term>
            VT_BLOB, VT_STREAM, VT_STREAMED_OBJECT, and VT_UNKNOWN values are converted to strings using an unsupported encoding. It is not
            possible to decode strings created in this way and the format may change in the future.
            </term>
            </item>
            </list>
            <para>
            If the extraction is successful, the function will initialize uType member of the STRRET structure with STRRET_WSTR and set the
            pOleStr member of that structure to point to an allocated copy of the string. The calling application is responsible for using
            CoTaskMemFree or StrRetToStr to free this string when it is no longer needed.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToString to access a string
            value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt16(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt16@)">
            <summary>Extracts a UInt16 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="puiRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt16Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt16[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts data from a PROPVARIANT structure into an <c>unsigned short</c> vector.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>USHORT*</c></para>
            <para>
            Points to a buffer containing crgn <c>unsigned short</c> values. When this function returns, the buffer has been initialized with
            pcElem <c>unsigned short</c> elements extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>unsigned short</c> values extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of <c>unsigned
            short</c> values with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_VECTOR</c> | <c>VT_UI2</c> or <c>VT_ARRAY</c> | <c>VT_UI2</c>, this helper function
            extracts up to crgn <c>unsigned short</c> values and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c>
            contains more elements than will fit into the prgn buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt16Vector to access an
            <c>unsigned short</c> vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt16VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated UInt16 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of UInt16 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of UInt16 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt16WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt16)">
            <summary>
            <para>
            Extracts an <c>unsigned short</c> value from a PROPVARIANT structure. If no value exists, then the specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="uiDefault">
            <para>Type: <c>USHORT</c></para>
            <para>Specifies a default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>unsigned short</c></para>
            <para>Returns extracted <c>unsigned short</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a <c>unsigned short</c> value.
            For instance, an application obtaining values from a property store can use this to safely extract the <c>unsigned short</c>
            value for UInt16 properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_UI2</c>, this helper function extracts the <c>unsigned short</c> value. Otherwise, it
            attempts to convert the value in the <c>PROPVARIANT</c> structure into a <c>unsigned short</c>. If a conversion is not possible,
            PropVariantToUInt16 will return a failure code and set puiRet to 0. See PropVariantChangeType for a list of possible conversions.
            Of note, <c>VT_EMPTY</c> is successfully converted to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt16 to access a
            <c>unsigned short</c> value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt32(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32@)">
            <summary>Extracts a UInt32 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pulRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt32Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts data from a PROPVARIANT structure into an <c>ULONG</c> vector.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>ULONG*</c></para>
            <para>
            Points to a buffer containing crgn <c>ULONG</c> values. When this function returns, the buffer has been initialized with pcElem
            <c>ULONG</c> elements extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn, in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>ULONG</c> values extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn is too small.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of <c>ULONG</c>
            values with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_VECTOR</c> | <c>VT_UI4</c> or <c>VT_ARRAY</c> | <c>VT_UI4</c>, this helper function
            extracts up to crgn <c>ULONG</c> values and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c> contains
            more elements than will fit into the prgn buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt32Vector to access a
            <c>ULONG</c> vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt32VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated UInt32 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of UInt32 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of UInt32 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt32WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt32)">
            <summary>
            <para>Extracts a <c>ULONG</c> value from a PROPVARIANT structure. If no value exists, then a specified default value is returned.</para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="ulDefault">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies a default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>ULONG</c></para>
            <para>Returns extracted <c>ULONG</c> value, or default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a <c>ULONG</c> value and would
            like to use a default value if it does not. For instance, an application obtaining values from a property store can use this to
            safely extract the <c>ULONG</c> value for <c>UInt32</c> properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_UI4</c>, this helper function extracts the <c>ULONG</c> value. Otherwise, it attempts to
            convert the value in the <c>PROPVARIANT</c> structure into a <c>ULONG</c>. If the source <c>PROPVARIANT</c> has type
            <c>VT_EMPTY</c> or a conversion is not possible, then PropVariantToUInt32WithDefault will return the default provided by
            ulDefault. See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt32WithDefault to
            access a <c>ULONG</c> value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt64(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt64@)">
            <summary>Extracts a UInt64 property value of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pullRet">When this function returns, contains the extracted property value if one exists; otherwise, 0.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt64Vector(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt64[],System.UInt32,System.UInt32@)">
            <summary>
            <para>Extracts data from a PROPVARIANT structure into a <c>ULONGLONG</c> vector.</para>
            </summary>
            <param name="propvar">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>ULONGLONG*</c></para>
            <para>
            Points to a buffer containing crgn <c>ULONGLONG</c> values. When this function returns, the buffer has been initialized with
            pcElem <c>ULONGLONG</c> elements extracted from the source PROPVARIANT.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Size of the buffer pointed to by prgn, in elements.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>ULONGLONG</c> values extracted from the source PROPVARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>This function can return one of these values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Returns S_OK if successful, or an error value otherwise.</term>
            </item>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source PROPVARIANT contained more than crgn values. The buffer pointed to by prgn.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The PROPVARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold an vector of <c>ULONGLONG</c>
            values with a fixed number of elements.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_VECTOR</c> | <c>VT_UI8</c> or <c>VT_ARRAY</c> | <c>VT_UI8</c>, this helper function
            extracts up to crgn <c>ULONGLONG</c> values and places them into the buffer pointed to by prgn. If the <c>PROPVARIANT</c>
            contains more elements than will fit into the prgn buffer, this function returns an error and sets pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt64Vector to access a
            <c>ULONGLONG</c> vector value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt64VectorAlloc(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure into a newly allocated UInt64 vector.</summary>
            <param name="propVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pprgf">
            When this function returns, contains a pointer to a vector of UInt64 values extracted from the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <param name="pcElem">
            When this function returns, contains the count of UInt64 elements extracted from source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToUInt64WithDefault(Vanara.PInvoke.Ole32.PROPVARIANT,System.UInt64)">
            <summary>
            <para>
            Extracts <c>ULONGLONG</c> value from a PROPVARIANT structure. If no value exists, then the specified default value is returned.
            </para>
            </summary>
            <param name="propvarIn">
            <para>Type: <c>REFPROPVARIANT</c></para>
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="ullDefault">
            <para>Type: <c>ULONGLONG</c></para>
            <para>Specifies a default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>ULONGLONG</c></para>
            <para>Returns the extracted unsigned <c>LONGLONG</c> value, or a default.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used in places where the calling application expects a PROPVARIANT to hold a <c>ULONGLONG</c> value and
            would like to use a default value if it does not. For instance, an application obtaining values from a property store can use
            this to safely extract the <c>ULONGLONG</c> value for <c>UInt64</c> properties.
            </para>
            <para>
            If the source PROPVARIANT has type <c>VT_UI8</c>, this helper function extracts the <c>ULONGLONG</c> value. Otherwise, it
            attempts to convert the value in the <c>PROPVARIANT</c> structure into a <c>ULONGLONG</c>. If the source <c>PROPVARIANT</c> has
            type <c>VT_EMPTY</c> or a conversion is not possible, then PropVariantToUInt64WithDefault will return the default provided by
            ullDefault. See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use PropVariantToUInt64WithDefault to
            access a <c>ULONGLONG</c> value in a PROPVARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToVariant(Vanara.PInvoke.Ole32.PROPVARIANT,System.IntPtr)">
            <summary>Converts the contents of a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure to a VARIANT structure.</summary>
            <param name="pPropVar">Reference to the source <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</param>
            <param name="pVar">Pointer to a VARIANT structure. When this function returns, the VARIANT contains the converted information.</param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.PropVariantToWinRTPropertyValue(Vanara.PInvoke.Ole32.PROPVARIANT,System.Guid@,System.Object@)">
            <summary>
            <para>
            Extracts data from a PROPVARIANT structure into a Windows Runtime property value. Note that in some cases more than one
            PROPVARIANT type maps to a single Windows Runtime property type.
            </para>
            </summary>
            <param name="propvar">
            <para>Reference to a source PROPVARIANT structure.</para>
            </param>
            <param name="riid">
            <para>A reference to the IID of the interface to retrieve through ppv, typically IID_IPropertyValue (defined in Windows.Foundation.h).</para>
            </param>
            <param name="ppv">
            <para>
            When this method returns successfully, contains the interface pointer requested in riid. This is typically an IPropertyValue
            pointer. If the call fails, this value is <c>NULL</c>.
            </para>
            </param>
            <returns>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            We recommend that you use the IID_PPV_ARGS macro, defined in Objbase.h, to package the riid and ppv parameters. This macro
            provides the correct IID based on the interface pointed to by the value in ppv, which eliminates the possibility of a coding
            error in riid that could lead to unexpected results.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.StgDeserializePropVariant(System.IntPtr,System.UInt32,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Deserializes a specified <c>SERIALIZEDPROPERTYVALUE</c> structure, creating a <c>PROPVARIANT</c> structure.</summary>
            <param name="pprop">
            <para>Type: <c>const <c>SERIALIZEDPROPERTYVALUE</c>*</c></para>
            <para>Pointer to a <c>SERIALIZEDPROPERTYVALUE</c> structure.</para>
            </param>
            <param name="cbMax">
            <para>Type: <c>ULONG</c></para>
            <para>The size of the <c>SERIALIZEDPROPERTYVALUE</c> structure, in bytes.</para>
            </param>
            <param name="ppropvar">
            <para>Type: <c><c>PROPVARIANT</c>*</c></para>
            <para>Pointer to the resulting <c>PROPVARIANT</c> structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.StgSerializePropVariant(Vanara.PInvoke.Ole32.PROPVARIANT,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Serializes a specified <c>PROPVARIANT</c> structure, creating a <c>SERIALIZEDPROPERTYVALUE</c> structure.</summary>
            <param name="ppropvar">
            <para>Type: <c>const <c>PROPVARIANT</c>*</c></para>
            <para>A constant pointer to the source <c>PROPVARIANT</c> structure.</para>
            </param>
            <param name="ppProp">
            <para>Type: <c><c>SERIALIZEDPROPERTYVALUE</c>**</c></para>
            <para>The address of a pointer to the <c>SERIALIZEDPROPERTYVALUE</c> structure.</para>
            </param>
            <param name="pcb">
            <para>Type: <c>ULONG*</c></para>
            <para>A pointer to the value representing the size of the <c>SERIALIZEDPROPERTYVALUE</c> structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantCompare(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Compares two variant structures, based on default comparison rules.</summary>
            <param name="var1">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a first variant structure.</para>
            </param>
            <param name="var2">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a second variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>INT</c></para>
            <list type="bullet">
            <item>
            <term>Returns 1 if var1 is greater than var2</term>
            </item>
            <item>
            <term>Returns 0 if var1 equals var2</term>
            </item>
            <item>
            <term>Returns -1 if var1 is less than var2</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>Note</c> This function does not support the comparison of different VARIANT types. If the types named in var1 and var2 are
            different, the results are undefined and should be ignored. Calling applications should ensure that they are comparing two of the
            same type before they call this function. The PropVariantChangeType function can be used to convert the two structures to the
            same type.
            </para>
            <para>By default, VT_NULL / VT_EMPTY / 0-element vectors are considered to be less than any other vartype.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetBooleanElem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.Boolean@)">
            <summary>Extracts a single Boolean element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pfVal">
            <para>Type: <c>BOOL*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetDoubleElem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.Double@)">
            <summary>Extracts one <c>double</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>DOUBLE*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetElementCount(Vanara.PInvoke.OleAut32.VARIANT@)">
            <summary>Retrieves the element count of a variant structure.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>ULONG</c></para>
            <para>Returns the element count for values of type VT_ARRAY; otherwise, returns 1.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetInt16Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.Int16@)">
            <summary>Extracts a single <c>Int16</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>SHORT*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetInt32Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.Int32@)">
            <summary>Extracts a single <c>Int32</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>LONG*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetInt64Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.Int64@)">
            <summary>Extracts a single <c>Int64</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>LONGLONG*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetStringElem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,Vanara.InteropServices.StrPtrUni@)">
            <summary>Extracts a single wide string element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies a vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="ppszVal">
            <para>Type: <c>PWSTR*</c></para>
            <para>The address of a pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetUInt16Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.UInt16@)">
            <summary>Extracts a single unsigned <c>Int16</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies a vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>USHORT*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetUInt32Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.UInt32@)">
            <summary>Extracts a single unsigned <c>Int32</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantGetUInt64Elem(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32,System.UInt64@)">
            <summary>Extracts a single unsigned <c>Int64</c> element from a variant structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iElem">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies vector or array index; otherwise, value must be 0.</para>
            </param>
            <param name="pnVal">
            <para>Type: <c>ULONGLONG*</c></para>
            <para>Pointer to the extracted element value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToBoolean(Vanara.PInvoke.OleAut32.VARIANT@,System.Boolean@)">
            <summary>
            Extracts the value of a Boolean property from a VARIANT structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pfRet">
            <para>Type: <c>BOOL*</c></para>
            <para>When this function returns, contains the extracted value if one exists; otherwise, <c>FALSE</c>.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold a Boolean value. For instance, an application
            that obtains values from a Shell folder can use this function to safely extract the value from one of the folder's Boolean properties.
            </para>
            <para>If the source VARIANT is of type VT_BOOL, this function extracts the <c>BOOL</c> value.</para>
            <para>
            If the source VARIANT is not of type VT_BOOL, this function attempts to convert the value in the <c>VARIANT</c> structure into a
            <c>BOOL</c>. If a conversion is not possible, VariantToBoolean returns a failure code and sets pfRet to <c>FALSE</c>. See
            PropVariantChangeType for a list of possible conversions. Of note, VT_EMPTY is successfully converted to <c>FALSE</c>.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToBoolean to access a
            <c>BOOL</c> value in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToBooleanArray(Vanara.PInvoke.OleAut32.VARIANT@,System.Boolean[],System.UInt32,System.UInt32@)">
            <summary>Extracts an array of Boolean values from a VARIANT structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="prgf">
            <para>Type: <c>BOOL*</c></para>
            <para>
            Pointer to a buffer that contains crgn Boolean values. When this function returns, the buffer has been initialized with *pcElem
            <c>BOOL</c> elements extracted from the source VARIANT structure.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the buffer pointed to by prgf.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>
            When this function returns, contains a pointer to the count of <c>BOOL</c> elements extracted from the source VARIANT structure.
            </para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise, including the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source VARIANT contained more than crgn values.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The VARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of
            Boolean values.
            </para>
            <para>
            If the source VARIANT is of type VT_ARRAY | VT_BOOL, this function extracts up to crgn <c>BOOL</c> values and places them into
            the buffer pointed to by prgf. If the <c>VARIANT</c> contains more elements than will fit into the prgf buffer, this function
            returns an error and sets *pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToBooleanArray to access an
            array of <c>BOOL</c> values stored in a VARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToBooleanArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Allocates an array of <c>BOOL</c> values then extracts data from a VARIANT structure into that array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pprgf">
            <para>Type: <c>BOOL**</c></para>
            <para>When this function returns, contains a pointer to an array of <c>BOOL</c> values extracted from the source VARIANT structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains a pointer to the count of elements extracted from the source VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function is used when the calling application expects a VARIANT to hold an array of <c>BOOL</c> values.</para>
            <para>
            If the source VARIANT is of type VT_ARRAY | VT_BOOL, this function extracts an array of <c>BOOL</c> values into a newly allocated
            array. The calling application is responsible for using CoTaskMemFree to release the array pointed to by pprgf when it is no
            longer needed.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToBooleanArrayAlloc to access
            an array of <c>BOOL</c> values stored in a VARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToBooleanWithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.Boolean)">
            <summary>Extracts a <c>BOOL</c> value from a VARIANT structure. If no value exists, then the specified default value is returned.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="fDefault">
            <para>Type: <c>BOOL</c></para>
            <para>The default value for use where no extractable value exists.</para>
            </param>
            <returns>
            <para>Type: <c>BOOL</c></para>
            <para>Returns the extracted <c>BOOL</c> value; otherwise, the default value specified in fDefault.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold a <c>BOOL</c> value and wants to use a
            default value if it does not.
            </para>
            <para>If the source VARIANT is of type VT_BOOL, this helper extracts the <c>BOOL</c> value.</para>
            <para>
            If the source VARIANT is not of type VT_BOOL, the function attempts to convert the value in the <c>VARIANT</c> into a <c>BOOL</c>.
            </para>
            <para>
            If the source VARIANT is of type VT_EMPTY or a conversion is not possible, then VariantToBooleanWithDefault returns the default
            value provided by fDefault. See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToBooleanWithDefault to access
            a <c>BOOL</c> value stored in a VARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToBuffer(Vanara.PInvoke.OleAut32.VARIANT@,System.Byte[],System.UInt32)">
            <summary>Extracts the contents of a buffer stored in a VARIANT structure of type VT_ARRRAY | VT_UI1.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pv">
            <para>Type: <c>VOID*</c></para>
            <para>
            Pointer to a buffer of length cb bytes. When this function returns, contains the first cb bytes of the extracted buffer value.
            </para>
            </param>
            <param name="cb">
            <para>Type: <c>UINT</c></para>
            <para>The size of the pv buffer, in bytes. The buffer should be the same size as the data to be extracted, or smaller.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns one of the following values:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>S_OK</term>
            <term>Data successfully extracted.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The VARIANT was not of type VT_ARRRAY | VT_UI1.</term>
            </item>
            <item>
            <term>E_FAIL</term>
            <term>The VARIANT buffer value had fewer than cb bytes.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is used when the calling application expects a VARIANT to hold a buffer value. The calling application should check
            that the value has the expected length before it calls this function.
            </para>
            <para>
            If the source VARIANT has type VT_ARRAY | VT_UI1, this function extracts the first cb bytes from the structure and places them in
            the buffer pointed to by pv.
            </para>
            <para>If the stored value has fewer than cb bytes, then VariantToBuffer fails and the buffer is not modified.</para>
            <para>If the value has more than cb bytes, then VariantToBuffer succeeds and truncates the value.</para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToBuffer to access a structure
            that has been stored in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToDosDateTime(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt16@,System.UInt16@)">
            <summary>Extracts a date and time value in Microsoft MS-DOS format from a VARIANT structure.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pwDate">
            <para>Type: <c>WORD*</c></para>
            <para>When this function returns, contains the extracted <c>WORD</c> that represents a MS-DOS date.</para>
            </param>
            <param name="pwTime">
            <para>Type: <c>WORD*</c></para>
            <para>When this function returns, contains the extracted contains the extracted <c>WORD</c> that represents a MS-DOS time.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function is used when the calling application expects a VARIANT to hold a datetime value.</para>
            <para>If the source VARIANT is of type <c>VT_DATE</c>, this function extracts the datetime value.</para>
            <para>
            If the source VARIANT is not of type <c>VT_DATE</c>, the function attempts to convert the value in the <c>VARIANT</c> structure
            into the right format. If a conversion is not possible, VariantToDosDateTime returns a failure code. See PropVariantChangeType
            for a list of possible conversions.
            </para>
            <para>See DosDateTimeToVariantTime for more information about the formats of pwDate, pwTime, and the source datetime value.</para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToDosDateTime to access a
            datetime value in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToDouble(Vanara.PInvoke.OleAut32.VARIANT@,System.Double@)">
            <summary>Extracts a <c>DOUBLE</c> value from a VARIANT structure. If no value can be extracted, then a default value is assigned.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pdblRet">
            <para>Type: <c>DOUBLE*</c></para>
            <para>When this function returns, contains the extracted value if one exists; otherwise, 0.0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold a <c>DOUBLE</c> value. For instance, an
            application that obtains values from a Shell folder can use this function to safely extract the value from one of the folder's
            properties whose value is stored as a <c>DOUBLE</c>.
            </para>
            <para>If the source VARIANT is of type VT_R8, this function extracts the <c>DOUBLE</c> value.</para>
            <para>
            If the source VARIANT is not of type VT_R8, the function attempts to convert the value stored in the <c>VARIANT</c> structure
            into a <c>DOUBLE</c>. If a conversion is not possible, VariantToDouble returns a failure code and sets pdblRet to . See
            PropVariantChangeType for a list of possible conversions. Of note, VT_EMPTY is successfully converted to 0.0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToDouble to access a
            <c>DOUBLE</c> value stored in a VARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToDoubleArray(Vanara.PInvoke.OleAut32.VARIANT@,System.Double[],System.UInt32,System.UInt32@)">
            <summary>Extracts an array of <c>DOUBLE</c> values from a VARIANT structure.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>DOUBLE*</c></para>
            <para>
            Pointer to a buffer that contains crgn <c>DOUBLE</c> values. When this function returns, the buffer has been initialized with
            *pcElem <c>DOUBLE</c> elements extracted from the source VARIANT structure.
            </para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>The number of elements in the buffer pointed to by prgn.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains the count of <c>DOUBLE</c> elements extracted from the source VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>Returns <c>S_OK</c> if successful, or an error value otherwise, including the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TYPE_E_BUFFERTOOSMALL</term>
            <term>The source VARIANT contained more than crgn values.</term>
            </item>
            <item>
            <term>E_INVALIDARG</term>
            <term>The VARIANT was not of the appropriate type.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of
            <c>DOUBLE</c> values.
            </para>
            <para>
            If the source VARIANT has type VT_ARRAY | VT_DOUBLE, this function extracts up to crgn <c>DOUBLE</c> values and places them into
            the buffer pointed to by prgn.
            </para>
            <para>
            If the VARIANT contains more elements than will fit into the prgn buffer, this function returns an error and sets *pcElem to 0.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToDoubleArray to access a
            <c>DOUBLE</c> array stored in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToDoubleArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Allocates an array of <c>DOUBLE</c> values then extracts data from a VARIANT structure into that array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>DOUBLE**</c></para>
            <para>When this function returns, contains a pointer to an array of <c>DOUBLE</c> values extracted from the source VARIANT structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>When this function returns, contains a pointer to the count of elements extracted from the source VARIANT structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>
            <para>This helper function is used when the calling application expects a VARIANT to hold an array of <c>DOUBLE</c> values.</para>
            <para>
            If the source VARIANT is of type VT_ARRAY | VT_R8, this function extracts an array of <c>DOUBLE</c> values into a newly allocated
            array. The calling application is responsible for using CoTaskMemFree to release the array pointed to by pprgn when it is no
            longer needed.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToDoubleArrayAlloc to access a
            <c>DOUBLE</c> array value in a VARIANT.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToDoubleWithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.Double)">
            <summary>
            Extracts a <c>DOUBLE</c> value from a VARIANT structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source VARIANT structure.</para>
            </param>
            <param name="dblDefault">
            <para>Type: <c>DOUBLE</c></para>
            <para>The default value for use where no extractable value exists.</para>
            </param>
            <returns>
            <para>Type: <c>DOUBLE</c></para>
            <para>Returns the extracted <c>double</c> value; otherwise, the default value specified in dblDefault.</para>
            </returns>
            <remarks>
            <para>
            This helper function is used when the calling application expects a VARIANT to hold a <c>DOUBLE</c> value and wants to use a
            default value if it does not.
            </para>
            <para>If the source VARIANT is of type VT_R8, this helper extracts the <c>DOUBLE</c> value.</para>
            <para>If the source VARIANT is not of type VT_R8, the function attempts to convert the value in the <c>VARIANT</c> into a <c>DOUBLE</c>.</para>
            <para>
            If the source VARIANT is of type VT_EMPTY or a conversion is not possible, then VariantToDoubleWithDefault returns the default
            value provided by dblDefault. See PropVariantChangeType for a list of possible conversions.
            </para>
            <para>Examples</para>
            <para>
            The following example, to be included as part of a larger program, demonstrates how to use VariantToDoubleWithDefault to access a
            <c>DOUBLE</c> value stored in a VARIANT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToFileTime(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.PInvoke.PropSys.PSTIME_FLAGS,System.Runtime.InteropServices.ComTypes.FILETIME@)">
            <summary>Extracts a FILETIME structure from a variant structure.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="stfOut">
            <para>Type: <c>PSTIME_FLAGS</c></para>
            <para>Specifies one of the following time flags:</para>
            <para>PSTF_UTC (0)</para>
            <para>Indicates coordinated universal time.</para>
            <para>PSTF_LOCAL (1)</para>
            <para>Indicates local time.</para>
            </param>
            <param name="pftOut">
            <para>Type: <c>FILETIME*</c></para>
            <para>Pointer to the extracted FILETIME structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
            <remarks>stfOut flags override any property description flags.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToGUID(Vanara.PInvoke.OleAut32.VARIANT@,System.Guid@)">
            <summary>Extracts a <c>GUID</c> property value of a variant structure.</summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pguid">
            <para>Type: <c>GUID*</c></para>
            <para>Pointer to the extracted property value.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt16(Vanara.PInvoke.OleAut32.VARIANT@,System.Int16@)">
            <summary>
            Extracts the <c>Int16</c> property value of a variant structure. If no value can be extracted, then a default value is assigned
            by this function.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="piRet">
            <para>Type: <c>SHORT*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt16Array(Vanara.PInvoke.OleAut32.VARIANT@,System.Int16[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an <c>Int16</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>SHORT*</c></para>
            <para>Pointer to the <c>Int16</c> data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies <c>Int16</c> array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of <c>Int16</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt16ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated <c>Int16</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>SHORT**</c></para>
            <para>Pointer to the address of the <c>Int16</c> data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of <c>Int16</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt16WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.Int16)">
            <summary>
            Extracts an <c>Int16</c> property value of a variant structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="iDefault">
            <para>Type: <c>SHORT</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>SHORT</c></para>
            <para>Returns the extracted <c>Int16</c> value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt32(Vanara.PInvoke.OleAut32.VARIANT@,System.Int32@)">
            <summary>
            Extracts an <c>Int32</c> property value of a variant structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="plRet">
            <para>Type: <c>LONG*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt32Array(Vanara.PInvoke.OleAut32.VARIANT@,System.Int32[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an <c>Int32</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>LONG*</c></para>
            <para>Pointer to the <c>Int32</c> data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies <c>Int32</c> array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of <c>Int32</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt32ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated <c>Int32</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>LONG**</c></para>
            <para>Pointer to the address of the <c>Int32</c> data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of <c>Int32</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt32WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.Int32)">
            <summary>
            Extracts an <c>Int32</c> property value of a variant structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="lDefault">
            <para>Type: <c>LONG</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>LONG</c></para>
            <para>Returns the extracted Int32 value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt64(Vanara.PInvoke.OleAut32.VARIANT@,System.Int64@)">
            <summary>
            Extracts an <c>Int64</c> property value of a variant structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pllRet">
            <para>Type: <c>LONGLONG*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt64Array(Vanara.PInvoke.OleAut32.VARIANT@,System.Int64[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an <c>Int64</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>LONGLONG*</c></para>
            <para>Pointer to the Int64 data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies Int64 array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of Int64 elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt64ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated <c>Int64</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>LONGLONG**</c></para>
            <para>Pointer to the address of the <c>Int64</c> data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of <c>Int64</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToInt64WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.Int32)">
            <summary>
            Extracts an <c>Int64</c> property value of a variant structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="llDefault">
            <para>Type: <c>LONGLONG</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>LONGLONG</c></para>
            <para>Returns extracted <c>Int64</c> value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToPropVariant(System.IntPtr,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Copies the contents of a VARIANT structure to a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure.</summary>
            <param name="pVar">Pointer to a source VARIANT structure.</param>
            <param name="pPropVar">
            Pointer to a <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> structure. When this function returns, the <see cref="T:Vanara.PInvoke.Ole32.PROPVARIANT"/> contains the
            converted information.
            </param>
            <returns>If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToString(Vanara.PInvoke.OleAut32.VARIANT@,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Extracts the variant value of a variant structure to a string. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pszBuf">
            <para>Type: <c>PWSTR</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, empty.</para>
            </param>
            <param name="cchBuf">
            <para>Type: <c>UINT</c></para>
            <para>Specifies string length, in characters.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToStringAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemString@)">
            <summary>
            Extracts the variant value of a variant structure to a newly-allocated string. If no value can be extracted, then a default value
            is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="ppszBuf">
            <para>Type: <c>PWSTR</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, empty.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToStringArray(Vanara.PInvoke.OleAut32.VARIANT@,System.String[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into a String array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgsz">
            <para>Type: <c>PWSTR*</c></para>
            <para>Pointer to the string data extracted from source variant structure.</para>
            </param>
            <param name="crgsz">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies string array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of string elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToStringArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated String array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgsz">
            <para>Type: <c>PWSTR**</c></para>
            <para>The address of a pointer to the string data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of string elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToStringWithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.String)">
            <summary>
            Extracts the string property value of a variant structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pszDefault">
            <para>Type: <c>LPCWSTR</c></para>
            <para>Pointer to the default Unicode string property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>PCWSTR</c></para>
            <para>Returns the extracted string value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt16(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt16@)">
            <summary>
            Extracts an unsigned <c>Int16</c> property value of a variant structure. If no value can be extracted, then a default value is
            assigned by this function.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="puiRet">
            <para>Type: <c>USHORT*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt16Array(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt16[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an unsigned <c>Int16</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>USHORT*</c></para>
            <para>Pointer to the unsigned <c>Int16</c> data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies unsigned <c>Int16</c> array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int16</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt16ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated unsigned <c>Int16</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>USHORT**</c></para>
            <para>Pointer to the address of the unsigned <c>Int16</c> data extracted from the source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int16</c> elements extracted from the source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt16WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt16)">
            <summary>
            Extracts an unsigned <c>Int16</c> property value of a variant structure. If no value exists, then the specified default value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="uiDefault">
            <para>Type: <c>USHORT</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>USHORT</c></para>
            <para>Returns extracted unsigned <c>Int16</c> value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt32(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32@)">
            <summary>
            Extracts unsigned <c>Int32</c> property value of a variant structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pulRet">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt32Array(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an unsigned <c>Int32</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the unsigned <c>Int32</c> data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies unsigned <c>Int32</c> array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int32</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt32ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated unsigned <c>Int32</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>ULONG**</c></para>
            <para>The address of a pointer to the unsigned <c>Int32</c> data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int32</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt32WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt32)">
            <summary>
            Extracts an unsigned <c>Int32</c> property value of a variant structure. If no value currently exists, then the specified default
            value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="ulDefault">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>ULONG</c></para>
            <para>Returns extracted unsigned <c>Int32</c> value, or default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt64(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt64@)">
            <summary>
            Extracts unsigned <c>Int64</c> property value of a variant structure. If no value can be extracted, then a default value is assigned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pullRet">
            <para>Type: <c>ULONGLONG*</c></para>
            <para>Pointer to the extracted property value if one exists; otherwise, 0.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt64Array(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt64[],System.UInt32,System.UInt32@)">
            <summary>Extracts data from a vector structure into an unsigned <c>Int64</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="prgn">
            <para>Type: <c>ULONGLONG*</c></para>
            <para>Pointer to the unsigned <c>Int64</c> data extracted from source variant structure.</para>
            </param>
            <param name="crgn">
            <para>Type: <c>ULONG</c></para>
            <para>Specifies unsigned <c>Int64</c> array size.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int64</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt64ArrayAlloc(Vanara.PInvoke.OleAut32.VARIANT@,Vanara.InteropServices.SafeCoTaskMemHandle@,System.UInt32@)">
            <summary>Extracts data from a vector structure into a newly-allocated unsigned <c>Int64</c> array.</summary>
            <param name="var">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="pprgn">
            <para>Type: <c>ULONGLONG**</c></para>
            <para>The address of a pointer to the unsigned <c>Int64</c> data extracted from source variant structure.</para>
            </param>
            <param name="pcElem">
            <para>Type: <c>ULONG*</c></para>
            <para>Pointer to the count of unsigned <c>Int64</c> elements extracted from source variant structure.</para>
            </param>
            <returns>
            <para>Type: <c>HRESULT</c></para>
            <para>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.VariantToUInt64WithDefault(Vanara.PInvoke.OleAut32.VARIANT@,System.UInt64)">
            <summary>
            Extracts an unsigned <c>Int64</c> property value of a variant structure. If no value currently exists, then the specified default
            value is returned.
            </summary>
            <param name="varIn">
            <para>Type: <c>REFVARIANT</c></para>
            <para>Reference to a source variant structure.</para>
            </param>
            <param name="ullDefault">
            <para>Type: <c>ULONGLONG</c></para>
            <para>Specifies default property value, for use where no value currently exists.</para>
            </param>
            <returns>
            <para>Type: <c>ULONGLONG</c></para>
            <para>Returns the extracted unsigned <c>Int64</c> value, or a default.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.PropSys.WinRTPropertyValueToPropVariant(System.Object,Vanara.PInvoke.Ole32.PROPVARIANT)">
            <summary>Copies the content from a Windows runtime property value to a PROPVARIANT structure.</summary>
            <param name="punkPropertyValue">
            A pointer to the IUnknown interface from which this function can access the contents of a Windows runtime property value by
            retrieving and using the Windows::Foundation::IPropertyValue interface.
            </param>
            <param name="ppropvar">
            Pointer to a PROPVARIANT structure. When this function returns, the <c>PROPVARIANT</c> contains the converted info.
            </param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.PropSys.SHCOLSTATE">
            <summary>Describes how a property should be treated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_DEFAULT">
            <summary>The value is displayed according to default settings for the column.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_TYPE_STR">
            <summary>The value is displayed as a string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_TYPE_INT">
            <summary>The value is displayed as an integer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_TYPE_DATE">
            <summary>The value is displayed as a date/time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_TYPEMASK">
            <summary>A mask for display type values SHCOLSTATE_TYPE_STR, SHCOLSTATE_TYPE_STR, and SHCOLSTATE_TYPE_DATE.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_ONBYDEFAULT">
            <summary>The column should be on by default in Details view.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_SLOW">
            <summary>Will be slow to compute. Perform on a background thread.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_EXTENDED">
            <summary>Provided by a handler, not the folder.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_SECONDARYUI">
            <summary>Not displayed in the context menu, but is listed in the More... dialog.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_HIDDEN">
            <summary>Not displayed in the UI.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_PREFER_VARCMP">
            <summary>VarCmp produces same result as IShellFolder::CompareIDs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_PREFER_FMTCMP">
            <summary>PSFormatForDisplay produces same result as IShellFolder::CompareIDs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_NOSORTBYFOLDERNESS">
            <summary>Do not sort folders separately.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_VIEWONLY">
            <summary>Only displayed in the UI.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_BATCHREAD">
            <summary>Marks columns with values that should be read in a batch.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_NO_GROUPBY">
            <summary>Grouping is disabled for this column.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_FIXED_WIDTH">
            <summary>Can't resize the column.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_NODPISCALE">
            <summary>The width is the same in all dpi.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_FIXED_RATIO">
            <summary>Fixed width and height ratio.</summary>
        </member>
        <member name="F:Vanara.PInvoke.PropSys.SHCOLSTATE.SHCOLSTATE_DISPLAYMASK">
            <summary>Filters out new display flags.</summary>
        </member>
        <member name="T:Vanara.PInvoke.PSExtensions">
            <summary>Extension methods for <see cref="T:Vanara.PInvoke.PropSys.IPropertyStore"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.PSExtensions.EnumKeys(Vanara.PInvoke.PropSys.IPropertyStore)">
            <summary>Enumerates the keys of a property store.</summary>
            <param name="ps">The <see cref="T:Vanara.PInvoke.PropSys.IPropertyStore"/> instance used to retrieve the keys.</param>
            <returns>A sequence of keys found in the property store.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PSExtensions.GetValue(Vanara.PInvoke.PropSys.IPropertyStore,Vanara.PInvoke.Ole32.PROPERTYKEY@)">
            <summary>Gets data for a specific property from a property store.</summary>
            <param name="ps">The <see cref="T:Vanara.PInvoke.PropSys.IPropertyStore"/> instance from which to request the value.</param>
            <param name="pkey">The key whose value to retrieve.</param>
            <returns>An object with the property data or <see langword="null"/> if <paramref name="pkey"/> was not found.</returns>
        </member>
        <member name="M:Vanara.PInvoke.PSExtensions.SetValue(Vanara.PInvoke.PropSys.IPropertyStore,Vanara.PInvoke.Ole32.PROPERTYKEY@,System.Object,System.Boolean)">
            <summary>Sets a new property value, or replaces or removes an existing value in a property store.</summary>
            <param name="ps">The <see cref="T:Vanara.PInvoke.PropSys.IPropertyStore"/> instance used to set the value.</param>
            <param name="pkey">The key whose value to set.</param>
            <param name="value">The value to set or <see langword="null"/> to remove an existing value.</param>
            <param name="commit">
            If <see langword="true"/>, the <see cref="M:Vanara.PInvoke.PropSys.IPropertyStore.Commit"/> method is called after setting the value.
            </param>
        </member>
    </members>
</doc>
